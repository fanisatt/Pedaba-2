// cd /home/fanisatt/CMAKE/
// gcc -c prog_221.c -lSDL_bgi -lSDL2

// gcc -o pedaba prog_221.o input53.o -lSDL_bgi -lSDL2 -lm
// zenity --calendar --date-format='%Y-%m-%d , %a'


#include<graphics.h>
#include<SDL2/SDL.h>
//#include <SDL2/SDL_ttf.h>
#include<stdio.h>
#include<time.h>
#include<ctype.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>
#include <memory.h>
#include <pwd.h>
#include <math.h>
#include <errno.h>

#define pause while (!(event())) refresh()
//#define GR 1
//#define EN 0
#define ttf 8 // Συνολικός αριθμός fonts

// Set cursor position
void gotoxy(int x, int y);
 
// Clear terminal screen and set cursor to top left
void clrscr();
// ***************************************************

void fidimundo_call(short int job , short int proel);
void eaninpundo();
int fields_undo ();
void show_help_2(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1);
void hide_help_2(unsigned short int xt1, unsigned short int yt1);
void superfilled_ellipse(int kx, int ky, int r1 , int r2, int *gem);
void superfilled_circle(int kx, int ky, int r , int *gem);
int multi_decs_pos(int xt1 , int yt1);
int multi_decs_mikropos(int dx, int dy, int *xl, int *yt ,int *xr , int *yb);
int decs_rec_move (int mx, int my, int *xl, int *yt ,int *xr , int *yb);
int change_mikrolabpos(int dx, int dy, int *xl, int *yt ,int *xr , int *yb);
int change_labdim(int xl, int yt ,int *mxright , int *mybottom);
int change_labpos(int mx, int my, int *xl, int *yt ,int *xr , int *yb);
void dbdecor_show ();
int decor_coord(int new , int page );
int fastmenu_show(short int plbut, char *menux, short int meg, char *but_name, unsigned short int moux, unsigned short int mouy );
void _outmystr_colsel(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk, int *selxr);
void _myfill_ellips (int x1, int y1 , int *gem);
void _outmystr_rcol(short int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *colchxr, int *colbkxr);
int add_edit_decor (short int new , short int *new1);
void _outmystr_centund_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr);
void _underline(unsigned char *str , int xt, int xb, int yb , int font, int xromas);
int inkualizer_spec (int font, int *chrxr , int *bkgxr , int pop , int fu , int* recgem);
int dbpage_decs();
int multi_change_mikropos(unsigned char *giam, short int aa, int dx, int dy, int *xl, int *yt ,int *xr , int *yb);
int multi_change_pos(int xt1 , int yt1);
int fields_rec_move (unsigned char *giam, short int aa, int mx, int my, int *xl, int *yt ,int *xr , int *yb);
int collect_fields(int *xl1, int *yt1 ,int *x1p , int *y1p);
int choise_alert_3 (char *astr1,char *astr2, char *astr3, short int akyro);
int _outmystr_right_col(short int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr);
void mynum_teleies (char *num , char type);
void mytext_perikop (unsigned char *str , short int a) ;
void piesl_stats (short int fifi, unsigned short int *disk_dom , short int choose);
int pedaba_statistics_3d(short int arped , unsigned short int *disk_dom , short int choose);
int regress(short int arped , unsigned short int *disk_dom , short int choose);
double mesoros (double *data , int num);
double std_dev (double *data , int num);
void multi_statistics(short int fifi, unsigned short int *disk_dom , short int choose);
void ypodiastol (char *str) ;
void _velos_up(short int xl,short int xr,short int yt);
void _velos_down(short int xl,short int xr,short int yb);
void qui_sort_double_si (double *item , int left , int right);
void pro_sort_double_si (double *item,int count);
int pedaba_statistics(short int arped , unsigned short int *disk_dom , short int choose);
void clear_alg(unsigned char *str);
double proanal_parast(short int arped, unsigned char *algebra , short int *problem );
int alg_help (unsigned char *ptralg , short int arped );
void _alg_txt_show (unsigned char *str , short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr , int *algbkxr );
int alg_input(int gfont, char *str, int *pxl,int *pyt,int *pxr,int *pyb,int orio,short int arped);
//int proter_calc_pedivn_rem (short int arped) ;
int check_pediaola_rem_math(short int arped);
int check_orio_write_math_rem(short int arped,  short int eggr , short int arped_rem);
double anal_parast_rem (short int arped, unsigned char *algebra , short int *problem , short int arped_rem);
void meion_pediaola_math(short int arped);
void zero_pediaola_math(short int arped);
int proter_calc_pedivn();
int check_pediaola_math();
int check_orio_write_mathped(short int arped, short int orio, short int eggr);
double anal_parast(short int arped, unsigned char *algebra , short int *problem , short int diskos);
int calc_rem_agk (short int start , short int telos, short int hook);
int new_text_input(int arped, char *str, int xl,int yt,int xr,int yb,int orio);
int proodos(char *str, int cur, int hm , int fun);
int new_input(int gfont, char *str, int *pxl,int *pyt,int *pxr,int *pyb,int orio,short int arped, unsigned short int wherp1);
char * pedaba_calendar(short int arped);
short int _show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int uday,unsigned short int stamonth);
short int find_dayname (unsigned short int uyear,unsigned short int umonth,unsigned short int uday) ;
int menu_dbfiles(char *loaddbfile);
int recent_files_inform (char *ndbpath , char *ndbname) ;
int mystrcpy_lim (unsigned char *str1 , unsigned char * str2 , int orio);
int choise_alert (char *str1,char *str2, short int akyro);
void * muldbfield_show_button(void *mem_str, unsigned char *pedia, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom, unsigned short int *flag_mulsel);
void * mulbutton_show(void *mem_str, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon );
int qnum_input(char *str, int xl,int yt,int xr,int yb,int orio,int num_type);
int qtext_input(char *str, int xl,int yt,int xr,int yb,int orio);
int criterio_show (int *cochxr , int *cobkxr);
int mystr_show(short int font, unsigned char *mystr, char *headername, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr );
void _outfanis_colxr(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *cchxr, int *cbkxr);
int filehelp_show(short int font, char *filename, char *helpname, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr ) ;
unsigned short int hlp_txt_scroll (short int font, unsigned short int cur, unsigned char *str, unsigned short int ar, short int xl , short int yt , short int xr , short int yb , int *cochxr , int *cobkxr);
void *prosans_21();
int spec_alert (int id,char *seleo,char *seleo1, char *img_file , int *spbkxr);
int photofield_show_button(void *mem_str, unsigned int ar, short int arped, short int arped2, short int *sorton , unsigned short int *disk_dom);
int info_dbsec(short int arped , unsigned short int *ar_dom);
void *proimpact_20();
int smmenu_show(short int plbut, char menu[][80], char *but_name, unsigned short int moux, unsigned short int mouy );
int bmptodisk_new (char *bmpname, unsigned int size_bytes,int width, int height);
void *procaviar_22();
void *convertinp_strstr  (short int left_right, char  *str, short int arped, unsigned short int *how_many, unsigned short int *cur);
void *prosans_18();
int fonts_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr );
int info_dbfnt();
void *protimes_18();
void hide_help(unsigned short int xt1, unsigned short int yt1);
void show_help(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1);
void *proarial_12();
int input_compl_search ();
unsigned short int field_txt_scrollsearch (short int arped, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr, int *coslxr);
unsigned char * convert_and_strstr  (short int arped, unsigned short int *how_many, unsigned short int *cur);
void what_mytime (time_t mytime, char *str);
int mystrcmp (unsigned char *str1 , unsigned char *str2);
int input_dbsearch_text(unsigned char *inp_str , short int arped );
int input_dbsearch_date(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str , short int arped );
int input_dbsearch_num(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str, short int type, short int arped );
int input_cardnum(unsigned char *inp_str);
int dbfield_show_button(void *mem_str, unsigned char *data, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom );
int info_dbfdata(short int arped , unsigned short int *ar_dom);
void pro_sort_usint (unsigned short int *item,int count);
void qui_sort_usint (unsigned short int *item , int left , int right);
void pro_sort_uint (unsigned int *item,unsigned short int *point,int count);
void qui_sort_uint (unsigned int *item , unsigned short int *point , int left , int right);
void pro_sort_double (double *item,unsigned short int *point,int count);
void qui_sort_double (double *item , unsigned short int *point , int left , int right);
void pro_sort_signedlong (long int *item,unsigned short int *point,int count);
void qui_sort_signedlong (long int *item , unsigned short int *point , int left , int right);
int info_dbfds() ;
int change_mikrodbpos(short int proel, int dx, int dy, int *xl, int *yt ,int *xr , int *yb);
int mypolystr (unsigned char *mega , unsigned char *mikro);
void _nofield_txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr);
void _field_txt_show (int arped, char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr);
int _outmystr_center_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr);
int change_dbdim(short int proel, int xl, int yt ,int *mxright , int *mybottom);
int change_dbpos(short int proel, int mx, int my, int *xl, int *yt ,int *xr , int *yb);
void dbrecs_show ();
void _outmystr_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk);
int dbpage_recs(int ergo);
int field_coord(int new , int page, int lab );
int mystrcpy (unsigned char *str1 , unsigned char * str2);
int add_edit_field (short int new , short int *_arped);
void * named_button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *full_name);
int mytext_toclipboard (char *data);
void qui_sort_24b(void *vitem , unsigned short int *point , int left , int right);
void pro_sort_24b(void *vitem, unsigned short int *point,int count);
int button_show(void *mem, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon );
void pro_sort_ulong (unsigned long int *item,unsigned short int *point,int count);
void qui_sort_ulong (unsigned long int *item , unsigned short int *point , int left , int right);
void * button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *but_name);
void _outfanis_colsel(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
void _outfanis_center_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
void _outfanis_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr);
int normtext_tomy(char *normstr , char *mystr);
void what_time (char *str);
int mytext_tonorm(unsigned char *mystr , char *normstr, int orio);
int input_alert (int id,char *seleo, char *inp_str, short int orio);
int gen_menu();
unsigned short int field_txt_scroll (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int xb , unsigned short int orio , int *cochxr , int *cobkxr);
int _puticon (int x1,int y1,void *mem1,int transp);
int _outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr);
int _outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
void _bareacls (int x,int y,int r,int d,int *cbkxr);
void _areacls (int x,int y,int r,int d,int kok,int pra,int mpl);
int _outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
int _putNOTicon (int x1,int y1,void *mem1);
int _outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
int text_input(char *str, int xl,int yt,int xr,int yb,int orio);
void pro_sort_int (int *item,unsigned short int *point,int count);
void qui_sort_int (int *item , unsigned short int *point , int left , int right);
int putNOTicon (int x1,int y1,void *mem1);
int readyinks (int *chrxr , int *bkgxr, int *selxr);
void create_colfiles ();
int outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
double convert_str(short int len , char *str);
int num_input(char *str, int xl,int yt,int xr,int yb,int orio,int num_type);
int outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr);
int inkualizer (int gfont, int *chrxr , int *bkgxr , int *selxr);
void bareacls (int x,int y,int r,int d,int *cbkxr);
void information (int id,char *seleo,char *seleo1);
void *sfalmata();
int alert (int id,char *seleo,char *seleo1);
int rgb_choose (int *bkxr , int *chxr) ;
int outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
int outnoto_col(int x, int y, char *str, int lang,int *chxr,int *bkxr);
int puticon (int x1,int y1,void *mem1,int transp);
int change_pos(int *xl, int *yt ,int *xr , int *yb);
int change_dim(int xl, int yt ,int *mxright , int *mybottom);
int pontik_rec(int *mxl, int *myt ,int *mxright , int *mybottom) ;
void fontoicW (int x , int y, int red, int green, int blue, void *mem1);
int puticW(int x, int y, void *mem_w);
void *icWtomem (char *filename);
int Wbmptodisk (char *bmpname, unsigned int size_bytes,short int width, short int height);
int outnoto_sma(int x, int y, char *str, int lang);
int outnoto_big(int x, int y, char *str, int lang, int syntx , int synty);
int outnoto(int x, int y, char *str, int lang);
void *pronoto();
void *icontomem (char *filename,int transp);
int bmptodisk (char *bmpname, unsigned int size_bytes,int width, int height);
int input(int gfont, char *str, int *pxl,int *pyt,int *pxr,int *pyb,int orio,short int arped);
void proinput ();
void fidicls(int x, int y, int x1, int y1 , int red , int green, int blue);
void cls();
int outsouv(int x, int y, char *str, int lang);
void * prosouv();
void areacls (int x,int y,int r,int d,int kok,int pra,int mpl);
void qcls (int kok,int pra,int mpl);
void efecls (int x,int y,int w,int h,int kok,int pra,int mpl);
long int inp_numb();
int my_esc=0;
int my_err=0;
char eid[44]={' ' , '!' , '\"' , '#' ,'$' ,'%' ,'&' ,'\'' ,'(' ,')' ,'*' ,'+' ,',' ,'-' ,'.' ,'/' ,'0' ,'1' ,'2' ,'3' ,'4' ,'5' ,'6' ,'7' ,'8' ,'9' ,':' ,';' ,'<' ,'=' ,'>', '?', '@', '[', '\\', ']' ,'^' ,'_' ,'`' ,'{' ,'|' ,'}' ,'~'};

unsigned char etm[22][3] =
{53 , '`' , '~' , 30 , '1' , '!' , 31 , '2', '@' , 32 , '3' , '#' , 33 , '4' , '$' , 34 , '5', '%' , 35 , '6' , '^' , 36 , '7' , '&' , 37 , '8' , '*' , 38 , '9' , '(' ,
39 , '0' , ')' , 45 , '-' , '_' , 46 , '=' , '+' , 47 , '[' , '{' , 48 , ']' , '}' , 49 , '\\' , '|' , 51 , ';' , ':' , 52 , '\'' , '\"' , 54 , ',' , '<', 55 , '.' , '>' ,
56 , '/' , '?' , 44, ' ' , ' '};

unsigned short int unico[69][2];

struct viewporttype info;
struct viewporttype *info_p ;


void *greek_addr=NULL, *souv_addr=NULL , *mem_sarial=0;
void *mem_small=0 , *mem_small_2, *mem_times = 0 , *mem_sans = 0 , *mem_caviar =0 , *mem_impact = 0 , *mem_sanser21=0 ; 

struct fansouv {
    char who;
    short int wid;
    short int hei;
    void *where;
} souv[165] ; // Σύνολο χαρακτήρων +1//

struct fansouv nouv[165] , sarial[165] , times18[165] , sanser18[165] , caviar22[165] , impact20[165], sanser21[165];
struct fansouv *gouv;

// const short int ttf=4;  // Πόσα fonts έχω συνολικά φορτωμένα !
struct fansouv *myfont[ttf];
short int myfont_hei[ttf];
short int myfont_wid[ttf];
char myfont_name [ttf][20]; 

struct fachars {
unsigned int scacod [57];
unsigned char faprint [57][2];
unsigned int sort [57][2];
} engl , grek ;

char user_name[36];
char file_1[1024];
char file_2[1024];
char str1kb[1512];
unsigned char file_3[640];
char path_name[512];
short int keyb_gr =0 ;
short int keyb_us =0 ;

SDL_Event sdlev;
int win_id ;
int chxr[3];
int bkxr[3];
int slxr[3];

char *sfalma=NULL;
int topbkxr[3];
int topchxr[3];
int topslxr[3];
int dbbkxr[3];
int dbchxr[3];
int dbslxr[3];
int bkxr1[3];
int chxr1[3];
int slxr1[3];
int eisag[3];
int delerg[3];
int klperg[3];
int sxedom[3];
int parous[3];
int klperg[3];
int syncardchxr[3];
int syncardbkxr[3];
unsigned short int mmed[24];

struct fanfield {
    short int finum ;
    unsigned char finame[30];                // field name=label
    char fitype;       // 0-6 : text, list gen, list spec, int number , float numb , photo-image , date
    char mathtype; // 0 or 1
    unsigned short int fiorio; // Μέγιστος αριθμός χαρακτήρων
    short int ficode;            // τετραψήφιος κωδικός
    unsigned char filistname[25];  //List Name (specific)
    unsigned short int fixt;  // field data xt - yt ....
    unsigned short int fiyt;
    unsigned short int fiwid;
    unsigned short int fihei;
    unsigned short int filaxt;  // field label xt-yt...
    unsigned short int filayt;
    unsigned short int filawid;
    unsigned short int filahei;    
    unsigned short int fipg; // Σελίδα στην οποία εμφανίζεται !
    int fibkxr[3];                         // field and field name colors
    int fichxr[3];
    int fislxr[3];
    short int fivar[7];
    // 0 : Δεδομένα εντός πλαισίου ΝΑΙ - ΌΧΙ 
    // 1 : Θέση δεδομέν. κλειδωμ.      //     //
    // 2 : Απόκρυψη δεδομένων         //     //
    // 3 : Ορατό όνομα πεδίου          //      //
    // 4 : Όνομα πεδίου σε πλαίσιο  //       //
    //5  : Θέση Ονόμ. πεδ. κλειδ.     //      //
    //6 :  Προκατ font                     //       //
    short int fifont;
    unsigned short int fifo_hei;
    unsigned short int fifo_wid; 
    time_t fiwhen;
} ;

struct fanlabel {
   unsigned char latype;        // text , text in rectangle , rectangle , line
    int labkxr[3];                         // label colors
    int lachxr[3];
    int laslxr[3];
    unsigned short int laxt;  // label xt-yt...
    unsigned short int layt;
    unsigned short int lawid;
    unsigned short int lahei;
    unsigned short int lapg; // Σελίδα στην οποία εμφανίζεται !
    unsigned char lafont;
    unsigned short int lafo_hei;
    unsigned short int lafo_wid;
    unsigned char lavi; // ορατό ή όχι label
} ;

struct db_bu {
    unsigned short int butt_orio;
    unsigned short int butt_ar;
    unsigned char butt_name[128];
    void *mem_butt;
    unsigned char butt_data[128];
    int butt_elem;
    unsigned short int butt_sorton;
} dbbut [10];

struct ope_bu {
     unsigned short int butt_orio;
    unsigned short int butt_ar;
    unsigned char butt_name[40];
    void *mem_butt;
    unsigned char butt_data[40];
    int butt_elem;
    unsigned short int butt_sorton;
} open_buts ;

// struct Data Base Fields (dbfds)
struct {
     unsigned short int fd_orio;
    unsigned short int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
} dbfds ;

// struct Data Base Field Data (dbfdata)
struct {
    unsigned short int fd_orio;
    unsigned int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
    short int fd_sort_type ;
    unsigned short int fd_arped;
} dbfdata;

struct criterio {
    union {
    unsigned int gitem[3];
    long int litem[3];
    double fitem[3];
    } numcr ;
 
    unsigned char sample [3][26];
    unsigned char sample_t [22] ;
    unsigned char sample_tcode[22];
    void *mem_ghost ;
    short int cron ;
    short int cron_1;
} ;

struct criterio_cp {
unsigned char sample_cp [3][26];
unsigned char sample_t_cp [22] ;
} ;

struct criterio *multicr[100];

short int dbmaxbut ;           // Πόσα συνολικά buttons είναι φορτωμένα ! (μέχρι 10 / 0-9 / αρχική τιμή -1)
short int delon ; //Καλαθάκι αχρήστων για τη button show !

struct fanfield *ptr_pedio[100];         // Μέγιστος αριθμός πεδίων
struct fanlabel *ptr_etiket[50];        // Μέγιστος αριθμός ετικετών

char savedbpath[768] , LDdbfile[1024] ;
char *loaddbfile;
char str1024 [1386];        // Γενικής Χρήσης str
int pdaba[4] , pdaca;
unsigned short int dblasize, dbfisize , dbplgr , dbplera, dbpg=1 , dbcurpage=1 , dbar =0 , dbrecxr , dbscrxr ,dbmag , dbtop , dbselxr , dbred , dbgreen , dbblack , dbyel , dbhelpcol;
short int dbfinum ;
const short int dblanum = -1;
unsigned char dbtime[100];
time_t loctime , metatime , protime ;
char *ptr_char=NULL;
struct tm *diary;
FILE *fpdb = NULL , *fpcard = NULL  ,*fpdom = NULL ;
unsigned short int dbkey , prodbkey;
unsigned char synolo_butstr[230]; //Για τα 10 ονόματα των 10 το πολύ φορτωμένων λιστών
unsigned char *synolo_fds , *synolo_fdata ;
unsigned int size_fds=512;
unsigned int size_fdata;

char mmestr[24][120];
unsigned int Xt,Xb,Yt,Yb,Wt,Wb,Ht,Hb ; // Menu Line , x and y Coordinates / Width - Height of screen elements 
unsigned short int topinfxt, topinfyt , topinfxb, topdbnamext, toppgxt , dbcard , dbcard1, dbcard_opt=0, dbtotcardxt , dbtotcardxb;
char top_str[40] , card_str [10];
void *memx1=0 , *memy1=0 , *memx2 =0 , *memy2=0 ; // Δέσμευση μνήμης για τις συντεταγμένες όλων των rectangles (πεδίων + labels πεδίων) - απόδοση της μνήμης σε int * και στο τέλος απελευθέρωση των memx... 
unsigned short int *dbx1 , *dby1 , *dbx2 , *dby2 ; // Εδώ είναι τα arrays των συντεταγμένων.
short int dbrecs = 0 ; // (Το άθροισμα των στοιχείων που αντιστοιχούν σε rectangles πεδίων - ετικετών πεδίων στις σελίδες της βάσης δεδομένων)
short int db_elem[102][2] ;
void *memk[100] , *memcp[100] ;
unsigned short int limk[100] , xlimk[100] , xlim=0 , xmemk=0;
unsigned char *keimk , *ceimk ,*deimk;
unsigned short int curk[100];
unsigned short int curk1[100];
unsigned int dbcardsize =0 , alma_deigma = 0;
time_t cardwhen ;

union {
    unsigned int ldate;
    unsigned char mydate[4]; // mydate[3]=Year/256 , mydate[2]=year%256 , mydate[1]=month , mydate[0]=day;
} cardiary;

union {
    unsigned short int wotim;
    unsigned char dyomikra[2];
} dysena;

unsigned short int hdhlpxt , hdhlpyt ,  hdhlpxt_2 , hdhlpyt_2 ;
int * baserg , *baserg1;
short int seflag=0;

// struct font button (dbfnt)
struct {
     unsigned short int fn_orio;
    unsigned short int fn_ar;
    unsigned char fn_name[30];
    void *mem_fn;
    unsigned char fn_data[20];
    int fn_elem;
    unsigned short int fn_sorton;
} dbfnt;

unsigned char  *synolo_fnts ;
unsigned int size_fnts=256;
void *inp_mem_ghost = 0;
unsigned short int gocards , firstcrit; // gocards = πόσες κάρτες ικανοποιούν κριτήρια , firstcrit = ο α/α της πρώτης κάρτας ...

char submenu[12][80];
char submenu_num[12][80];
char submenu_ico[7][80];
unsigned short int dbaspro;

struct {
    unsigned int fd_ar;
    unsigned short int fd_sorton;
    void *mem_fd;
} dbsec;

unsigned int size_sec ;
unsigned char *synolo_sec ;
int helpchxr[3] , helpbkxr[3] ;
FILE *fpch ;
char missing[40];

unsigned short int *epil_pos =0 ;
unsigned short int tot_opts=0;
short int user_opts=0;
unsigned short int mulsel ;
unsigned char crits[65534]; // Αν είναι 1 τότε η κάρτα ικανοποιεί τα κριτήρια εύρεσης.
char *dropfile;
unsigned char langex=0;
short int logand=1;
unsigned char normdeigma[101][22] ;
int fide_fpdb , fide_fpcard ,fide_fpdom, fide_lims ;
char Strcardfp [1024] , Strdomfp[1024] ;
unsigned char wasopdb=0 , wasopca=0 , wasopdo=0 ;
short int addped=0 , delped=0 , allorio=0 ;
unsigned char please_wait[26];
void *pomem=0;
int pcur , phm ;
///gia mathtype

struct {
char sths ;
short int agk ;
short int steos;
short int field;
} prst [1024];

short int maxprst ;
double *ier;
short int numped; // Σύνολο αριθμητικών πεδίων
unsigned char *alg_str[100];
unsigned int empl_size ;
char *empl_mem=0;
char prot_calc[100]; // Για την προτεραιότητα υπολογισμού πεδίων

short int enmath=0;  // Το σύνολο των mathtype πεδίων .
short int enmath_1 ; // Το σύνολο των mathtype πεδίων για τα οποία τίθεται θέμα προτεραιότητας.
unsigned int math_alma ;
unsigned char prox_alg_str[1026] ;
double dfx , posmax, negmax , bigd;
long int lfx;
short int alg_err;
int dpro ;
short int roca ;
unsigned char *Nemk[100];
short int metataj=0;
char alg_prob[13][90];

//GIA DECORATION

struct fandecor {
    char dephoto[1024];
    unsigned char detext[72];
    char detype [8];
    short int dext;  
    short int deyt;
    short int dewid;
    short int dehei; 
    short int depg; // Σελίδα στην οποία εμφανίζεται !
    short int delayer ;
    short int defill;
    int delinexr[3];
    int debkxr[3];                         
    int dechxr[3];
    short int delinefat ;
    short int defont;
    short int defohei;
    short int defowid;
} ptr_dec[150];

void *dmemx1=0 , *dmemy1=0 , *dmemx2 =0 , *dmemy2=0 ; // Αντίστοιχες μνήμες διακοσμητικών ετικετών
unsigned short int *dbdx1 , *dbdy1 , *dbdx2 , *dbdy2 ; // Αντίστοιχα arrays διακοσμητικών ετικετών
short int dbdecs = 0 ; // Αντίστοιχο άθροισμα για διακοσμητικές ετικέτες = decor * 4...
short int dd_elem[150];
unsigned int dec_lab_db ; // Το άλμα fseek για εγγραφή του decor στο fpdb
unsigned int screen_alma ; // //  //    //   //    ///  στοιχείων οθόνης
int decor=0 , dcar=0 ;
short int diax_dec=0 ;
unsigned char diaxetik[40]; // Προσωρινή επικεφαλίδα
unsigned char diaxped[40];
char mmestr3c[120];
char design_t[30];
int decorsize;
FILE *fpdec;
int fide_fpdec;
int prin_dec;
short int teos_dec;
void *mem_ouon=0;
int *piotop ;
char photopath[1024];
int Stx,Sty ;
short int gundo_xt , gundo_xb , gredo_xt, gredo_xb ; 
int gundo_sit = 0 , gundo_but=0 ;
int undochxr[3] , undobkxr[3] , undolight[3] ;
int redochxr[3] , redobkxr[3], redolight[3] ;
unsigned char undo_text[6];
unsigned char redo_text[6];
int etikchxr[3] , etikbkxr[3];
struct undo_dim {
    short int uarel ;
    unsigned short int ux1 ;
    unsigned short int uy1 ;
    unsigned short int ux2 ;
    unsigned short int uy2 ;
    short int ped;
    short int multi ;
    short int telos ;
    short int arxh ;
} ;
struct undo_dim udim[500] , rdim[500];
short int fidim_undo=0, fidim_but=0 , fidim_redo=0, fidim_redobut=0 ;
int size_undo_dim ;
short int alter1_but=0;
short int ics_arped=-1;
void *mem_kato=0 , *mem_chain=0 , *mem_cross=0;
short int prorec , trecx, trecy ,chainx, chainy, proi1 , fiornam ;
short int seclevsort=1 , sec_dbkey=-1 ;

/////// MAIN /////////////////////////// MAIN  ////////////////////////////////// M A I N ///////////////////////////////////// MAIN //////////////////////////

int main(int argc , char *argv[] )
{
SDL_Window *window;
SDL_DisplayMode DM;
SDL_Cursor* cursor;
uid_t uid ;
struct passwd *pw ;
struct fansouv *whouv , *whouv2;

union pixcols{
  int ltimi;
  unsigned char xro[4];
} pixel ;

union {
    long unsigned int big;
    unsigned char sma[8];
} xitem [3] ;

struct XX4_bytes {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};

struct XX4_bytes *item , check_item ;

unsigned int *Gitem ;
long int *Litem ;
double *Fitem;
time_t *Ditem;

FILE *fp ,*fpsflalm , *fpera = NULL, *fpex , *fpout ;
int fide_fpera , fide_gen , fide_fpsflalm , fide_fpout ;
unsigned char notes_str[60002];
char str[512];
int OUON_WID , OUON_HEI ;
char ch,cha, chb, chc, ch_state;
unsigned char ch2 , what , ch3 , *gen_ergo , deigma[28] ;
unsigned short int ch1 , cur ,mbut , ar ,low , *ar_dom , *new_dom , thesi , p ,f1 ;
short int w, h , a1 , m , a , c , kyk , posafoto , papiso , tokyk=100 , rego=0 ;
register int i , f;
unsigned int mem_need  ;
void *mem1 = 0 , *mem2=0 , *mem3=0, *item_mem=0 ,*new_dom_vo=0 , *mem_search , *mem4=0 , *mem5=0 ;
void *mem_butmenu=0 , *mem_pgdn=0 , *mem_pgup=0 , *mem_savecard =0 , *mem_leftcard =0 , *mem_rightcard =0 , *mem_sumdb=0 , *ardom_mem=0 , *mem_usersel=0 ;
void *mem_progvn=0 ;
void *mem_addcard=0 ;
int *mem_int , *pgchxr;
int size ,inpx , inpy , inpx1, inpy1, start , metr ;
unsigned short int ch_mod,ch_scan;
const Uint8 *state ;
int mx, my, mx1, my1 ,x ,y ,diaf1 , user_ans , Cx1, Cy1, Cx2, Cy2 ,dx, dy , dz, i1 ;
long int lbig , Lidb ;
double fbig , Fidb;
unsigned int Gidb ;
unsigned short int sGidb , sG ;
double big_d , big_t;
unsigned short int bmenuxt, bmenuyt, bmenuxb, bmenuyb ,ektos ,ox1, ox2, oy1, oy2 , gx2, gy2, dbwxr , butpgupxt , butpgdnxt , topdbnamext , topdbnamexb , cardlext, cardrixt , cardsaxt , cardNoxt , cardNoxb , dbasext  , cardnewxt , uhupgxt , uhupgxb, cardareaxt , cardareaxb ;  
unsigned short int search_flagxt , how_many ;
char new_dbname[64];
unsigned char dbopen;
unsigned char *list_str , *eplfi ,*percho ;
int inp_pedaba[4];
int redchxr[3] , greenchxr[3]; int orangechxr[3];
char *ptr_ch , totcard_str[10];
short int back_arped , proel, progvn , prodvn, dbpgup=0 , dbpgdn=0 , alma=0 , cardribut=0, cardlebut=0 , cardsabut=0 , cardnewbut=0 , cardareabut=0 ;
short int critflag=0 , dbfname=0 , dbincards=0;
short int by , rby , sumcrit, rl ;
unsigned char nu[4];
unsigned char *deigma_text ;
unsigned char klik ;
unsigned char savenow=0;
int savebkxr[3];
int fide_rlist , fide_notes , fide_exp ;
unsigned char ex_file=0;
short int i4;
short int prodec;
short int xyz_del;


// TELOS METABLHTVN
//See man getlogin_r

info_p = &info;
fpdb=NULL;
 if( SDL_Init( SDL_INIT_VIDEO ) < 0 ) { printf( "SDL could not initialize! SDL_Error: %s\n", SDL_GetError() ); return 0;}
//Να δούμε το maximum της οθόνης
SDL_GetCurrentDisplayMode(0, &DM);
x = DM.w;
y = DM.h;

if (x<1200 || y<800) {printf ("Screen Resolution Very Small - Exit \n") ; return 0;}
setwinoptions(" P E D A B A  2 ",-1,-1,-1);
//SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
initwindow (x,y);
setactivepage(0);
sdlbgifast();
win_id=getcurrentwindow();
getviewsettings (info_p);
setblendmode (SDL_BLENDMODE_BLEND);
qcls(0,0,0);
myfont[0]=souv;
myfont[1]=nouv;
myfont[2]=sarial;
myfont[3]=times18;
myfont[4]=sanser18;
myfont[5]=caviar22;
myfont[6]=impact20;
myfont[7]=sanser21;
myfont_hei[0]=18;  // souv
myfont_wid[0]=17; 
myfont_hei[1]=26;  //nouv
myfont_wid[1]=19;
myfont_hei[2]=13; // Arial 12
myfont_wid[2]=12;
myfont_hei[3]=19; // Times 18
myfont_wid[3]=18;
myfont_hei[4]=22; // SansSer 18
myfont_wid[4]=18;
myfont_hei[5]=25; // Caviar Dreams 22
myfont_wid[5]=22;
myfont_hei[6]=23; // Impact 20
myfont_wid[6]=20;
myfont_hei[7]=25; // SansSer 21
myfont_wid[7]=21;
strcpy (myfont_name[0] , "Souvenir 16");
strcpy (myfont_name[1] , "NotoSans 25");
strcpy (myfont_name[2] , "Arial 12");
strcpy (myfont_name[3] , "Times 18");
strcpy (myfont_name[4] , "Sans Serif 18");
strcpy (myfont_name[5] , "Caviar Dreams 22");
strcpy (myfont_name[6] , "Impact 20");
strcpy (myfont_name[7] , "Sans Serif 21");

inp_pedaba[0]=22111963; inp_pedaba[1]=404976; inp_pedaba[2]=99; inp_pedaba[3]=167330;

topbkxr[0]=topbkxr[1]=topbkxr[2]=0;
topchxr[0]=topchxr[2]=92; topchxr[1]=240;
topslxr[0]=32; topslxr[1]=19; topslxr[2]=192;

dbbkxr[0]=dbbkxr[1]=dbbkxr[2]=30;
dbchxr[0]=dbchxr[2]=92; dbchxr[1]=206;
dbslxr[0]=32; dbslxr[1]=19; dbslxr[2]=140;

helpchxr[0]=helpchxr[1]=helpchxr[2]=0;
helpbkxr[0]=helpbkxr[2]=60 ; helpbkxr[1]=180 ;
undolight[0]=0 ; undolight[1]=193 ; undolight[2]=0 ; 
undochxr[0]=145 ; undochxr[1]=undochxr[2]=0;
undobkxr[0]=184; undobkxr[1]=240; undobkxr[2]=0;  
redolight[0]=151 ; redolight[1]=151 ; redolight[2]=52 ; 
redochxr[0]=redochxr[1]=redochxr[2]=0;
redobkxr[0]=0; redobkxr[1]=210; redobkxr[2]=216; 
eisag[0]=0 ; eisag[1]=41 ; eisag[2]=0 ; // Πρασινωπό  
sxedom[0]=sxedom[2]=168 ; sxedom[1]=0; // ροζ
etikchxr[0]=64 ; etikchxr[1]=17 ; etikchxr[2]=221 ;
etikbkxr[0]=106 ; etikbkxr[1]=255 ; etikbkxr[2]=144 ; 
parous[0]=0 ; parous[1]=30 ; parous[2]=255 ; // Μπλέ  
klperg[0]=klperg[1]=klperg[2]=46 ;  // Γκρί 
delerg[0]=129 ; delerg[1]=delerg[2]=0 ; // Κοκκινωπό
dbrecxr = 777; dbscrxr=778; dbmag=779; dbtop=780;dbred=781;dbselxr=782;dbgreen=783;dbblack=784;dbyel=785;
dbhelpcol=790; dbaspro=791 ;
setrgbpalette(dbrecxr,dbchxr[0],dbchxr[1],dbchxr[2]);
setrgbpalette(dbscrxr,dbbkxr[0],dbbkxr[1],dbbkxr[2]);
setrgbpalette(dbselxr,dbslxr[0],dbslxr[1],dbslxr[2]);
setrgbpalette(dbblack,0,0,0);
setrgbpalette(dbyel,255,255,0);
setrgbpalette(dbhelpcol,255,255,0);

setrgbpalette(dbmag,255,0,255);
setrgbpalette(dbred,255,0,0);
setrgbpalette(dbgreen,0,255,0);
setrgbpalette(dbaspro,255,255,255);
setrgbpalette(dbtop,topbkxr[0],topbkxr[1],topbkxr[2]);

bkxr[0]=48;bkxr[1]=57;bkxr[2]=0;
chxr[0]=40;chxr[1]=255;chxr[2]=229;
slxr[0]=47;slxr[1]=0;slxr[2]=76;

bkxr1[0]=48;bkxr1[1]=57;bkxr1[2]=0;
chxr1[0]=40;chxr1[1]=255;chxr1[2]=229;
slxr1[0]=47;slxr1[1]=0;slxr1[2]=76;

savebkxr[0]=255 ; savebkxr[1]=215; savebkxr[2]=0 ;

syncardchxr[0]=254 ; syncardchxr[1]=108 ; syncardchxr[2]=255 ; 
syncardbkxr[0] = 11 ; syncardbkxr[1] = 78 ; syncardbkxr[2] = 82 ; 


dbfisize=sizeof(struct fanfield );
dblasize=sizeof (struct fanlabel);
decorsize=sizeof (struct fandecor);
size_undo_dim = sizeof (struct undo_dim);
size_undo_dim = (499 * size_undo_dim) / 2 ;
math_alma = 104 + 100*dbfisize + 50*dblasize ;
dec_lab_db = 104 + (100*dbfisize);
screen_alma = dec_lab_db + 4 ;
pdaba[0]=112263; pdaba[1]=559500; pdaba[2]=120; pdaba[3]=17330;

// DISCOVER THE USER NAME 
if (! (getlogin_r(user_name,20))) sprintf(path_name,"/home/%s%s",user_name,"/Pedaba/");
    else { 
            ptr_char=getlogin();

            if (ptr_char!=NULL) {sprintf (user_name,"%1.19s", ptr_char); sprintf(path_name,"/home/%s%s",user_name,"/Pedaba/");}
                else 
                {
                uid = geteuid();
                pw = getpwuid(uid);
                    if (pw) {sprintf (user_name,"%1.19s", pw->pw_name); sprintf(path_name,"/home/%s%s",user_name,"/Pedaba/");}
                    else exit (0);
                }}

sprintf (file_2,"%s%s",path_name,"TMP/zenerr.dat");
fpsflalm=freopen(file_2,"w",stderr);
sprintf (file_2,"%s%s",path_name,"TMP/zenout.dat");
fpout=freopen(file_2,"w",stdout);

if ( (fpsflalm==NULL) || (fpout==NULL) ) { printf("stdout or stderr redirection problem\n") ; goto gamidia ; }

fide_fpsflalm = fileno (fpsflalm);
fide_fpout = fileno (fpout);

ptr_char=0;
// ELEGXOS GIA AGGLIKO - ELLHNIKO PLHKTROLOGIO
sprintf(str1024,"setxkbmap -query > %s%s",path_name,"kbmap.txt");
system(str1024);
sprintf(file_1,"%s%s",path_name,"kbmap.txt");
fp=fopen(file_1,"r");
if (fp==NULL) {perror("I/O Problem"); goto gamidia;}
str[0]='\0';
do{
fgets(str,30,fp);
ptr_char=strstr(str,"layout");
if (ptr_char!=NULL) 
    { 
    ptr_char=strstr(str,"us");
    if (ptr_char!=NULL) keyb_us=1 ; 
    ptr_char=strstr(str,"uk");
    if (ptr_char!=NULL) keyb_us=1 ; 
    ptr_char=strstr(str,"gr");
    if (ptr_char!=NULL) keyb_gr=1 ; 
    break;
    }
    else continue;
}
while ( ! feof(fp) ) ;
if (ferror(fp)) {clearerr(fp); fclose(fp);}
else fclose(fp); fp=NULL;

if (!keyb_us) {printf("It seems that there is no support for US keyboard \n");}
keyb_us=1;

if (!keyb_gr) {
    // ELEGXOS GIA ELLHNIKH GLVSSA
    sprintf(str1024,"locale > %s%s",path_name,"local.txt");
    system(str1024);
    sprintf(file_1,"%s%s",path_name,"local.txt");
    fp=fopen(file_1,"r");
    if (fp==NULL) {perror("I/O Problem"); goto gamidia;}
    str[0]='\0';
    do{
    fgets(str,30,fp);
    ptr_char=strstr(str,"LANG");
    if (ptr_char!=NULL) 
        { 
        ptr_char=strstr(str,"el");
        if (ptr_char!=NULL) keyb_gr=1 ; 
        ptr_char=strstr(str,"GR");
        if (ptr_char!=NULL) keyb_gr=1 ; 
        break;
        }
        else continue;
    }
    while ( ! feof(fp) ) ;
    if (ferror(fp)) {clearerr(fp); fclose(fp);}
    else fclose(fp); fp=NULL;
}
// Προπαρασκευές !!!
greek_addr=pronoto();
souv_addr=prosouv();
mem_sarial=proarial_12();
mem_times=protimes_18();
mem_sans=prosans_18();
mem_caviar=procaviar_22();
mem_impact=proimpact_20();
mem_sanser21=prosans_21();
if(greek_addr==NULL) goto gamidia;
if(souv_addr==NULL) goto gamidia;
if(mem_sarial==NULL) goto gamidia;
if(mem_times==NULL) goto gamidia;
if(mem_sans==NULL) goto gamidia;
if(!mem_caviar) goto gamidia ;
if(!mem_impact) goto gamidia ;
if(!mem_sanser21) goto gamidia;
proinput();
sfalma=sfalmata(); 
if(sfalma==NULL) goto gamidia;


// ΑΝΑΓΝΩΣΗ ΕΛΛΗΝΙΚΩΝ UNICODES //
sprintf(file_1,"%s%s",path_name,"GrUni.txt");

fp=fopen(file_1,"r");
for(f=0;f<69;f++) {
    fread(&ch,1,1,fp);
    fread(&cha,1,1,fp);
    unico[f][0]=(ch*256)+cha;
    unico[f][1]=95+f;}
if (ferror(fp)) {clearerr(fp); fclose(fp); perror ("Disk I/O Problem ");}  
else fclose(fp);  fp=NULL;


//create_colfiles (); // ΜΟΝΟ ΜΙΑ ΦΟΡΑ ΤΡΕΧΕΙ ΑΥΤΟ - DHMIOYRGEI TO ARXEIO DOMVN XRVMATVN !!!


//*******************************************************************************************************
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/add_found.bmp",6538  ,40,40);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Left_17.bmp",2858,40,17);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Save_25.bmp",2638,25,25);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Load_25.bmp",2638,25,25);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/save_alert.bmp",325387,90,90);
//M E T A F O R A BMP EIKONAS STO DISKO SE MORFH ico ??
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Pedia_en.bmp",1167458 ,758,385);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/Yes_Key.bmp",3738 ,30,30);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/No_Key.bmp",3738 ,30,30);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/rinks_26.bmp",3502 ,29,29);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/seardb.bmp",2730 ,36,18);
// bmptodisk_new("/home/fanisatt/CMAKE/ICONS/sm_DB.bmp",2082 ,27,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/card_left.bmp",1650  ,21,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/card_right.bmp",1650  ,21,18);
//bmptodisk("/home/fanisatt/CMAKE/ICONS/arrows_18.bmp",1434 ,18,18);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Colors_17.bmp",2178,30,17);
// bmptodisk_new("/home/fanisatt/CMAKE/ICONS/Fonter_17.bmp",1294,17,17);
//bmptodisk_new("/home/fanisatt/CMAKE/ICONS/pedaba_db2.bmp",654858,480,341);
//mem1=icontomem("/home/fanisatt/CMAKE/ICONS/upload_database_21015.ico",255);
//puticon(300,300,mem1,255);
// inkualizer (chxr , bkxr , slxr);
//readimagefile ("/home/fanisatt/CMAKE/ICONS/paste.bmp",100,100,0,0);
//information(1,"Για να δούμε πόσο μαλάκας είσαι...",NULL);
//gouv = myfont[0];
//metr=num_input(str, x, y, x1, y1, 27,3);
//big_d= convert_str(metr , str);
//sprintf (str, "Πρόσθεση %f + 100.34 = %f ! - Long int Size = %d " , big_d, big_d+100.34,sizeof(long int) );
//outnoto (100,300,str,1) ;
//areacls(300,300,600,326,bkxr[0],bkxr[1],bkxr[2]);
//x=300 ; y=300 ; x1=600; y1=326;
//gouv = myfont[1];
//metr=text_input(str, x, y, x1, y1, 40);
//getch();

// KLHSH THS INPUT
      //  gouv=myfont[1];
      //  metr=input(str, &x, &y, &x1, &y1, 3000);
      //  while (metr==-10) metr=input(str, &x, &y, &x1, &y1, 3000);
      
gouv=myfont[1];
redchxr[0]=orangechxr[0]=255; redchxr[1]=redchxr[2]=greenchxr[0]=greenchxr[2]=0;
greenchxr[1]=255; orangechxr[1]=160;orangechxr[2]=122;

dbfinum =-1; 


if (keyb_gr) {
    
    strcpy (mmestr[0],"Δημιουργία Νέας Βάσης Δεδομένων");
    strcpy (mmestr[1],"Φόρτωση Βάσης Δεδομένων");
    strcpy (mmestr[2],"Σώσιμο Βάσης Δεδομένων");
    strcpy (design_t,"Σχεδίαση Δομής");
    strcpy (mmestr[4],"Σύνθετη Αναζήτηση/Καθορίστε κριτήρια");
    strcpy (mmestr[5],"Κλείσιμο Βάσης Δεδομένων");
    strcpy (mmestr[6],"Πρoσθαφαίρεση-Διαχείριση Πεδίων / Ετικετών");
    strcpy (mmestr[7],"Εισαγωγή - Επεξεργασία Στοιχείων στα Πεδία");
    strcpy (mmestr[8],"Δείξε / Άλλαξε το Κλειδί Ταξινόμησης");
    strcpy (mmestr[9],"Παρουσίαση Καρτελών (ελεύθερη)");
    strcpy (mmestr[10],"Παρουσίαση Καρτελών με κριτήρια");
    strcpy (mmestr[11],"Λίστα Έτοιμων Συνδυασμών Χρωμάτων");
    strcpy (mmestr[12],"Εντοπισμός καρτέλας με Απλή Αναζήτηση");
    strcpy (mmestr[13],"Διαγραφή Καρτέλας-ών");
    strcpy (mmestr[14],"Εξαγωγή Καρτέλας-ων στο δίσκο ως .txt");
    strcpy (mmestr[15],"Εμφάνιση Λίστας που φορτώθηκε τελευταία");
    strcpy (mmestr[16],"Πολλαπλή Επιλογή Καρτελών");
    strcpy (mmestr[17],"Δημιουργία Συνδυασμών Χρωμάτων");
    strcpy (mmestr[18],"Χρώματα Οθόνης");
    strcpy (mmestr[19],"Σημειωματάριο");
    strcpy (mmestr[20],"Δημιουργία Λίστας Δεδομένων");
    strcpy (mmestr[21],"Επιλογή Λίστας από τις ήδη φορτωμένες");
    strcpy (mmestr[22],"Φόρτωση Νέας Λίστας από το Δίσκο");
    strcpy (mmestr[23],"Φύγε..");
} 
else
{
    strcpy (mmestr[0],"Creation of a new Data Base");
    strcpy (mmestr[1],"Load a DB");
    strcpy (mmestr[2],"Save the DB");
    strcpy (design_t,"Design the DB");
    strcpy (mmestr[4],"Complex Data Search/Define criteria");
    strcpy (mmestr[5],"Close the DB");
    strcpy (mmestr[6],"Add - Remove - Edit DB Fields / Labels");
    strcpy (mmestr[7],"Input Data - Edit DB Fields' Data");
    strcpy (mmestr[8],"Show / Change the Sorting key (field)");
    strcpy (mmestr[9],"DB Cards Presentation (no criteria)");
    strcpy (mmestr[10],"DB Cards Presentation by search criteria");
    strcpy (mmestr[11],"Ready Color combinations for DB Fields");
    strcpy (mmestr[12],"Locate DB Card with simple Data Search");
    strcpy (mmestr[13],"DB Card(s) Deletion");
    strcpy (mmestr[14],"Export DB Card(s) as .txt");
    strcpy (mmestr[15],"Show last loaded Ready List");
    strcpy (mmestr[16],"Multiple DB cards Selection");
    strcpy (mmestr[17],"Inkualizer");
    strcpy (mmestr[18],"Screen Colors");
    strcpy (mmestr[19],"Draft Notebook");
    strcpy (mmestr[20],"Creation of a Ready List");
    strcpy (mmestr[21],"Choose a loaded Ready List");
    strcpy (mmestr[22],"Load Ready List");
    strcpy (mmestr[23],"Go..");
}

for (f=0;f<24;f++) {
    if (f==3) continue ;
    normtext_tomy (mmestr[f],0);
}

if (keyb_gr) {
    strcpy (submenu[0],"ΑΝΤΙΓΡΑΦΗ στον Clipboard");
    strcpy (submenu[1],"Σύνδεση με GIMP");
    strcpy (submenu[2],"Σύνδεση με INKSCAPE");
    strcpy (submenu[3],"Σύνδεση με NOMACS");
    strcpy (submenu[4],"Σύνδεση με GEEQIE");
    strcpy (submenu[5],"Σύνδεση με FEATHER PAD");
    strcpy (submenu[6],"Σύνδεση με KWRITE");
    strcpy (submenu[7],"Σύνδεση με VLC (προσκήνιο)");
    strcpy (submenu[8],"Σύνδεση με VLC (παρασκήνιο)");
    strcpy (submenu[9],"Σύνδεση με Firefox");
    strcpy (submenu[10],"Σύνδεση με Google-Chrome");
    strcpy (submenu[11],"ΔΙΑΓΡΑΦΗ στοιχείων πεδίου");
}
else
{
    strcpy (submenu[0],"COPY to Clipboard");
    strcpy (submenu[1],"Edit with GIMP");
    strcpy (submenu[2],"Edit with INKSCAPE");
    strcpy (submenu[3],"Edit with NOMACS");
    strcpy (submenu[4],"Link with GEEQIE");
    strcpy (submenu[5],"Link with FEATHER PAD");
    strcpy (submenu[6],"Link with KWRITE");
    strcpy (submenu[7],"Link with VLC (foreground)");
    strcpy (submenu[8],"Link with VLC (background)");
    strcpy (submenu[9],"Link with Firefox");
    strcpy (submenu[10],"Link with Google-Chrome");   
    strcpy (submenu[11],"DELETE Field's Data");  
}


if (keyb_gr) {
    strcpy (submenu_num[0],"ΑΝΤΙΓΡΑΦΗ στον Clipboard");
    strcpy (submenu_num[1],"ΔΙΑΓΡΑΦΗ στοιχείων πεδίου");
    strcpy (submenu_num[2],"Στατιστική πεδίου (επί συνόλου)");
    strcpy (submenu_num[3],"Ιστόγραμμα-έως 5 πεδία (επί συνόλου)");
    strcpy (submenu_num[4],"Ραβδόγραμμα πεδίου (επί συνόλου)");
    strcpy (submenu_num[5],"Γραμμή Παλινδρ. πεδίου (επί συνόλου)");
    strcpy (submenu_num[6],"Κυκλικό διάγραμμα πεδίων (επί συνόλου)");
    strcpy (submenu_num[7],"Στατιστική πεδίου (σε επιλογή)");
    strcpy (submenu_num[8],"Ιστόγραμμα-έως 5 πεδία (σε επιλογή)");  
    strcpy (submenu_num[9],"Ραβδόγραμμα πεδίου (σε επιλογή)");
    strcpy (submenu_num[10],"Γραμμή Παλινδρ.πεδίου (σε επιλογή)");
    strcpy (submenu_num[11],"Κυκλικό διάγραμμα πεδίων (σε επιλογή)");
}
else
{
    strcpy (submenu_num[0],"COPY to Clipboard");
    strcpy (submenu_num[1],"DELETE Field's Data"); 
    strcpy (submenu_num[2],"Field Statistics (All DB Cards)");  
    strcpy (submenu_num[3],"Histogram (All DB Cards)");
    strcpy (submenu_num[4],"Bar Diagram (All DB Cards)");
    strcpy (submenu_num[5],"Regression Line (All DB Cards)");
    strcpy (submenu_num[6],"Piechart (All DB Cards)");
    strcpy (submenu_num[7],"Field Statistics (Chosen Cards)");
    strcpy (submenu_num[8],"Histogram (Chosen Cards)");
    strcpy (submenu_num[9],"Bar Diagram (Chosen Cards)");
    strcpy (submenu_num[10],"Regression Line (Chosen Cards)");
    strcpy (submenu_num[11],"Piechart (Chosen Cards)");
}

if (keyb_gr) {
    strcpy (submenu_ico[0],"ΑΝΤΙΓΡΑΦΗ στον Clipboard");
    strcpy (submenu_ico[1],"Σύνδεση ΕΙΚΟΝΑΣ με GIMP");
    strcpy (submenu_ico[2],"Σύνδεση ΕΙΚΟΝΑΣ με INKSCAPE");
    strcpy (submenu_ico[3],"Σύνδεση ΕΙΚΟΝΑΣ με NOMACS");
    strcpy (submenu_ico[4],"Σύνδεση ΕΙΚΟΝΑΣ με GEEQIE");
    strcpy (submenu_ico[5],"ΔΙΑΓΡΑΦΗ στοιχείων πεδίου");
}
else
{
    strcpy (submenu_ico[0],"COPY to Clipboard");
    strcpy (submenu_ico[1],"Edit IMAGE with GIMP");
    strcpy (submenu_ico[2],"Edit IMAGE with INKSCAPE");
    strcpy (submenu_ico[3],"Edit IMAGE with NOMACS");
    strcpy (submenu_ico[4],"Open IMAGE with GEEQIE"); 
    strcpy (submenu_ico[5],"DELETE Field's Data");  
}

if (keyb_gr) strcpy (missing , "Το αρχείο λείπει!");
else strcpy (missing , "Missing File!");
normtext_tomy(missing,0);

if (keyb_gr) {
    strcpy (alg_prob[0],"Συντακτικώς είναι εντάξει");
    strcpy (alg_prob[1],"Ακατάλληλη ή κενή αριθμητική παράσταση");
    strcpy (alg_prob[2],"Συντακτικό Σφάλμα");
    strcpy (alg_prob[3],"Κακή χρήση τελεστών");
    strcpy (alg_prob[4],"Κακή χρήση παρενθέσεων");
    strcpy (alg_prob[5],"Κακή αλληλοσυσχέτιση πεδίων");
    strcpy (alg_prob[6],"Πολύ μεγάλος αριθμός");
    strcpy (alg_prob[7],"Αναδρομική Συσχέτιση πεδίου");
    strcpy (alg_prob[8],"Υπολογιστική αδυναμία");
    strcpy (alg_prob[9],"Aνύπαρκτο πεδίο");
    strcpy (alg_prob[10],"Aκατάλληλο πεδίο");
    strcpy (alg_prob[11],"Απροσδιόριστο σφάλμα");
    strcpy (alg_prob[12],"Kενό πεδίο υπολογισμών");
    strcpy (diaxetik , "Διαχείριση Ετικετών");
    strcpy (diaxped , "Διαχείριση Πεδίων");
}
else {
    strcpy (alg_prob[0],"It seem's ok");
    strcpy (alg_prob[1],"Invalid or empty arithmetic expression");
    strcpy (alg_prob[2],"Syntax Error");
    strcpy (alg_prob[3],"Bad use of operators");
    strcpy (alg_prob[4],"Bad use of brackets");
    strcpy (alg_prob[5],"Bad fields' cross-correlation");
    strcpy (alg_prob[6],"Huge Number");
    strcpy (alg_prob[7],"Retrospective field correlation");
    strcpy (alg_prob[8],"Calculation Error");
    strcpy (alg_prob[9],"Non-existent field");
    strcpy (alg_prob[10],"Inappropriate field");
    strcpy (alg_prob[11],"Undefined Error");
    strcpy (alg_prob[12],"Empty Calculation Field");
    strcpy (diaxetik , "Labels Management");
    strcpy (diaxped , "Fields Management");
}

sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
normtext_tomy ( mmestr3c , mmestr[3]) ;

normtext_tomy("UNDO",undo_text);
normtext_tomy("REDO",redo_text);

ch3=255;
gen_ergo=&ch3;
// Μηδενίζω δείκτες μνήμης των 10 buttons  - ορίζω όριο=50 - μηδενίζω σημαία sorting!
for (f=0;f<10;f++) { dbbut[f].mem_butt=0; dbbut[f].butt_sorton=0; dbbut[f].butt_orio=50;}

// Μηδενίζω 100 δείκτες δεδομένων καρτελλών και 100 δείκτες δομών κριτηρίων εύρεσης και 101 κριτήρια...
for(f=0;f<100;f++) { memk[f]=0; memcp[f]=0; multicr[f]=0; normdeigma[f][0]=255; }

normdeigma[100][0] = 255 ;


      
dbfdata.mem_fd=0 ; // Μηδενίζω τον void * για το button που δείχνει στοιχεία πεδίων .
dbfdata.fd_sorton=0; // Αρχική τιμή 0 στον sorton.
bmenuxt=info.left+1;bmenuyt=info.top+1 ; bmenuxb=bmenuxt+68 ; bmenuyb=bmenuyt+17;    
topdbnamext=info.left+74;topdbnamexb=topdbnamext+147; // Στο X=72 kai χ=149 διαχωρ. γραμμή
topinfxt=topdbnamexb+4; topinfyt=info.top+1 ;

strcpy (file_1,path_name);
strcat (file_1,"ICD/menu_18.ico");
mem_butmenu=icontomem(file_1,255);
if (!mem_butmenu) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_up_18.ico");
mem_pgup=icontomem(file_1,255);
if (!mem_pgup) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_down_18.ico");
mem_pgdn=icontomem(file_1,255);
if (!mem_pgdn) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/chain-link.ico");
mem_chain=icontomem(file_1,255);
if (!mem_chain) {information (2-keyb_gr,0,0); goto gamidia;}

mem_kato=malloc(imagesize (0,0,15,15));
if (!mem_kato) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/save-card.ico");
mem_savecard=icontomem(file_1,255);
if (!mem_savecard) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/card_left.ico");
mem_leftcard=icontomem(file_1,255);
if (!mem_leftcard) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/card_right.ico");
mem_rightcard=icontomem(file_1,255);
if (!mem_rightcard) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sm_DB.ico");
mem_sumdb=icontomem(file_1,255);
if (!mem_sumdb) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/addcard.ico");
mem_addcard=icontomem(file_1,255);
if (!mem_addcard) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/seardb.ico");
mem_search=icontomem(file_1,255);
if (!mem_search) {information (2-keyb_gr,0,0); goto gamidia;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Selections_18.ico");
mem_usersel=icontomem(file_1,255);
if (!mem_usersel) {information (2-keyb_gr,0,0); goto gamidia;}


// Είναι για τις σημειώσεις
notes_str[0]=255;
strcpy (file_1,path_name);
strcat (file_1,"draftnotes.dat");
fp=fopen(file_1,"rb");
if (fp!=NULL) {
    i=0;
    fread (&what,1,1,fp);
    do {
        if (what<164 || what==200) {notes_str[i++]=what ;}
        fread(&what,1,1,fp);
    }while (what!=255 && i<59999);
    notes_str[i]=255;
    fclose(fp);
    fp=NULL;
}
else {
    fp=fopen(file_1,"wb");
    if (fp!=NULL) {
        fide_notes=fileno(fp);
        notes_str[0]=255;
        fwrite (notes_str,1,1,fp);
        fsync (fide_notes);
        fclose (fp);
        fp=NULL;
    }
}

setcolor( COLOR (topslxr[0],topslxr[1],topslxr[2]) );
line(info.left,info.top+19,info.right,info.top+19);
line(info.left,info.top+20,info.right,info.top+20);
_puticon(bmenuxt,bmenuyt,mem_butmenu,255);
setcolor(COLOR(255,255,255));
line(topdbnamext-2,info.top,topdbnamext-2,info.top+18);
line(topdbnamexb+2,info.top,topdbnamexb+2,info.top+18);
//line(topinfxb+2,info.top,topinfxb+2,info.top+18);
info.top+=21;
savedbpath[0]='\0';
synolo_butstr[0]=255; synolo_butstr[1]=254; 
mem1=malloc(size_fds);
if (!mem1) { information (2-keyb_gr,0,0); goto gamidia; }
synolo_fds=mem1;
synolo_fds[0]=255 ; synolo_fds[1]=254;
mem1=0;

// Καθορισμός των ενεργών ή μη επιλογών του βασικού μενού
// Οι ενεργές είναι 0 !
for (f=2;f<18;f++) mmed[f]=1;
// mmed[20]=0; // Δημιουργία Λίστας
mmed[21]=1; // Επιλέγω από έτοιμες φορτωμένες λίστες
// mmed[22]=0; // Φόρτωση Νέας Λίστας
mmed[0]=mmed[1]=mmed[11]=mmed[17]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;

setcolor(COLOR(255,255,255));
dbopen=0;
dbmaxbut=-1;delon=0;
metr=0;
mbut=0; // Ελέγχει εικονίδιο μενού 
kyk=-1;
// str[0]=255; // Είναι για τις σημειώσεις
ektos=1;
inpx=info.right-info.left;
inpy=info.bottom-info.top;
inpx=(inpx-500)/2; inpy=(inpy-400)/2; inpx1=inpx+500; inpy1=inpy+400;
Xt=info.right-275 ; Yt=Xt+65 ; Wt=Yt+82 ; Ht=Wt+75; 
Xb=Xt+17; Yb=Yt+17 ; Wb=Wt+17 ; Hb=Ht+17;
butpgupxt=Xt-130 ; butpgdnxt=butpgupxt+85;
toppgxt=butpgupxt + 56 ;
line (butpgdnxt+22 , topinfyt , butpgdnxt+22 , topinfyt+17);
line (butpgupxt-5,topinfyt,butpgupxt-5,topinfyt+17);
cardlext = butpgupxt-143; cardNoxt=cardlext+24; cardNoxb=cardNoxt+50; cardrixt=cardNoxb+3; cardsaxt = cardrixt+24; 
dbasext=cardlext-95 , dbtotcardxt=dbasext + 30 ; dbtotcardxb = dbtotcardxt+50 ;
uhupgxt=butpgupxt+20 ; uhupgxb=butpgdnxt-2;
cardareaxt=cardlext+23; cardareaxb=cardrixt-2;
cardnewxt=dbasext-43;
search_flagxt=cardnewxt-43;
gundo_xt = search_flagxt - 55 ;
gundo_xb = gundo_xt + 48;
gredo_xb = gundo_xt-4;
gredo_xt = gredo_xb-48;

_puticon(butpgupxt,bmenuyt,mem_pgup,255);
_puticon(butpgdnxt,bmenuyt,mem_pgdn,255);
line (cardlext-3,topinfyt,cardlext-3,topinfyt+17);
line (cardsaxt+39,topinfyt,cardsaxt+39,topinfyt+17);
line (dbasext-3,topinfyt,dbasext-3,topinfyt+17);
line (dbasext-5,topinfyt,dbasext-5,topinfyt+17);
line (dbtotcardxb+10,topinfyt,dbtotcardxb+10,topinfyt+17);
line (cardnewxt-3,topinfyt,cardnewxt-3,topinfyt+17);
line (cardnewxt-5,topinfyt,cardnewxt-5,topinfyt+17);
line(search_flagxt-5, topinfyt , search_flagxt-5 , topinfyt+17);
line(search_flagxt-3, topinfyt , search_flagxt-3 , topinfyt+17);
_puticon(cardlext,bmenuyt,mem_leftcard,255);
_puticon(cardrixt,bmenuyt,mem_rightcard,255);
_puticon(cardsaxt,bmenuyt,mem_savecard,255);
_puticon(dbasext,bmenuyt,mem_sumdb,255);
_puticon(cardnewxt,bmenuyt,mem_addcard,255);
topinfxb = search_flagxt-6;
//line(topinfxb+2,bmenuyt,topinfxb+2,bmenuyt+17);

cls();

//Στοιχεία για τη δομή open_buts η οποία χρησιμοποιείται για να επιλέγονται τα φορτωμένα buttons/lists 

open_buts.butt_orio=21;
if (keyb_gr) sprintf(str1024,"Φορτωμένες Λίστες"); else sprintf(str1024,"Loaded Lists");
normtext_tomy(str1024 , open_buts.butt_name);
open_buts.butt_sorton=0;
open_buts.mem_butt=(void *) synolo_butstr;
open_buts.butt_ar=0;

//Στοιχεία για τη δομή dbfds η οποία χρησιμοποιείται για να επιλέγονται πεδία της data base  - Επόμενες ενημερώσεις με την info_dbfds()

dbfds.fd_orio=32;
if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
normtext_tomy(str1024 , dbfds.fd_name);
dbfds.fd_sorton=0;
dbfds.mem_fd = (void *) synolo_fds ;
dbfds.fd_ar=0;

if (keyb_gr) strcpy (str1024 , "Παρακαλώ Περιμένετε..");
else strcpy (str1024 , "Please Wait..");
normtext_tomy (str1024,please_wait);

// Ενημέρωση στοιχείων δομής dbfnt.


i=info_dbfnt();
if (!i) {information (2-keyb_gr,0,0); goto gamidia;}
if (keyb_gr) sprintf(str1024,"Επιλέξατε Γραμματοσειρά");
else sprintf(str1024,"Choose Character Font");
normtext_tomy(str1024 , dbfnt.fn_name);

//Μηδενίζει το void δείκτη της δομής dbsec που χρησιμοποιείται στη παρουσίαση φώτο της DB !
dbsec.mem_fd=0;


// ΕΛΕΓΧΟΣ ΓΙΑ ΛΙΣΤΕΣ που πρέπει να φορτωθούν αυτόματα !

sprintf (file_2,"%s%s",path_name,"Lists/usrLst.dat");
fp = fopen(file_2,"rb");

if (fp==NULL) { 
        fp = fopen(file_2,"wb");
        if (fp==NULL) {information (6-keyb_gr,file_2,0); goto EVENT_HANDLER;}
        fide_gen = fileno (fp) ;
        fwrite (&dbmaxbut,2,1,fp) ;
        if (ferror(fp)) {information (6-keyb_gr,file_2,0);clearerr(fp) ; fclose(fp);} 
        else {fsync(fide_gen); fclose (fp);} 
        fp=NULL;
        goto EVENT_HANDLER;}
    
fread (&dbmaxbut,2,1,fp) ;

if (dbmaxbut>=0 && dbmaxbut<10) {
    
    fread (&diaf1,4,1,fp);
    fread (synolo_butstr,1,diaf1,fp);
    if (ferror(fp)) {information (6-keyb_gr,file_2,0);clearerr(fp) ; fclose(fp); fp=NULL; dbmaxbut=-1; synolo_butstr[0]=255; synolo_butstr[1]=254; goto EVENT_HANDLER;} else fclose (fp);
    fp=NULL;
    f=0;
    while(synolo_butstr[f]!=254) f++;
    open_buts.butt_ar=f;
    a=0;w=0;
    for (f=0;f<=dbmaxbut;f++) {
        
        i=w;h=0;
        while (synolo_butstr[i]!=255) {file_3[h++]=synolo_butstr[i++];}
        file_3[h]=255; w=i+1;
        mytext_tonorm(file_3 , file_2, 45);
        sprintf (str1024,"%s%s%s.inp",path_name,"Lists/",file_2);
        dbbut[f-a].mem_butt = named_button_load(&dbbut[f-a].butt_orio, &dbbut[f-a].butt_ar, str1024);
        if (!dbbut[f-a].mem_butt) a++;  
            else {
                i=0;
                what=file_3[i];
                while(what!=255) {dbbut[f-a].butt_name[i]=what; what=file_3[++i];}
                dbbut[f-a].butt_name[i]=255;
        }
    }
    
    dbmaxbut-=a; w=0;
    if ( (a) && (dbmaxbut>=0) ) {
        
        for (f=0;f<=dbmaxbut;f++) {
            i=0;
            what=dbbut[f].butt_name[i];
            while (what!=255) {synolo_butstr[w++]=what; what=dbbut[f].butt_name[++i];}
            synolo_butstr[w++]=255;
           }
            synolo_butstr[w]=254;
            open_buts.butt_ar=w;
        }
    
    if (dbmaxbut>=0) {mmed[15]=mmed[21]=0;} else {synolo_butstr[0]=255; synolo_butstr[1]=254;open_buts.butt_ar=0;dbmaxbut=-1;}
}
else {fclose (fp);dbmaxbut=-1; }

EVENT_HANDLER :

for (f=0 ; f<100 ; f++) { alg_str[f]=0; }
prox_alg_str[0]=255;

                  // E V E N T    HANDLER !
if (keyb_gr){
    sprintf(top_str,"X:      Y:       Pl:      Yc:      ");    
    outsouv_col(butpgupxt+22,topinfyt+2,"Sel.",1,redchxr,topbkxr);
    outsouv_col(Xt-18,2,top_str,1,redchxr,topbkxr);
    }
else {                                                     
    sprintf(top_str,"X:      Y:       Wd:      He:      ");
    outsouv_col(butpgupxt+22,topinfyt+2,"Pg. ",0,redchxr,topbkxr);
    outsouv_col(Xt-18,2,top_str,0,redchxr,topbkxr);
    }

 proel=progvn=prodvn=i1=-1; 
 photopath[0]='\0';
 
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);

if (argc==2) {
    f=0;
    //information (0,"ARGC=2 !",0) ;
    i=strlen ( argv[1] ) ;
    if ( i>762 || i<12) goto NORM_SYN;
    ptr_ch=strstr(argv[1],"/Mainped.aba");
    if (!ptr_ch) {
        ptr_ch=strstr(argv[1],".aba");
        if (!ptr_ch) goto NORM_SYN;
        strcpy (str1kb , argv[1]);
        i--;
        while ( (str1kb[i] != '/') && (i) ) i--;
        if (!i) goto NORM_SYN;
        i++;
        str1kb[i]='\0';
        strcat (str1kb,"Mainped.aba");
        f=1;
        //printf("%s\n",str1kb) ;
    }
    mem1=malloc(1024);
    if (!mem1) {information (2-keyb_gr,0,0); goto gamidia;}
    loaddbfile=mem1;
    if (!f) strcpy (loaddbfile , argv[1]);
    else strcpy (loaddbfile , str1kb);
    ex_file=1;
    baserg=klperg;
    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
    _outmystr_center_col (0, mmestr[1],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
    kyk=1;
    refresh();
}
                                                         
mem_progvn = malloc (imagesize(0,0,18,18));
if (!mem_progvn)  {information (2-keyb_gr,0,0); goto gamidia;}

mem_ouon = malloc (imagesize(info.top,info.left,info.right,info.bottom));
if (!mem_ouon)  {information (2-keyb_gr,0,0); goto gamidia;}

mem_cross = malloc (imagesize(0,0,50,50));
if (!mem_cross)  {information (2-keyb_gr,0,0); goto gamidia;}

NORM_SYN:
for(;;) {
    
    if (ex_file) { ex_file=0; goto PRO_OPENDB; }
    
    if (savenow) {
            
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);}
            else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop);  line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();}
            
            if (!cardsabut) {cardsabut=1; putNOTicon(cardsaxt,bmenuyt,mem_savecard);}
            savenow=0;
            goto SVSE_TVRA ; 
        
    }
    
if (!SDL_PollEvent(&sdlev)) continue;

switch (sdlev.type) {
       
    case SDL_MOUSEMOTION:
    {
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (my<0 || my>info.bottom || mx<info.left || mx>info.right) {
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        if (ektos) continue;
        ektos=1;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        continue;
        } 
        
        //_bareacls(Xt,1,Xt+39,18,topbkxr);
        //_bareacls(Yt,1,Yt+39,18,topbkxr);
        if ( (proel==-1) && (prodec==-1)){
        setrgbcolor(dbtop);  
        for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
        sprintf(top_str,"%04d",mx); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
        sprintf (top_str,"%04d",my); outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
        }
        
        if (mx>bmenuxt && mx<bmenuxb && my>bmenuyt && my<bmenuyb) { // Menu Button !!
            
            if (proel!=-1) {proel=-1; putimage(ox1,oy1,mem_ouon,0);
            setrgbcolor(dbtop); if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);}
            refresh();
            for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
            
            }
            else if (progvn!=-1) {
                progvn=-1;
                putimage(gx2-9,gy2-7,mem_progvn,0);
                refresh();
                hide_help(hdhlpxt , hdhlpyt);
            }
            else if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
            else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
            else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop);  line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
            else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
            else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
            else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
            else if (gundo_but) {
                gundo_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }
            else if (fidim_but) {
                fidim_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }
            else if (fidim_redobut) {
                fidim_redobut=0;
                _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                refresh();
            }
            
            else if (alter1_but) { alter1_but=0; hide_help(hdhlpxt , hdhlpyt); }
            
            ektos=0;
            if (mbut) continue;
            putNOTicon(bmenuxt,bmenuyt,mem_butmenu);
            mbut=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
        }
        
        if (mbut) {mbut=0;puticon (bmenuxt,bmenuyt,mem_butmenu,255);}
        
        
        if (mmed[3]==2) {
            
            if (mx>topinfxt+1 && mx<gredo_xt-1 && my>topinfyt && my<topinfyt+17) {   // Alter1_but
                
                if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
                else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                else if (gundo_but) {
                    gundo_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                else if (fidim_but) {
                    fidim_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                else if (fidim_redobut) {
                    fidim_redobut=0;
                    _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                    _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                    refresh();
                }
                else if (prodec!=-1) {
                    hide_help(hdhlpxt , hdhlpyt);
                    putimage(ox1,oy1,mem_ouon,0);
                    prodec=-1;
                    setrgbcolor(dbtop);
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                    refresh();
                    continue;
                }
                else if (prodvn!=-1) {
                    prodvn=-1;
                    putimage(gx2-9,gy2-7,mem_progvn,0);
                    putimage(ox1,oy1,mem_ouon,0);
                    refresh();
                    hide_help(hdhlpxt , hdhlpyt);
                    }
                else if (progvn!=-1) {
                    progvn=-1;
                    putimage(gx2-9,gy2-7,mem_progvn,0);
                    refresh();
                    hide_help(hdhlpxt , hdhlpyt);
                    }
                else if (proel!=-1) {proel=-1; putimage(ox1,oy1,mem_ouon,0); 
                    setrgbcolor(dbtop); if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                    refresh();
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
                    hide_help(hdhlpxt , hdhlpyt);
                }
                
                if (ektos) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }

                ektos=0;
                
                if (alter1_but) continue ;
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                alter1_but=1;
                if (keyb_gr) {
                    if (diax_dec) strcpy (str1024," Εναλλαγή σε Διαχείριση Πεδίων ");
                    else strcpy (str1024," Εναλλαγή σε Διαχείριση Ετικετών ");
                }
                else {
                    if (diax_dec) strcpy (str1024," Switching to Field Management ");
                    else strcpy (str1024," Switching to Label Management ");
                }
                
                show_help (str1024, topinfxt+2, topinfyt+20,  &hdhlpxt , &hdhlpyt) ;
                continue ;
            }
            
            if (alter1_but) { alter1_but=0; hide_help(hdhlpxt , hdhlpyt); }
        }
            
        if (diax_dec && mmed[3]==2) {  // Κίνηση στο χώρο με ενεργή διαχείριση διακοσμητικών ετικετών
            proel=-1; progvn=-1;
                
            a=0;   // Κίνηση στις κάτω γωνίες ετικετών

            for (f=0;f<dcar;f++){
                if (mx>dbdx2[f]-6 && mx<dbdx2[f]+11 && my>dbdy2[f]-6 && my<dbdy2[f]+11 ) {
                    a++ ;
                    if (a==1) {
                     dx=dbdx2[f]-dbdx1[f]+dbdy2[f]-dbdy1[f];
                     dy=mx-dbdx1[f]+my-dbdy1[f];
                     dz=f;
                     continue;
                    }
                    else {
                        mx1=dbdx2[f]-dbdx1[f]+dbdy2[f]-dbdy1[f];
                        my1=mx-dbdx1[f]+my-dbdy1[f];
                        if (mx1<dx) { dx=mx1 ; dz=f; continue ; }
                        else if (mx1==dx) {
                            if (my1<dy) {dy=my1; dz=f;}
                        }
                    }
                    
                } 
            }
                    
            if (a) {
            
                f=dz;
                
                if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
                else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                else if (gundo_but) {
                    gundo_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                else if (fidim_but) {
                    fidim_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                else if (fidim_redobut) {
                    fidim_redobut=0;
                    _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                    _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                    refresh();
                }
                else if (prodec!=-1) {
                    hide_help(hdhlpxt , hdhlpyt);
                    putimage(ox1,oy1,mem_ouon,0);
                    prodec=-1;
                    setrgbcolor(dbtop);
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                    refresh();
                    continue;
                }
                
                if (ektos) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }

                ektos=0;
                cur=dd_elem[f];
                if (prodvn==f) continue ;

                if (prodvn!=-1) {
                    hide_help(hdhlpxt , hdhlpyt);
                    putimage(gx2-9,gy2-7,mem_progvn,0);
                    putimage(ox1,oy1,mem_ouon,0);
                    refresh();
                }
                prodvn=f;
                gx2 = dbdx2[f] ; gy2=dbdy2[f];
                ox1=dbdx1[f] ; oy1=dbdy1[f] ; ox2 = dbdx2[f] ; oy2=dbdy2[f];
                getimage(ox1,oy1,ox2,oy2,mem_ouon);
                getimage(gx2-9,gy2-7,gx2+7,gy2+6,mem_progvn);
                setrgbcolor(dbmag);
                rectangle (dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
                line (dbdx2[f]-9,dbdy2[f]+2,dbdx2[f]+7,dbdy2[f]+2);
                line (dbdx2[f]+7,dbdy2[f]+2,dbdx2[f]+7,dbdy2[f]-7);
                line (dbdx2[f]-7,dbdy2[f]+4,dbdx2[f]+5,dbdy2[f]+4);
                line (dbdx2[f]+5,dbdy2[f]+4,dbdx2[f]+5,dbdy2[f]-5);
                line (dbdx2[f]-4,dbdy2[f]+6,dbdx2[f]+3,dbdy2[f]+6);
                line (dbdx2[f]+3,dbdy2[f]+6,dbdx2[f]+3,dbdy2[f]-3);
                line (dbdx2[f]+1,dbdy2[f]+1,dbdx2[f]+3,dbdy2[f]+5);
                if (keyb_gr) show_help(" Αλλαγή Διαστάσεων ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                else show_help(" Change Dimensions ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                continue ;
            }
    
            if (prodvn!=-1) {
                prodvn=-1;
                putimage(gx2-9,gy2-7,mem_progvn,0);
                putimage(ox1,oy1,mem_ouon,0);
                refresh();
                hide_help(hdhlpxt , hdhlpyt);
                }
                
                
            a=0;
            for (f=0;f<dcar;f++){
                if (mx>dbdx1[f] && mx<dbdx2[f] && my>dbdy1[f] && my<dbdy2[f] ) { 
                    a++ ;
                    if (a==1) {
                     dx=dbdx2[f]-dbdx1[f]+dbdy2[f]-dbdy1[f];
                     dy=mx-dbdx1[f]+my-dbdy1[f];
                     dz=f;
                     continue;
                    }
                    else {
                        mx1=dbdx2[f]-dbdx1[f]+dbdy2[f]-dbdy1[f];
                        my1=mx-dbdx1[f]+my-dbdy1[f];
                        if (mx1<dx) { dx=mx1 ; dz=f; continue ; }
                        else if (mx1==dx) {
                            if (my1<dy) {dy=my1; dz=f;}
                        }
                    }
                } 
            }
                
                    if (a) {
                        
                        f=dz;
                        
                        if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
                        else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                        else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                        else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if (gundo_but) {
                            gundo_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_but) {
                            fidim_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_redobut) {
                            fidim_redobut=0;
                            _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                            _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                            refresh();
                        }

                        
                    if (ektos) {
                        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        }
                    ektos=0;
                    if (f==prodec) continue ;
                    
                    if (prodec!=-1) {
                        hide_help(hdhlpxt , hdhlpyt);
                        putimage(ox1,oy1,mem_ouon,0);
                        refresh();
                    }
                    prodec=f;
                    cur=dd_elem[f];
                    ox1=dbdx1[f] ; oy1=dbdy1[f] ; ox2 = dbdx2[f] ; oy2=dbdy2[f];
                    getimage(ox1,oy1,ox2,oy2,mem_ouon);
                    if (keyb_gr) sprintf (str1kb,"%s%d " , " Ετικέτα Νο " , cur+1);
                    else sprintf (str1kb,"%s%d " , " Label Νο " , cur+1);
                    show_help(str1kb, dbdx1[f], dbdy2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                    setrgbcolor(dbmag);
                    rectangle (dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
                    rectangle (dbdx1[f]+1,dbdy1[f]+1,dbdx2[f]-1,dbdy2[f]-1);
                    setrgbcolor(dbtop);  
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                    f=prodec;
                    sprintf(top_str,"%04d",dbdx1[f]); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
                    sprintf (top_str,"%04d",dbdy1[f]); outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
                    sprintf(top_str,"%04d",(dbdx2[f]-dbdx1[f]+1)); _outsouv_col(Wt,1,top_str,0,topchxr,topbkxr);
                    sprintf (top_str,"%04d",(dbdy2[f]-dbdy1[f]+1)); _outsouv_col(Ht,1,top_str,0,topchxr,topbkxr);
                    refresh();
                    continue ;
                
                }
                
                if (prodec!=-1) {
                    hide_help(hdhlpxt , hdhlpyt);
                    putimage(ox1,oy1,mem_ouon,0);
                    prodec=-1;
                    setrgbcolor(dbtop);
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                    refresh();
                    continue;
                }
            }
        
        if (!diax_dec) {
            prodec=-1; prodvn=-1;
            a=0;                                                        // Κίνηση στους χώρους πεδίων-ετικετών ?
            for (f=0;f<dbar;f++){
                if (mx>dbx1[f] && mx<dbx2[f] && my>dby1[f] && my<dby2[f] ) { a =1 ; break ;} else continue ; }
                    
                    if (a) {
                        
                        if (progvn!=-1) {
                            progvn=-1;
                            putimage(gx2-9,gy2-7,mem_progvn,0);
                            refresh();
                            hide_help(hdhlpxt , hdhlpyt);
                        }
                        else if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
                        else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                        else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                        else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if (gundo_but) {
                            gundo_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_but) {
                            fidim_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_redobut) {
                            fidim_redobut=0;
                            _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                            _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                            refresh();
                        }

                        
                    if (ektos) {
                        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        }
                ektos=0;
                if (f==proel) continue ;
                diaf1=i=f;
                if (proel==-1) {
                    proel=f;
                    cur=db_elem[f][0];
                    
                    
                        if(!db_elem[f][1]) { // Αφορά όνομα πεδίου άρα σίγουρα υπάρχει rectangle πεδίου ορατό !!
                            //dbwxr = (ptr_pedio[cur]->fivar[4]) ? dbrecxr : dbscrxr ;
                            for (i=0;i<dbar;i++) {if (i==f) continue; if (db_elem[i][0]==cur) break;}
                            getimage(dbx1[i]+1,dby1[i]+1,dbx1[i]+16,dby1[i]+16,mem_kato);
                            _puticon(dbx1[i]+1,dby1[i]+1,mem_chain,255);  i1=i;
                        }
                        else {
                            if (mmed[3]==2) {
                                if ( (ptr_pedio[cur]->fitype!=3) && (ptr_pedio[cur]->fitype!=4) ) {
                                    if (keyb_gr) show_help("Αριστ.κλικ : Μετακίνηση / Δεξί κλικ : Επεξεργασία Πεδίου", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                    else show_help("Left Click : Move / Right click:Edit Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                                else if ( ((ptr_pedio[cur]->fitype==3) || (ptr_pedio[cur]->fitype==4)) && (!ptr_pedio[cur]->mathtype) ) {
                                        if (keyb_gr) sprintf (str1kb,"F%u , Αριθμητικό πεδίο - Αριστ.κλικ : Μετακίνηση / Δεξί κλικ : Επεξεργασία Πεδίου",cur+1) ;
                                        else sprintf (str1kb,"F%u , Numeric Field - Left Click : Move / Right click:Edit Field",cur+1) ;
                                        show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                                else {
                                    if (keyb_gr) sprintf (str1kb,"F%u , Πεδίο Υπολογισμών - Αριστ.κλικ : Μετακίνηση / Δεξί κλικ : Επεξεργασία Πεδίου",cur+1) ;
                                    else sprintf (str1kb,"F%u , Calc. Field - Left Click : Move / Right click:Edit Field",cur+1) ;
                                    show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                            }
                            else if (mmed[7]==2) {
                                switch (ptr_pedio[cur]->fitype) {
                                    case 0 :
                                        if (keyb_gr) show_help ("Πεδίο Κειμένου", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Text Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 1:
                                    case 2:
                                        if (keyb_gr) show_help ("Πεδίο Κειμένου Δυναμικής Λίστας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Ready List Text Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 3:
                                    case 4:

                                        if (  !ptr_pedio[cur]->mathtype ) {
                                        if (keyb_gr) sprintf (str1kb,"Αριθμητικό πεδίο F%u",cur+1) ;
                                        else sprintf (str1kb,"Numeric Field F%u",cur+1) ;
                                        show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        }
                                        else {
                                            if (keyb_gr) sprintf (str1kb,"Πεδίο Υπολογισμών  F%u",cur+1) ;
                                            else sprintf (str1kb,"Calculation Field F%u",cur+1) ;
                                            show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        }
                                        break; 
                                        
                                    case 5 :
                                        if (keyb_gr) show_help ("Πεδίο Εικόνας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Image Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 6 :
                                        if (keyb_gr) show_help ("Πεδίο Ημερομηνίας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Date Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                }
                            }
                            else if (mmed[9]==2 || mmed[10]==2) {
                                if (ptr_pedio[cur]->fitype<3) {
                                    if (keyb_gr) show_help("Αρ.κλικ:Εμφάνιση - υπόδειξη ζητούμενων στοιχείων - Δεξί κλικ:Μενού επιλογών", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                    else show_help("Left Click:Show and indicate searching data - Right click:Menu", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                                else {
                                    if (keyb_gr) show_help("Δεξί κλικ:Μενού επιλογών", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                    else show_help("Right click:Menu", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                            }
                            
                            //dbwxr = (ptr_pedio[cur]->fivar[0]) ? dbrecxr : dbscrxr ;
                            if (ptr_pedio[cur]->fivar[3]) {
                            for (i=0;i<dbar;i++) {if (i==f) continue; if (db_elem[i][0]==cur) break;}
                            getimage(dbx1[i]+1,dby1[i]+1,dbx1[i]+16,dby1[i]+16,mem_kato);
                            _puticon(dbx1[i]+1,dby1[i]+1,mem_chain,255);  i1=i;   
                            }
                            else i1=-1;
                        }
                    
                    
                    ox1=dbx1[f] ; oy1=dby1[f] ; ox2 = dbx2[f] ; oy2=dby2[f];
                    getimage(ox1,oy1,ox2,oy2,mem_ouon);
                    setrgbcolor(dbmag);
                    rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                     rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                    setrgbcolor(dbtop);  
                    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                    f=diaf1;
                    sprintf(top_str,"%04d",dbx1[f]); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
                    sprintf (top_str,"%04d",dby1[f]); outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
                    sprintf(top_str,"%04d",(dbx2[f]-dbx1[f]+1)); _outsouv_col(Wt,1,top_str,0,topchxr,topbkxr);
                    sprintf (top_str,"%04d",(dby2[f]-dby1[f]+1)); _outsouv_col(Ht,1,top_str,0,topchxr,topbkxr);
                    refresh();
                    continue ;
                    }
                    else { // proel != -1
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        putimage(ox1,oy1,mem_ouon,0);
                        if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                        refresh();
                        proel=f;
                        cur=db_elem[f][0];
                        
                            if(!db_elem[f][1]) {
                                //dbwxr = (ptr_pedio[cur]->fivar[4]) ? dbrecxr : dbscrxr ;
                                for (i=0;i<dbar;i++) {if (i==f) continue; if (db_elem[i][0]==cur) break;}
                                getimage(dbx1[i]+1,dby1[i]+1,dbx1[i]+16,dby1[i]+16,mem_kato);
                                _puticon(dbx1[i]+1,dby1[i]+1,mem_chain,255); i1=i;
                            }
                            else {

                            if (mmed[3]==2) {if (keyb_gr) show_help("Αριστ.κλικ:(1'')Μετακίνηση / Δεξί κλικ:Επεξεργασία Χαρακτηριστικών Πεδίου-ων", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                            else show_help("Left Click:(1'')Move / Right click:Edit Field(s) Characteristics", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;}
                            else if (mmed[7]==2) {
                                switch (ptr_pedio[cur]->fitype) {
                                    case 0 :
                                        if (keyb_gr) show_help ("Πεδίο Κειμένου", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Text Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 1:
                                    case 2:
                                        if (keyb_gr) show_help ("Πεδίο Κειμένου Δυναμικής Λίστας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Ready List Text Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 3:
                                    case 4:

                                        if (  !ptr_pedio[cur]->mathtype ) {
                                        if (keyb_gr) sprintf (str1kb,"Αριθμητικό πεδίο F%u",cur+1) ;
                                        else sprintf (str1kb,"Numeric Field F%u",cur+1) ;
                                        show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        }
                                        else {
                                            if (keyb_gr) sprintf (str1kb,"Πεδίο Υπολογισμών  F%u",cur+1) ;
                                            else sprintf (str1kb,"Calculation Field F%u",cur+1) ;
                                            show_help(str1kb, dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        }
                                        break; 
                                        
                                    case 5 :
                                        if (keyb_gr) show_help ("Πεδίο Εικόνας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Image Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                        
                                    case 6 :
                                        if (keyb_gr) show_help ("Πεδίο Ημερομηνίας", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        else show_help ("Date Field", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                        break ;
                                }
                            }
                            else if (mmed[9]==2 || mmed[10]==2) {
                                if (ptr_pedio[cur]->fitype<3) {
                                    if (keyb_gr) show_help("Αρ.κλικ:Εμφάνιση - υπόδειξη ζητούμενων στοιχείων - Δεξί κλικ:Μενού επιλογών", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                    else show_help("Left Click:Show and indicate searching data - Right click:Menu", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                                else {
                                    if (keyb_gr) show_help("Δεξί κλικ:Μενού επιλογών", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                    else show_help("Right click:Menu", dbx1[f], dby2[f]+2 , &hdhlpxt , &hdhlpyt) ;
                                }
                            }
            
                                //dbwxr = (ptr_pedio[cur]->fivar[0]) ? dbrecxr : dbscrxr ;
                                if (ptr_pedio[cur]->fivar[3]) {
                            for (i=0;i<dbar;i++) {if (i==f) continue; if (db_elem[i][0]==cur) break;}
                            getimage(dbx1[i]+1,dby1[i]+1,dbx1[i]+16,dby1[i]+16,mem_kato);
                            _puticon(dbx1[i]+1,dby1[i]+1,mem_chain,255); i1=i;   
                                }
                                else i1=-1 ;
                            }
                        
                        ox1=dbx1[f] ; oy1=dby1[f] ; ox2 = dbx2[f] ; oy2=dby2[f];
                        
                        getimage(ox1,oy1,ox2,oy2,mem_ouon);
                        setrgbcolor(dbmag);
                        rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                        rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                        setrgbcolor(dbtop);
                        for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
                        f=diaf1;
                        sprintf(top_str,"%04d",dbx1[f]); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
                        sprintf (top_str,"%04d",dby1[f]); outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
                        sprintf(top_str,"%04d",(dbx2[f]-dbx1[f]+1)); _outsouv_col(Wt,1,top_str,0,topchxr,topbkxr);
                        sprintf (top_str,"%04d",(dby2[f]-dby1[f]+1)); _outsouv_col(Ht,1,top_str,0,topchxr,topbkxr);
                        refresh();
                        continue ;
                    }
                }
            
            if (proel!=-1) {proel=-1; putimage(ox1,oy1,mem_ouon,0); 
                setrgbcolor(dbtop); if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                refresh();
                for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
                hide_help(hdhlpxt , hdhlpyt);
            }
                
    
            if (mmed[3]==2) {
                a=0;                                                        // Κίνηση στις κάτω γωνίες πεδίων-ετικετών

                for (f=0;f<dbar;f++){
                    if (mx>dbx2[f]-6 && mx<dbx2[f]+11 && my>dby2[f]-6 && my<dby2[f]+11 ) {a=1;break;} else continue ;}
                        
                        if (a) {
                        
                        if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
                        else if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                        else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                        else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                        else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                        else if (gundo_but) {
                            gundo_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_but) {
                            fidim_but=0;
                            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                            refresh();
                        }
                        else if (fidim_redobut) {
                            fidim_redobut=0;
                            _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                            _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                            refresh();
                        }
                        
                        if (ektos) {
                            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            }

                    ektos=0;
                    i=f;
                    if (i==progvn) continue ;

                    if (progvn==-1) {
                        progvn=i;
                        
                        gx2 = dbx2[f] ; gy2=dby2[f];
                        getimage(gx2-9,gy2-7,gx2+7,gy2+6,mem_progvn);
                        setrgbcolor(dbmag);
                        line (dbx2[f]-9,dby2[f]+2,dbx2[f]+7,dby2[f]+2);
                        line (dbx2[f]+7,dby2[f]+2,dbx2[f]+7,dby2[f]-7);
                        line (dbx2[f]-7,dby2[f]+4,dbx2[f]+5,dby2[f]+4);
                        line (dbx2[f]+5,dby2[f]+4,dbx2[f]+5,dby2[f]-5);
                        line (dbx2[f]-4,dby2[f]+6,dbx2[f]+3,dby2[f]+6);
                        line (dbx2[f]+3,dby2[f]+6,dbx2[f]+3,dby2[f]-3);
                        line (dbx2[f]+1,dby2[f]+1,dbx2[f]+3,dby2[f]+5);
                        if (keyb_gr) show_help(" Αλλαγή Διαστάσεων ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Change Dimensions ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                        continue ;
                        }
                        else {
                            putimage(gx2-9,gy2-7,mem_progvn,0);

                            gx2 = dbx2[f] ; gy2=dby2[f];
                            getimage(gx2-9,gy2-7,gx2+7,gy2+6,mem_progvn);
                            setrgbcolor(dbmag);
                            line (dbx2[f]-9,dby2[f]+2,dbx2[f]+7,dby2[f]+2);
                            line (dbx2[f]+7,dby2[f]+2,dbx2[f]+7,dby2[f]-7);
                            line (dbx2[f]-7,dby2[f]+4,dbx2[f]+5,dby2[f]+4);
                            line (dbx2[f]+5,dby2[f]+4,dbx2[f]+5,dby2[f]-5);
                            line (dbx2[f]-4,dby2[f]+6,dbx2[f]+3,dby2[f]+6);
                            line (dbx2[f]+3,dby2[f]+6,dbx2[f]+3,dby2[f]-3);
                            line (dbx2[f]+1,dby2[f]+1,dbx2[f]+3,dby2[f]+5);
                            refresh();
                            if (keyb_gr) show_help(" Αλλαγή Διαστάσεων ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                            else show_help(" Change Dimensions ", gx2+10, gy2+10 , &hdhlpxt , &hdhlpyt) ;
                            continue ;
                        }
                    }
                
                if (progvn!=-1) {
                    progvn=-1;
                    putimage(gx2-9,gy2-7,mem_progvn,0);
                    refresh();
                    hide_help(hdhlpxt , hdhlpyt);
                    }
                }
            }
            
            
            if (fidim_undo && mmed[3]==2) {
                if (mx>=gundo_xt && mx<=gundo_xb && my>topinfyt && my<topinfyt+18) {
                    
                    if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                    else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                    else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                    else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                    else if (gundo_but) {
                        gundo_but=0;
                        _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                        _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                        refresh();
                    }
                    else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                    else if (fidim_redobut) {
                        fidim_redobut=0;
                        _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                        _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                        refresh();
                    }
                    
                    
                    if (ektos) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }

                    ektos=0;
                    
                    if (fidim_but) continue ;
                    fidim_but=1;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undolight);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undolight);
                    refresh();
                    continue ;
                }
                
                if (fidim_but) {
                    fidim_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
            }
            

            if (fidim_redo && mmed[3]==2) {
                if (mx>=gredo_xt && mx<=gredo_xb && my>topinfyt && my<topinfyt+18) {
                    
                    if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                    else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                    else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
                    else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
                    else if (gundo_but) {
                        gundo_but=0;
                        _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                        _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                        refresh();
                    }
                    else if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (ektos) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }

                    ektos=0;
                    
                    if (fidim_redobut) continue ;
                    fidim_redobut=1;
                    _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redolight);
                    _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redolight);
                    refresh();
                    continue ;
                }
                
                if (fidim_redobut) {
                    fidim_redobut=0;
                    _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                    _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                    refresh();
                }
            }
            
                
        if (seflag==2 || user_opts) {
            if (mx>search_flagxt && mx<search_flagxt+36 && my>topinfyt-1 && my<topinfyt+19) { // Search - Criteria Flag

            if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
            else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
            else if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
            else if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
            else if (gundo_but) {
                gundo_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }

            
            if (ektos) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }

            ektos=0;
            if (critflag) continue ;
            critflag=1;
            
            if (seflag==2) {
            if (keyb_gr) sprintf(str1024, " Ένδειξη Kριτηρίων Eύρεσης - %u καρτέλες / ΔΕΞΙ κλίκ για καθαρισμό!", gocards) ;
            else sprintf(str1024, " Search Criteria indicator - %u DB cards / RIGHT click for cleaning ", gocards) ;
            }
            else {
                if (keyb_gr) sprintf(str1024, " Ένδειξη Επιλογών Χρήστη - %u καρτέλες / ΔΕΞΙ κλικ για καθαρισμό! ", tot_opts) ;
                else sprintf(str1024, " User Selections indicator -  %u DB cards / RIGHT click for cleaning! ", tot_opts) ;
            }
            show_help(str1024, search_flagxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            continue ;
            }
        }
         
        if ( critflag ) {critflag=0; hide_help(hdhlpxt , hdhlpyt);}
        
        if (dbplgr) {
            if (mx>dbasext && mx<dbasext+80 && my>topinfyt-1 && my<topinfyt+19) {  // DB cards number saved 

                if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                else if (gundo_but) {
                    gundo_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                
                if (ektos) {
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }

                ektos=0;
                if (dbincards) continue ;
                dbincards=1;
                
                if (keyb_gr) strcpy(str1024," Σύνολο καρτελών στο δίσκο ") ;
                else sprintf(str1024," Total DB cards in the disk ") ;
                show_help(str1024, dbasext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
                continue ;
                
            }
        }
        
        if ( dbincards ) {dbincards=0; hide_help(hdhlpxt , hdhlpyt);}
        
        if (savedbpath[0]!='\0') {
            if (mx>topdbnamext && mx<topdbnamexb && my>topinfyt-1 && my<topinfyt+19) {  // DB Name ?
    
                if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
                else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
                else if (gundo_but) {
                    gundo_but=0;
                    _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                    _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                    refresh();
                }
                
                if (ektos) {
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }

                ektos=0;
                if (dbfname) continue ;
                dbfname=1;
                
                if (keyb_gr) sprintf(str1024," Φάκελος Βάσης Δεδομένων : %s ",savedbpath) ;
                else sprintf(str1024,"Data Base Directory : %s ",savedbpath) ;
                show_help(str1024, topdbnamext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
                continue ;
                
            }
        }
        
        if ( dbfname ) {dbfname=0; hide_help(hdhlpxt , hdhlpyt);}
         
        if (mx>butpgupxt && mx<butpgupxt+18 && my>topinfyt-1 && my<topinfyt+19) {  // DB Page Up
            
            if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
            else if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);refresh();}
            else if (gundo_but) {
                gundo_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }
            
            if (ektos) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }

            ektos=0;
            
            if (dbpgup) continue;
            dbpgup=1;
            putNOTicon(butpgupxt,bmenuyt,mem_pgup);
            continue ;
            
        }
        
        if (dbpgup) {dbpgup=0; puticon(butpgupxt,bmenuyt,mem_pgup,255);}
        
        
        if (mx>butpgdnxt && mx<butpgdnxt+18 && my>topinfyt-1 && my<topinfyt+19) {  // DB Page Down
            
            if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();hide_help(hdhlpxt , hdhlpyt);}
            else if (gundo_but) {
                gundo_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }
            
            
            if (ektos) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }

            ektos=0;
            
            if (dbpgdn) continue;
            dbpgdn=1;
            putNOTicon(butpgdnxt,bmenuyt,mem_pgdn);
            continue ;
            
        }
        
    if (dbpgdn) {dbpgdn=0; puticon(butpgdnxt,bmenuyt,mem_pgdn,255);}
        
    if (mx>cardlext && mx<cardlext+21 && my>topinfyt-1 && my<topinfyt+19) {  // Card to the Left

            if (cardsabut) {cardsabut=0 ; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();hide_help(hdhlpxt , hdhlpyt);}
            else if (gundo_but) {
                gundo_but=0;
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
            }
                    

        if (ektos) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }

        ektos=0;
        if (cardlebut) continue ;
        cardlebut=1;
        putNOTicon(cardlext,bmenuyt,mem_leftcard);
        
        if (seflag!=2 && !user_opts) {
            if (keyb_gr) show_help(" Προηγούμενη Καρτέλα ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Previous DB Card ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
            
        else if (user_opts) {
            if (keyb_gr) show_help(" Προηγούμενη Καρτέλα (επιλογές χρήστη) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Previous DB Card (user selections) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
        
        else { 
            if (keyb_gr) show_help(" Προηγούμενη Καρτέλα (Κριτήρια Εύρεσης) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Previous DB Card (Search Criteria) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
        continue ;
    }
    
    if (cardlebut) {cardlebut=0; puticon(cardlext,bmenuyt,mem_leftcard,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (mx>cardrixt && mx<cardrixt+21 && my>topinfyt-1 && my<topinfyt+19) {  // Card to the right
        
    if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();hide_help(hdhlpxt , hdhlpyt);}
    else if (gundo_but) {
        gundo_but=0;
        _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
        _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
        refresh();
    }
            
    if (ektos) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }

    ektos=0;
    if (cardribut) continue ;
    cardribut=1;
    putNOTicon(cardrixt,bmenuyt,mem_rightcard);
    
        if (seflag!=2 && !user_opts) {
            if (keyb_gr) show_help(" Επόμενη Καρτέλα ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Next DB Card ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
            
        else if (user_opts) {
            if (keyb_gr) show_help(" Επόμενη Καρτέλα (επιλογές χρήστη) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Next DB Card (user selections)", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
        
        else { 
            if (keyb_gr) show_help(" Επόμενη Καρτέλα (Κριτήρια Εύρεσης) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Next DB Card (Search Criteria) ", cardlext, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        }
         continue;
    }
    
    if (cardribut) {cardribut=0; puticon(cardrixt,bmenuyt,mem_rightcard,255);hide_help(hdhlpxt , hdhlpyt);}
        
    
    if (mx>cardsaxt && mx<cardsaxt+37 && my>topinfyt-1 && my<topinfyt+19) {  // SAVE Card
        
    if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);hide_help(hdhlpxt , hdhlpyt);}
    else if (gundo_but) {
        gundo_but=0;
        _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
        _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
        refresh();
    }
       
    if (ektos) {
       cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
       }

    ektos=0;
    if (cardsabut) continue ;
    cardsabut=1;
    putNOTicon(cardsaxt,bmenuyt,mem_savecard);
    if (keyb_gr) show_help(" Σώσε την Καρτέλα στο Δίσκο ", cardsaxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" Save DB Card to the Disk ", cardsaxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
    continue;
    }
    
    if (cardsabut) {cardsabut=0; puticon(cardsaxt,bmenuyt,mem_savecard,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (mx>cardnewxt && mx<cardnewxt+37 && my>topinfyt-1 && my<topinfyt+19) {  // New Card
        
        if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();hide_help(hdhlpxt , hdhlpyt);}
        else if (gundo_but) {
            gundo_but=0;
            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
            refresh();
        }
            
        if (ektos) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }

        ektos=0;
        if (cardnewbut) continue ;
        cardnewbut=1;
        putNOTicon(cardnewxt,bmenuyt,mem_addcard);
        if (keyb_gr) show_help(" Νέα Καρτέλα ", cardnewxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" New DB Card ", cardnewxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        continue;
    }
    
    if (cardnewbut) {cardnewbut=0; puticon(cardnewxt,bmenuyt,mem_addcard,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (mx>cardareaxt && mx<cardareaxb && my>topinfyt-1 && my<topinfyt+19) {  // Show DB Card No ...
         
        if (gundo_but) {
            gundo_but=0;
            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
            refresh();
        }

        
    if (ektos) {
       cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
       }

    ektos=0;
       
    if (cardareabut) continue ;
    cardareabut=1;
    setrgbcolor (dbred); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18); refresh();
    if (dbplgr && dbcard<=dbplgr) {
        what_mytime (cardwhen, str1kb);
        if (keyb_gr) {
            sprintf (str1024 , " Καρτέλα Νο %u , Εγγραφή : [%s] / Μετάβαση σε άλλη καρτέλα " , dbcard , str1kb);
        }
        else {
            sprintf (str1024 , " DB Card No %u - Entry : [%s] / Goto another DB Card " , dbcard , str1kb);
        }
    show_help(str1024, cardareaxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
    }
    else {
        if (keyb_gr) show_help(" Μετάβαση σε συγκεκριμένη Καρτέλα ", cardareaxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Goto specific DB Card ... ", cardareaxt, topinfyt+30 , &hdhlpxt , &hdhlpyt) ;
    }
    continue;
    }
    
    if (cardareabut) {cardareabut=0 ; setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();hide_help(hdhlpxt , hdhlpyt);}
    
    if (gundo_sit) {
        if (mx>=gundo_xt && mx<=gundo_xb && my>topinfyt && my<topinfyt+18) {
            
            if (ektos) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }

            ektos=0;
            
            if (gundo_but) continue ;
            gundo_but=1;
            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undolight);
            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undolight);
            refresh();
            continue ;
        }
        
        if (gundo_but) {
            gundo_but=0;
            _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
            _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
            refresh();
        }
    }
    
          
    if (ektos) break;
        ektos=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        break ;
    }
    
    case SDL_DROPFILE :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    dropfile=sdlev.drop.file;
    if (!dropfile) break;
    c=strlen (dropfile);
    if ( c < 1024 ) strcpy (str1024,dropfile);
    else { SDL_free(dropfile); break; }
    SDL_free(dropfile);
    setcurrentwindow(win_id);refresh();
    if (mmed[7] != 2) break ; 
    ptr_char=strstr(str1024,".bmp");
    if (!ptr_char) {
        if (keyb_gr) information (0,"Πρέπει να είναι εικόνα τύπου .bmp","Προσπαθήστε πάλι..");
        else information (0,"It must be a .bmp icon file!","Try again..");
        break;}
    a=0;
    do {
        if (! SDL_PollEvent(&sdlev)) continue ;
         if  (sdlev.type != SDL_MOUSEMOTION) continue ; 
        mx = sdlev.motion.x ; my = sdlev.motion.y ;
        if (my<info.top || my>info.bottom || mx<info.left || mx>info.right) a=0 ;
        else a=1;
    }
    while (!a);
    //printf ("%s\n",str1024);
           
    a=0;                                                        // Έλεγχος του χώρου πεδίων-ετικετών ?
    for (f=0;f<dbar;f++){
        if (mx>dbx1[f] && mx<dbx2[f] && my>dby1[f] && my<dby2[f] ) { a =1 ; break ;} else continue ; }
    if (!a) break ;
    
    if (!db_elem[f][1]) break; // Είναι ετικέτα - όνομα πεδίου
    a=i=db_elem[f][0]; // field number
    cur=f;
    
    if (ptr_pedio[i]->fitype!=5) break ;
    
    
    

    if (ptr_pedio[i]->ficode) {
        mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
        file_2[0]=255;
        input_alert (40-keyb_gr,str1kb, file_2 ,4);
        f=(int) convert_str(4 , file_2);
        if (ptr_pedio[i]->ficode != (short int) f ) break;
    }
    //if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0); }
    //putimage(ox1,oy1,mem_ouon,0); refresh();
    keimk=memk[i];
    Cx1=dbx1[cur]; Cy1=dby1[cur]; Cx2=dbx2[cur]; Cy2=dby2[cur]; 
    strcpy(keimk,str1024);
    f=c;
    while (str1024[f] != '/') f-- ;
    for (i=0;i<=f;i++) photopath[i] = str1024[i];
    photopath[i]='\0';
    readimagefile (keimk,Cx1+1, Cy1+1, Cx2-1, Cy2-1);
    proel=-1 ; ektos=1;
    if (ptr_pedio[a]->fivar[2]) bareacls(Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
    eaninpundo();
    break;
    
    case SDL_MOUSEBUTTONDOWN:
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
        dx=abs(mx-mx1) ; dy=abs(my-my1);
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        if (dx>40 || dy>40) continue;
        while (SDL_PollEvent(&sdlev)) continue;
        time(&protime);
        
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
        if (fidim_but || fidim_redobut ) {
            fidimundo_call(0,0);
            continue ;
        }
        
         if (gundo_but) {
            gundo_sit=0; gundo_but=0;
            bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
            continue ;
        }
            
        if (mx1>search_flagxt && mx1<search_flagxt+36 && my1>topinfyt-1 && my1<topinfyt+19) {

            if (epil_pos && user_opts) {
                // Διαγραφή ευρετηρίου προηγούμενης επιλογής !!
                tot_opts=0; 
                mem2=epil_pos; if (mem2) free(mem2); epil_pos=mem2=0;
                user_opts=0;
                bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                break ;
                }
            else if (seflag==2) {

                // ΚΑΘΑΡΙΣΜΟΣ ΚΡΙΤΗΡΙΩΝ
                for (f=0;f<=dbfinum;f++){
                        if (ptr_pedio[f]->fitype!=5) {
                            if (multicr[f]->mem_ghost) free(multicr[f]->mem_ghost) ; 
                            multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;
                        }
                    }
                seflag=0; mmed[10]=1; mmed[9]=2; gen_ergo=mmestr[9];baserg=parous;
                 _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                refresh();
                for (f=0;f<dbplgr;f++) crits[f]=0;
                gocards=0; firstcrit=0;
                break;
            }
        }
            
        
            if ( ( (mmed[7]==2) || (mmed[9]==2) || (mmed[10]==2) ) && (proel!=-1) ) {
                if (!db_elem[proel][1]) break;
                cur=db_elem[proel][0];
                 
                 if (ptr_pedio[cur]->fivar[2]) break ;
                 if (ptr_pedio[cur]->ficode) {
                     mytext_tonorm ( ptr_pedio[cur]->finame , str1kb , 60 );
                     str1024[0]=255;
                     input_alert (40-keyb_gr,str1kb, str1024 ,4);
                     f=(int) convert_str(4 , str1024);
                    if (ptr_pedio[cur]->ficode != (short int) f ) break ;
                }
                
                 keimk=memk[cur];
                if (keimk[0]==255 && ptr_pedio[cur]->fitype!=3 && ptr_pedio[cur]->fitype!=4) break ;
                //if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                setrgbcolor(dbtop); 
                for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
                if (keyb_gr) normtext_tomy ("Μενού επιλογών",str1024);
                else normtext_tomy ("Options Menu",str1024);
                dx=dy=dz=-3; xyz_del=0 ;
                if (ptr_pedio[cur]->fitype==3 || ptr_pedio[cur]->fitype==4) {
                    what = (tot_opts) ? 12 : 7 ;
                    dy=smmenu_show(what, submenu_num, str1024, mx1, my1);}
                else if (ptr_pedio[cur]->fitype==6) {dy=smmenu_show(2, submenu_num, str1024, mx1, my1);}
                else if (ptr_pedio[cur]->fitype==5) {
                    dz=smmenu_show(6, submenu_ico, str1024, mx1, my1);
                }
                else {
                    dx=smmenu_show(12, submenu, str1024, mx1, my1);}
                if (dx<0 && dy<0 && dz<0) {break;}
                i=0;f=0;
                what=keimk[f];
                do {
                    if (what>163) break ;
                    str1024[i++]=what;
                    f++; what=keimk[f];
                }while (f<limk[cur] && i<1023);
                str1024[i]=255;
                i=0;
                               
                switch (dx) {
                    
                    case -3 : 
                        
                        switch (dy) {
                            case -3 : 
                                break;
                            case 0:
                                if (ptr_pedio[cur]->fitype!=5) i=mytext_toclipboard (keimk);
                                else {
                                        i=SDL_SetClipboardText(keimk);
                                        i = (!i) ? 1: 0 ;                       
                                    }
                                if (i) {
                                    if (keyb_gr) {information (0,"Η αντιγραφή στον clipboard πέτυχε!",0);}
                                    else {information (0,"COPY to clipboard succeed !" , 0);}
                                }
                                i=0;
                                break ;
                                
                                
                            case 1:
                                if (keimk[0]==255) break ;
                                user_ans=alert(26-keyb_gr,0,0);
                                if (user_ans==1){
                                xyz_del=1;
                                if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                                putimage(ox1,oy1,mem_ouon,0);
                                Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                                keimk[0]=255;
                                _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1,ptr_pedio[cur]->fibkxr);
                                refresh();
                                }
                                break ;
                        
                            case 2:
                                
                                pedaba_statistics(cur , ar_dom , 0);
                                break ;
                                
                            case 3:
                                
                                multi_statistics(cur , ar_dom , 0);
                                break ;
                                
                            case 4:
                                
                                pedaba_statistics_3d(cur , ar_dom , 0);
                                break ;
                            
                                
                            case 5:
                                
                                regress(cur , ar_dom , 0);
                                break ;
                                
                            case 6:
                                piesl_stats (cur, ar_dom,0) ;
                                break ;
                                
                           case 7:
                                
                                pedaba_statistics(cur , ar_dom , 1);
                                break ;
                                

                           case 8:
                                
                                multi_statistics(cur , ar_dom , 1);
                                break ;
                                
                            case 9:
                                
                                pedaba_statistics_3d(cur , ar_dom , 1);
                                break ;

                           
                            case 10:
                                
                                regress(cur , ar_dom , 1);
                                break ;
                                
                            case 11 :
                                
                              piesl_stats (cur, ar_dom,1) ;  
                                break ;
                                
                        }
                        
                        if (dy>=0) break ;
                        
                        switch (dz) {
                            case -3 : 
                                dy=0;
                                break;
                                
                            case 0:
                                dy=0;
                                if (ptr_pedio[cur]->fitype!=5) i=mytext_toclipboard (keimk);
                                else {
                                        i=SDL_SetClipboardText(keimk);
                                        i = (!i) ? 1: 0 ;                       
                                    }
                                if (i) {
                                    if (keyb_gr) {information (0,"Η αντιγραφή στον clipboard πέτυχε!",0);}
                                    else {information (0,"COPY to clipboard succeed !" , 0);}
                                }
                                i=0;
                                break ;
                        
                            case 1:
                                sprintf(str1024,"gimp -n \"%s\" &",keimk);
                                dy=1;
                                break;
                                
                            case 2:
                                sprintf(str1024,"inkscape \"%s\" &",keimk);
                                dy=1;
                                break;
                                
                            case 3:
                                sprintf(str1024,"nomacs \"%s\" &",keimk);
                                dy=1;
                                break;
                                
                            case 4: 
                                sprintf(str1024,"geeqie \"%s\" &",keimk);
                                dy=1;
                                break ;
                                
                            case 5:
                                dy=0;
                                if (keimk[0]==255) break ;
                                user_ans=alert(26-keyb_gr,0,0);
                                if (user_ans==1){
                                xyz_del=1;
                                if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                                putimage(ox1,oy1,mem_ouon,0);
                                Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                                keimk[0]=255;
                                _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1,ptr_pedio[cur]->fibkxr);
                                refresh();
                                }
                                break ;
                        }
                        
                        if (!dy) break;
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        
                    break ;
                        
                
                    case 0:
                        if (ptr_pedio[cur]->fitype!=5) i=mytext_toclipboard (keimk);
                        else {
                                i=SDL_SetClipboardText(keimk);
                                i = (!i) ? 1: 0 ;                       
                            }
                        if (i) {
                            if (keyb_gr) {information (0,"Η αντιγραφή στον clipboard πέτυχε!",0);}
                            else {information (0,"COPY to clipboard succeed !" , 0);}
                        }
                        i=0;
                        break ;
                
                    case 1:
                         if (ptr_pedio[cur]->fitype==5) {
                             sprintf(str1024,"gimp -n \"%s\" &",keimk);
                        }
                        else if (ptr_pedio[cur]->fitype<3) 
                        {
                        mytext_tonorm(str1024,str1kb,1023);
                        if (str1kb[0] != '/') {i=1; break;}
                        fpex = fopen (str1kb,"r");
                        if (fpex==NULL) {i=1; break;} else fclose(fpex);
                        sprintf(str1024,"gimp -n \"%s\" &",str1kb);
                        }
                        else break ;
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 2:
                         if (ptr_pedio[cur]->fitype==5) {
                             sprintf(str1024,"inkscape \"%s\" &",keimk);
                        }
                        else if (ptr_pedio[cur]->fitype<3)  
                        { 
                            mytext_tonorm(str1024,str1kb,1023);
                            if (str1kb[0] != '/') {i=1; break;}
                            fpex = fopen (str1kb,"r");
                            if (fpex==NULL) {i=1; break;} else fclose(fpex);
                            sprintf(str1024,"inkscape \"%s\" &",str1kb);
                        }
                        else break ;
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 3:
                         if (ptr_pedio[cur]->fitype==5) {
                             sprintf(str1024,"nomacs \"%s\" &",keimk);
                        }
                        else if (ptr_pedio[cur]->fitype<3)  
                        { 
                            mytext_tonorm(str1024,str1kb,1023);
                            if (str1kb[0] != '/') {i=1; break;}
                            fpex = fopen (str1kb,"r");
                            if (fpex==NULL) {i=1; break;} else fclose(fpex);
                            sprintf(str1024,"nomacs \"%s\" &",str1kb);
                        }
                        else break ;
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 4:
                         if (ptr_pedio[cur]->fitype==5) {
                             sprintf(str1024,"geeqie \"%s\" &",keimk);
                        }
                        else if (ptr_pedio[cur]->fitype<3)  
                        { 
                            mytext_tonorm(str1024,str1kb,1023);
                            if (str1kb[0] != '/') {i=1; break;}
                            fpex = fopen (str1kb,"r");
                            if (fpex==NULL) {i=1; break;} else fclose(fpex);
                            sprintf(str1024,"geeqie \"%s\" &",str1kb);
                        }
                        else break ;
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 5:
                         if (ptr_pedio[cur]->fitype>2) break ;
                        else { 
                            mytext_tonorm(str1024,str1kb,1023);
                            if (str1kb[0] != '/') {i=1; break;}
                            fpex = fopen (str1kb,"r");
                            if (fpex==NULL) {i=1; break;} else fclose(fpex);
                            sprintf(str1024,"featherpad \"%s\" &",str1kb);
                        }
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 6:
                         if (ptr_pedio[cur]->fitype>2) break ;
                        else { 
                            mytext_tonorm(str1024,str1kb,1023);
                            if (str1kb[0] != '/') {i=1; break;}
                            fpex = fopen (str1kb,"r");
                            if (fpex==NULL) {i=1; break;} else fclose(fpex);
                            sprintf(str1024,"kwrite \"%s\" &",str1kb);
                        }
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 7: 
                        if (ptr_pedio[cur]->fitype>2) break ;
                        mytext_tonorm(str1024,str1kb,1023);
                        if (str1kb[0] != '/') {i=1; break;}
                        fpex = fopen (str1kb,"r");
                        if (fpex==NULL) {i=1; break;} else fclose(fpex);
                        sprintf(str1024,"vlc --play-and-exit \"%s\" &",str1kb);
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 8 :
                        
                        if (ptr_pedio[cur]->fitype>2) break ;
                        mytext_tonorm(str1024,str1kb,1023);
                        if (str1kb[0] != '/') {i=1; break;}
                        fpex = fopen (str1kb,"r");
                        if (fpex==NULL) {i=1; break;} else fclose(fpex);
                        sprintf(str1024,"cvlc \"%s\" &",str1kb);
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                     
                    case 9 :
                        
                        if (ptr_pedio[cur]->fitype>2) break ;
                        mytext_tonorm(str1024,str1kb,1023);
                        if (!(strstr (str1kb,"http"))) {i=2; break ;}
                        sprintf(str1024,"firefox \"%s\" &",str1kb);
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 10 :
                        
                        if (ptr_pedio[cur]->fitype>2) break ;
                        mytext_tonorm(str1024,str1kb,1023);
                        if (!(strstr (str1kb,"http"))) {i=2; break ;}
                        sprintf(str1024,"google-chrome \"%s\" &",str1kb);
                        
                        if ( (wasopdb) && (fpdb!=NULL) ) {
                            fsync (fide_fpdb);
                            fclose (fpdb);
                            fpdb=NULL;
                        }
                        
                        if ( (wasopca) && (fpcard!=NULL) ) {
                            fsync (fide_fpcard);
                            fclose (fpcard);
                            fpcard=NULL;
                        }
                        
                        if ( (wasopdo) && (fpdom!=NULL) ) {
                            fsync (fide_fpdom);
                            fclose (fpdom);
                            fpdom=NULL;
                        } 
                        
                        system(str1024);
                        break ;
                        
                    case 11 :
                        if (keimk[0]==255) break ;
                        user_ans=alert(26-keyb_gr,0,0);
                        if (user_ans==1){
                        xyz_del=1;
                        if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                        putimage(ox1,oy1,mem_ouon,0);
                        Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                        keimk[0]=255;
                        _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1,ptr_pedio[cur]->fibkxr);
                        refresh();
                        }
                        break ;
                }
                
                //setrgbcolor(dbwxr); rectangle (ox1, oy1, ox2 ,oy2) ;
                //refresh();
                if (!xyz_del) {
                if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                putimage(ox1,oy1,mem_ouon,0);}
                refresh();
                
                if (i==2) {
                    if (keyb_gr) strcpy (str1024,"Μη έγκυρος διαδικτυακός σύνδεσμος!");
                    else strcpy (str1024,"Illegal WEB link!");
                    information (0,str1024,0);
                }
                else if (i==1) {
                    if (keyb_gr) strcpy (str1024,"Μη έγκυρη διαδρομή ή αρχείο !");
                    else strcpy (str1024,"Illegal pathname or file !");
                    information (0,str1024,0);
                }
                
                if ( (wasopdb) && (fpdb==NULL) ) {
                    fpdb=fopen(LDdbfile,"r+b");
                    if (fpdb==NULL) {information (6-keyb_gr,LDdbfile,"Please .. Quit Now !!");}
                    else { fide_fpdb = fileno (fpdb); }
                }
                
                if ( (wasopca) && (fpcard==NULL) ) {
                    fpcard=fopen(Strcardfp,"r+b");
                    if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please .. Quit Now !!");}
                    else { fide_fpcard = fileno (fpcard); }
                }
                
                if ( (wasopdo) && (fpdom==NULL) ) {
                    fpdom=fopen(Strdomfp,"r+b");
                    if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,"Please .. Quit Now !!");}
                    else { fide_fpdom = fileno (fpdom); } 
                } 
                if (mmed[7]==2) eaninpundo();
                proel=-1;ektos=1;
                break;
            }
            
            if (prodec!=-1) {
                teos_dec=(short int) cur;
                fidimundo_call(0,0);
                trecx=ox1 ; trecy=oy1; prorec=1;
                do {
                    dx=add_edit_decor (teos_dec , &teos_dec);
                    if (dx!=2) dbpage_decs();
                    dbdecor_show();
                    dbrecs_show();
                    if (dx!=1) break;
                    dy=0;
                    for (f=0; f<dcar; f++) {
                        if (teos_dec==dd_elem[f]) {dy=1;break;}
                    }
                    if (dy) {
                        prorec=1;
                        trecx=dbdx1[f]; trecy=dbdy1[f];
                        getimage(trecx,trecy,dbdx2[f],dbdy2[f],mem_ouon);
                        setrgbcolor(dbmag);
                        rectangle (dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
                        rectangle (dbdx1[f]+1,dbdy1[f]+1,dbdx2[f]-1,dbdy2[f]-1);
                        refresh();
                    }
                    else prorec=0;
                } while (dx==1);
                prodec=-1;
                continue;
            }
            
            if ( proel!=-1 && (mmed[3]==2) ) {
                //putimage(ox1,oy1,mem_ouon,4);
                //if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                //refresh();
                cur=db_elem[proel][0];
                fiornam=db_elem[proel][1];
                
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                setrgbcolor(dbtop); 
                for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
                fidimundo_call(0,0);
                trecx=ox1 ; trecy=oy1 ; prorec=1; 
                if (i1>=0) {proi1=1; chainx=dbx1[i1]+1; chainy=dby1[i1]+1;}
                i=add_edit_field (cur , &back_arped);
                
                while ( (i==1) && (back_arped<=dbfinum) ) {
                    
                    dbdecor_show (); dbrecs_show (); 
                    dx=0;
                    if (  (!fiornam) && (!ptr_pedio[back_arped]->fivar[3]) ) {
                        fiornam=1;
                    }
                    for (f=0 ; f<dbar; f++) {
                        if ( db_elem[f][0]==back_arped && (db_elem[f][1]==fiornam) ) {dx=1; break;} 
                    }
                    
                    if (dx) {
                        prorec=1;
                        getimage(dbx1[f],dby1[f],dbx2[f],dby2[f],mem_ouon);
                        setrgbcolor(dbmag);
                        rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                        rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                        trecx=dbx1[f] ; trecy=dby1[f];
                        dy=0; 
                        if ( (fiornam)  &&  (ptr_pedio[back_arped]->fivar[3])) {
                            for (f=0; f<dbar; f++) {
                                if ( db_elem[f][0]==back_arped && (!db_elem[f][1]) ) {dy=1;break;} 
                                }
                        }
                        else  if (!fiornam) {
                            for (f=0; f<dbar; f++) {
                                if ( db_elem[f][0]==back_arped && (db_elem[f][1]) ) {dy=1;break;} 
                                }
                        }
                        
                        if (dy) { 
                            proi1=1;
                            chainx=dbx1[f]+1; chainy=dby1[f]+1;
                            getimage(chainx,chainy,dbx1[f]+16,dby1[f]+16,mem_kato);
                            _puticon(chainx,chainy,mem_chain,255);
                        }
                        else proi1=0;
                        
                        refresh();
                    }
                    else { prorec=proi1=0; fiornam=1; }
                    i=add_edit_field (back_arped , &back_arped);
                }
                
                if (i==3) { 

                    if (dbfinum>=0) {for (f=0;f<=dbfinum;f++) {if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}}}
                    
                    mem1=0;
                    if (memx1) {free(memx1); memx1=0;}
                    if (memy1) {free(memy1); memy1=0;}
                    if(memx2)  {free(memx2); memx2=0;}
                    if(memy2)  {free(memy2); memy2=0;}
                    if (dmemx1) {free(dmemx1); dmemx1=0;}
                    if (dmemy1) {free(dmemy1); dmemy1=0;}
                    if(dmemx2)  {free(dmemx2); dmemx2=0;}
                    if(dmemy2)  {free(dmemy2); dmemy2=0;}
                    dbdecs=0;
                    dbpg=dbcurpage=1;dbfinum=-1;decor=0;dcar=0;
                    dbar=dbopen=dbplgr=dbplera=dbrecs=0;
                    savedbpath[0]='\0';
                    _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                    _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                    gen_ergo=&ch3;
                    loaddbfile=LDdbfile;
                    if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                    tot_opts=0; 
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);} 
                    goto OPENDB ;}
                    
                    else if ( (i==4) || (i==5) ) {  // ΠΡΟΣΘΑΦΑΙΡΕΣΗ ΠΕΔΙΟΥ με ενεργή βάση δεδομένων
                        
                        addped=0;
                        delped=0;
                        allorio=0 ;
                        
                        for (f=0;f<=dbfinum;f++) {
                            if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}
                            if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                            if (memk[f]) {free(memk[f]) ; memk[f]=0;}
                            if (memcp[f]) {free(memcp[f]) ; memcp[f]=0;}
                        }
                        
                        
                        mem1=0;
                        
                        if (memx1) {free(memx1); memx1=0;}
                        if (memy1) {free(memy1); memy1=0;}
                        if(memx2)  {free(memx2); memx2=0;}
                        if(memy2)  {free(memy2); memy2=0;}
                        if (dmemx1) {free(dmemx1); dmemx1=0;}
                        if (dmemy1) {free(dmemy1); dmemy1=0;}
                        if(dmemx2)  {free(dmemx2); dmemx2=0;}
                        if(dmemy2)  {free(dmemy2); dmemy2=0;}
                        dbdecs=0;
                        mmed[2]=mmed[5]=mmed[6]=mmed[3]=mmed[4]=mmed[7]=mmed[8]= mmed[9]=mmed[10]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;
                        mmed[0]=mmed[1]=mmed[17]=mmed[11]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;
                        dbpg=dbcurpage=1;dbfinum=-1; decor=0; dcar=0; dbplgr=xlim=xmemk=0;
                        dbar=dbopen=dbplera=dbrecs=0;
                        proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=0 ;  ektos=1;
                        
                        _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                        if (dbfds.mem_fd) free(dbfds.mem_fd) ; 
                        dbfds.mem_fd=0; synolo_fds=0;  size_fds=512; dbfds.fd_ar=0; 
                        if (!dbcard_opt) {
                        if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                        tot_opts=0; 
                        if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        }
                        if (seflag>=2) bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        seflag=0; gocards=0; firstcrit=0;
                        for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                        
                        if (fpdb!=NULL) fclose (fpdb) ; 
                        if(fpcard!=NULL) fclose(fpcard); 
                        
                        if(fpdom!=NULL) {
                            f=fsync(fide_fpdom); 
                            i=fclose(fpdom); 
                            sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); 
                            if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; rewind (fpdom); fclose (fpdom);}
                        }
                        if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; rewind(fpera); fclose (fpera);}}
                        
                        savedbpath[0]='\0';
                        fpdb=NULL; wasopdb=0; fpcard=NULL; wasopca=0; fpdom=NULL; wasopdo=0; fpera=NULL;
                        if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                        if(item_mem) { free(item_mem); item_mem=0; }
                        gen_ergo=&ch3;
                        loaddbfile=LDdbfile;
                        goto OPENDB ;
                    }
                    
                    
                    else if (i==6) { //Διαγραφή τελευταίου πεδίου στοιχείων ! 
                        
                        f=0;
                        if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}
                        if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                        if (memk[f]) {free(memk[f]) ; memk[f]=0;}
                        if (memcp[f]) {free(memcp[f]) ; memcp[f]=0;}
                        
                        
                        
                        mem1=0;
                        
                        if (memx1) {free(memx1); memx1=0;}
                        if (memy1) {free(memy1); memy1=0;}
                        if(memx2)  {free(memx2); memx2=0;}
                        if(memy2)  {free(memy2); memy2=0;}
                        if (dmemx1) {free(dmemx1); dmemx1=0;}
                        if (dmemy1) {free(dmemy1); dmemy1=0;}
                        if(dmemx2)  {free(dmemx2); dmemx2=0;}
                        if(dmemy2)  {free(dmemy2); dmemy2=0;}
                        dbdecs=0;
                        mmed[2]=mmed[5]=mmed[6]=mmed[3]=mmed[4]=mmed[7]=mmed[8]= mmed[9]=mmed[10]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;
                        mmed[0]=mmed[1]=mmed[17]=mmed[11]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;
                        dbpg=dbcurpage=1;dbfinum=-1; dbplgr=xlim=xmemk=0;decor=0;dcar=0;
                        dbar=dbopen=dbplera=dbrecs=0;
                        proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=0 ;  ektos=1;
                        
                        _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                        if (dbfds.mem_fd) free(dbfds.mem_fd) ; 
                        dbfds.mem_fd=0; synolo_fds=0;  size_fds=512; dbfds.fd_ar=0; 
                        if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                        tot_opts=0; dbcard_opt=0;
                        if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        if (seflag>=2) bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        seflag=0; gocards=0; firstcrit=0;
                        for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                        
                        if (fpera!=NULL) fclose(fpera);
                        dbplera=0;
                        sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                        fpera=fopen(str1024,"wb");
                        if (fpera!=NULL) { 
                        fide_fpera = fileno (fpera) ;
                        fwrite (&dbplera,2,1,fpera);
                        fsync (fide_fpera);
                        fclose (fpera); fpera=NULL ;}
                        else {
                            information(6-keyb_gr,str1024,0);
                        }
                        /*
                        if (fpdb!=NULL) fclose (fpdb) ; 
                        if(fpcard!=NULL) fclose(fpcard); 
                        if(fpdom!=NULL) {f=fsync(fide_fpdom); i=fclose(fpdom); sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; rewind (fpdom); fclose (fpdom);}}
                        if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; rewind(fpera); fclose (fpera);}}
                        fpdb=NULL; wasopdb=0; fpcard=NULL; wasopca=0; fpdom=NULL; wasopdo=0; fpera=NULL;
                        */
                        savedbpath[0]='\0';
                        if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                        if(item_mem) { free(item_mem); item_mem=0; }
                        gen_ergo=&ch3;
                        loaddbfile=LDdbfile;
                        goto OPENDB ;
                    }
                    
                    else if (i==11) { // Τροποποίηση mathtype πεδίου
                        a1=0;
                        dx=check_pediaola_math();
                        if (dx<0) {information (2-keyb_gr,0,0); goto ANASORT_FYGE;}
                        dpro = proter_calc_pedivn();
                        if (dpro>0) {
                            for (f=0 ; f<enmath_1; f++) {
                                if (dbkey==prot_calc[f]) { a1=prot_calc[f]; break ; }
                            }
                        }
                        
                        f1=0;
                        if (dbcard>dbplgr) f1=1;
                        else thesi=ar_dom[dbcard-1];

                        if (keyb_gr) strcpy (str1kb,"Επανυπολογισμοί..");
                        else strcpy (str1kb,"Recalculations..");
                        user_ans = proodos(  str1kb, 0, dbplgr,0) ;
                        
                        for (i=0;i<dbplgr;i++) {
                            
                            if (user_ans) { proodos(  0, i, dbplgr,0) ;}
                            
                            dx = fseek (fpcard , ar_dom[i]*dbcardsize , 0) ;
                            if (dx) {information (6-keyb_gr,Strcardfp,0) ; break ;}
                            
                            dx=0;
                            for (f=0;f<=dbfinum;f++) {
                                fread (memk[f] , 1, xlimk[f], fpcard);
                                if (ferror(fpcard)) {information (6-keyb_gr,Strcardfp,0) ; dx=1; break ;}
                            }
                            
                            if (dx) break ;
                            
                            if (dpro>0) {
                                for (dy=0 ; dy<enmath_1; dy++) {
                                    a=prot_calc[dy];
                                    dfx = anal_parast (a, alg_str[a] , &alg_err , 0);
                                    check_orio_write_mathped(a, ptr_pedio[a]->fiorio, 1);
                                    
                                    if (a==dbkey) {
                                        keimk=memk[a];
                                        if ( ptr_pedio[dbkey]->fitype==3 ) {
                                            Litem[i]= (keimk[0]!=255) ? (long int) convert_str(ptr_pedio[a]->fiorio , keimk) : 0 ;
                                        }
                                        else if ( ptr_pedio[dbkey]->fitype==4 ) {
                                            Fitem[i]= (keimk[0]!=255) ? (double) convert_str(ptr_pedio[a]->fiorio , keimk) : 0 ;}
                                    }
                                }
                            }
                            
                                    
                            dx = fseek (fpcard , ar_dom[i]*dbcardsize , 0) ;
                            if (dx) {information (6-keyb_gr,Strcardfp,0) ; break ;}
                            dx=0;
                            for (f=0;f<=dbfinum;f++) {
                                fwrite (memk[f] , 1, xlimk[f], fpcard);
                                if (ferror(fpcard)) {information (6-keyb_gr,Strcardfp,0) ; dx=1; break ;}
                                fdatasync (fide_fpcard) ;
                            }
                            if (dx) break ;
                        }
                        
                        proodos(  0, i, dbplgr,1) ;
                        
                        if (a1) {
                            if ( ptr_pedio[dbkey]->fitype==3 ) {
                                
                            if (dbplgr>1) {
                                new_dom_vo = malloc (dbplgr*2);
                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto ANASORT_FYGE; }
                                new_dom=new_dom_vo;
                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                pro_sort_signedlong(item_mem,new_dom,dbplgr);
                                }
                            }
                            else if ( ptr_pedio[dbkey]->fitype==4 ) {
                                if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto ANASORT_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                    pro_sort_double(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                }
                            }
                            
                            if (dbplgr==1) {
                                rewind (fpdom) ;
                                fwrite(&ar_dom[0],2,1,fpdom); 
                                fdatasync(fide_fpdom) ;
                                if (ferror(fpdom)) {information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}
                                //dbcard=1;
                            }
                            
                            else

                            {

                            // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                            for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                            ar_dom = new_dom;
                            free (ardom_mem);
                            ardom_mem=new_dom_vo;
                            new_dom_vo=0;
                            rewind(fpdom);
                            fwrite(ar_dom,2,dbplgr,fpdom);
                            fdatasync (fide_fpdom);
                            if (ferror(fpdom)) { information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}

                            }

                            // Αριθμός καρτέλας που προκύπτει μετά από ταξινόμηση !!
                            if (!f1) {
                                for (f=0;f<dbplgr;f++) {
                                    if (ar_dom[f]==thesi) break ; 
                                } 
                                dbcard=f+1;
                            }

                        }
                        
                        if (dbcard<=dbplgr) {
                                dx = fseek (fpcard , ar_dom[dbcard-1]*dbcardsize , 0) ;
                                if (dx) {information (6-keyb_gr,Strcardfp,0) ; goto ANASORT_FYGE;}
                                
                                for (f=0;f<=dbfinum;f++) {
                                    fread (memk[f] , 1, xlimk[f], fpcard);
                                    keimk=memk[f];
                                    ceimk=memcp[f];
                                    i=0;
                                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                                    else {
                                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                                        else ceimk[i]=255;
                                    }
                                }
                            }
                        else {
                            for (f=0;f<=dbfinum;f++) {keimk=memk[f]; keimk[0]=255;}
                        }


ANASORT_FYGE:
                        /*
                            if (dbcurpage!=1) {
                            dbcurpage=1;
                            if (memx1) {free(memx1); memx1=0;}
                            if (memy1) {free(memy1); memy1=0;}
                            if(memx2)  {free(memx2); memx2=0;}
                            if(memy2)  {free(memy2); memy2=0;}
                            dbrecs=0;
                            dbpage_recs(0);
                            }
                        */
                        if (seflag>=2) seflag=1;
                        _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                        sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                        _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                        refresh();
                    }
                    
                    
            if (prodbkey!=dbkey) {
                prodbkey=dbkey;
                sec_dbkey=-1;seclevsort=1;

EPANASORT :                    
                if (dbplgr){
                    f1=0;
                    if (seflag>=2) {
                        seflag=1; 
                        mmed[10]=1;
                        _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr); 
                        mmed[9]=2; big_t=2.0 ;
                        baserg=parous; gen_ergo=mmestr[9];
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                        _outmystr_center_col (0, mmestr[9],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); 
                        refresh();}
                        
                    if (dbcard>dbplgr) f1=1;
                    else thesi=ar_dom[dbcard-1];
                    
                    if (seclevsort==2) {
                        if(sec_dbkey != -1) dbkey=sec_dbkey;
                        else seclevsort=1;
                    }
                    
                    h=0;
// ΑΠΟ ΕΔΩ ...      
                    do {
                        
                        seclevsort--;
                        
                        if (item_mem) free (item_mem) ; item_mem=0;
                        
                        alma_deigma=0;
                        for (f=0;f<=dbfinum;f++) { 
                        if (f==dbkey) break; // Υπολογισμός του βήματος fseek ανάλογα με το dbkey !
                        alma_deigma+=xlimk[f];
                        }
                        
                        if (dbkey==100) {
                        cur= sizeof (time_t);    
                        item_mem=malloc(dbplgr*cur);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; h=1; break ;}
                        Ditem=item_mem;
                        dx=0;
                        for (f=0;f<dbplgr;f++) {
                            dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                            if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; h=1; break ;}
                            fread(&Ditem[f],cur,1,fpcard);
                            }
                            if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                            if (dbplgr>1) {
                            new_dom_vo = malloc (dbplgr*2);
                            if (!new_dom_vo) {information (2-keyb_gr,0,0); h=1; break ; }
                            new_dom=new_dom_vo;
                            for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                        
                            pro_sort_ulong(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                            }
                        }
                                                    
                        else if (ptr_pedio[dbkey]->fitype==6) {  // Ημερομηνία !
                        item_mem=malloc(dbplgr*4);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; h=1; break ;}
                        Gitem=item_mem;
                        dx=0;
                        cur=25;
                        for (f=0;f<dbplgr;f++) {
                        dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; h=1; break ;}
                        fread(deigma,1,cur,fpcard);
                        cardiary.ldate=0;
                        if (deigma[0]!=255) {
                        mytext_tonorm(deigma,str1024,50);
                        //i=1;
                        //while (str1024[i]!='\0') i++;
                        //w=i;
                        
                        // Μετατροπή Ημερομηνίας σε unsigned int (cardiary.ldate)
                        w=strlen(str1024);
                        for (i=0;i<4;i++) {
                            nu[i]= str1024[w-i-1] - '0' ;
                        }
                        dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                        //dysena.wotim -= 1900;
                        cardiary.mydate[3]=dysena.dyomikra[1];
                        cardiary.mydate[2]=dysena.dyomikra[0];

                        nu[0]=  str1024[w-6] - '0' ;
                        nu[1]=  str1024[w-7] -  '0';
                        if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                        else cardiary.mydate[0]=nu[1]*10 + nu[0];

                        nu[0]=  str1024[w-9] - '0' ;
                        nu[1]=  str1024[w-10] - '0' ;
                        if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                        else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                }
                        Gitem[f]=cardiary.ldate ;
                        }
                        if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                        if (dbplgr>1) {
                            new_dom_vo = malloc (dbplgr*2);
                            if (!new_dom_vo) {information (2-keyb_gr,0,0); h=1; break ; }
                            new_dom=new_dom_vo;
                            for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                        
                            pro_sort_uint(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                        }
                    }
                    
                    else if ( ptr_pedio[dbkey]->fitype==3 ) { // To κλειδί είναι ακέραιος αριθμός !!
                    
                        cur=limk[dbkey];
                        item_mem=malloc(dbplgr*8);
                            if (!item_mem) {information (2-keyb_gr,0,0) ; h=1; break ;}
                        Litem=item_mem;
                        dx=0;
                        
                        for (f=0;f<dbplgr;f++) {
                        dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; h=1; break ;}
                        fread(deigma,1,cur,fpcard);
                        Litem[f]= (deigma[0]!=255) ? (long int) convert_str(cur , deigma) : 0 ;
                        }
                    if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                    
                    if (dbplgr>1) {
                        new_dom_vo = malloc (dbplgr*2);
                        if (!new_dom_vo) {information (2-keyb_gr,0,0); h=1; break ; }
                        new_dom=new_dom_vo;
                        for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                        pro_sort_signedlong(item_mem,new_dom,dbplgr);
                        }
                    }
                    
                    else if (ptr_pedio[dbkey]->fitype==4) { // To κλειδί είναι φλοατ αριθμός !!
                        cur=limk[dbkey];
                        item_mem=malloc(dbplgr*8);
                            if (!item_mem) {information (2-keyb_gr,0,0) ; h=1; break ;}
                        Fitem=item_mem;
                        dx=0;
                        
                        for (f=0;f<dbplgr;f++) {
                        dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; h=1; break ;}
                        fread(deigma,1,cur,fpcard);
                        Fitem[f]= (deigma[0]!=255) ? (double) convert_str(cur , deigma) : 0 ;
                        }
                    if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                    if (dbplgr>1) {
                            new_dom_vo = malloc (dbplgr*2);
                            if (!new_dom_vo) {information (2-keyb_gr,0,0); h=1; break ; }
                            new_dom=new_dom_vo;
                            for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                        
                            pro_sort_double(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                            }
                    }
                    
                    else {                                               // Απλό κείμενο το sorting key
                    cur=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                    item_mem=malloc(dbplgr*24);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; h=1; break ;}
                    item=item_mem;
                    dx=0;
                    for (f=0;f<dbplgr;f++) {
                        dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; h=1; break ;}
                        fread(deigma,1,cur,fpcard);
                        deigma[cur]=255;
                        xitem[0].big=xitem[1].big=xitem[2].big=0;
                        i=0;by=23;
                        do {
                        what=deigma[i];
                        if (what>163) break;
                        if (keyb_gr){
                                switch (what) {

                                    case 96:
                                    case 101:
                                    case 104:
                                    case 107:
                                    case 116:
                                    case 122:
                                    case 129:
                                    case 132:
                                    case 137:
                                    case 140:
                                    case 143:
                                    case 151:
                                    case 157:
                                    case 163:
                                    what--;
                                    break;

                                    case 108:
                                    case 123:
                                    case 144:
                                    case 158:
                                    what-=2;
                                    break;


                                    case 109:
                                    case 124:
                                    what-=3;
                                    break;

                                    case 130:
                                    what=119;

                                }

                            }
                        rby=by%8; low=(2-(by/8));
                        xitem[low].sma[rby]=what;
                        by-- ; i++;
                        } while (by>=0);
                        item[f].fg=xitem[0].big;
                        item[f].sg=xitem[1].big;
                        item[f].tg=xitem[2].big;
                    }
                if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                if (dbplgr>1) {
                            new_dom_vo = malloc (dbplgr*2);
                            if (!new_dom_vo) {information (2-keyb_gr,0,0); h=1; break ; }
                            new_dom=new_dom_vo;
                            for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                        
                            pro_sort_24b(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                        }
                }
                
            if (dbplgr>1) {              
                // Αναδιάταξη των δεικτών ταξινόμησης στη μνήμη !
                for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                ar_dom = new_dom;
                free (ardom_mem);
                ardom_mem=new_dom_vo;
                new_dom_vo=0;
            }
            
        dbkey=prodbkey;
                        
        } while (seclevsort);
        
// ΜΕΧΡΙ ΕΔΩ
// Σώσιμο Δεικτών Ταξινόμησης !
        
        if (h) goto RESORT_FYGE;
        
        rewind(fpdom);
        fwrite(ar_dom,2,dbplgr,fpdom);
        fdatasync (fide_fpdom);
        if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
        if (dbkey==100) { if (item_mem) free(item_mem) ; item_mem=0;}    

        // Αριθμός καρτέλας που προκύπτει μετά από ταξινόμηση !!
        if (!f1) {
            for (f=0;f<dbplgr;f++) {
            if (ar_dom[f]==thesi) break ; 
            }
            dbcard=f+1;
        }
        
       

RESORT_FYGE:
                seclevsort=1;
                if (dbcurpage!=1) {
                dbcurpage=1;
                if (memx1) {free(memx1); memx1=0;}
                if (memy1) {free(memy1); memy1=0;}
                if(memx2)  {free(memx2); memx2=0;}
                if(memy2)  {free(memy2); memy2=0;}
                dbrecs=0;
                dbpage_decs();
                dbpage_recs(0);
                }
                
                _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                refresh();
                str1kb[0]='\0';
                if (dbkey!=100) {
                    mytext_tonorm ( ptr_pedio[dbkey]->finame , file_1 , 60 );
                    if (keyb_gr) sprintf (str1024,"Η βάση δεδομένων αναταξινομήθηκε!\nΝέο κλειδί : [%s].",file_1);
                    else sprintf (str1024,"The DB has been reclassified !\nNew key : [%s].",file_1);
                    
                    if (sec_dbkey!=-1) {
                        mytext_tonorm ( ptr_pedio[sec_dbkey]->finame , file_1 , 60 );
                        if (keyb_gr) sprintf (str1kb,"Δευτερεύων κλειδί : [%s].",file_1);
                        else sprintf (str1kb,"Secondary Key : [%s].",file_1);
                    }
                }
                else {
                    if (keyb_gr) sprintf (str1024,"Η βάση δεδομένων αναταξινομήθηκε,\nσύμφωνα με τη σειρά καταχώρησης!");
                    else  sprintf (str1024,"The DB has been reclassified,\naccording to the  entry order!");
                }
                
                information (0,str1024,str1kb);
                
             }
        }

            _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
            sprintf(top_str,"%02d",dbcurpage);
            pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
            outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
            dx=check_pediaola_math();
            if (dx<0) {information (2-keyb_gr,0,0);}
            dpro = proter_calc_pedivn(); 
            dbdecor_show ();
            dbrecs_show ();
            dx=info_dbfds(); // Ενημέρωση της δομής dbfds (button με ονόματα πεδίων)
            if (!dx) {information (2-keyb_gr,0,0); break ;}
            if (dbfinum>=0) { if (mmed[7]==1) mmed[7]=0;}
            if (dbfinum>=0) mmed[8]=0;
            proel=-1;ektos=1;
            if (mmed[7]==2) eaninpundo();

            break;
            }
            else
            {
                if (my1<info.top) continue ;
              // Με δεξί κλικ καλείται το button των πεδίων για να πάω αμέσως όπου θέλω .
              if (dbfinum>=0) dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 ); 
              else continue ; 
              if (dx<0) continue;
              proel=-1; ektos=1;
              cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
              SDL_SetCursor(cursor);
FLDSRCH:
              i=dx;
              if (ptr_pedio[i]->fipg != dbcurpage ) {
                dbcurpage=ptr_pedio[i]->fipg;
                if (memx1) {free(memx1); memx1=0;}
                if (memy1) {free(memy1); memy1=0;}
                if(memx2)  {free(memx2); memx2=0;}
                if(memy2)  {free(memy2); memy2=0;}
                
                dbrecs=0;
                _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                sprintf(top_str,"%02d",dbcurpage);
                pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
                dbpage_decs();
                dbpage_recs(0);
                dbdecor_show ();
                dbrecs_show ();
                }
FLDSRCH_1:
                setrgbcolor(dbmag);
                Cx1=ptr_pedio[i]->fixt ; Cy1= ptr_pedio[i]->fiyt ;
                Cx2 = ptr_pedio[i]->fixt+ptr_pedio[i]->fiwid-1 ; Cy2=ptr_pedio[i]->fiyt + ptr_pedio[i]->fihei-1;
                getimage (Cx1-1, Cy1-1, Cx2+1, Cy2+1, mem_ouon);
                putimage (Cx1-1, Cy1-1, mem_ouon,4); refresh();
                rectangle(Cx1-1,Cy1-1,Cx2+1,Cy2+1);
                rectangle(Cx1,Cy1,Cx2,Cy2);
                refresh();
                metr=180000;f=0;a=1;c=0;
                
                 do {SDL_PollEvent(&sdlev);} while (sdlev.type == SDL_MOUSEBUTTONDOWN);
                
                    do {
                        //if ( !SDL_PollEvent(&sdlev) ) continue ;
                        SDL_PollEvent(&sdlev);
                        if (!c) {c=1; mx=sdlev.motion.x ; my=sdlev.motion.y;}
                        mx1=sdlev.motion.x ; my1=sdlev.motion.y;
                        f++;
                    if (f<metr) continue;
                        else {
                        f=0;
                            if (a) {
                            a=0;
                            putimage (Cx1-1, Cy1-1, mem_ouon,0); refresh();
                            setrgbcolor(dbscrxr);
                            rectangle(Cx1-1,Cy1-1,Cx2+1,Cy2+1);
                            rectangle(Cx1,Cy1,Cx2,Cy2);
                            refresh();
                            }
                            else {
                            a=1;
                            setrgbcolor(dbmag);
                            putimage (Cx1-1, Cy1-1, mem_ouon,4); refresh();
                            rectangle(Cx1-1,Cy1-1,Cx2+1,Cy2+1);
                            rectangle(Cx1,Cy1,Cx2,Cy2);
                            refresh();
                            }    
                        }
                    } while ( (abs(mx1-mx)<100) && (abs(my1-my)<100) );
               
                putimage (Cx1-1, Cy1-1, mem_ouon,0); refresh();
            }
            
        continue;
        }
        
        else if (sdlev.button.button==SDL_BUTTON_LEFT) {
            
           if (mbut) {
            
            kyk = gen_menu();
            tokyk=kyk;
            puticon(bmenuxt,bmenuyt,mem_butmenu,255);
PROS_EPILKYK:
            mbut=0;
            ektos=1;
            if (kyk==-60) continue;
            rl=0;
            if (kyk<0) {rl=1; kyk=-kyk;}
            switch (kyk) {
                
                case 25: // ΓΕΝΙΚΕΣ ΟΔΗΓΙΕΣ - HELP
                     if (keyb_gr) filehelp_show(4, "Bas_HELP_GR.dat", "Γενικές Οδηγίες", bmenuxt+(kyk%6)*80+80, bmenuyt+(kyk/6)*80, helpchxr , helpbkxr );
                     else filehelp_show(4, "Bas_HELP_EN.dat", "General Instructions", bmenuxt+(kyk%6)*80+80, bmenuyt+(kyk/6)*80, helpchxr , helpbkxr );
                     continue ;
                    
                case 0:         // Create new DB
                    
                    if (mmed[0]) break ;
                    
                    tokyk=100;
                    diax_dec=0; prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    str1024[0]=255;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                     _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                    user_ans=input_alert (28-keyb_gr,0,str1024, 30);
                    if (user_ans!=1) {new_dbname[0]='\0'; break;}
                    mytext_tonorm (str1024 , new_dbname , 62);
                    diaf1=strlen(new_dbname); 
                    if (!diaf1) {new_dbname[0]='\0'; break;}

                    for (f=0;f<diaf1;f++) {
                    if ( new_dbname[f]=='.' || new_dbname[f]=='/' || new_dbname[f]==' ' ) {new_dbname[f]='_'; continue ;}}
                                        // Alert για το όνομα της βάσης.
                    if (keyb_gr) { 
                        sprintf (str1024,"Ο φάκελος της νέας Βάσης Δεδομένων [%s] θα δημιουργηθεί μέσα στον ήδη υπάρχοντα φάκελο \"Pedaba\" !",new_dbname);
                        sprintf (str1kb,"Ο φάκελος της νέας Βάσης Δεδομένων [%s] θα δημιουργηθεί κάπου αλλού. Θα καθορίσετε τη διαδρομή αμέσως μετά ! ",new_dbname);
                    }
                    else {
                        sprintf (str1024,"The folder of the new Data Base [%s] will be created into the default \"Pedaba\" directory !",new_dbname);
                        sprintf (str1kb,"The folder of the new Data Base [%s] will be created somewhere else. You will be asked to choose an other directory !",new_dbname); 
                    }
                    user_ans = choise_alert (str1024,str1kb,1) ;
                    
                    if (!user_ans || user_ans<0) {new_dbname[0]='\0'; break;}
                    
                    if (user_ans==2) {
                    
                    sprintf (file_2,"/home/%s/",user_name);
                    if (keyb_gr) strcpy (file_1,"\"Eπιλέξτε Διαδρομή\"");
                    else strcpy (file_1,"\"Choose Directory\"");                   
                    sprintf(savedbpath,"zenity --file-selection --title=%s --filename=%s --directory > %s%s",file_1,file_2,path_name,"zenity.txt");
                    system(savedbpath);
                    refresh();

                    // Διαβάζει το όνομα της νέας διαδρομής από το zenity.txt
                    sprintf (savedbpath,"%s%s",path_name,"zenity.txt");
                    fp = fopen(savedbpath,"r");
                    if (fp==NULL) {savedbpath[0]='\0'; break;}
                    f=0;
                    do {
                    savedbpath[f]= (char) getc(fp);
                    f++;
                    }while ( (!feof(fp)) && (f<700) );
                    fclose(fp); fp=NULL;
                    if (f<3) {savedbpath[0]='\0'; break;}
                    f-=2; savedbpath[f]='\0';
                    diaf1=strlen(savedbpath); 
                    if ( (!diaf1)  || (diaf1>700) ) {savedbpath[0]='\0'; break;}
                    strcat(savedbpath,"/");
                    
                    }
                    else {
                        strcpy (savedbpath,path_name);
                    }
                    
                    mem1=malloc(1024);
                    if (!mem1) {information (2-keyb_gr,0,0);savedbpath[0]='\0'; break;}
                    chdir(savedbpath);
                    //sprintf(str1024,"cd%s%s"," ",savedbpath);
                    //system(str1024);
                    sprintf(str1024,"dir > %s%s",path_name,"zendir.txt");
                    system(str1024);
                    sprintf(str1024,"%s%s",path_name,"zendir.txt");
                    fp = fopen(str1024,"r");
                    if (fp==NULL) {savedbpath[0]='\0'; free(mem1); mem1=0; break;}
                    f=0; size=1024;
                    ptr_ch=mem1;
                    ch= (char) getc(fp);
                    while (ch!=EOF) {
                    ptr_ch[f]=ch;
                    f++;
                    ch=(char) getc(fp);
                    if (f>size-4) {
                        size+=1024; 
                        mem1=realloc(mem1,size);
                        if (!mem1) {information (2-keyb_gr,0,0);savedbpath[0]='\0'; break;}
                        ptr_ch=mem1;
                        }
                    }
                    if (!mem1) break ;
                    ptr_ch[f]='\0';
                    fclose(fp); fp=NULL;
                    ptr_char=strstr(ptr_ch,new_dbname);
                    if (ptr_char) {
                        free(mem1);mem1=0;savedbpath[0]='\0';
                        if (keyb_gr) information (0,"Βρέθηκε φάκελος με ίδιο όνομα!" , "Δώστε άλλο όνομα...");
                        else information (0,"There is a same name here !","Give an other name..");
                        break;}
                    free(mem1); mem1=0;
                    
                    strcat(savedbpath,new_dbname);
                    
                    sprintf(str1024,"mkdir%s%s"," ",savedbpath);
                    system(str1024);
                    strcat(savedbpath,"/");
      
                    sprintf(str1024,"%s%s",savedbpath,"Mainped.aba");
                    if (fpdb!=NULL) { rewind(fpdb); fclose (fpdb); fpdb=NULL; wasopdb=0; }
                    fpdb=fopen(str1024,"wb");
                    if (fpdb==NULL) {
                        information(6-keyb_gr,0,0); savedbpath[0]='\0'; break;}
                        
                    fide_fpdb = fileno (fpdb) ;
                        // ΕΓΓΡΑΦΗ ΒΑΣΙΚΩΝ ΣΤΟΙΧΕΙΩΝ της DATA BASE !
                                    // Gia HMEROMHNIA - VRA !!
                                    
                    loaddbfile=str1024;
                    strcpy(LDdbfile,str1024);
                    what_time (dbtime);
                    normtext_tomy (dbtime , 0);
                    
                                // LOIPA STOIXEIA BASHS
                    dbplgr=dbplera=0; dbpg=1;   
                    dbkey=prodbkey=100;
                    dbfinum = -1 ;
                    fwrite (pdaba,4,4,fpdb);     // Κωδικοί αναγνώρισης (fseek 0)
                    fdatasync(fide_fpdb);
                    fwrite (dbtime,1,42,fpdb);  // Ημερομηνία - ώρα δημιουργίας της βάσης δεδομ. (fseek 16)
                    fdatasync(fide_fpdb);
                    fwrite (&dbfinum,2,1,fpdb);   // αριθμός πεδίων (fseek 58)
                    fdatasync(fide_fpdb);
                    fwrite (&a,2,1,fpdb);  // αριθμός ετικετών (fseek 60)
                    fdatasync(fide_fpdb);
                    fwrite (&dbplgr,2,1,fpdb);  // πληθος εγγραφών (fseek 62)
                    fdatasync(fide_fpdb);
                    fwrite (&dbpg,2,1,fpdb);    //  απαραίτητες σελίδες οθόνης  (fseek 64)
                    fdatasync(fide_fpdb);
                    fwrite (dbchxr,4,3,fpdb); // Χρώματα οθόνης (fseek 66)
                    fwrite (dbbkxr,4,3,fpdb);
                    fwrite (dbslxr,4,3,fpdb);
                    fdatasync(fide_fpdb);
                    fwrite (&dbkey,2,1,fpdb);   // (fseek 102)
                    fdatasync(fide_fpdb);
                    mem1=malloc(100*dbfisize);
                    if (!mem1) {information (2-keyb_gr,0,0);break ;}
                    ptr_ch=mem1;
                    for (f=0;f<100*dbfisize;f++) {ptr_ch[f]=0; }
                    
                    fwrite (ptr_ch,1,100*dbfisize,fpdb); //fseek 104
                    fdatasync(fide_fpdb);
                    free(mem1);
                    
                    mem1=malloc(50*dblasize);
                    if (!mem1) {information (2-keyb_gr,0,0);break ;} 
                    ptr_ch=mem1;
                    for (f=0;f<50*dblasize;f++) { ptr_ch[f]=0;}
                    fwrite (ptr_ch,1,50*dblasize,fpdb);  // fseek 104 + 100*dbfisize
                    fdatasync(fide_fpdb);
                    fseek(fpdb,screen_alma,SEEK_SET);
                    fwrite(&DM.w , 4 , 1,fpdb) ;
                    fdatasync(fide_fpdb);
                    fwrite(&DM.h , 4 , 1,fpdb) ;
                    fdatasync(fide_fpdb);
                    free(mem1);mem1=0;
                    
                    if ( ferror(fpdb) ) {information (6-keyb_gr,str1024,0); clearerr(fpdb); fclose (fpdb); fpdb=NULL; wasopdb=0; break;}
                    else { 
                        dx=fsync (fide_fpdb); 
                        dy=fclose (fpdb) ; 
                        fpdb=NULL ; 
                        wasopdb=0;
                        if (dx || dy) information(6-keyb_gr,str1024,0);                    
                    }
                    
                    sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); // Αρχείο Καρτελλών
                    fpcard=fopen(str1024,"wb");
                    if (fpcard==NULL) {information(6-keyb_gr,str1024,0); break ;}
                    fide_fpcard = fileno (fpcard) ;
                    fwrite (&dbplgr,2,1,fpcard);
                    fsync(fide_fpcard);
                    fclose(fpcard); fpcard=NULL; wasopca=0 ;
                    
                    sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); // Αρχείο Δεικτών σειράς Ταξινόμησης
                    fpdom=fopen(str1024,"wb");
                    if (fpdom==NULL) {information(6-keyb_gr,str1024,0); break ;}
                    fide_fpdom = fileno (fpdom) ;
                    fwrite (&dbplgr,2,1,fpdom);
                    fsync(fide_fpdom);
                    fclose(fpdom); fpdom=NULL; wasopdo=0 ;                   
                    
                    sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                    fpera=fopen(str1024,"wb");
                    if (fpera==NULL) {information(6-keyb_gr,str1024,0); break ;}
                    fide_fpera = fileno (fpera) ;
                    fwrite (&dbplera,2,1,fpera);
                    fsync(fide_fpera);
                    fclose(fpera); fpera=NULL;    
                    
                    sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                    fpdec=fopen(str1024,"wb");
                    if (fpdec==NULL) {information(6-keyb_gr,str1024,0); break ;}
                    fide_fpdec = fileno (fpdec) ;
                    fsync(fide_fpdec);
                    fclose(fpdec); fpdec=NULL;  
                    
                    sprintf(str1024,"%s%s",savedbpath,"Mainped.aba");
                    if (keyb_gr) information (0,"H Βάση Δεδομένων δημιουργήθηκε ! \nΤο βασικό αρχείο λέγεται Mainped.aba.",str1024);
                    else information(0,"Data Base created !\nThe basic file is Mainped.aba.",str1024);
                    
                    if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                    tot_opts=0; 
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                    goto OPENDB;
                    break;
                    
                case 1:         // Load DB
                    if (mmed[1]) break;
                    tokyk=100; rego=0 ;prodec=-1;prodvn=-1;
                    diax_dec=0; prodec=prodvn=-1;
                    
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    inp_mem_ghost = 0;
                    if (dbfdata.mem_fd) free (dbfdata.mem_fd) ;
                    dbfdata.mem_fd=0 ; // Μηδενίζω τον void * για το button που δείχνει στοιχεία πεδίων .
                    dbfdata.fd_sorton=0; // Αρχική τιμή 0 στον sorton.
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                    //outsouv_col (topinfxt,topinfyt,mmestr[kyk],keyb_gr,topchxr,topbkxr);
                    mem1=malloc(1024);
                    if (!mem1) {information (2-keyb_gr,0,0); break;}
                    loaddbfile=mem1;
                    
                    dx=menu_dbfiles(loaddbfile);
                    //printf ("From menu_dbfiles : %s\n",loaddbfile);
                    if (dx>0) goto PRO_OPENDB ;
                    
                    
                    sprintf (file_2,"/home/%s/",user_name);
                    if (keyb_gr) strcpy (file_1,"\"Eπιλέξτε και ΦΟΡΤΩΣΤΕ\"");
                    else strcpy (file_1,"\"Choose and LOAD\"");

                    sprintf(loaddbfile,"zenity --file-selection --title=%s --filename=%s --file-filter='*ped.aba' > %s%s",file_1,file_2, path_name,"zenity.txt");
                    system(loaddbfile);
                    refresh();
                    sprintf (loaddbfile,"%s%s",path_name,"zenity.txt");
                    fp = fopen(loaddbfile,"r");
                    if (fp==NULL) {information (6-keyb_gr,0,0); free(mem1); mem1=0; break;}
                    f=0;
                        do {
                        loaddbfile[f]= (char) getc(fp);
                        f++;
                        }while ( (!feof(fp)) && (f<762) );
                    fclose(fp); fp=NULL;
                    if (f<3) {free(mem1); mem1=0; break ;}
                    f-=2; loaddbfile[f]='\0';
                    i=strlen(loaddbfile);
                    if ( i<12 ) {free(mem1); mem1=0; break;}
                    ptr_ch=strstr(loaddbfile,"/Mainped.aba");
                    if (!ptr_ch) {
                        ptr_ch=strstr(loaddbfile,".aba");
                        if (!ptr_ch) {free(mem1); break;}
                        i--;
                        while ( (loaddbfile[i] != '/') && (i) ) i--;
                        if (!i) {free(mem1); break;}
                        i++;
                        loaddbfile[i]='\0';
                        strcat (loaddbfile,"Mainped.aba");
                    }
PRO_OPENDB:
                    strcpy(LDdbfile,loaddbfile);
                    if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                    tot_opts=0; 
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                    
OPENDB:
                    diax_dec=0; prodec=prodvn=-1;gundo_sit=0;gundo_but=0;
                    fidimundo_call(0,0); ics_arped=-1; seclevsort=1 ; sec_dbkey=-1;
                    prin_dec=-1; alter1_but=0;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    c=0;
                    posafoto=0;
                    //dec_lab_db = 104 + (100*dbfisize);
                    //screen_alma = dec_lab_db + 4 ;
                    dbplgr=0 ; dbfinum = -1 ; dbkey = prodbkey = 100 ; dbpg=1 ; 
                    if (fpdb!=NULL) { printf ("KOYFAUHKA !!\n"); rewind(fpdb); fclose (fpdb); fpdb=NULL; wasopdb=0; }
                    //printf("OPENDB : %s\n",loaddbfile);
                    //information (0,loaddbfile ,0);
                    fpdb=fopen(loaddbfile,"r+b");
                                                            
                    if (fpdb==NULL) {information (6-keyb_gr,loaddbfile,0); wasopdb=0; if (mem1) free(mem1) ; mem1=0; break;}

                    fide_fpdb = fileno (fpdb) ;
                    
                        for (f=0 ; f<4 ; f++) {
                        fread(&pdaca,4,1,fpdb);
                        if (feof(fpdb)) { c=1; break; }
                        if (pdaca!=pdaba[f]) {c=1;break;}}

                    if (c) { fclose (fpdb) ; fpdb=NULL; wasopdb=0; if (mem1) free(mem1); mem1=0; break ; } // PROSOXH ΨΕΥΤΙΚΟ ΑΡΧΕΙΟ .aba !!!!!!
                    
                    wasopdb=1 ;
                    // Παίρνω Όνομα φακέλου βάσης δεδομένων
                    
                    ptr_ch=strstr(loaddbfile,"/Mainped.aba");
                    if (!ptr_ch) {fclose (fpdb) ; fpdb=NULL; wasopdb=0; if (mem1) free(mem1); mem1=0; break;} // Πολύ περίεργο θα είναι !!
                    ptr_char=ptr_ch;
                    
                    f=0;
                    while (ptr_char>=(loaddbfile+f)) { savedbpath[f]=loaddbfile[f]; f++;}
                    savedbpath[f]='\0';
                    f=0; ptr_ch--;
                    ch = *ptr_ch;
                    while (ch!='/') {f++ ; ptr_ch--; ch=*ptr_ch;}
                    ptr_ch++;
                    for (i=0;i<f;i++) file_2[i]=*ptr_ch++;
                    file_2[i]='\0'; 
                    
                    // To savedbpath είναι όλο το path και το file_2 είναι το όνομα του φακέλου της βάσης
                    // Ενημέρωση του αρχείου opened.dat με τα πρόσφατα ανοιγμένα αρχεία
                    recent_files_inform (savedbpath,file_2) ;
                    
                     normtext_tomy(file_2,str1024);
                    _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                     _outmystr_center_col (0,str1024 ,topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topchxr,topbkxr); 
                     refresh();
                    
                                          
                    fread (dbtime,1,42,fpdb);  // Ημερομηνία - ώρα δημιουργίας της βάσης δεδομ. (fseek 16)

                    fread (&dbfinum,2,1,fpdb);   // αριθμός πεδίων (fseek 58)
                    // printf("dbfinum=%d\n",dbfinum);
                    fread (&a,2,1,fpdb);  // αριθμός ετικετών (fseek 60)
                    
                    fread (&dbplgr,2,1,fpdb);  // πληθος εγγραφών (fseek 62)
                    
                    fread (&dbpg,2,1,fpdb);    //  απαραίτητες σελίδες οθόνης  (fseek 64)
                    
                    fread (dbchxr,4,3,fpdb); // Χρώματα οθόνης (fseek 66)
                    fread (dbbkxr,4,3,fpdb);
                    fread (dbslxr,4,3,fpdb);
                    setrgbpalette(dbrecxr,dbchxr[0],dbchxr[1],dbchxr[2]);
                    setrgbpalette(dbscrxr,dbbkxr[0],dbbkxr[1],dbbkxr[2]);
                    setrgbpalette(dbselxr,dbslxr[0],dbslxr[1],dbslxr[2]);

                    fread (&dbkey,2,1,fpdb);   // (fseek 102)
                    prodbkey=dbkey;
                                        
                    mmed[0]=mmed[1]=2; mmed[2]=mmed[3]=mmed[5]=mmed[6]=0;
                                         
                    // Με fseek 104 ξεκινάω να διαβάζω τα στοιχεία των πεδίων .
                    
                    for (f=0;f<=dbfinum;f++) {
                        ptr_pedio[f] = malloc (dbfisize);
                        if (!ptr_pedio[f]) {information (2-keyb_gr,0,0); break;}
                        fread (ptr_pedio[f],1,dbfisize,fpdb);
                    }
                    
                    fseek(fpdb, dec_lab_db , 0);
                    fread (&decor,4,1,fpdb);
                    
                    fread (&OUON_WID,4,1,fpdb);
                    fread (&OUON_HEI,4,1,fpdb);
                    if (OUON_WID && OUON_HEI) {
                        if (DM.w<OUON_WID || DM.h<OUON_HEI) {
                            if (keyb_gr) sprintf(str1kb,"Η ανάλυση της οθόνης είναι μικρότερη..\n..από την επιλεγείσα όταν δημιουργήθηκε η βάση!\n Δοκιμάστε σε ανάλυση %d x %d !" , OUON_WID, OUON_HEI);
                            else sprintf(str1kb,"Screen resolution is lower..\n..than the selected one during DB creation!\n Try at %d x %d !" , OUON_WID, OUON_HEI);
                            information (0,str1kb,0);
                        }
                    }
                    
                    fseek(fpdb , math_alma , 0);
                    for(f=0 ; f<=dbfinum ; f++) {
                        if (alg_str[f]) { free(alg_str[f]) ; alg_str[f]=0;}
                        if (ptr_pedio[f]->mathtype) {
                            mem5=malloc(1026);
                            if (!mem5) {information (2-keyb_gr,0,0); break;}
                            alg_str[f]=mem5;
                            fread(alg_str[f],1,1024,fpdb);
                        }
                    }
                    

                    fseek (fpdb , 0 , SEEK_SET) ;
                    if (ferror(fpdb)) {information (6-keyb_gr,loaddbfile,0); clearerr(fpdb); fclose (fpdb); fpdb=NULL; wasopdb=0; if (mem1) free(mem1); mem1=0;break;}
                    else {dbopen=1; mmed[0]=2; mmed[1]=1; mmed[2]=mmed[5]=0;mmed[3]=2; big_t=1.0 ;}
                    if (mem1) free(mem1);mem1=0;
                    
                    if (decor) {
                    sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                    fpdec=fopen(str1024,"rb");
                        if (fpdec==NULL) {information(6-keyb_gr,str1024,0); 
                            decor=0; 
                            fseek(fpdb, dec_lab_db , 0);
                            fwrite (&decor,4,1,fpdb);
                            fdatasync (fide_fpdb);
                        }
                        else { 
                        fread (ptr_dec , decorsize , decor, fpdec);
                        fclose(fpdec); fpdec=NULL;
                        }
                    }
                    
                    dx=info_dbfds(); // Ενημέρωση του button για τα ονόματα των πεδίων !
                    if (!dx) {information (2-keyb_gr,0,0); break ;}
                    
                    if (dbfinum>=0) mmed[7]=0; else mmed[7]=1;
                    if (dbfinum>=0) mmed[8]=0; else mmed[8]=1;
                    
                    dbcard = dbplgr+1;
                    if (dbcard>=65530) {
                        if (keyb_gr) information (0,"Η χωρητικότητα της βάσης εξαντλείται.\nΔιαγράψτε καρτέλες, για να μπορείτε\nνα αποθηκεύσετε νέες!",0);
                        else information (0,"The capacity of the data base is depleted.\nDelete cards, so you can save\nnew ones!",0);
                    } // Οδηγίες επειδή φούλαρεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεεε !
                    
                                        
                    sprintf(Strcardfp,"%s%s",savedbpath,"Data1.aba");
                    fpcard=fopen(Strcardfp,"r+b"); // Αρχείο ΚΑΡΤΕΛΛΩΝ !!                  
                    if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,0); gen_ergo=&ch3 ; break ;}
                    fide_fpcard = fileno (fpcard) ; wasopca=1 ;
                    
                    sprintf(Strdomfp,"%s%s",savedbpath,"Doms1.aba"); // Αρχείο Δεικτών σειράς Ταξινόμησης
                    fpdom=fopen(Strdomfp,"r+b");
                    if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,0); gen_ergo=&ch3 ; break ;}
                    fide_fpdom = fileno (fpdom) ; wasopdo=1 ;
                    
                    sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                    fpera=fopen(str1024,"rb");
                    if (fpera==NULL) {information(6-keyb_gr,str1024,0); break ;}
                    fread (&dbplera,2,1,fpera);
                    fclose(fpera); fpera=NULL;  
                    savenow=0;
                    
                    
                    
                    if (dbplgr) {
                        
                        gen_ergo=mmestr[7];
                        baserg=eisag;
                        mmed[6]=1;
                        mmed[9]=mmed[4]=mmed[13]=mmed[14]=0;
                        mmed[7]=2;mmed[10]=1;big_t=2.0 ; mmed[3]=mmed[12]=0;
                        mmed[16]=0; 
                        dbcardsize=alma_deigma=0;
                        ardom_mem=malloc(dbplgr*2);
                        if (!ardom_mem) {information (2-keyb_gr,0,0); gen_ergo=&ch3 ; break; }
                        ar_dom=ardom_mem;
                        fread(ar_dom,2,dbplgr,fpdom); // Ενημέρωση Δεικτών Ταξινόμησης Καρτελλών !!!
                        if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom); gen_ergo=&ch3 ;break;}
                        
                        sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                        fp=fopen(str1024,"rb");
                        if (fp==NULL) {information (6-keyb_gr,str1024,0); gen_ergo=&ch3 ; break ;}
                        fread (xlimk,2,dbfinum+1,fp); // Ενημέρωση μέγιστων ορίων για εγγραφή στοιχείων στο δίσκο !
                        xlim=1;
                        if (ferror(fp)) {information (6-keyb_gr,str1024,0); clearerr(fp); fclose (fp); fp=NULL;gen_ergo=&ch3 ; break;}
                        fclose (fp);
                        
                        for (f=0;f<=dbfinum;f++) { // Δέσμευση μνήμης για κάθε πεδίο !!
                            limk[f]= (ptr_pedio[f]->fitype != 5) ? ptr_pedio[f]->fiorio+1 : 1024 ;
                            memk[f]=malloc(xlimk[f]); memcp[f]=malloc(xlimk[f]);
                            if (!memk[f]) {information (2-keyb_gr,0,0) ; break ;}
                            if (!memcp[f]) {information (2-keyb_gr,0,0) ; break ;}
                            keimk=memk[f] ; keimk[0]=255; ceimk=memcp[f] ; ceimk[0]=255;
                            curk[f]=0; curk1[f]=0;
                            if (!seflag) { // Αν υπάρχουν κριτήρια δεν τα σβήνουμε...
                                // Δέσμευση μνήμης κατά πεδίο για ενημέρωση του πίνακα δεικτών multicr (κριτήρια εύρεσης στοιχείων) !! (Βλέπε δομή criterio).
                                // Μηδενισμός των δειγμάτων κριτηρίων (τύπου δικού μου στριγκ αλλά και της σημαίας κριτηρίων cron.

                                if (ptr_pedio[f]->fitype!=5) {
                                    if (!multicr[f]) {multicr[f] = mem1= malloc ( sizeof (struct criterio) ) ;} 
                                    if (!multicr[f]) {information (2-keyb_gr,0,0) ; break ;}
                                    else {multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;}
                                } 
                                else multicr[f]=0;
                            }
                            if (f==dbkey) alma_deigma=dbcardsize; // Υπολογισμός του βήματος fseek ανάλογα με το dbkey !
                            dbcardsize+=xlimk[f];
                            if (ptr_pedio[f]->fitype==5) posafoto++;
                        }
                        mem1=0;
                        xmemk=1;
                        if (dbkey==100) alma_deigma=dbcardsize; 
                        dbcardsize += sizeof (time_t); // Τελικός υπολογισμός του μεγέθους καρτέλλας δεδομένων σε bytes !
                        
                        
                        if (dbkey!=100) {
                            // Ενημέρωση των στοιχείων item-Gitem-Fitem-Litem για ετοιμότητα ανα-ταξινόμησης !!!
                            // Αντιγράφονται στοιχεία από το δίσκο - δηλαδή από το πεδίο-κλειδί ταξινόμησης στο array item. Αν βρίσκονται εκεί και  Ελληνικοί χαρακτήρες ρυθμίζονται για ορθό και εύκολο έλεγχο ταξινόμησης. 
                            
                            if (ptr_pedio[dbkey]->fitype==5) { // Λαθάρα , εικόνα ως κλειδί - ΑΠΑΙΤΕΤΑΙ ΑΛΛΑΓΗ - Ενημέρωση Χρήστη !!
                             } 
                            
                            if (ptr_pedio[dbkey]->fitype==6) {  // Δοθείσα Ημερομηνία ως κλειδί - θέλει άλλη δουλειά εδώ !!!!
                                
                              item_mem=malloc(dbplgr*4);
                              if (!item_mem) {information (2-keyb_gr,0,0);break ;}
                              Gitem=item_mem;
                              dx=0;
                              cur=25;
                              for (f=0;f<dbplgr;f++) {
                                dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; break ;}
                                fread(deigma,1,cur,fpcard);
                                cardiary.ldate=0;
                                if (deigma[0]!=255) {
                                mytext_tonorm(deigma,str1024,50);
                                
                                // Μετατροπή Ημερομηνίας σε unsigned int (cardiary.ldate)
                                w=strlen(str1024);
                                for (i=0;i<4;i++) {
                                    nu[i]= (unsigned char) str1024[w-i-1] - '0' ;
                                }
                                
                                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                                //dysena.wotim -= 1900;
                                cardiary.mydate[3]=dysena.dyomikra[1];
                                cardiary.mydate[2]=dysena.dyomikra[0];

                                nu[0]= (unsigned char) str1024[w-6] - '0' ;
                                nu[1]= (unsigned char) str1024[w-7] - '0' ;
                                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                                nu[0]= (unsigned char) str1024[w-9] - '0' ;
                                nu[1]= (unsigned char) str1024[w-10] - '0' ;
                                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                                Gitem[f]=cardiary.ldate ;
                                }
                                if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                            }
                            
                            else if ( ptr_pedio[dbkey]->fitype==3 ) { // To κλειδί είναι ακέραιος αριθμός !!
                            
                                cur=limk[dbkey];
                                item_mem=malloc(dbplgr*8);
                                if (!item_mem) {information (2-keyb_gr,0,0);break ;}
                                Litem=item_mem;
                                dx=0;
                              
                              for (f=0;f<dbplgr;f++) {
                                dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; break ;}
                                fread(deigma,1,cur,fpcard);
                                Litem[f]= (deigma[0]!=255) ? (long int) convert_str(cur , deigma) : 0 ;
                                }
                                if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                                
                                if (metataj && dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); dx=1; break; }
                                    metataj=0;
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                    pro_sort_signedlong(item_mem,new_dom,dbplgr);
                                    
                                    // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                                    for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                                    ar_dom = new_dom;
                                    free (ardom_mem);
                                    ardom_mem=new_dom_vo;
                                    new_dom_vo=0;
                                    rewind(fpdom);
                                    fwrite(ar_dom,2,dbplgr,fpdom);
                                    fdatasync (fide_fpdom);
                                    if (ferror(fpdom)) { information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}
                                }
                            }
                            
                            else if (ptr_pedio[dbkey]->fitype==4) { // To κλειδί είναι φλοατ αριθμός !!
                                cur=limk[dbkey];
                                item_mem=malloc(dbplgr*8);
                                if (!item_mem) {information (2-keyb_gr,0,0);break ;}
                                Fitem=item_mem;
                                dx=0;
                              
                              for (f=0;f<dbplgr;f++) {
                                dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; break ;}
                                fread(deigma,1,cur,fpcard);
                                Fitem[f]= (deigma[0]!=255) ? (double) convert_str(cur , deigma) : 0 ;
                                }
                                if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                                
                                if (metataj && dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); dx=1; break; }
                                    metataj=0;
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                    pro_sort_double(item_mem,new_dom,dbplgr);
                                    
                                    // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                                    for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                                    ar_dom = new_dom;
                                    free (ardom_mem);
                                    ardom_mem=new_dom_vo;
                                    new_dom_vo=0;
                                    rewind(fpdom);
                                    fwrite(ar_dom,2,dbplgr,fpdom);
                                    fdatasync (fide_fpdom);
                                    if (ferror(fpdom)) { information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}
                                }
                            }
                            
                            else {                                               // Απλό κείμενο το sorting key
                            cur=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                            item_mem=malloc(dbplgr*24);
                            if (!item_mem) {information (2-keyb_gr,0,0); break; }
                            item=item_mem;
                            dx=0;
                            for (f=0;f<dbplgr;f++) {
                                dx=fseek(fpcard , ((ar_dom[f] * dbcardsize) + alma_deigma) , 0);
                                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; break ;}
                                fread(deigma,1,cur,fpcard);
                                deigma[cur]=255;
                                xitem[0].big=xitem[1].big=xitem[2].big=0;
                                i=0;by=23;
                                do {
                                what=deigma[i];
                                if (what>163) break;
                                if (keyb_gr){
                                        switch (what) {

                                            case 96:
                                            case 101:
                                            case 104:
                                            case 107:
                                            case 116:
                                            case 122:
                                            case 129:
                                            case 132:
                                            case 137:
                                            case 140:
                                            case 143:
                                            case 151:
                                            case 157:
                                            case 163:
                                            what--;
                                            break;

                                            case 108:
                                            case 123:
                                            case 144:
                                            case 158:
                                            what-=2;
                                            break;


                                            case 109:
                                            case 124:
                                            what-=3;
                                            break;

                                            case 130:
                                            what=119;

                                        }

                                    }
                                rby=by%8; low=(2-(by/8));
                                xitem[low].sma[rby]=what;
                                by-- ; i++;
                                } while (by>=0);
                                item[f].fg=xitem[0].big;
                                item[f].sg=xitem[1].big;
                                item[f].tg=xitem[2].big;
                            }
                        if (dx) break ; // Πρόβλημα στο διάβασμα στοιχείων καρτελλών !!!
                        }
                    }
                    
                    dx=check_pediaola_math();
                    if (dx<0) {information (2-keyb_gr,0,0); break;}
                    //printf ("mexri edo kala....");
                    dpro = proter_calc_pedivn();
                    //printf ("mexri edo kala dpro....");
                    
                }
                else {mmed[9]=mmed[10]=mmed[4]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;gen_ergo=mmestr[3];baserg=sxedom;}
                    
                    dbpage_decs();
                    dbpage_recs(0); // Ενημερώνει (για πρώτη φορά) τα στοιχεία των rectangles πεδίων και ετικετών της τρέχουσας σελίδας για να εμφανισθούν μετά στην οθόνη !
                    dbdecor_show ();                    
                    dbrecs_show ();
                                       
                     _outmystr_center_col (0, gen_ergo ,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); 
                     
                    // Η dbrecs_show παρουσιάζει τα στοιχεία στη σελίδα αναλόγως του dbar - δεν έχει σχέση με καταχώρηση παρά μόνον με σχεδίαση.
                    
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
                        _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                        _bareacls(dbtotcardxt-1 , topinfyt+1, dbtotcardxb+1 , topinfyt+17,syncardbkxr);     // Συνολο Καρτελλών στη βάση
                        sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                        sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
                        sprintf(totcard_str,"%05u",dbplgr);  // Για σύνολο καρτελλών
                        pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                        _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
                        _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                        _outsouv_col(dbtotcardxt,topinfyt+1,totcard_str,0,syncardchxr,syncardbkxr);
                        refresh();
                        proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=0; big_d=0.0; ektos=1;
                        if ( (dbfinum>=0) && (!dbplgr) ) {mmed[7]=0; big_t=1.0;}
                        if (user_opts && dbcard_opt) {

                            p = ar_dom[dbcard_opt-1];
                            a=0;
                            for (f=0 ; f<tot_opts ; f++) {
                                if (epil_pos[f]==p) {a=1 ; break; }
                            }
                            if (!a)
                            {
                                cur = epil_pos[0]; i=0;
                                for (f=0 ; f<dbplgr ; f++) {
                                    if (ar_dom[f]==cur) {i=1; dbcard=f+1; break ;}
                                }
                                if (!i) {mem3=epil_pos; free(mem3); epil_pos=mem3=0;
                                tot_opts=0; user_opts=0;
                                bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                                break;}
                                goto METAB_PROT ;
                            }
                            else {
                                dbcard=dbcard_opt;
                                goto METAB_PROT ;
                            }
                        }
                    break;
                    
                case 2:         // Save DB
                    if (mmed[2]) break ;
                    tokyk=100; rego=0 ; 
                    if (gundo_sit) {
                    gundo_sit=0; gundo_but=0;
                    if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
                    }
                    fidimundo_call(0,0);
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                    dbcard_opt = (user_opts) ? dbcard : 0 ;
                    
                                        // Πρέπει να σώσει την καρτέλα που δουλεύω τώρα ...?? !!!
                    
                    if (dbplgr) {
                        
                        //if (!xmemk) goto SORTCL_FYGE_1;
                        if (mmed[9]==2) goto SORTCL_FYGE_1;
                        if (mmed[10]==2) {mmed[10]=1 ; seflag=1 ; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr); goto SORTCL_FYGE_1;}
                        i=0; a1=0;savenow=0;tokyk=100;
                        if (dbcard>dbplgr) { // Πρόκειται για νέα κάρτα
                            if (dbplgr==65533) goto SORTCL_FYGE_1;
                            a1=1; a=0;
                            for (f=0;f<=dbfinum;f++) {
                                keimk=memk[f];
                                if (keimk[0]!=255) {a=1;break;}
                            }
                                if (!a) goto SORTCL_FYGE;
                        
                            if (dbplera) {
                            sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                            fpera=fopen(str1024,"r+b");
                            if (fpera==NULL) {information(6-keyb_gr,str1024,NULL); goto SORTCL_FYGE_1;}
                            fide_fpera = fileno (fpera) ;
                            fseek(fpera,dbplera*2,0);
                            fread(&thesi,2,1,fpera);
                            dbplera--; i=1 ;
                            rewind(fpera);
                            fwrite(&dbplera,2,1,fpera);
                            fsync(fide_fpera);
                            if (ferror(fpera)) { information(2-keyb_gr,str1024,NULL); clearerr(fpera); fclose(fpera); fpera=NULL;}
                            else {fclose(fpera); fpera=NULL;}
                            }
                            if (i) dx=fseek(fpcard,(thesi * dbcardsize),0);
                            else dx=fseek(fpcard,(dbplgr * dbcardsize) ,0);
                            if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); goto SORTCL_FYGE_1;}
                            dbplgr++;
                            if (mmed[9]==1) mmed[9]=0;
                            mmed[4]=mmed[12]=mmed[13]=mmed[14]=0 ;
                            mmed[16]=0;
                            
                            // mmed[6]=1;
                            dx=fseek(fpdb,62,0);
                            fwrite (&dbplgr,2,1,fpdb);  
                            fdatasync (fide_fpdb) ;
                            if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);rewind(fpdb); clearerr(fpdb); goto SORTCL_FYGE_1;}
                            if (ardom_mem) ardom_mem=realloc(ardom_mem,dbplgr*2);
                            else ardom_mem=malloc(dbplgr*2);
                            if (!ardom_mem) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                            ar_dom=ardom_mem;
                            ar_dom[dbplgr-1]= (i) ? thesi : dbplgr-1;
                            thesi = ar_dom[dbplgr-1] ;
                        }
                        
                        else {  // Πρόκειται για κάρτα που υπήρχε και τροποποιήθηκε
                            cur=thesi=ar_dom[dbcard-1];
                            dx=fseek(fpcard,(cur*dbcardsize),0);
                            if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); goto SORTCL_FYGE_1;}
                        }
                        
                        // Εγγραφή Στοιχείων στο Δίσκο (σε κάθε περίπτωση - νέας ή παλιάς κάρτας πλην του cardwhen που δείχνει πότε ανοίχτηκε η κάρτα για πρώτη φορά) !!!
                        
                for (f=0;f<=dbfinum;f++) {
                    fwrite(memk[f],1,xlimk[f],fpcard);
                    fdatasync (fide_fpcard);
                    keimk=memk[f];
                    ceimk=memcp[f];
                    i=0;
                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                    else {
                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                        else ceimk[i]=255;
                    }
                }
                
                if (a1) {
                    cardwhen=time(NULL);
                    fwrite(&cardwhen,sizeof(time_t),1,fpcard);
                    fdatasync (fide_fpcard);
                    if (dbplgr==1) {
                        for (f=0;f<=dbfinum;f++) {
                            if (ptr_pedio[f]->fitype!=5) {
                            multicr[f] = mem1= malloc ( sizeof (struct criterio) ) ; 
                            if (!multicr[f]) {information (2-keyb_gr,0,0) ; break ;}
                            else {multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;}
                            } 
                            else multicr[f]=0;
                        }
                        mem1=0;
                    }
                }
                            
                            if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                            
                            // Ενημέρωση του array item και πιθανώς ΤΑΞΙΝΟΜΗΣΗ !!             

                                if (dbkey!=100) {
                                    switch (ptr_pedio[dbkey]->fitype) {
                                        
                                        case 0 :
                                        case 1 :
                                        case 2 :
                                            // cur=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                                            if (!item_mem) item_mem=malloc(dbplgr*24);
                                            else item_mem=realloc(item_mem,dbplgr*24);
                                            if (!item_mem) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                            item=item_mem;
                                            
                                            // Μετατροπή δείγματος από το sorting key field σε 24 bit item !
                                            
                                            cur=by=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                                            keimk=memk[dbkey];
                                            i=0;
                                            what=keimk[i];
                                            while ( (what!=255) && (by) ) { deigma[i]=what; by-- ; i++ ; what=keimk[i];}
                                            deigma[i]=255;
                                            
                                            xitem[0].big=xitem[1].big=xitem[2].big=0;
                                            i=0;by=23;
                                            do {
                                                what=deigma[i];
                                                if (what>163) break;
                                                if (keyb_gr){
                                                        switch (what) {

                                                            case 96:
                                                            case 101:
                                                            case 104:
                                                            case 107:
                                                            case 116:
                                                            case 122:
                                                            case 129:
                                                            case 132:
                                                            case 137:
                                                            case 140:
                                                            case 143:
                                                            case 151:
                                                            case 157:
                                                            case 163:
                                                            what--;
                                                            break;

                                                            case 108:
                                                            case 123:
                                                            case 144:
                                                            case 158:
                                                            what-=2;
                                                            break;


                                                            case 109:
                                                            case 124:
                                                            what-=3;
                                                            break;

                                                            case 130:
                                                            what=119;

                                                        }

                                                }
                                            rby=by%8; low=(2-(by/8));
                                            xitem[low].sma[rby]=what;
                                            by-- ; i++;
                                            } while (by>=0);
                                            
                                            check_item.fg=xitem[0].big;
                                            check_item.sg=xitem[1].big;
                                            check_item.tg=xitem[2].big;

                                            if (a1) { // Νέα καρτέλλα
                                            
                                                item[dbplgr-1].fg=check_item.fg;
                                                item[dbplgr-1].sg=check_item.sg;
                                                item[dbplgr-1].tg=check_item.tg;
                                                
                                            }
                                            else
                                            {              // Παλιά καρτέλλα
                                                
                                                cur=dbcard-1;
                                                if ( (check_item.fg==item[cur].fg) && (check_item.sg==item[cur].sg) && (check_item.tg==item[cur].tg) ) {
                                                goto SORTCL_FYGE ; } // Δεν χρειάζεται ταξινόμηση - δεν άλλαξε τίποτε στους 24 πρώτους χαρακτήρες !!
                                            
                                                item[cur].fg=check_item.fg;
                                                item[cur].sg=check_item.sg;
                                                item[cur].tg=check_item.tg;
                                                
                                            }
                                            
                                            if (dbplgr>1) {
                                                new_dom_vo = malloc (dbplgr*2);
                                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                                new_dom=new_dom_vo;
                                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                            
                                                pro_sort_24b(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                            }
                                            break ;
                                            
                                        // Αριθμός ως κλειδί !
                                            
                                        case 3: // Aκέραιος
                                            if (!item_mem) item_mem=malloc(dbplgr*8);
                                            else item_mem=realloc(item_mem,dbplgr*8);
                                            if (!item_mem) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                            Litem=item_mem;
                                            
                                            // Μετατροπή δείγματος !
                                            
                                            cur=limk[dbkey];
                                            keimk=memk[dbkey];
                                            lbig= (keimk[0]!=255) ? (long int) convert_str(cur , keimk) : 0 ;
                                            
                                            if (a1) { // Νέα καρτέλα
                                            Litem[dbplgr-1]=lbig; 
                                            }
                                            else {  // Παλιά καρτέλα 
                                                if (lbig==Litem[dbcard-1]) goto SORTCL_FYGE;
                                                else Litem[dbcard-1]=lbig;
                                            }
                                            
                                            if (dbplgr>1) {
                                                new_dom_vo = malloc (dbplgr*2);
                                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                                new_dom=new_dom_vo;
                                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                            
                                                pro_sort_signedlong(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                            }
                                            break ;
                                            
                                        case 4:  // Δεκαδικός
                                            if (!item_mem) item_mem=malloc(dbplgr*8);
                                            else item_mem=realloc(item_mem,dbplgr*8);
                                            if (!item_mem) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1;}
                                            Fitem=item_mem;
                                            
                                            // Μετατροπή δείγματος !
                                            
                                            cur=limk[dbkey];
                                            keimk=memk[dbkey];
                                            fbig= (keimk[0]!=255) ? (double) convert_str(cur , keimk) : 0 ;
                                            
                                            if (a1) { // Νέα καρτέλα
                                            Fitem[dbplgr-1]=fbig; 
                                            }
                                            else {  // Παλιά καρτέλα 
                                                if (fbig==Fitem[dbcard-1]) goto SORTCL_FYGE;
                                                else Fitem[dbcard-1]=fbig;
                                            }
                                            
                                            if (dbplgr>1) {
                                                new_dom_vo = malloc (dbplgr*2);
                                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                                new_dom=new_dom_vo;
                                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                            
                                                pro_sort_double(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                            }
                                            break;
                                            
                                        case 6:  // Date
                                            
                                            if (!item_mem) item_mem=malloc(dbplgr*4);
                                            else item_mem=realloc(item_mem,dbplgr*4);
                                            if (!item_mem) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                            Gitem=item_mem;
                                            
                                            // Μετατροπή δείγματος !
                                            
                                            keimk=memk[dbkey];
                                            cardiary.ldate=0;
                                            
                                            if (keimk[0]!=255) {
                                            mytext_tonorm(keimk,str1024,50);
                                            
                                            // Μετατροπή Ημερομηνίας σε unsigned int (cardiary.ldate)
                                            w=strlen(str1024);
                                            for (i=0;i<4;i++) {
                                                nu[i]= (unsigned char) str1024[w-i-1] - '0' ;
                                            }
                                            
                                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                                            //dysena.wotim -= 1900;
                                            cardiary.mydate[3]=dysena.dyomikra[1];
                                            cardiary.mydate[2]=dysena.dyomikra[0];

                                            nu[0]= (unsigned char) str1024[w-6] - '0';
                                            nu[1]= (unsigned char) str1024[w-7] - '0' ;
                                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                                            nu[0]= (unsigned char) str1024[w-9] - '0' ;
                                            nu[1]= (unsigned char) str1024[w-10] - '0' ;
                                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                            
                                            }
                                        
                                            if (a1) { // Νέα καρτέλα
                                            Gitem[dbplgr-1]=cardiary.ldate; 
                                            }
                                            else {  // Παλιά καρτέλα 
                                                if (cardiary.ldate==Gitem[dbcard-1]) goto SORTCL_FYGE;
                                                else Gitem[dbcard-1]=cardiary.ldate;
                                            }
                                        
                                        if (dbplgr>1) {
                                                new_dom_vo = malloc (dbplgr*2);
                                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORTCL_FYGE_1; }
                                                new_dom=new_dom_vo;
                                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                            
                                                pro_sort_uint(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                        }
                                            break ;
                                    }
                                    
                                    if (dbplgr==1) {
                                rewind (fpdom) ;
                                fwrite(&ar_dom[0],2,1,fpdom); 
                                fdatasync (fide_fpdom);
                                if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                                dbcard=1;
                                    }
                                    else {
                                    // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                                    for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                                    ar_dom = new_dom;
                                    free (ardom_mem);
                                    ardom_mem=new_dom_vo;
                                    new_dom_vo=0;
                                    rewind(fpdom);
                                    fwrite(ar_dom,2,dbplgr,fpdom);
                                    fdatasync (fide_fpdom);
                                    if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                                    
                                    // Αριθμός καρτέλας που προκύπτει μετά από ταξινόμηση !!
                                    for (f=0;f<dbplgr;f++) {
                                    if (ar_dom[f]==thesi) break ; } 
                                    dbcard=f+1;
                                    }
                                }
                                else {
                                    if (a1) {
                                        fseek(fpdom,(dbplgr-1)*2,0);
                                        fwrite(&ar_dom[dbplgr-1],2,1,fpdom); 
                                        fdatasync (fide_fpdom);
                                        if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                                    }
                                }
SORTCL_FYGE:
                            puticon(cardsaxt,bmenuyt,mem_savecard,255);
                            for (i=0 ; i<4 ; i++) {
                                for (f=0;f<200000;f++) continue;
                                bareacls(cardsaxt,bmenuyt,cardsaxt+35,bmenuyt+17,topchxr);
                                for (f=0;f<200000;f++) continue;
                                putNOTicon(cardsaxt,bmenuyt,mem_savecard);
                                for (f=0;f<200000;f++) continue;   
                                bareacls(cardsaxt,bmenuyt,cardsaxt+35,bmenuyt+17,topbkxr);
                                for (f=0;f<200000;f++) continue;
                                puticon(cardsaxt,bmenuyt,mem_savecard,255);
                            }
                            _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                            sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                            _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                            _bareacls(dbtotcardxt-1 , topinfyt+1, dbtotcardxb+1 , topinfyt+17,syncardbkxr);     // Συνολο Καρτελλών στη βάση
                            sprintf(totcard_str,"%05u",dbplgr);  // Για σύνολο καρτελλών
                            _outsouv_col(dbtotcardxt,topinfyt+1,totcard_str,0,syncardchxr,syncardbkxr);
                            refresh();
                    }
                    else {
                        if (xmemk){
                            a=0;
                            for (f=0;f<=dbfinum;f++) {
                                keimk=memk[f];
                                if (keimk[0]!=255) {a=1;break;}
                            }
                            if (a) {
                                if (keyb_gr) information (0,"Η πρώτη καρτέλα της Bάσης εγγράφεται στο δίσκο μόνον με κλικ στο εικονίδιο :\n\'Σώσε την Καρτέλα στο Δίσκο\'\n(Kατάσταση Εισαγωγής-Επεξεργασίας)","Προς το παρόν θα σωθεί η δομή της Βάσης !");
                                else information (0,"The first database card can be saved only..\n..by clicking on the icon :\n\'Save DB Card to the Disk\'\n(Input-Edit Mode)","For now,only the DB structure can be saved!");
                            }
                        }
                    }
SORTCL_FYGE_1:
                    if (fpdb!=NULL) {f=fsync(fide_fpdb); i=fclose (fpdb) ;} 
                    if (i || f) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind(fpdb); fclose (fpdb); } 
                    if(fpcard!=NULL) {f=fsync(fide_fpcard); i=fclose(fpcard); sprintf(str1024,"%s%s",savedbpath,"Data1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpcard) ; rewind (fpcard); fclose (fpcard);}}
                    if(fpdom!=NULL) {f=fsync(fide_fpdom); i=fclose(fpdom); sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; rewind (fpdom); fclose (fpdom);}}
                    if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; rewind(fpera); fclose (fpera);}}
                    fpdb=NULL; wasopdb=0; fpcard=NULL; wasopca=0; fpdom=NULL; wasopdo=0; fpera=NULL;
                    
                    if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                    if(item_mem) { free(item_mem); item_mem=0; }
                    
                    if (dbfinum>=0) {for (f=0;f<=dbfinum;f++) {if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}}}
                    if (dbplgr) {
                        xmemk=0; xlim=0;
                        for (f=0;f<=dbfinum;f++) {
                            if (memk[f]) { free (memk[f]) ; memk[f]=0; } 
                            if (memcp[f]) { free (memcp[f]) ; memcp[f]=0; }
                            // if (multicr[f]) { mem1=multicr[f]; free (mem1) ; multicr[f]=0 ; }
                        }
                    }
                    
                    mem1=0;
                    if (memx1) {free(memx1); memx1=0;}
                    if (memy1) {free(memy1); memy1=0;}
                    if(memx2)  {free(memx2); memx2=0;}
                    if(memy2)  {free(memy2); memy2=0;}
                    if (dmemx1) {free(dmemx1); dmemx1=0;}
                    if (dmemy1) {free(dmemy1); dmemy1=0;}
                    if(dmemx2)  {free(dmemx2); dmemx2=0;}
                    if(dmemy2)  {free(dmemy2); dmemy2=0;}
                    dbdecs=0;
                    dbfinum=-1; decor=0;
                    mmed[0]=mmed[1]=0; mmed[5]=mmed[6]=mmed[3]=1;dbar=dbopen=dbrecs=0;
                    savedbpath[0]='\0';
                    _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                    _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                    proel=progvn=-1;  ektos=1;
                    loaddbfile=LDdbfile;
                    gen_ergo=&ch3;
                    goto OPENDB;
                    break;
                    
                case 3:         // Design of a DB
                    if (mmed[3]) break ;
                    
                    if (dbplgr) {
                        for (f=0 ; f<=dbfinum ; f++) {    
                            keimk=memk[f];
                            ceimk=memcp[f];
                            
                            if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                            else {
                                if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                                else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                                else dx=1;
                            }
                            if (dx) {savenow=1 ; break ;}
                        }
                        if (savenow) {
                            if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                            switch (user_ans) {
                                
                                case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                    savenow=0;
                                    break;
                                    
                                case 1 : // ΣΩΣΕ ΤΩΡΑ
                                    continue ;
                                
                                case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                    savenow=0;
                                    tokyk=100;
                                    continue ;
                            }
                        }
                    }
                    tokyk=100;
                    gundo_sit=0;gundo_but=0;
                    
                    if (!diax_dec) {
                        baserg=sxedom;
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                        _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);}
                    else {
                        baserg=etikbkxr;
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,etikbkxr);
                        _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,etikchxr,etikbkxr);}
                    refresh();
                     if (seflag>=2) {seflag=1; mmed[10]=1; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    mmed[6]=0; if (dbplgr) mmed[9]=0 ; if(dbfinum>=0) mmed[7]=0;
                    mmed[3]=2; big_t=1.0 ;gen_ergo=mmestr[kyk];
                                                             
                    break ;
                    
                case 4:         // Complex Search the DB - Θα πάει στην πρώτη κάρτα από την αρχή της βάσης δεδομένων.
                    if (mmed[4]) break ;
                    if (!dbplgr) break ;
                    
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    
                    tokyk=100; diax_dec=0;prodec=prodvn=-1;
                    fidimundo_call(0,0);
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    dbcard1=dbcard ;
                            if (rl){                                       // ΚΑΘΑΡΙΣΜΟΣ ΚΡΙΤΗΡΙΩΝ
                        for (f=0;f<=dbfinum;f++){
                            if (ptr_pedio[f]->fitype!=5) {
                                if (multicr[f]->mem_ghost) free(multicr[f]->mem_ghost) ; 
                                multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;
                            }
                        }
                        if (seflag==2) {seflag=0; mmed[10]=1; mmed[9]=2; gen_ergo=mmestr[9];baserg=parous; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        else { seflag=0; mmed[10]=1; }
                        for (f=0;f<dbplgr;f++) crits[f]=0;
                        gocards=0; firstcrit=0;
                        rl=0;
                        break;
                    }
                    big_t=2.0 ;
                    if (mmed[7]==2) { mmed[7]=0 ; gundo_sit=0; gundo_but=0;} 
                    else if (mmed[3]==2) { mmed[3]=0; mmed[6]=1; baserg=sxedom;}
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,klperg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                    
                    
                    user_ans= input_compl_search ();
                    
                    
                    if (user_ans!=1) {
                        if (user_opts) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];baserg=eisag;
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                            break;
                        }
                        if (dbcard==dbplgr+1) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];
                            baserg=eisag; 
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                            break;
                        }
                        if (seflag!=2) {
                            mmed[9]=2; baserg=parous; gen_ergo=mmestr[9]; _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[9],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                            break ;}
                        break;
                    }
                    
                    if (seflag==10) {
                        seflag=0;
                        mmed[10]=1; 
                        //_bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr); 
                        if (user_opts) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];baserg=eisag;
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                            //_puticon (search_flagxt,topinfyt,mem_usersel,255);
                            refresh();
                            break;
                        }
                        if (dbcard==dbplgr+1) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];
                            baserg=eisag; 
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                            break;
                        }
                        mmed[9]=2 ; 
                        baserg=parous; gen_ergo=mmestr[9];  
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                        _outmystr_center_col (0, mmestr[9],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                        _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);refresh();
                        break; }
                        
                    else if(seflag==9) {
                        mmed[10]=1; 
                        seflag=0;
                        for (f=0;f<dbplgr;f++) crits[f]=0;
                        gocards=0; firstcrit=0;
                        for (f=0;f<=dbfinum;f++){
                            if (ptr_pedio[f]->fitype!=5) {
                                multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;
                            }
                        }
                        if (user_opts) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];baserg=eisag;
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                            //_puticon (search_flagxt,topinfyt,mem_usersel,255);
                            refresh();
                            break;
                        }
                        if (dbcard==dbplgr+1) {
                            mmed[7]=2;
                            gen_ergo=mmestr[7];
                            baserg=eisag; 
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[7],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                            break;
                        }
                        mmed[9]=2; gen_ergo=mmestr[9];baserg=parous;
                        _outmystr_center_col (0, mmestr[9],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                        _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        refresh();
                                               
                        break ;
                    }
                    
                    h=0; sumcrit=0; 
                    for (f=0 ; f<=dbfinum ; f++ ) {
                        if (ptr_pedio[f]->fitype==5) continue ;
                        if (multicr[f]->cron) sumcrit++;
                    }
                    // printf("sumcrit = %d\n" , sumcrit) ;
                    if (sumcrit>1) {
                        
                        if (keyb_gr) {
                            sprintf (str1024 ,"ΣΥΖΕΥΞΗ κριτηρίων εύρεσης για εντοπισμό εκείνων των καρτελών της βάσης δεδομένων, οι οποίες ικανοποιούν όλα τα κριτήρια!");
                            sprintf (str1kb , "ΔΙΑΖΕΥΞΗ κριτηρίων εύρεσης για εντοπισμό εκείνων των καρτελών της βάσης δεδομένων οι οποίες ικανοποιούν έστω και ένα από τα κριτήρια!");
                        }
                        else {
                            sprintf (str1024 ,"Search criteria COUPLING to identify those database cards that meet all  criteria!");
                            sprintf (str1kb , "Search criteria DISSOLUTION to identify those database cards that meet even one of the criteria!");
                        }
                        user_ans = choise_alert (str1024,str1kb,0) ;
                        logand = (user_ans==2) ? 0 : 1 ;
                    }
                    else logand=1;
                    gocards=0 ;// Πόσες κάρτες πληρούν τα κριτήρια
                    if (keyb_gr) strcpy (str1kb , "Σύνθετη Αναζήτηση Στοιχείων..");
                    else strcpy (str1kb , "Complex Data Search..");
                    user_ans = proodos(str1kb, 0, dbplgr , 0) ;
                    for (p=0 ; p<dbplgr ; p++ ) {
                        if (user_ans) proodos(  0, p, dbplgr , 0) ;
                        fseek(fpcard , (ar_dom[p] * dbcardsize) , 0);
                            
                            crits[p]=0; 
                    
                        for (f1=0;f1<=dbfinum;f1++) {
                            fread (memk[f1] , 1, xlimk[f1] , fpcard); 
                            if (ferror(fpcard)) {
                            proodos(  0, 0, dbplgr , 1) ;
                            sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);h=1; break ;}
                            if (ptr_pedio[f1]->fitype==5) continue ;
                            if (!multicr[f1]->cron) continue ;
                            keimk=memk[f1]; if (keimk[0]==255) continue ;
                            mem1=0;
                            
                            switch (ptr_pedio[f1]->fitype) {
                                
                                case 3 :  // Ακέραιος αριθμός
                                    // Συγκριση
                                                                
                                    Lidb= (long int) convert_str( 15 , keimk ) ;
                                    
                                    if (multicr[f1]->sample[0][0] !=255) {
                                            if ( Lidb==multicr[f1]->numcr.litem[0] ) {crits[p]+=1; break;}
                                    }
                                    
                                    if ( (multicr[f1]->sample[1][0] !=255) && (multicr[f1]->sample[2][0]!=255) ) {
                                        if ( (Lidb>multicr[f1]->numcr.litem[1]) && (Lidb<multicr[f1]->numcr.litem[2]) ) {crits[p]+=1; break;}
                                        break;
                                    }
                                    
                                    if (multicr[f1]->sample[1][0] !=255) {
                                        if ( (Lidb>multicr[f1]->numcr.litem[1]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    if (multicr[f1]->sample[2][0] !=255) {
                                        if ( (Lidb<multicr[f1]->numcr.litem[2]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    break;
                                    
                                    
                                case 4 :  // DEKADIKOS αριθμός
                                    // Συγκριση
                                                                
                                    Fidb= (double) convert_str( 15 , keimk ) ;
                                    
                                    if (multicr[f1]->sample[0][0] !=255) {
                                            if ( Fidb==multicr[f1]->numcr.fitem[0] ) {crits[p]+=1; break;}
                                    }
                                    
                                    if ( (multicr[f1]->sample[1][0] !=255) && (multicr[f1]->sample[2][0]!=255) ) {
                                        if ( (Fidb>multicr[f1]->numcr.fitem[1]) && (Fidb<multicr[f1]->numcr.fitem[2]) ) {crits[p]+=1; break;}
                                        break;
                                    }
                                    
                                    if (multicr[f1]->sample[1][0] !=255) {
                                        if ( (Fidb>multicr[f1]->numcr.fitem[1]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    if (multicr[f1]->sample[2][0] !=255) {
                                        if ( (Fidb<multicr[f1]->numcr.fitem[2]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    break;
            
                                
                                case 6 : // Ημερομηνία
                                    // Μετατρέπει στοιχεία καρτέλας  !
                                    cardiary.ldate=0;
                                    mytext_tonorm(keimk,str1024,50);
                                    w=strlen(str1024);
                                    for (i=0;i<4;i++) {
                                        nu[i]= str1024[w-i-1] - '0' ;
                                    }
                                    dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                                    //dysena.wotim -= 1900;
                                    cardiary.mydate[3]=dysena.dyomikra[1];
                                    cardiary.mydate[2]=dysena.dyomikra[0];

                                    nu[0]=  str1024[w-6] - '0' ;
                                    nu[1]=  str1024[w-7] -  '0';
                                    if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    else cardiary.mydate[0]=nu[1]*10 + nu[0];

                                    nu[0]=  str1024[w-9] - '0' ;
                                    nu[1]=  str1024[w-10] - '0' ;
                                    if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                                    else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    
                                    Gidb=cardiary.ldate ; 
                                    
                                    if (multicr[f1]->sample[0][0] !=255) {
                                            sGidb=(unsigned short int) Gidb ; 
                                            sG= (unsigned short int) multicr[f1]->numcr.gitem[0];
                                            if (sGidb == sG ) { crits[p]+=1; break; }
                                            //if ( Gidb==multicr[f1]->numcr.gitem[0] ) {crits[p]+=1; break;}
                                            
                                    }
                                    
                                    if ( (multicr[f1]->sample[1][0] !=255) && (multicr[f1]->sample[2][0]!=255) ) {
                                        if ( (Gidb>multicr[f1]->numcr.gitem[1]) && (Gidb<multicr[f1]->numcr.gitem[2]) ) {crits[p]+=1; break;}
                                        break;
                                    }
                                    
                                    if (multicr[f1]->sample[1][0] !=255) {
                                        if ( (Gidb>multicr[f1]->numcr.gitem[1]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    if (multicr[f1]->sample[2][0] !=255) {
                                        if ( (Gidb<multicr[f1]->numcr.gitem[2]) ) {crits[p]+=1; break;}
                                    }
                                    
                                    break;
                                    
                                    
                                case 0:
                                case 1:
                                case 2:

                                    mem1=malloc(xlimk[f1]);
                                    if (!mem1) {proodos(  0, 0, dbplgr , 1) ; information (2-keyb_gr,0,0);h=1;break;}
                                    deigma_text = mem1;
                                    
                                    i=0;
                                    while (keimk[i]!=255) {deigma_text[i]=keimk[i];  i++; }
                                    deigma_text[i]=255;

                                    for (f=0;f<i;f++) {
                                        if (keyb_gr) {
                                            switch (deigma_text[f]) {

                                                case 96:
                                                case 131:
                                                case 132:
                                                deigma_text[f]=95;
                                                break;
                                                
                                                case 133:
                                                case 134:
                                                case 135:
                                                case 138:
                                                case 141:
                                                deigma_text[f]-=36;
                                                break;
                                                
                                                case 101:
                                                case 136:
                                                case 137:
                                                deigma_text[f]=100;
                                                break;
                                                
                                                case 104:
                                                case 139:
                                                case 140:
                                                deigma_text[f]=103;
                                                break;
                                                
                                                case 107:
                                                case 108:
                                                case 109:
                                                case 142:
                                                case 143:
                                                case 144:
                                                deigma_text[f]=106;
                                                break;
                                                
                                                case 145 :
                                                case 146 :
                                                case 147 :
                                                case 148 :
                                                case 149 :
                                                case 152 :
                                                case 153 :
                                                case 154 :
                                                case 155 :
                                                deigma_text[f]-=35;
                                                break ;
                                                
                                                case 116 :
                                                case 150 :
                                                case 151 :
                                                deigma_text[f]=115;
                                                break;
                                                
                                                case 122 :
                                                case 123 :
                                                case 124 :
                                                case 156 :
                                                case 157 :
                                                case 158 :
                                                deigma_text[f]=121;
                                                break;
                                                
                                                case 159 :
                                                case 160 :
                                                case 161 :
                                                deigma_text[f]-=34;
                                                break;
                                                
                                                case 129 :
                                                case 162 :
                                                case 163 :
                                                deigma_text[f]=128;
                                                break;

                                                case 130:
                                                deigma_text[f]=119;
                                            }
                                        }
                                        if ( (deigma_text[f]>68) && (deigma_text[f]<95) ) deigma_text[f]-=26;
                                    }
                                    
                                    i=0;
                                    while (multicr[f1]->sample_tcode[i]!=255) i++;
                                    by=i;
                                    
                                    // Mystrstr ....
                                    
                                    i=0;
                                    do {
                                        what=deigma_text[i];
                                        f=0; w=by; rby=0;metr=i;
                                        while( (what!=255) && (w) ) {
                                            if (what==multicr[f1]->sample_tcode[f++]) {rby++; i++; w--; what=deigma_text[i];continue;}
                                            else break;}
                                            
                                            if (rby==by) { i=-1; break ;}
                                            else i=metr+1;
                                            
                                    }while (what!=255);
                                    
                                    if (i==-1) crits[p]+=1 ;
                            
                            } // TELOS switch (fitype)
                        
                            if (mem1) {free (mem1) ; mem1=0;}
                            if (h) break ;
                            if ( (!logand) && (crits[p]) ) {
                                gocards++;
                                if (gocards==1) firstcrit = p ;
                                break ;
                            }
                            
                            if ( (logand) && (crits[p]==sumcrit) ) {
                                gocards++;
                                if (gocards==1) firstcrit = p ;
                                break ;
                            }
                        }
                    if (h) break ;
                    if ( (logand) && (crits[p]!=sumcrit) ) crits[p]=0 ;
                    }
                    //printf ("sumcrit = %d\n" , sumcrit) ;
                    if (dbplgr) {
                    for (f=0;f<=dbfinum;f++) {if (ptr_pedio[f]->fitype<3) mystrcpy(normdeigma[f],multicr[f]->sample_t);}
                    }
                    // Ενημέρωση το πόσες κάρτες ικανοποιούν τα κριτήρια.
                    if (gocards){ //Αν υπάρχουν κάρτες που συμφωνούν με κριτήρια  !!
                        seflag=2 ;
                         if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        puticon(search_flagxt,topinfyt,mem_search,255);
                        dbcard=firstcrit+1;
                        mmed[7]=mmed[9]=0;gundo_sit=0;gundo_but=0;mmed[10]=2;big_t=2.0 ;
                        baserg=parous; gen_ergo=mmestr[10];
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                        _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                         refresh();
                        
                        if (keyb_gr){
                            sprintf (str1024,"Τα κριτήρια ικανοποιήθηκαν σε %u κάρτες στοιχείων!\nΟι κάρτες αυτές μπορούν να προστεθούν τώρα στις  επιλογές χρήστη !\n(Οι επιλογές χρήστη συνδέονται με την Πολλαπλή Επιλογή Καρτελών)",gocards);
                            strcpy (str1kb ,"Όχι, να μην προστεθεί τίποτε στις επιλογές χρήστη!");
                            strcpy (file_3,"Να αντικατασταθούν οι επιλογές χρήστη με τις κάρτες που εντοπίσθηκαν τώρα!");
                        }
                        else {
                            sprintf (str1024,"Search criteria are met in %u DB cards.\nYou can add these DB cards to your personal selection list now !\n(Your selections are related with Multiple DB cards Selection)",gocards);
                            strcpy (str1kb,"No , don't add anything to user options!");
                            strcpy (file_3,"Replace user options with these cards that are now found!");
                        }
                        
                        if (!epil_pos) { user_ans = choise_alert (str1024,str1kb,0) ; }
                        else { user_ans = choise_alert_3 (str1024,str1kb,file_3,0) ;}
                        
                        if (user_ans==1) {
                            if ( (epil_pos) && (!tot_opts) ) {epil_pos=0;}
                            if (!tot_opts) {
                                mem3=malloc(gocards*2);
                                if (!mem3) {information (2-keyb_gr,0,0); goto PROKARTCRIT; }
                                epil_pos=mem3; mem3=0;
                                i=0;
                                for (f=firstcrit ; ( (f<dbplgr) && (i<gocards) ) ; f++) {
                                    if (crits[f]) {epil_pos[i]=ar_dom[f]; i++ ;}
                                }
                                tot_opts=i;
                            }
                            else {
                                mem3=epil_pos;
                                f1=0;p=0;
                                for (f=firstcrit ; ( (f<dbplgr) && (f1<gocards) ); f++) {
                                    if (crits[f]) {
                                        f1++;
                                        a=0;
                                        for (i=0 ; i<tot_opts; i++) {
                                            if (ar_dom[f] == epil_pos[i]) {a=1 ; break ;}
                                        }
                                        if (!a) {
                                            p++; 
                                            mem3 = realloc ( mem3, ((tot_opts+p)*2) );
                                            if (!mem3) {information (2-keyb_gr,0,0); epil_pos=0; tot_opts=0; goto PROKARTCRIT;}
                                            epil_pos = mem3;
                                            epil_pos[tot_opts+p-1] = ar_dom[f];
                                        }
                                    }
                                }
                                if (p) {
                                    tot_opts+=p; mem3=0 ;
                                    if (keyb_gr) sprintf (str1kb,"%u Καρτέλες προστέθηκαν στις επιλογές σας!",p);
                                    else sprintf (str1kb,"%u DB Cards have been added to your selections!",p);
                                    information (0,str1kb,0);
                                }
                                else {
                                    if (keyb_gr) information (0,"Δεν προστέθηκε κάτι νέο στις επιλογές σας",0);
                                    else information (0,"Nothing new was added to your selections",0);
                                }
                            }
                        }
                        else if (user_ans==3) {
                            mem3=epil_pos; if (mem3) free(mem3); epil_pos=mem3=0; tot_opts=0;

                            mem3=malloc(gocards*2);
                            if (!mem3) {information (2-keyb_gr,0,0); goto PROKARTCRIT; }
                            epil_pos=mem3; mem3=0;
                            i=0;
                            for (f=firstcrit ; ( (f<dbplgr) && (i<gocards) ) ; f++) {
                                if (crits[f]) {epil_pos[i]=ar_dom[f]; i++ ;}
                            }
                            tot_opts=i;
                        }
                    }
                    else { // Καμία κάρτα δεν υπάρχει σύμφωνη ...
                        seflag=1;
                        mmed[10]=1;
                        user_opts=0;
                        _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        mmed[9]=2; big_t=2.0 ;baserg=parous; gen_ergo=mmestr[9];
                        _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                        _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                        
                        if (dbcard==dbplgr+1) dbcard--;
                    
                        if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε!",0);
                        else information(0,"Nothing found !",0) ;
                    }
                    
                    // Μετάβαση στην πρώτη κάρτα που ικανοποιεί τα κριτήρια και ...υπόψη ειδικό show αν mmed[10]=2 !
PROKARTCRIT:
                fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                for (f=0;f<=dbfinum;f++) {
                    fread (memk[f] , 1, xlimk[f] , fpcard);
                    keimk=memk[f];
                    ceimk=memcp[f];
                    i=0;
                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                    else {
                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                        else ceimk[i]=255;
                    }
                }
                
                if (dbcard1!=dbcard) {
                    for (f=0;f<=dbfinum;f++) {curk[f]=curk1[f]=0;}
                }
                
                fread (&cardwhen,sizeof(time_t),1,fpcard);
                if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                     
            
                if  (dbcurpage!=1)  {
                dbcurpage=1;
                if (memx1) {free(memx1); memx1=0;}
                if (memy1) {free(memy1); memy1=0;}
                if(memx2)  {free(memx2); memx2=0;}
                if(memy2)  {free(memy2); memy2=0;}
                dbrecs=0;
                dbpage_decs();
                dbpage_recs(0);
                _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
                sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
                pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
                refresh();
                }
                dbdecor_show ();
                dbrecs_show ();
                        
                _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                refresh();
                    break;
                    
                case 5:         // Close a DB
                    if (mmed[5]) break;
                    if (dbplgr) {
                        for (f=0 ; f<=dbfinum ; f++) {    
                            keimk=memk[f];
                            ceimk=memcp[f];
                            
                            if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                            else {
                                if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                                else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                                else dx=1;
                            }
                            if (dx) {savenow=1 ; break ;}
                        }
                        if (savenow) {
                            if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                            switch (user_ans) {
                                
                                case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                    savenow=0;
                                    break;
                                    
                                case 1 : // ΣΩΣΕ ΤΩΡΑ
                                    continue ;
                                
                                case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                    savenow=0;
                                    tokyk=100;rego=0;
                                    continue ;
                            }
                        }
                    }
                    tokyk=100; rego=0 ; gundo_sit=0;gundo_but=0;
                    fidimundo_call(0,0);
                    diax_dec=0; prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                     baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                    _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                    _bareacls(dbtotcardxt-1 , topinfyt+1, dbtotcardxb+1 , topinfyt+17,syncardbkxr);     // Συνολο Καρτελλών στη βάση
                    sprintf(card_str,"%u",0); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                    sprintf(totcard_str,"%05u",0);  // Για σύνολο καρτελλών
                    _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                    _outsouv_col(dbtotcardxt,topinfyt+1,totcard_str,0,syncardchxr,syncardbkxr);

                    if(fpdb!=NULL) { 
                        f=fsync(fide_fpdb);
                        i=fclose (fpdb) ; 
                        if (i || f) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind (fpdb); fclose (fpdb); }
                        fpdb = NULL ;
                        wasopdb=0;
                    }
                    else
                    {
                       information (6-keyb_gr,LDdbfile,0);
                    }
                    
                    
                    if(fpcard!=NULL) {f=fsync(fide_fpcard); i=fclose(fpcard); sprintf(str1024,"%s%s",savedbpath,"Data1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpcard) ; fclose (fpcard);}}
                    if(fpdom!=NULL) {f=fsync(fide_fpdom); i=fclose(fpdom); sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; fclose (fpdom);}}
                    if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; fclose (fpera);}}
                    fpcard=NULL; wasopca=0 ; fpdom=NULL; wasopdo=0 ; fpera=NULL;
                    
                    if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                    if(item_mem) { free(item_mem); item_mem=0; }
                    
                    if (dbfinum>=0) {for (f=0;f<=dbfinum;f++) {if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}}}
                    if (dbplgr) {
                        
                        for (f=0;f<=dbfinum;f++) {
                            if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                            if (memk[f]) {free(memk[f]) ; memk[f]=0;}
                            if (memcp[f]) {free(memcp[f]) ; memcp[f]=0;}
                        }
                    }
                    
                    
                    if (memx1) {free(memx1); memx1=0;}
                    if (memy1) {free(memy1); memy1=0;}
                    if(memx2)  {free(memx2); memx2=0;}
                    if(memy2)  {free(memy2); memy2=0;}
                    if (dmemx1) {free(dmemx1); dmemx1=0;}
                    if (dmemy1) {free(dmemy1); dmemy1=0;}
                    if(dmemx2)  {free(dmemx2); dmemx2=0;}
                    if(dmemy2)  {free(dmemy2); dmemy2=0;}
                    dbdecs=0;
                    
                    dbpg=1;dbcurpage=1;dbfinum=-1; dbplgr=xlim=xmemk=0;decor=0;
                    mmed[2]=mmed[5]=mmed[6]=mmed[3]=mmed[4]=mmed[7]=mmed[8]= mmed[9]=mmed[10]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;
                    mmed[0]=mmed[1]=mmed[17]=mmed[11]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;
                    dbar=dbopen=dbplera=dbrecs=0;
                    savedbpath[0]='\0';
                    _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                    _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                     if (seflag>=2) bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                    proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=seflag=0 ;  ektos=1;
                    gen_ergo=&ch3;
                    if (dbfds.mem_fd) free(dbfds.mem_fd) ; dbfds.mem_fd=0; synolo_fds=0;  size_fds=512; dbfds.fd_ar=0;
                     if(epil_pos) {mem3=epil_pos; free(mem3); epil_pos=mem3=0; tot_opts=0;}
                      if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    dbcard_opt=0;
                    dbfds.fd_sorton=0;
                    for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                    for(f=0 ; f<100; f++) { if (alg_str[f]) {mem1=alg_str[f]; free (mem1); alg_str[f]=0; } }
                    if (empl_mem) {mem1=empl_mem; free(mem1); empl_mem=0; }
                    mem1=0;
                    cls();
                    break;
                    
                case 6:         // Add - Delete - Fields and Decorative Labels Management
                    if (mmed[6]) break;
                    if (mmed[7]==2 || mmed[9]==2 || mmed[10]==2) {
                        if (keyb_gr) information (0,"Η επιλογή αυτή λειτουργεί μόνον σε ..\n..κατάσταση Σχεδίασης Δομής!",0);
                        else information (0,"This option is functional only..\n..in \"Design the DB\" mode!",0);
                        continue ;
                    }
                    
                    if (dbplgr) {
                        for (f=0 ; f<=dbfinum ; f++) {    
                            keimk=memk[f];
                            ceimk=memcp[f];
                            
                            if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                            else {
                                if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                                else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                                else dx=1;
                            }
                            if (dx) {savenow=1 ; break ;}
                        }
                        if (savenow) {
                            if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                            switch (user_ans) {
                                
                                case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                    savenow=0;
                                    break;
                                    
                                case 1 : // ΣΩΣΕ ΤΩΡΑ
                                    continue ;
                                
                                case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                    savenow=0;
                                    tokyk=100;
                                    continue ;
                            }
                        }
                    }
                    
                    tokyk=100; gundo_sit=0;gundo_but=0;
                    fidimundo_call(0,0);
                    
                    if (rl) {    // Ενεργοποίηση διαχείρισης διακοσμητικών ετικετών !!
                        diax_dec=1-diax_dec ;
                        
                        if (!diax_dec) {
                            baserg=sxedom ;
                            sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                            normtext_tomy ( mmestr3c , mmestr[3]) ;
                            //_bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            //_outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                        }
                        else {
                            baserg=etikbkxr;
                            sprintf (mmestr3c , "%s - %s" , design_t , diaxetik);
                            normtext_tomy ( mmestr3c , mmestr[3]) ;
                            //_bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,etikbkxr);
                            //_outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,etikchxr,etikbkxr);
                        }
                        //refresh();
                        break ;
                    }
                    
                    
                    if (diax_dec) {      // Add_edit_decor
                        prorec=0;
                        teos_dec=(short int) decor;
                        do {
                            
                            dx=add_edit_decor (teos_dec , &teos_dec);
                            dbpage_decs();
                            dbdecor_show();
                            dbrecs_show();
                            if (dx!=1) break ;
                            dy=0;
                            for (f=0; f<dcar; f++) {
                                if (teos_dec==dd_elem[f]) {dy=1;break;}
                            }
                            if (dy) {
                                prorec=1;
                                trecx=dbdx1[f]; trecy=dbdy1[f];
                                getimage(trecx,trecy,dbdx2[f],dbdy2[f],mem_ouon);
                                setrgbcolor(dbmag);
                                rectangle (dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
                                rectangle (dbdx1[f]+1,dbdy1[f]+1,dbdx2[f]-1,dbdy2[f]-1);
                                refresh();
                            }
                            else prorec=0;
                        
                        } while (dx==1);
                        break ;
                    }
                    
                    prorec=proi1=0; fiornam=1;
                    i=add_edit_field (dbfinum+1 , &back_arped);
                    //if (i==2) break ;
                    while ( (i==1) && (back_arped<=dbfinum) ) {
                        dbdecor_show ();
                        dbrecs_show (); 
                        dx=0;
                        for (f=0 ; f<dbar; f++) {
                            if ( db_elem[f][0]==back_arped && (db_elem[f][1]) ) {dx=1; break;} 
                        }
                        if (dx) {
                            prorec=1;
                            getimage(dbx1[f],dby1[f],dbx2[f],dby2[f],mem_ouon);
                            setrgbcolor(dbmag);
                            rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                            rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                            trecx=dbx1[f] ; trecy=dby1[f];
                            dy=0; 
                            for (f=0; f<dbar; f++) {
                                if ( db_elem[f][0]==back_arped && (!db_elem[f][1]) ) {dy=1;break;} 
                                }
                            
                            if (dy) { 
                                proi1=1;
                                chainx=dbx1[f]+1; chainy=dby1[f]+1;
                                getimage(chainx,chainy,dbx1[f]+16,dby1[f]+16,mem_kato);
                                _puticon(chainx,chainy,mem_chain,255);
                            }
                            else proi1=0;
                            
                            refresh();
                        }
                        else {prorec=proi1=0;}
                        
                        i=add_edit_field (back_arped , &back_arped);
                    }
                    
                    if (i==3) { 

                    if (dbfinum>=0) {for (f=0;f<=dbfinum;f++) {if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}}}
                    
                    mem1=0;
                    if (memx1) {free(memx1); memx1=0;}
                    if (memy1) {free(memy1); memy1=0;}
                    if(memx2)  {free(memx2); memx2=0;}
                    if(memy2)  {free(memy2); memy2=0;}
                    if (dmemx1) {free(dmemx1); dmemx1=0;}
                    if (dmemy1) {free(dmemy1); dmemy1=0;}
                    if(dmemx2)  {free(dmemx2); dmemx2=0;}
                    if(dmemy2)  {free(dmemy2); dmemy2=0;}
                    dbdecs=0;
                    dbpg=dbcurpage=1;dbfinum=-1; decor=0;
                    dbar=dbopen=dbplgr=dbplera=dbrecs=0;
                    savedbpath[0]='\0'; dbcurpage=1;
                    _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                    _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                    gen_ergo=&ch3;
                    loaddbfile=LDdbfile;
                    if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                    tot_opts=0; 
                     if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    goto OPENDB ;}
                    
                    else if ( (i==4) || (i==5) ) { 
                        
                        addped=0; delped=0; allorio=0 ;
                        
                        for (f=0;f<=dbfinum;f++) {
                            if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}
                            if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                            if (memk[f]) {free(memk[f]) ; memk[f]=0;}
                            if (memcp[f]) {free(memcp[f]) ; memcp[f]=0;}
                        }
                        
                        
                        mem1=0;
                        
                        if (memx1) {free(memx1); memx1=0;}
                        if (memy1) {free(memy1); memy1=0;}
                        if(memx2)  {free(memx2); memx2=0;}
                        if(memy2)  {free(memy2); memy2=0;}
                        if (dmemx1) {free(dmemx1); dmemx1=0;}
                        if (dmemy1) {free(dmemy1); dmemy1=0;}
                        if(dmemx2)  {free(dmemx2); dmemx2=0;}
                        if(dmemy2)  {free(dmemy2); dmemy2=0;}
                        dbdecs=0;
                        mmed[2]=mmed[5]=mmed[6]=mmed[3]=mmed[4]=mmed[7]=mmed[8]= mmed[9]=mmed[10]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1; 
                        mmed[0]=mmed[1]=mmed[17]=mmed[11]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;
                        dbpg=dbcurpage=1;dbfinum=-1; dbplgr=xlim=xmemk=0;
                        dbar=dbopen=dbplera=dbrecs=0; decor=0;
                        proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=0 ;  ektos=1;
                        
                        _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                        if (dbfds.mem_fd) free(dbfds.mem_fd) ; 
                        dbfds.mem_fd=0; synolo_fds=0;  size_fds=512; dbfds.fd_ar=0; 
                        if (!dbcard_opt) {
                        if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                        tot_opts=0; 
                        if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        }
                        if (seflag>=2) bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        seflag=0; gocards=0; firstcrit=0;
                        for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                        
                        if (fpdb!=NULL) fclose (fpdb) ; 
                        if(fpcard!=NULL) fclose(fpcard); 
                        if(fpdom!=NULL) {f=fsync(fide_fpdom); i=fclose(fpdom); sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; rewind (fpdom); fclose (fpdom);}}
                        if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; rewind(fpera); fclose (fpera);}}
                        fpdb=NULL; wasopdb=0; fpcard=NULL; wasopca=0; fpdom=NULL; wasopdo=0; fpera=NULL;
                        savedbpath[0]='\0';
                        if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                        if(item_mem) { free(item_mem); item_mem=0; }
                        gen_ergo=&ch3;
                        loaddbfile=LDdbfile;
                        goto OPENDB ;
                    }
                    
                    
                    else if (i==6) { //Διαγραφή τελευταίου πεδίου στοιχείων ! 
                        
                        f=0;
                        if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);ptr_pedio[f]=0;}
                        if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                        if (memk[f]) {free(memk[f]) ; memk[f]=0;}
                        if (memcp[f]) {free(memcp[f]) ; memcp[f]=0;}
                        
                        
                        
                        mem1=0;
                        
                        if (memx1) {free(memx1); memx1=0;}
                        if (memy1) {free(memy1); memy1=0;}
                        if(memx2)  {free(memx2); memx2=0;}
                        if(memy2)  {free(memy2); memy2=0;}
                        if (dmemx1) {free(dmemx1); dmemx1=0;}
                        if (dmemy1) {free(dmemy1); dmemy1=0;}
                        if(dmemx2)  {free(dmemx2); dmemx2=0;}
                        if(dmemy2)  {free(dmemy2); dmemy2=0;}
                        dbdecs=0;
                        mmed[2]=mmed[5]=mmed[6]=mmed[3]=mmed[4]=mmed[7]=mmed[8]= mmed[9]=mmed[10]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;
                        mmed[0]=mmed[1]=mmed[17]=mmed[11]=mmed[18]=mmed[19]=mmed[20]=mmed[22]=mmed[23]=0;
                        dbpg=dbcurpage=1;dbfinum=-1; dbplgr=xlim=xmemk=0;
                        dbar=dbopen=dbplera=dbrecs=0; decor=0; 
                        proel=progvn=-1; mbut=dbpgdn=dbpgup=cardribut=cardlebut=cardsabut=cardnewbut=cardareabut=0 ;  ektos=1;
                        
                        _bareacls (topdbnamext , topinfyt+1, topdbnamexb, topinfyt+18, topbkxr);
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                        if (dbfds.mem_fd) free(dbfds.mem_fd) ; 
                        dbfds.mem_fd=0; synolo_fds=0;  size_fds=512; dbfds.fd_ar=0; 
                        if (epil_pos) {mem3=epil_pos; free(mem3); mem3=epil_pos=0; }
                        tot_opts=0; dbcard_opt=0;
                        if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        if (seflag>=2) bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                        seflag=0; gocards=0; firstcrit=0;
                        for (f=0 ; f<101 ; f++) normdeigma[f][0]=255;
                        
                        if (fpera!=NULL) fclose(fpera);
                        dbplera=0;
                        sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                        fpera=fopen(str1024,"wb");
                        if (fpera!=NULL) { 
                        fide_fpera = fileno (fpera) ;
                        fwrite (&dbplera,2,1,fpera);
                        fsync (fide_fpera);
                        fclose (fpera); fpera=NULL ;}
                        else {
                            information(6-keyb_gr,str1024,0);
                        }
                        
                        /*
                        if (fpdb!=NULL) fclose (fpdb) ; 
                        if(fpcard!=NULL) fclose(fpcard); 
                        if(fpdom!=NULL) {f=fsync(fide_fpdom); i=fclose(fpdom); sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpdom) ; rewind (fpdom); fclose (fpdom);}}
                        if(fpera!=NULL) {f=fsync(fide_fpera); i=fclose(fpera); sprintf(str1024,"%s%s",savedbpath,"era1.aba");  if (i || f) {information (6-keyb_gr,str1024,0); clearerr(fpera) ; rewind(fpera); fclose (fpera);}}
                        fpdb=NULL; wasopdb=0; fpcard=NULL; wasopca=0; fpdom=NULL; wasopdo=0; fpera=NULL;
                        */
                        savedbpath[0]='\0';
                        if(ardom_mem) { free(ardom_mem); ardom_mem=0;}
                        if(item_mem) { free(item_mem); item_mem=0; }
                        gen_ergo=&ch3;
                        loaddbfile=LDdbfile;
                        goto OPENDB ;
                    }
                    
                    else if (i==11) { // Τροποποίηση mathtype πεδίου
                        a1=0;
                        dx=check_pediaola_math();
                        if (dx<0) {information (2-keyb_gr,0,0); goto ANASORT1_FYGE;}
                        dpro = proter_calc_pedivn();
                        if (dpro>0) {
                            for (f=0 ; f<enmath_1; f++) {
                                if (dbkey==prot_calc[f]) { a1=prot_calc[f]; break ; }
                            }
                        }
                        
                        f1=0;
                        if (dbcard>dbplgr) f1=1;
                        else thesi=ar_dom[dbcard-1];

                        if (keyb_gr) strcpy (str1kb,"Επανυπολογισμοί..");
                        else strcpy (str1kb,"Recalculations..");
                        user_ans = proodos(  str1kb, 0, dbplgr,0) ;
                        
                        for (i=0;i<dbplgr;i++) {
                            
                            if (user_ans) { proodos(  0, i, dbplgr,0) ;}
                            
                            dx = fseek (fpcard , ar_dom[i]*dbcardsize , 0) ;
                            if (dx) {information (6-keyb_gr,Strcardfp,0) ; break ;}
                            dx=0;
                            for (f=0;f<=dbfinum;f++) {
                                fread (memk[f] , 1, xlimk[f], fpcard);
                                if (ferror(fpcard)) {information (6-keyb_gr,Strcardfp,0) ; dx=1; break ;}
                            }
                                if (dx) break ;    
                            
                                if (dpro>0) {
                                    for (dy=0 ; dy<enmath_1; dy++) {
                                        a=prot_calc[dy];
                                        dfx = anal_parast (a, alg_str[a] , &alg_err , 0);
                                        check_orio_write_mathped(a, ptr_pedio[a]->fiorio, 1);
                                        
                                        if (a==dbkey) {
                                            keimk=memk[a];
                                            if ( ptr_pedio[dbkey]->fitype==3 ) {
                                                Litem[i]= (keimk[0]!=255) ? (long int) convert_str(ptr_pedio[a]->fiorio , keimk) : 0 ;
                                            }
                                            else if ( ptr_pedio[dbkey]->fitype==4 ) {
                                                Fitem[i]= (keimk[0]!=255) ? (double) convert_str(ptr_pedio[a]->fiorio , keimk) : 0 ;}
                                        }
                                    }
                                }
                            
                                    
                            dx = fseek (fpcard , ar_dom[i]*dbcardsize , 0) ;
                            if (dx) {information (6-keyb_gr,Strcardfp,0) ; break ;}
                            dx=0;
                            for (f=0;f<=dbfinum;f++) {
                                fwrite (memk[f] , 1, xlimk[f], fpcard);
                                if (ferror(fpcard)) {information (6-keyb_gr,Strcardfp,0) ; dx=1; break ;}
                                fdatasync (fide_fpcard) ;
                            }  
                        }
                        
                        proodos(  0, i, dbplgr,1) ;
                        
                        if (a1) {
                            if ( ptr_pedio[dbkey]->fitype==3 ) {
                                
                            if (dbplgr>1) {
                                new_dom_vo = malloc (dbplgr*2);
                                if (!new_dom_vo) {information (2-keyb_gr,0,0); goto ANASORT1_FYGE; }
                                new_dom=new_dom_vo;
                                for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                pro_sort_signedlong(item_mem,new_dom,dbplgr);
                                }
                            }
                            else if ( ptr_pedio[dbkey]->fitype==4 ) {
                                if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto ANASORT1_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                    pro_sort_double(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                }
                            }
                            
                            if (dbplgr==1) {
                                rewind (fpdom) ;
                                fwrite(&ar_dom[0],2,1,fpdom); 
                                fdatasync(fide_fpdom) ;
                                if (ferror(fpdom)) {information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}
                                //dbcard=1;
                            }
                            
                            else

                            {

                            // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                            for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                            ar_dom = new_dom;
                            free (ardom_mem);
                            ardom_mem=new_dom_vo;
                            new_dom_vo=0;
                            rewind(fpdom);
                            fwrite(ar_dom,2,dbplgr,fpdom);
                            fdatasync (fide_fpdom);
                            if (ferror(fpdom)) { information (6-keyb_gr,Strdomfp,0); clearerr(fpdom);}

                            }

                            // Αριθμός καρτέλας που προκύπτει μετά από ταξινόμηση !!
                            if (!f1) {
                                for (f=0;f<dbplgr;f++) {
                                    if (ar_dom[f]==thesi) break ; 
                                } 
                                dbcard=f+1;
                            }

                        }
                        
                        if (dbcard<=dbplgr) {
                                dx = fseek (fpcard , ar_dom[dbcard-1]*dbcardsize , 0) ;
                                if (dx) {information (6-keyb_gr,Strcardfp,0) ; goto ANASORT1_FYGE;}
                                
                                for (f=0;f<=dbfinum;f++) {
                                    fread (memk[f] , 1, xlimk[f], fpcard);
                                    keimk=memk[f];
                                    ceimk=memcp[f];
                                    i=0;
                                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                                    else {
                                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                                        else ceimk[i]=255;
                                    }
                                }
                            }
                        else {
                            for (f=0;f<=dbfinum;f++) {keimk=memk[f]; keimk[0]=255;}
                        }


ANASORT1_FYGE:
                        /*
                            if (dbcurpage!=1) {
                            dbcurpage=1;
                            if (memx1) {free(memx1); memx1=0;}
                            if (memy1) {free(memy1); memy1=0;}
                            if(memx2)  {free(memx2); memx2=0;}
                            if(memy2)  {free(memy2); memy2=0;}
                            dbrecs=0;
                            dbpage_recs(0);
                            }
                        */
                        if (seflag>=2) seflag=1;
                        _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                        sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                        _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                        refresh();
                    }
                    
                        
                    if (dbkey!=prodbkey) { prodbkey=dbkey; sec_dbkey=-1;seclevsort=1;
                        if (dbplgr) goto EPANASORT ; }
                    dx=check_pediaola_math();
                    if (dx<0) {information (2-keyb_gr,0,0);}
                    dpro = proter_calc_pedivn(); 
                    dbdecor_show ();
                    dbrecs_show ();
                    dx=info_dbfds(); // Ενημέρωση της δομής dbfds (button με ονόματα πεδίων)
                    if (!dx) {information (2-keyb_gr,0,0); break ;}
                    if (!dbplgr) {
                    if (dbfinum>=0) mmed[7]=0;
                    if (dbfinum>=0) mmed[8]=0;
                    }
                     _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                     sprintf(top_str,"%02d",dbcurpage);
                    pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                    outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);

                    break;
                    
                case 7:         // Εισαγωγή Στοιχείων
                    if (mmed[7]) continue;
                    fidimundo_call(0,0);
                    tokyk=100;
                    baserg=eisag;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    mmed[7]=2; big_t=2.0 ;mmed[6]=1; mmed[3]=0 ; if (dbplgr) mmed[9]=0;
                    diax_dec=0;prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    mmed[10]=1;if (seflag>=2) {seflag=1; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    gen_ergo=mmestr[kyk];
                    if (!xlim) {
                    if (!dbplgr) {
                        sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                        fp=fopen(str1024,"wb");
                        if (fp==NULL) {information (6-keyb_gr,str1024,0); gen_ergo=&ch3 ; break ;}
                        fide_lims = fileno (fp) ;
                          for (f=0;f<=dbfinum;f++) {
                            a=ptr_pedio[f]->fitype;
                            xlimk[f]=ptr_pedio[f]->fiorio+1;
                            switch (a) {
                                case 0 :
                                    if ( xlimk[f] < 1000 ) xlimk[f] += (80 * xlimk[f] / 100) ;
                                    else if ( xlimk[f] < 5000 ) xlimk[f] += (60 * xlimk[f] / 100) ;
                                    else if ( xlimk[f] < 10000 ) xlimk[f] += (40 * xlimk[f] / 100) ;
                                    else if ( xlimk[f] < 30000 ) xlimk[f] += (20 * xlimk[f] / 100) ;
                                    else if ( xlimk[f] < 50000 ) xlimk[f] += (10 * xlimk[f] / 100) ;
                                    break ;
                                case 1 :
                                case 2 :
                                    xlimk[f]=51 ;
                                    break;
                                case 3:
                                case 4:
                                    xlimk[f]=15 ;
                                    break;
                                case 5 :
                                    xlimk[f]=1024 ;
                                    break;
                                case 6:
                                    xlimk[f]=25;
                        }
                  fwrite (&xlimk[f],2,1,fp);
                    }
                  fsync (fide_lims);
                  fclose (fp);
                  xlim=1;
                }
                else {
                    sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                    fp=fopen(str1024,"rb");
                    if (fp==NULL) {information (6-keyb_gr,str1024,0); gen_ergo=&ch3 ; break ;}
                    fread (xlimk,2,dbfinum+1,fp);
                    xlim=1;
                    fclose (fp);
                }
            }
                    // if ( xmemk==2 ) { for (f=0; f<=dbfinum; f++) { free (memk[f]) ; memk[f]=0;} }
                    
                    if (!xmemk) {
                        dbcardsize=alma_deigma=0;
                    for (f=0;f<=dbfinum;f++) {
                        if (dbkey==f) alma_deigma=dbcardsize ;
                        limk[f]= (ptr_pedio[f]->fitype != 5) ? ptr_pedio[f]->fiorio+1 : 1024 ;
                        memk[f]=malloc(xlimk[f]); keimk=memk[f] ; keimk[0]=255;
                        memcp[f]=malloc(xlimk[f]); ceimk=memcp[f] ; ceimk[0]=255;
                        if (!memk[f] || !memcp[f]) {information (2-keyb_gr,0,0) ;}
                        dbcardsize+=xlimk[f];
                    }
                    if (dbkey==100) alma_deigma=dbcardsize ;
                    xmemk=1;
                    dbcardsize += sizeof (time_t);
                    for (f=0;f<=dbfinum;f++) {curk[f]=0; curk1[f]=0;}
                    /*
                    fseek(fpdb , math_alma , 0);
                    for(f=0 ; f<=dbfinum ; f++) {
                        if (alg_str[f]) { free(alg_str[f]); alg_str[f]=0;}
                        if (ptr_pedio[f]->mathtype) {
                            mem5=malloc(1026);
                            if (!mem5) {information (2-keyb_gr,0,0); break;}
                            alg_str[f]=mem5;
                            fread(alg_str[f],1,1024,fpdb);
                        }
                    }
                    
                    
                    //printf ("mexri edo kala....");
                    dpro = proter_calc_pedivn(); 
                    //printf ("mexri edo kala dpro....");
                    */
                    }
                    dx=check_pediaola_math();
                    if (dx<0) {information (2-keyb_gr,0,0); break;}
                    dpro = proter_calc_pedivn();
                    for (f=0;f<=dbfinum;f++) {curk[f]=curk1[f];}
                    eaninpundo();
                    break;
                    
                case 8:         // Goto and Show the sorting key Field
                    if (mmed[8]) continue ;
                     baserg1=baserg;
                     baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    if (diax_dec) {baserg1=sxedom; fidimundo_call(0,0);}
                    diax_dec=0; prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    
                    
                    if (rl) {
                        if (dbplgr) {
                            
                            fidimundo_call(0,0);
                            for (f=0 ; f<=dbfinum ; f++) {    
                                keimk=memk[f];
                                ceimk=memcp[f];
                                
                                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                                else {
                                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                                    else dx=1;
                                }
                                if (dx) {savenow=1 ; break ;}
                            }
                            if (savenow) {
                                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                            else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                                switch (user_ans) {
                                    
                                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                        savenow=0;
                                        break;
                                        
                                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                                        continue ;
                                    
                                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                        savenow=0;
                                        tokyk=100;
                                        continue ;
                                }
                            }
                        }
                        tokyk=100;
                        if (dbkey==100) {
                            if (keyb_gr) {
                                strcpy(str1024,"Δεν έχει ορισθεί κλειδί ταξινόμησης!\nΕπιλογή κλειδιού ταξινόμησης..");
                                strcpy(str1kb,"Επιλογή κλειδιού ταξινόμησης και δευτερεύοντος κλειδιού !\n(Η ταξινόμηση σε δεύτερο επίπεδο ισχύει προσωρινά!)");
                                strcpy(file_2,"Να μην γίνει τίποτε !\n Οι καρτέλες θα συνεχίσουν να ταξινομούνται με βάση τη χρονική σειρά καταχώρησης.");
                            }
                            else {
                                strcpy(str1024,"No sorting key is defined!\nSorting key definition..");
                                strcpy(str1kb,"Sorting key definition and secondary key definition ..!\n(Second level sorting is provisionally valid!)");
                                strcpy(file_2,"Nothing to do!\nDB Cards will continue to be sorted in the order of registration.");
                                
                            }
                        }
                        else {
                            mytext_tonorm (ptr_pedio[dbkey]->finame , file_2 , 60);
                            if (sec_dbkey>dbfinum) sec_dbkey=-1;
                            if (sec_dbkey!=-1) {
                                if (ptr_pedio[sec_dbkey]->fitype == 5) sec_dbkey=-1;
                            }
                            if (sec_dbkey!=-1) {
                               mytext_tonorm (ptr_pedio[sec_dbkey]->finame , file_3,60); 
                            }
                            else seclevsort=1;
                            
                            if (keyb_gr) {
                                if (sec_dbkey==-1) { sprintf (str1024,"Έχετε ορίσει ως κλειδί ταξινόμησης το πεδίο [%s]!\nΑλλαγή κλειδιού και (προαιρετικά) ορισμός δευτερεύοντος (ισχύει προσωρινά)!",file_2);}
                                else {sprintf (str1024,"Έχετε ορίσει ως κλειδί ταξινόμησης το πεδίο [%s] και ως δευτερεύων κλειδί το πεδίο [%s]!\n Aναδιάταξη με τα ίδια κλειδιά..!",file_2 , file_3);}
                                    
                                if (sec_dbkey==-1) strcpy (str1kb , "Διατήρηση του κλειδιού ταξινόμησης και καθορισμός δευτερεύοντος!\n(Η ταξινόμηση σε δεύτερο επίπεδο ισχύει προσωρινά!)");
                                else  strcpy (str1kb , "Αλλαγή αμφότερων των κλειδιών !");
                                       
                                strcpy(file_2,"Κατάργηση κλειδιού-ών !\n Οι καρτέλες να ταξινομούνται με βάση τη χρονική σειρά καταχώρησης.");
                            }
                            else {
                                if (sec_dbkey==-1) { sprintf (str1024,"You have defined as the sorting key the field [%s]!\nChange key and (optionally) define a secondary one ! (provisionally valid)",file_2);}
                                else {sprintf (str1024,"You have defined as the sorting key the field [%s] and as the secondary one the field [%s]!\n Rearrangement with the same keys..!",file_2 , file_3);}
                                    
                                if (sec_dbkey==-1) strcpy (str1kb , "Keep the sorting key and  define a secondary one !\n(Second level sorting is provisionally valid !)");
                                else  strcpy (str1kb , "Change both keys!");
                                
                                strcpy(file_2,"Νο more sorting key(s)!\nDB Cards will be sorted in the order of registration.");
                            }
                        }
                        
                        user_ans = choise_alert_3 (str1024,str1kb, file_2, 1) ;
                        if (!user_ans) break ;

                        if (keyb_gr) strcpy(str1024,"Επιλέξτε κλειδί ταξινόμησης"); 
                        else strcpy(str1024,"Select the DB sorting key");
                        if (keyb_gr) strcpy(str1kb,"Επιλέξτε Δευτερεύων κλειδί"); 
                        else strcpy(str1kb,"Select Secondary key");
                        if (dbkey==100) {
                            switch (user_ans) {
                                case 1 :
                                    dx=-1;
                                    normtext_tomy(str1024 , dbfds.fd_name);
                                    dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    break;
                                    
                                case 2 :
                                    normtext_tomy(str1024 , dbfds.fd_name);
                                    dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    if (dy<0) break;
                                    normtext_tomy(str1kb , dbfds.fd_name);
                                    dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    break;
                                    
                                case 3:
                                    dx=-1;dy=-1;
                                    break;
                            }
                        }
                        else {
                            switch (user_ans) {
                                case 1 :
                                    if (sec_dbkey==-1){
                                        normtext_tomy(str1024 , dbfds.fd_name);
                                        dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                        if (dy<0) break;

                                        normtext_tomy(str1kb , dbfds.fd_name);
                                        dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    }
                                    else {
                                        dy=dbkey; dx=sec_dbkey;
                                    }
                                    break;
                                    
                                case 2 :
                                    if (sec_dbkey==-1){
                                    dy=dbkey; 
                                    normtext_tomy(str1kb , dbfds.fd_name);
                                    dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    }
                                    else {
                                    normtext_tomy(str1024 , dbfds.fd_name);
                                    dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    if (dy<0) break;
                                    normtext_tomy(str1kb , dbfds.fd_name);
                                    dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                    }                                    
                                    break;
                                    
                                case 3:
                                    dx=-1;dy=100;
                                    break;
                            }
                        }
                        
                        
                        if (keyb_gr) strcpy(str1024,"Επιλογή Πεδίου Δεδομένων"); 
                        else strcpy(str1024,"Select DB Field");
                        normtext_tomy(str1024 , dbfds.fd_name);
                        
                        if (dbkey==100 && dx==-1 && dy==-1) break ;
                        
                        if (dy<0) break ;
                        
                        if (dy>=0 && dy<100) {
                            if (ptr_pedio[dy]->fitype == 5) {
                                if (keyb_gr) sprintf(str1024,"Τα πεδία εικόνων είναι ακατάλληλα !");
                                else sprintf(str1024,"The image fields are inappropriate !");
                                information (0,str1024,0);
                                sec_dbkey=-1; seclevsort=1;
                                break;
                            }
                        }

                        
                        if (dx>=0) {
                            if (ptr_pedio[dx]->fitype == 5) {
                                if (keyb_gr) sprintf(str1024,"Τα πεδία εικόνων είναι ακατάλληλα !");
                                else sprintf(str1024,"The image fields are inappropriate !");
                                information (0,str1024,0);
                                dx=-1;
                            }
                        }
                        
                        if (dbkey!=100 && dy==100) {sec_dbkey=-1; seclevsort=1; dbkey=100;}
                        else if (dy>=0 && dy<100) { dbkey=dy; }
                        
                        if (dx>=0) {sec_dbkey=dx ; seclevsort=2;}
                        else {sec_dbkey=-1 ; seclevsort=1;}
                        
                        gundo_but=0;
                        
                        if (dbkey != prodbkey) { 
                            prodbkey=dbkey;
                            fseek(fpdb,102,0);
                            fwrite (&dbkey,2,1,fpdb);
                            fdatasync (fide_fpdb);
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg1);
                            _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                             }
                             
                        goto EPANASORT ;
                        
                    }
                    
                    tokyk=100;
                    if (dbkey==100) {
                        information(44-keyb_gr,0,0); break ;
                    }
                    
                    dx=dbkey;
                    alma=8; // Για να φλασάρει το τρέχων πεδίο ταξινόμησης...
                    break;
                    
                case 9:         // Show the Data Base Cards Freely
                    if (mmed[9]) break;
                    
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    diax_dec=0; prodec=prodvn=-1; fidimundo_call(0,0);
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    tokyk=100;
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    if (dbcard>dbplgr) {
                        if (keyb_gr) information (0,"Η καρτέλα δεν έχει ακόμη αρχειοθετηθεί!","Προσπαθήστε ξανά αργότερα..");
                        else information(0,"This DB card has not archived yet!","Retry later..");
                        break ;
                    }
                    gundo_sit=0;gundo_but=0;
                    baserg=parous; 
                    mmed[9]=2 ; big_t=2.0 ; mmed[3]=mmed[7]=0; gundo_sit=0; gundo_but=0; mmed[6]=1;
                    fidimundo_call(0,0);
                    if (seflag==2) {mmed[10]=0; seflag=3; _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    gen_ergo=mmestr[kyk];
                    break ;
                    
                case 10:        // Show Cards with search criteria
                    if (mmed[10]) break ;
                    if (seflag!=3) break ;
                    
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    tokyk=100; 
                    if (gundo_sit ) {
                        gundo_sit=0; gundo_but=0;
                        if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
                    }
                   fidimundo_call(0,0);
                    diax_dec=0; prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    seflag=2;
                    dbcard1=dbcard ;
                     if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    baserg=parous;
                    mmed[10]=2;big_t=2.0 ; mmed[9]=0;mmed[3]=0; mmed[6]=1;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    gen_ergo=mmestr[kyk];
                    for (f=0;f<dbplgr;f++) if (crits[f]) break ;
                    dbcard=f+1;
                    puticon(search_flagxt,topinfyt,mem_search,255);
                    fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                    for (f=0;f<=dbfinum;f++) {
                        fread (memk[f] , 1, xlimk[f] , fpcard);
                        keimk=memk[f];
                        ceimk=memcp[f];
                        i=0;
                        if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                        else {
                            if(keimk[i]!=255) strcpy (ceimk,keimk); 
                            else ceimk[i]=255;
                        }
                    }
                    
                    if (dbcard1!=dbcard) {
                        for (f=0;f<=dbfinum;f++) {curk[f]=curk1[f]=0;}
                    }
                    
                    fread (&cardwhen,sizeof(time_t),1,fpcard);
                    if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                     
            
                    if  (dbcurpage!=1)  {
                    dbcurpage=1;
                    if (memx1) {free(memx1); memx1=0;}
                    if (memy1) {free(memy1); memy1=0;}
                    if(memx2)  {free(memx2); memx2=0;}
                    if(memy2)  {free(memy2); memy2=0;}
                    dbrecs=0;
                    dbpage_decs();
                    dbpage_recs(0);
                    _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
                    sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
                    pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                    _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
                    refresh();
                    }
                    dbdecor_show ();
                    dbrecs_show ();
                            
                    _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                    sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                    _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                    refresh();
                        break;
                    
                case 11:        // readyinks
                    tokyk=100;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    readyinks (chxr , bkxr , slxr);
                    break;
                    
                case 12:        // Δείχνει τα στοιχεία που περιέχει ένα πεδίο για επιλογή κάποιου και εμφάνιση της αντίστοιχης καρτέλλας.
                    if (mmed[12]) continue ;
                    if (!dbplgr) continue;
                    papiso=1;
                    
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    
                     tokyk=100; 
                    if (gundo_sit ) {
                        gundo_but=0;
                        if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
                    }
                   fidimundo_call(0,0);
                     diax_dec=0;prodec=prodvn=-1;
                     sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                     normtext_tomy ( mmestr3c , mmestr[3]) ;
                     dbcard1=dbcard ;
                     baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                   // Καλείται το button των πεδίων για να δω που θα πάω μετά...
                    dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );  
                    if (dx<0) goto APOK_KEF ;
                    if (ptr_pedio[dx]->fivar[2]) {
                        if (keyb_gr) information(0,"Το πεδίο έχει απόκρυψη !",0);
                        else information(0,"The data field is hidden !",0);
                        goto APOK_KEF ;
                    }
                    if (ptr_pedio[dx]->ficode) {
                        str1024[0]=255;
                        input_alert (40-keyb_gr,0, str1024 ,4);
                        f=(int) convert_str(4 , str1024);
                        if (ptr_pedio[dx]->ficode != (short int) f ) goto APOK_KEF ;
                    }
                    //normtext_tomy ("Εντοπισμός Καρτέλλας" , dbfdata.fd_name) ;
                    if (ptr_pedio[dx]->fitype==5) {
                        
                        if (dbfinum+1>posafoto) {
                            if (dbkey!=100) {
                                mytext_tonorm (ptr_pedio[dbkey]->finame , new_dbname, 61);
                                if (keyb_gr) { 
                                    sprintf (str1024 , "Είναι πεδίο εικόνων !\nΜπορείτε να συνδυάσετε την παρουσίαση των εικόνων με το κλειδί ταξινόμησης :\n[%s] για αποτελεσματικότερο έλεγχο της βάσης δεδομένων." , new_dbname);
                                    sprintf (str1kb , "Μπορείτε επίσης να επιλέξετε κάποιο άλλο πεδίο δεδομένων (όχι εικόνας), διαφορετικό από το κλειδί ταξινόμησης για να συνδυάσετε με αυτό την παρουσίαση των εικόνων."); 
                                }
                                else {
                                    sprintf (str1024 , "It is an image data field!\nYou can combine the presentation of the images with the sorting key :\n[%s] for more effective database control." , new_dbname);
                                    sprintf (str1kb , "You can also select another data field (not an image type), other than the sorting key , in order to combine the presentation of the images with this one.");
                                }
                            }
                            else { // dbkey=100 !!
                                if (keyb_gr) { 
                                    sprintf (str1024 , "Είναι πεδίο εικόνων !\nΜπορείτε να συνδυάσετε την παρουσίαση των εικόνων με κάποιο άλλο πεδίο (όχι εικόνας) που θα επιλέξετε στη συνέχεια, για αποτελεσματικότερο έλεγχο της βάσης δεδομένων." );
                                    sprintf (str1kb , "Μπορείτε απλά να δείτε τις εικόνες με τη χρονική σειρά εγγραφής των αντίστοιχων καρτελών τους."); 
                                }
                                else {
                                    sprintf (str1024 , "It is an image data field!\nYou can combine the presentation of the images with another data field (not an image type),which you will then select for more effective database control.");
                                    sprintf (str1kb , "You can simply view the images based on the recording time of their respective data cards");
                                }
                            }
                        }
                        new_dbname[0]='\0';
                        user_ans = choise_alert (str1024,str1kb,1) ;
                        if (!user_ans || user_ans<0) goto APOK_KEF ;
                        dy=-1;
                        if (dbkey!=100) {
                            if (user_ans==1) dy=dbkey;
                            else {dy=button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );}
                        }
                        else {
                            if (user_ans==1) {dy=button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );}
                            else dy=-1;
                        }
                        
                        if (dy>=0) {
                            
                            if(ptr_pedio[dy]->fitype!=5) {
                            
                                if (ptr_pedio[dy]->fivar[2]) {
                                    if (keyb_gr) information(0,"Το πεδίο έχει απόκρυψη !",0);
                                    else information(0,"The data field is hidden !",0);
                                    dy=-1;
                                }
                                
                                if (dy>=0 && ptr_pedio[dy]->ficode) {
                                    str1024[0]=255;
                                    input_alert (40-keyb_gr,0, str1024 ,4);
                                    f=(int) convert_str(4 , str1024);
                                    if (ptr_pedio[dy]->ficode != (short int) f ) dy=-1 ;
                                }
                            }
                            else dy=-1;
                        
                        }
                        
                        if (dy>=0) {
                            i=info_dbsec((short int) dy , ar_dom) ; 
                            if (!i) goto APOK_KEF ;
                        }
                        
    
                    i=photofield_show_button(dbsec.mem_fd, dbsec.fd_ar, (short int) dx , (short int) dy , &dbsec.fd_sorton , ar_dom);
                    
                    goto META_FOTOFIELD ;
                    }
                    
                    
                    i=info_dbfdata((short int) dx , ar_dom) ; 
                    if (!i) goto APOK_KEF ;
                    i=dbfield_show_button(dbfdata.mem_fd, dbfdata.fd_data, dbfdata.fd_ar, dbfdata.fd_orio, dbfdata.fd_name, &dbfdata.fd_sorton , dbfdata.fd_sort_type , 1 , ar_dom);
                    
META_FOTOFIELD : 
                    if (i<0) goto APOK_KEF ;
                    papiso=0;
                    dbcard=i+1;
                    
                    if (user_opts) {

                        p = ar_dom[i];
                        a=0;
                        for (f=0 ; f<tot_opts ; f++) {
                            if (epil_pos[f]==p) {a=1 ; break; }
                        }
                        if (!a) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    }                    
                    

                    fseek(fpcard , (ar_dom[i] * dbcardsize) , 0);
                    for (f=0;f<=dbfinum;f++) {
                        fread (memk[f] , 1, xlimk[f] , fpcard);
                        keimk=memk[f];
                        ceimk=memcp[f];
                        i=0;
                        if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                        else {
                            if(keimk[i]!=255) strcpy (ceimk,keimk); 
                            else ceimk[i]=255;
                        }
                    }
                    
                    if (dbcard1!=dbcard) {
                        for (f=0;f<=dbfinum;f++) {curk[f]=curk1[f]=0;}
                    }
                    
                    fread (&cardwhen,sizeof(time_t),1,fpcard);
                    if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                    
                    proel=-1; ektos=1;
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                    SDL_SetCursor(cursor);
                    _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                    sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                    _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                    refresh();
                     i=dx;
                    if (ptr_pedio[i]->fipg != dbcurpage ) {
                        dbcurpage=ptr_pedio[i]->fipg;
                        if (memx1) {free(memx1); memx1=0;}
                        if (memy1) {free(memy1); memy1=0;}
                        if(memx2)  {free(memx2); memx2=0;}
                        if(memy2)  {free(memy2); memy2=0;}
          
                        dbrecs=0;
                        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
                        sprintf(top_str,"%02d",dbcurpage);
                        pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
                        _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
                        dbpage_decs();
                        dbpage_recs(0);
                    }
                    if (gen_ergo[0] != 255) { 
                    if (mmed[7]==2) baserg=eisag ;
                    else if (mmed[9]==2) baserg=parous;
                    else if (mmed[3]==2) baserg=sxedom ;
                    else if (seflag>=2) {seflag=1; mmed[10]=1; mmed[9]=2; big_t=2.0 ; gen_ergo=mmestr[9];baserg=parous; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    else baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); }
                    else _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    refresh();
                    dbdecor_show ();
                    dbrecs_show ();
                    
                    goto FLDSRCH_1;
                    
APOK_KEF :

                    if (gen_ergo[0] != 255) { 
                    if (mmed[7]==2) baserg=eisag ;
                    else if (mmed[9]==2) baserg=parous;
                    else if (mmed[3]==2) baserg=sxedom ;
                    else if (seflag>=2) {
                        if (papiso) {
                            baserg=parous;
                        }
                        else {
                            seflag=1; mmed[10]=1; mmed[9]=2; big_t=2.0 ; gen_ergo=mmestr[9];baserg=parous; bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        
                    }
                    else baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); }
                    else _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    refresh();
                    break;
                    
                case 13:        // Delete DB Card
                    if (mmed[13]) continue ;
                    
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,delerg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,delerg);refresh();
                    
                    if (dbcard>dbplgr) {
                        if (keyb_gr) information (0,"Η καρτέλα δεν έχει ακόμη αρχειοθετηθεί!",0);
                        else information(0,"This DB card has not archived yet!",0);
                        tokyk=100;
                        break ;
                    }
                    fidimundo_call(0,0);
                    dx=0;
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                dx=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                dx=1;
                                break ;
                        }
                    }
                    if (dx) break ;
                    tokyk=100; 
                    
                    diax_dec=0;prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    if (rl && user_opts){
                        
                        if (keyb_gr) {
                            sprintf(str1024,"%s%u%s" ,"Θα διαγραφούν ", tot_opts , " επιλεγμένες κάρτες !!");
                            user_ans=alert(50-keyb_gr,str1024,0);
                            if (user_ans != 1) break ;}
                        else {
                            sprintf(str1024,"%u%s" ,tot_opts , " selected cards will be deleted !!");
                            user_ans=alert(50-keyb_gr,str1024,0);
                            if (user_ans != 1) break;}
                            
                            sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                            fpera=fopen(str1024,"r+b");
                            if (fpera==NULL) {information(6-keyb_gr,str1024,NULL); break ;}
                            fide_fpera = fileno (fpera) ;
                            
                            if (seflag) {
                                seflag=0;
                                for (f=0 ; f<dbplgr ; f++) crits[f]=0;
                                gocards=0;  firstcrit=0;
                            }

                            a=0 ; cur = tot_opts ; f1=0 ;
                            fseek(fpera,( (dbplera+1)*2 ),0) ; 
                            
                            do {
                                p=0; i=epil_pos[f1];
                                for (f=0 ; f<dbplgr ; f++) {
                                    if (i==ar_dom[f]) {p=1; break ;}
                                }
                                if (!p) {f1++; cur--; continue;}
                                i=f;
                                fwrite(&ar_dom[f],2,1,fpera); // Γράφεται η θέση της κάρτας στοιχείων που δεν θα φαίνεται πλέον !
                                fdatasync (fide_fpera);
                                if (ferror(fpera)) { information(2-keyb_gr,str1024,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera); fpera=NULL; a=1; break; }
                                dbplera++; dbplgr--; cur--; f1++ ;
                                for (f=i ; f<dbplgr ; f++) {
                                    ar_dom[f]=ar_dom[f+1]; // Αναταξινόμηση δεικτών
                                }
                            } while ( cur );
                        if (a) break ;
                        rewind(fpera);
                        fwrite (&dbplera,2,1,fpera);
                        fdatasync (fide_fpera);
                        mem3=epil_pos; free(mem3); epil_pos=mem3=0; tot_opts=0;
                        user_opts=0; 
                        goto FIN_DELETION ;
                    }
                    
                    if (seflag==2) {
                        if (keyb_gr) {
                            sprintf(str1024,"%s%u%s" ,"Θα διαγραφούν ", gocards , " κάρτες !!");
                            user_ans=alert(50-keyb_gr,str1024,0);
                            if (user_ans != 1) break ;}
                        else {
                            sprintf(str1024,"%u%s" ,gocards , " cards will be deleted !!");
                            user_ans=alert(50-keyb_gr,str1024,0);
                            if (user_ans != 1) break;}}
                            
                    else {
                        if (keyb_gr) {
                            sprintf(str1024,"%s%u%s" ,"Θα διαγραφεί η κάρτα Νο ", dbcard, " !");
                            user_ans=alert(26-keyb_gr,str1024,0);
                            if (user_ans != 1) break;}
                        else {
                            sprintf(str1024,"%s%u%s" ,"The card No ", dbcard, " will be deleted !");
                            user_ans=alert(26-keyb_gr,str1024,0);
                            if (user_ans != 1) break;}}

                    sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                    fpera=fopen(str1024,"r+b");
                    if (fpera==NULL) {information(6-keyb_gr,str1024,NULL); break ;}
                    fide_fpera = fileno (fpera) ;

                    // Μαζική Διαγραφή βάσει κριτηρίων
                    if (seflag==2) { 
                        i=firstcrit; a=0;
                        fseek(fpera,( (dbplera+1)*2 ),0) ; // Αν π.χ. dbplera ήταν 4 (έχει ήδη 4 θέσεις διαγραφής) πηδάει 10 bytes για να γράψει την επόμενη. Αν ήταν 0 , πηδάει τα 2 πρώτα bytes...
                        do {
                            if (!crits[i]) { i++; continue ;}
                            cur=ar_dom[i] ;
                            fwrite(&ar_dom[i],2,1,fpera); // Γράφεται η θέση της κάρτας στοιχείων που δεν θα φαίνεται πλέον !
                            fdatasync (fide_fpera);
                            if (ferror(fpera)) { information(2-keyb_gr,str1024,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera); fpera=NULL; a=1; break; }
                            dbplera++; dbplgr--; gocards--;
                            for (f=i ; f<dbplgr ; f++) {
                                ar_dom[f]=ar_dom[f+1]; // Αναταξινόμηση δεικτών
                                crits[f]=crits[f+1];
                            }
                            if (epil_pos) {
                                f1=0;
                                for (f=0 ; f<tot_opts ; f++) {
                                    if (cur == epil_pos [f]) {f1=1; break ;}
                                }
                                if (f1) {
                                    f1=f;
                                    tot_opts--;
                                    if (!tot_opts) {user_opts=0; mem3=epil_pos; free(mem3); epil_pos=mem3=0;}
                                    else {
                                        for (f=f1 ; f<tot_opts ; f++) {epil_pos[f]=epil_pos[f+1];}
                                    }
                                }
                            }
                        }while ( (i<dbplgr) && (gocards) );
                    if (a) break ;
                    rewind(fpera);
                    fwrite (&dbplera,2,1,fpera);
                    fdatasync (fide_fpera) ;
                    }
                    // Μεμονωμένη Διαγραφή 
                    else {
                        dbplera++;
                        fwrite (&dbplera,2,1,fpera);
                        fdatasync (fide_fpera);
                        fseek(fpera,((dbplera-1)*2),1); // Αν π.χ. dbplera έγινε 4 (έχει ήδη 3 θέσεις διαγραφής) πηδάει (4-1)*2 = 6 bytes (ακόμη) για να γράψει την επόμενη.
                        cur = ar_dom[dbcard-1];
                        fwrite(&ar_dom[dbcard-1],2,1,fpera); // Γράφεται η θέση της κάρτας στοιχείων που δεν θα φαίνεται πλέον (σαν να διαγράφεται).
                        fdatasync (fide_fpera);
                        if (ferror(fpera)) { information(2-keyb_gr,str1024,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera); fpera=NULL; break; }
                        dbplgr--;
                        if (dbplgr) {
                            for (f=dbcard-1 ; f<dbplgr ; f++) {
                                ar_dom[f]=ar_dom[f+1]; // Αναταξινόμηση δεικτών
                            }
                        }
                        
                        if (epil_pos) {
                            f1=0;
                            for (f=0 ; f<tot_opts ; f++) {
                                if (cur == epil_pos [f]) {f1=1; break ;}
                            }
                            if (f1) {
                                f1=f;
                                tot_opts--;
                                if (!tot_opts) {
                                    mem3=epil_pos; free(mem3); epil_pos=mem3=0;
                                    user_opts=0; 
                                }
                                else {
                                    for (f=f1 ; f<tot_opts ; f++) {epil_pos[f]=epil_pos[f+1];}
                                }
                            }
                        }
                    }
                    
FIN_DELETION :

                    if (!dbplgr) {
                         if(epil_pos) {mem3=epil_pos; free(mem3); epil_pos=mem3=0; tot_opts=0;user_opts=0;dbcard_opt=0;}
                        dbplera=0 ; 
                        fclose(fpera); fclose(fpdom); fclose(fpcard);
                        sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); // Αρχείο Καρτελλών
                        fpcard=fopen(str1024,"wb");
                        if (fpcard==NULL) {information(6-keyb_gr,str1024,0); wasopca=0; break ;}
                        fide_fpcard = fileno (fpcard) ;
                        fwrite (&dbplgr,2,1,fpcard);
                        fsync(fide_fpcard);
                        fclose(fpcard); fpcard=NULL; wasopca=0 ;

                        sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); // Αρχείο Δεικτών σειράς Ταξινόμησης
                        fpdom=fopen(str1024,"wb");
                        if (fpdom==NULL) {information(6-keyb_gr,str1024,0); wasopdo=0 ; break ;}
                        fide_fpdom = fileno (fpdom) ;
                        fwrite (&dbplgr,2,1,fpdom);
                        fsync(fide_fpdom);
                        fclose(fpdom); fpdom=NULL; wasopdo=0 ;                  

                        sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                        fpera=fopen(str1024,"wb");
                        if (fpera==NULL) {information(6-keyb_gr,str1024,0); break ;}
                        fide_fpera = fileno (fpera) ;
                        fwrite (&dbplera,2,1,fpera);
                        fdatasync (fide_fpera);
                        
                        mmed[9]=mmed[10]=mmed[4]=mmed[12]=mmed[13]=mmed[14]=mmed[16]=1;
                        for (f=0;f<=dbfinum;f++) {
                            if (memk[f]) { free (memk[f]) ; memk[f]=0; }
                            if (memcp[f]) { free (memcp[f]) ; memcp[f]=0; }
                            if (multicr[f]) { mem1=multicr[f]; free (mem1) ;  multicr[f]=0 ; }
                            }
                        mem1=0; xmemk=0; xlim=0;
                        }
                        
                    fsync(fide_fpera);
                    fclose(fpera) ; fpera=NULL;
                    // Καταγραφή των ενημερωμένων δεικτών στο δίσκο !
                    if (dbplgr) {
                        rewind(fpdom);
                        fwrite(ar_dom,2,dbplgr,fpdom);
                        fdatasync (fide_fpdom);
                        if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                    }
                    fseek(fpdb,62,0);
                    fwrite (&dbplgr,2,1,fpdb); 
                    fdatasync (fide_fpdb);
                    if (ferror(fpdb)) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb);rewind(fpdb);}
                    bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                    if (seflag) seflag=0; 
                    
                    goto SORTCL_FYGE_1 ;
                    break;

                case 14:        // Εγγραφή καρτέλλας / ων στο δίσκο ως txt
                    if (mmed[14]) break ;
                    
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    tokyk=100; 
                    diax_dec=0; prodec=prodvn=-1;
                   fidimundo_call(0,0);
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    
                    if ( (user_opts) && (!rl) ) { // Σώνει την τρέχουσα κάρτα (Κατάσταση επιλογής χρήστη)

                        if (dbcard>dbplgr) {
                            if (keyb_gr) information (0,"Η καρτέλα δεν έχει ακόμη αρχειοθετηθεί!","Παρακαλώ αποθηκεύστε την αργότερα...");
                            else information(0,"This DB card has not archived yet!","Please save it later...");
                    break ;
                    }
                    
                    if (dbfinum>0){
                    
                        if (keyb_gr) user_ans=alert (0,"Θέλετε να συμπεριληφθούν όλα τα πεδία\nστην αναφορά που θα σωθεί στο δίσκο ;",0);
                        else user_ans=alert (0,"Do you want all the fields to be included\nin the report that will be saved in the disk ?",0);
                        if (!user_ans) {
                            if (keyb_gr) sprintf(str1024,"Πολλαπλή Επιλογή Πεδίων"); else sprintf(str1024,"DB Fields Multiselection");
                            normtext_tomy(str1024 , dbfds.fd_name);
                            mem4 = mulbutton_show(dbfds.mem_fd, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                            if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
                            normtext_tomy(str1024 , dbfds.fd_name);
                            if (!mem4) break;
                            eplfi=mem4;
                        }
                        else if (user_ans==1) {
                            mem4=malloc(dbfinum+1);
                            if (!mem4) {information (2-keyb_gr,0,0); break;}
                            eplfi=mem4;
                            for (f=0 ; f<=dbfinum ; f++) eplfi[f]=1;
                        }
                        else break ;
                    }
                    else {
                        mem4=malloc(2);
                        if (!mem4) {information (2-keyb_gr,0,0); break;}
                        eplfi=mem4;
                        eplfi[0]=1;
                    }
                        
                        sprintf(str1024,"%s%s%u.txt",savedbpath,"DBcard_",dbcard);
                        fp=fopen(str1024,"w");
                        if (fp==NULL) {information (6-keyb_gr,str1024,0); free(mem4) ; mem4=0 ; break;}
                        fide_exp = fileno(fp);

                        if (keyb_gr) sprintf(str1024,"%s%u","Καρτέλα Νο " , dbcard) ;
                        else sprintf(str1024,"%s%u .","DB Card Νο " , dbcard) ;
                        fprintf (fp,"%s\n",str1024);
                        what_mytime (cardwhen, str1024);
                        if (keyb_gr) fprintf (fp,"%s%s\n","Δημιουργήθηκε .. " , str1024);
                        else fprintf (fp,"%s%s\n","Created .. " , str1024);
                        for (f=0 ; f<=dbfinum ; f++) {
                            if (!eplfi[f]) continue ;
                            mytext_tonorm (ptr_pedio[f]->finame , str1024 , 64);
                            fprintf (fp,"%s : ",str1024);
                            keimk=memk[f];
                            if (ptr_pedio[f]->fivar[2] || ptr_pedio[f]->ficode || keimk[0]==255) { fprintf (fp,"\n"); continue ; }
                            if (ptr_pedio[f]->fitype==5) { fprintf (fp,"%s\n",keimk); continue ; }
                            mem1=malloc((2*xlimk[f])+2);
                            if (!mem1) {information (2-keyb_gr,0,0); break;}
                            ptr_char=mem1;
                            mytext_tonorm (keimk , ptr_char , 2*xlimk[f]);
                            fprintf (fp,"%s\n",ptr_char);
                            free(mem1); mem1=0;
                        }
                        fprintf (fp,"\n");
                        fsync(fide_exp);
                        fclose (fp); fp=NULL;
                        sprintf(str1024,"%s%s%u.txt",savedbpath,"DBcard_",dbcard);
                        if (keyb_gr) information (0,"Η καρτέλα σώθηκε!",str1024);
                        else information (0,"DB card saved !",str1024);
                        free(mem4) ; mem4=0 ;
                        break ;
                    }

                    if ( (user_opts) && (rl) ) { // Σώνει όλες τις επιλεγμένες από το χρήστη κάρτες.
                        
                        if (dbfinum>0){
                        
                            if (keyb_gr) user_ans=alert (0,"Θέλετε να συμπεριληφθούν όλα τα πεδία\nστην αναφορά που θα σωθεί στο δίσκο ;",0);
                            else user_ans=alert (0,"Do you want all the fields to be included\nin the report that will be saved in the disk ?",0);
                            if (!user_ans) {
                                if (keyb_gr) sprintf(str1024,"Πολλαπλή Επιλογή Πεδίων"); else sprintf(str1024,"DB Fields Multiselection");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                mem4 = mulbutton_show(dbfds.mem_fd, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                if (!mem4) break;
                                eplfi=mem4;
                            }
                            else if (user_ans==1) {
                                mem4=malloc(dbfinum+1);
                                if (!mem4) {information (2-keyb_gr,0,0); break;}
                                eplfi=mem4;
                                for (f=0 ; f<=dbfinum ; f++) eplfi[f]=1;
                            }
                            else break ;
                        }
                        else {
                            mem4=malloc(2);
                            if (!mem4) {information (2-keyb_gr,0,0); break;}
                            eplfi=mem4;
                            eplfi[0]=1;
                        }
                        
                        if (dbcard>dbplgr) {
                             for (f=0 ; f<=dbfinum ; f++) {
                                keimk=memk[f];
                                ceimk=memcp[f];
                                 if (ptr_pedio[f]->fitype!=5) mystrcpy (ceimk,keimk);
                                 else { 
                                     if(keimk[0]!=255) strcpy (ceimk,keimk); 
                                    else ceimk[0]=255;
                                }
                            }
                        }

                        i = 0 ; 
                        ch1=0 ;
                        sprintf(str1024,"%s%u%s.txt",savedbpath,tot_opts,"DBCards");

                        fp=fopen(str1024,"w");
                        if (fp==NULL) {information (6-keyb_gr,str1024,0); free(mem4) ; mem4=0 ; break;}
                        fide_exp = fileno(fp);
                        phm=tot_opts;
                        if (keyb_gr) strcpy (str1024 , "Εξαγωγή Δεδομένων Βάσης ..");
                        else strcpy (str1024 , "Export Data ..");
                        user_ans = proodos(  str1024, i, phm ,0) ;
                        do {
                            if (user_ans) { proodos(  0, i, phm ,0) ; }
                            p=epil_pos[i];
                            a=0;
                            for (f=0 ; f<dbplgr ; f++) {
                                if (p==ar_dom[f]) {a=1 ; break ;}
                            }
                            if (!a) { i++; continue; }
                            cur=f;
                            dx=fseek(fpcard,(p*dbcardsize),0);
                            if (dx) {proodos(  0, i, phm ,1) ; sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
                            if (keyb_gr) sprintf(str1024,"%s%u","Καρτέλα Νο " , cur+1) ;
                            else sprintf(str1024,"%s%u .","DB Card Νο " , cur+1) ;
                            fprintf (fp,"%s\n",str1024);
                            for (f=0 ; f<=dbfinum ; f++) {
                                fread(memk[f],1,xlimk[f],fpcard);
                            }
                            fread (&cardwhen,sizeof(time_t),1,fpcard);
                            what_mytime (cardwhen, str1024);
                            if (keyb_gr) fprintf (fp,"%s%s\n","Δημιουργήθηκε .. " , str1024);
                            else fprintf (fp,"%s%s\n","Created .. " , str1024);
                            
                            a=0;
                            for (f=0 ; f<=dbfinum ; f++) {
                                if (!eplfi[f]) continue ;
                                mytext_tonorm (ptr_pedio[f]->finame , str1024 , 64);
                                fprintf (fp,"%s : ",str1024);
                                keimk=memk[f];
                                if (ptr_pedio[f]->fivar[2] || ptr_pedio[f]->ficode || keimk[0]==255) { fprintf (fp,"\n"); continue ; }
                                if (ptr_pedio[f]->fitype==5) { fprintf (fp,"%s\n",keimk); continue ; }
                                mem1=malloc((2*xlimk[f])+2);
                                if (!mem1) { proodos(  0, i, phm ,1) ; information (2-keyb_gr,0,0); a=1 ; break;}
                                ptr_char=mem1;
                                mytext_tonorm (keimk , ptr_char , 2*xlimk[f]);
                                fprintf (fp,"%s\n",ptr_char);
                                free(mem1); mem1=0;
                            }
                            fprintf (fp,"\n"); 
                            if (a) break ;
                            i++; ch1++;
                        }while (i<tot_opts );
                        proodos(  0, i, phm ,1) ;
                        fsync(fide_exp);
                        fclose (fp); fp=NULL;
                        sprintf(str1024,"%s%u%s.txt",savedbpath,tot_opts,"DBCards");

                        if (ch1>1) {
                            if (keyb_gr) information (0,"Οι καρτέλες εξάχθηκαν!",str1024);
                            else information (0,"DB cards were exported !",str1024);}
                        else {
                            if (keyb_gr) information (0,"H καρτέλα εξάχθηκε!",str1024);
                            else information (0,"DB card was exported !",str1024);}
                            
                        free(mem4) ; mem4=0 ;

                        if (dbcard<=dbplgr) {
                        i=dbcard-1;
                        dx=fseek(fpcard,(ar_dom[i]*dbcardsize),0);
                        if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
                        for (f=0;f<=dbfinum;f++) {
                            fread (memk[f],1,xlimk[f],fpcard);
                            keimk=memk[f];
                            ceimk=memcp[f];
                            i=0;
                            if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                            else {
                                if(keimk[i]!=255) strcpy (ceimk,keimk); 
                                else ceimk[i]=255;
                            }
                        }
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                        }
                        
                        else {
                             for (f=0 ; f<=dbfinum ; f++) {
                                keimk=memk[f];
                                ceimk=memcp[f];
                                 if (ptr_pedio[f]->fitype!=5) { mystrcpy (keimk,ceimk); ceimk[0]=255; }
                                 else { 
                                     if(ceimk[0]!=255) { strcpy (keimk,ceimk);  ceimk[0]=255; }
                                    else keimk[0]=255;
                                }
                            }
                        }
                        
                        break;
                    }
                    
                    if (seflag!=2 && (!rl) ) { // Σώνει την τρέχουσα κάρτα
                        if (dbcard>dbplgr) {
                            if (keyb_gr) information (0,"Η καρτέλα δεν έχει ακόμη αρχειοθετηθεί!","Παρακαλώ αποθηκεύστε την αργότερα...");
                            else information(0,"This DB card has not archived yet!","Please save it later...");
                        break ;
                    }
                        //ch='\n'; cha='\0';
                        if (dbfinum>0){
                        
                            if (keyb_gr) user_ans=alert (0,"Θέλετε να συμπεριληφθούν όλα τα πεδία\nστην αναφορά που θα σωθεί στο δίσκο ;",0);
                            else user_ans=alert (0,"Do you want all the fields to be included\nin the report that will be saved in the disk ?",0);
                            if (!user_ans) {
                                if (keyb_gr) sprintf(str1024,"Πολλαπλή Επιλογή Πεδίων"); else sprintf(str1024,"DB Fields Multiselection");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                mem4 = mulbutton_show(dbfds.mem_fd, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                if (!mem4) break;
                                eplfi=mem4;
                            }
                            else if (user_ans==1) {
                                mem4=malloc(dbfinum+1);
                                if (!mem4) {information (2-keyb_gr,0,0); break;}
                                eplfi=mem4;
                                for (f=0 ; f<=dbfinum ; f++) eplfi[f]=1;
                            }
                            else break ;
                        }
                        else {
                            mem4=malloc(2);
                            if (!mem4) {information (2-keyb_gr,0,0); break;}
                            eplfi=mem4;
                            eplfi[0]=1;
                        }
                        
                        sprintf(str1024,"%s%s%u.txt",savedbpath,"DBcard_",dbcard);
                        fp=fopen(str1024,"w");
                        
                        if (fp==NULL) {information (6-keyb_gr,str1024,0); free(mem4); mem4=0; break;}
                        fide_exp = fileno(fp);
                        if (keyb_gr) sprintf(str1024,"%s%u","Καρτέλα Νο " , dbcard) ;
                        else sprintf(str1024,"%s%u .","DB Card Νο " , dbcard) ;
                        fprintf (fp,"%s\n",str1024);
                        what_mytime (cardwhen, str1024);
                        if (keyb_gr) fprintf (fp,"%s%s\n","Δημιουργήθηκε .. " , str1024);
                        else fprintf (fp,"%s%s\n","Created .. " , str1024);
                        for (f=0 ; f<=dbfinum ; f++) {
                            if (!eplfi[f]) continue ;
                            mytext_tonorm (ptr_pedio[f]->finame , str1024 , 64);
                            fprintf (fp,"%s : ",str1024);
                            keimk=memk[f];
                            if (ptr_pedio[f]->fivar[2] || ptr_pedio[f]->ficode || keimk[0]==255) { fprintf (fp,"\n"); continue ; }
                            if (ptr_pedio[f]->fitype==5) { fprintf (fp,"%s\n",keimk); continue ; }
                            mem1=malloc((2*xlimk[f])+2);
                            if (!mem1) {information (2-keyb_gr,0,0); break;}
                            ptr_char=mem1;
                            mytext_tonorm (keimk , ptr_char , 2*xlimk[f]);
                            //printf ("xlimkf = %u\n" , (2*xlimk[f]+1) );
                            fprintf (fp,"%s\n",ptr_char);
                            free(mem1); mem1=0;
                        }
                        fprintf (fp,"\n");
                        fsync(fide_exp);
                        fclose (fp); fp=NULL;
                        sprintf(str1024,"%s%s%u.txt",savedbpath,"DBcard_",dbcard);
                        if (keyb_gr) information (0,"Η καρτέλα σώθηκε!",str1024);
                        else information (0,"DB card saved !",str1024);
                        free(mem4); mem4=0;
                        break ;
                    }
                    else
                    {  // Σώνει είτε όλες τις κάρτες  - είτε εκείνες που συμφωνούν με κριτήρια εύρεσης / δεξιό - αριστερό κλικ
                        
                        if (dbfinum>0){
                        
                            if (keyb_gr) user_ans=alert (0,"Θέλετε να συμπεριληφθούν όλα τα πεδία\nστην αναφορά που θα σωθεί στο δίσκο ;",0);
                            else user_ans=alert (0,"Do you want all the fields to be included\nin the report that will be saved in the disk ?",0);
                            if (!user_ans) {
                                if (keyb_gr) sprintf(str1024,"Πολλαπλή Επιλογή Πεδίων"); else sprintf(str1024,"DB Fields Multiselection");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                mem4 = mulbutton_show(dbfds.mem_fd, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
                                normtext_tomy(str1024 , dbfds.fd_name);
                                if (!mem4) break;
                                eplfi=mem4;
                            }
                            else if (user_ans==1) {
                                mem4=malloc(dbfinum+1);
                                if (!mem4) {information (2-keyb_gr,0,0); break;}
                                eplfi=mem4;
                                for (f=0 ; f<=dbfinum ; f++) eplfi[f]=1;
                            }
                            else break ;
                        }
                        else {
                            mem4=malloc(2);
                            if (!mem4) {information (2-keyb_gr,0,0); break;}
                            eplfi=mem4;
                            eplfi[0]=1;
                        }
                        
                      i = (rl) ? 0 : firstcrit; 
                      a=0 ; ch1=0 ;
                      cur=gocards ;
                      pcur=0;
                      if (rl) { gocards=1; phm=dbplgr; }
                      else { phm=cur ; }
                      if (!rl) sprintf(str1024,"%s%u%s.txt",savedbpath,gocards,"DBCards");
                      else sprintf(str1024,"%s%u%s.txt",savedbpath,dbplgr,"DBCards");
                      fp=fopen(str1024,"w");
                      if (fp==NULL) {information (6-keyb_gr,str1024,0); free(mem4); mem4=0; break;}
                      if (keyb_gr) strcpy (str1024 , "Εξαγωγή Δεδομένων Βάσης ..");
                      else strcpy (str1024 , "Export Data ..");
                      user_ans = proodos(  str1024, pcur, phm ,0) ;
                      fide_exp = fileno(fp);
                      do {
                            if (!rl) { if (!crits[i]) { i++; continue ;} }
                            if (user_ans) { proodos(  0, pcur, phm ,0) ; pcur++; }
                            dx=fseek(fpcard,(ar_dom[i]*dbcardsize),0);
                            if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); proodos(  0, pcur, phm ,1) ; information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
                            if (keyb_gr) sprintf(str1024,"%s%u","Καρτέλα Νο " , i+1) ;
                            else sprintf(str1024,"%s%u .","DB Card Νο " , i+1) ;
                            fprintf (fp,"%s\n",str1024);
                            for (f=0 ; f<=dbfinum ; f++) {
                                fread(memk[f],1,xlimk[f],fpcard);
                            }
                            fread (&cardwhen,sizeof(time_t),1,fpcard);
                            what_mytime (cardwhen, str1024);
                            if (keyb_gr) fprintf (fp,"%s%s\n","Δημιουργήθηκε .. " , str1024);
                            else fprintf (fp,"%s%s\n","Created .. " , str1024);
                            
                            for (f=0 ; f<=dbfinum ; f++) {
                                if (!eplfi[f]) continue ;
                                mytext_tonorm (ptr_pedio[f]->finame , str1024 , 64);
                                fprintf (fp,"%s : ",str1024);
                                keimk=memk[f];
                                if (ptr_pedio[f]->fivar[2] || ptr_pedio[f]->ficode || keimk[0]==255) { fprintf (fp,"\n"); continue ; }
                                if (ptr_pedio[f]->fitype==5) { fprintf (fp,"%s\n",keimk); continue ; }
                                mem1=malloc((2*xlimk[f])+2);
                                if (!mem1) {proodos(  0, pcur, phm ,1) ; information (2-keyb_gr,0,0); a=1 ; break;}
                                ptr_char=mem1;
                                mytext_tonorm (keimk , ptr_char , 2*xlimk[f]);
                                fprintf (fp,"%s\n",ptr_char);
                                free(mem1); mem1=0;
                            }
                            fprintf (fp,"\n"); 
                            if (a) break ;
                            i++; ch1++;
                            if (!rl) gocards--;
                      }while ( (i<dbplgr) && (gocards) );
                      
                        proodos(  0, pcur, phm ,1) ; 
                        gocards=cur;
                        fsync(fide_exp);
                        fclose (fp); fp=NULL;
                        if (!rl) sprintf(str1024,"%s%u%s.txt",savedbpath,gocards,"DBCards");
                        else sprintf(str1024,"%s%u%s.txt",savedbpath,dbplgr,"DBCards");
                        if (ch1>1) {
                            if (keyb_gr) information (0,"Οι καρτέλες εξάχθηκαν!",str1024);
                            else information (0,"DB cards were exported !",str1024);}
                        else {
                            if (keyb_gr) information (0,"H καρτέλα εξάχθηκε!",str1024);
                            else information (0,"DB card was exproted !",str1024);}
                        }
                        free(mem4); mem4=0;
                        i=dbcard-1;
                        dx=fseek(fpcard,(ar_dom[i]*dbcardsize),0);
                        if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
                        for (f=0;f<=dbfinum;f++) {
                            fread (memk[f],1,xlimk[f],fpcard);
                            keimk=memk[f];
                            ceimk=memcp[f];
                            i=0;
                            if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                            else {
                                if(keimk[i]!=255) strcpy (ceimk,keimk); 
                                else ceimk[i]=255;
                            }
                        }
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                        break;
                    
                case 15:        // Εμφάνιση της τελευταίας φορτωμένης λίστας !
                    tokyk=100;
                    if ( mmed[15] || (dbmaxbut==-1) ) break ;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    f=dbmaxbut;
                    delon=0;
                    dbbut[f].butt_elem = button_show ( dbbut[f].mem_butt , dbbut[f].butt_data , dbbut[f].butt_ar , dbbut[f].butt_orio , dbbut[f].butt_name , &dbbut[f].butt_sorton , delon );
            
                    break;

                case 16:        // Multiple Field Show
                     if ( mmed[16] ) break ;
                     
                    for (f=0 ; f<=dbfinum ; f++) {    
                        keimk=memk[f];
                        ceimk=memcp[f];
                        
                        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                        else {
                            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                            else dx=1;
                        }
                        if (dx) {savenow=1 ; break ;}
                    }
                    if (savenow) {
                        if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                        switch (user_ans) {
                            
                            case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                                savenow=0;
                                break;
                                
                            case 1 : // ΣΩΣΕ ΤΩΡΑ
                                continue ;
                            
                            case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                                savenow=0;
                                tokyk=100;
                                continue ;
                        }
                    }
                    tokyk=100;
                    diax_dec=0; prodec=prodvn=-1;
                    sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                    normtext_tomy ( mmestr3c , mmestr[3]) ;
                   fidimundo_call(0,0);
                    dbcard1=dbcard ;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    
                    if (rl) {
                        
                            if (epil_pos && user_opts) {
                            // Διαγραφή ευρετηρίου προηγούμενης επιλογής !!
                            tot_opts=0; 
                            mem2=epil_pos; free(mem2); epil_pos=mem2=0;
                            user_opts=0;
                            bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                            break ;
                            }
                            else if (epil_pos && !user_opts) {
                                user_opts=1;
                                 if(seflag>=2) {seflag=1;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);mmed[10]=1;}
                                 cur = epil_pos[0]; i=0;
                                 for (f=0 ; f<dbplgr ; f++) {
                                     if (ar_dom[f]==cur) {i=1; dbcard=f+1; break ;}
                                }
                            if (!i) {mem2=epil_pos; free(mem2); epil_pos=mem2=0;tot_opts=0; user_opts=0;break;}
                            goto METAB_PROT ;
                            }
                    }
                    
                     if (dbfinum>=0 && posafoto<dbfinum+1) { 
                        if (keyb_gr) sprintf(str1024,"Πολλαπλή Επιλογή Πεδίων"); else sprintf(str1024,"DB Fields Multiselection");
                        normtext_tomy(str1024 , dbfds.fd_name);
                        mem1 = mulbutton_show(dbfds.mem_fd, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );}
                     else break ; 
                     if (keyb_gr) sprintf(str1024,"Επιλογή Πεδίου Δεδομένων"); else sprintf(str1024,"Select DB Field");
                     normtext_tomy(str1024 , dbfds.fd_name);
                     if (!mem1) break;
                     eplfi=mem1;
                     a=0;
                     for (f=0 ; f<=dbfinum ; f++) {
                           if ( (eplfi[f]) && (ptr_pedio[f]->fitype!=5) ) {
                                if (ptr_pedio[f]->fivar[2]) {
                                    mytext_tonorm (ptr_pedio[f]->finame , file_1,60);
                                    if (keyb_gr) sprintf (str1024, "Το πεδίο [%s] έχει απόκρυψη !\nΔεν θα συμπεριληφθεί !",file_1);
                                    else sprintf (str1024, "The field [%s] is hidden !\nIt will not be included !",file_1);
                                    information(0,str1024,0);
                                    eplfi[f]=0;
                                    continue;
                                }
                                if (ptr_pedio[f]->ficode) {
                                    mytext_tonorm (ptr_pedio[f]->finame , str1kb,60);
                                    str1024[0]=255;
                                    input_alert (40-keyb_gr,str1kb ,str1024,4);
                                    i=(int) convert_str(4 , str1024);
                                    if (ptr_pedio[f]->ficode != (short int) i ) {
                                        eplfi[f]=0;
                                        continue ;
                                    }
                                    else {
                                      if (keyb_gr) information(0,"Ο κωδικός είναι σωστός !",0);
                                      else information(0,"The password is ok !",0);
                                    }
                                }
                               a++;
                        }
                     }
                     if (!a) break;
                     
                     i=-1;
                     for (f=0 ; f<=dbfinum ; f++) {
                        if (eplfi[f] && f==dbkey) { i=f; break ;}
                        if ( (i==-1) && (eplfi[f]) && (ptr_pedio[f]->fitype!=5) ) i=f;
                        }
                       user_ans=3;
                       mytext_tonorm ( ptr_pedio[i]->finame , file_1 ,60 );                         
                       if (a>1) {
                           if (keyb_gr) {
                               sprintf (str1024,"Ως πεδίο βάσης (για ταξινόμηση - αναζήτηση), μπορεί να χρησιμοποιηθεί το  πεδίο:\n[%s] ." , file_1);
                               sprintf (str1kb,"Επιλέξτε κάποιο άλλο πεδίο δεδομένων ως πεδίο βάσης..");
                            }
                            else {
                                sprintf (str1024,"As the base field (for sorting and searching) you can use the field:\n [%s] ." , file_1);
                                sprintf (str1kb,"Select an other data field as the base field..");
                                
                            }
                           user_ans = choise_alert (str1024,str1kb,1) ; 
                        }
                        
                      if (!user_ans || user_ans<0) {if (mem1) free(mem1); mem1=0; break ;}
                      if (user_ans == 2 ) { dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 ); } 
                      else dy=-1;
                      if (dy>=0 && ptr_pedio[dy]->fitype!=5) i=dy;
                      
                      dx=0;
                      if (!eplfi[i]) {
                          a=0;
                          do {
                            if (ptr_pedio[i]->fivar[2]) {
                                mytext_tonorm (ptr_pedio[i]->finame , file_1,60);
                                if (keyb_gr) sprintf (str1024, "Το πεδίο [%s] έχει απόκρυψη !\nΔεν θα συμπεριληφθεί !",file_1);
                                else sprintf (str1024, "The field [%s] is hidden !\nIt will not be included !",file_1);
                                information(0,str1024,0);
                                a=1;
                            }
                            else if (ptr_pedio[i]->ficode) {
                                mytext_tonorm (ptr_pedio[i]->finame , str1kb,60);
                                str1024[0]=255;
                                input_alert (40-keyb_gr,str1kb, str1024 ,4);
                                f=(int) convert_str(4 , str1024);
                                if (ptr_pedio[i]->ficode != (short int) f ) {
                                    a=1 ;
                                }
                                else {
                                    a=0;
                                    if (keyb_gr) information(0,"Ο κωδικός είναι σωστός !",0);
                                    else information(0,"The password is ok !",0);
                                }
                            }
                            if (a)  {
                                dy = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                                if (dy>=0 && ptr_pedio[dy]->fitype!=5) { i=dy; if (!eplfi[i]) continue; else dx=1;}
                                else dx=2 ;
                            }
                            else dx=1; 
                        } while (!dx);
                    }
 
                      if (dx==2) {if (mem1) free(mem1); mem1=0; break ;}
                      eplfi[i]=1;
                      dx = info_dbfdata((short int) i , ar_dom) ; 
                      if (!dx) {free (mem1) ; mem1=0; break;}
                      if (keyb_gr) normtext_tomy ("Πολλαπλή Επιλογή" , dbfdata.fd_name);
                      else normtext_tomy ("Multiple Selection" , dbfdata.fd_name);
                      mulsel=1;
                      mem2=muldbfield_show_button(dbfdata.mem_fd, eplfi , dbfdata.fd_ar, dbfdata.fd_orio, dbfdata.fd_name, &dbfdata.fd_sorton , dbfdata.fd_sort_type , 1 , ar_dom, &mulsel);
                      free (mem1) ; mem1=0; 
                    if (!mem2) { 
                        if (!mulsel) break ; 
                        if(epil_pos) {mem3=epil_pos; free(mem3); epil_pos=mem3=0; tot_opts=0;}
                        if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        break ;
                    }
                    if(epil_pos) {mem3=epil_pos; free(mem3); epil_pos=mem3=0; tot_opts=0;}
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    percho=mem2; i=0;
                    for (f=0 ; f<dbplgr ; f++) {
                        if (percho[f]) i++;
                    }
                    tot_opts=i;
                    mem1=malloc(2*tot_opts);
                    if (!mem1) { 
                        information (2-keyb_gr,0,0) ;
                        break ;
                    }
                    epil_pos=mem1;
                    mem1=0;
                    i=0; metr=-1;
                    for(f=0 ; f<dbplgr ; f++) {
                        if (percho[f]) {
                            if (metr<0) metr=f;
                            epil_pos[i]=ar_dom[f];
                            i++;
                        }
                    }
                    user_opts=1;
                    mem2=percho;
                    free(mem2) ;
                    mem2=percho=0 ;
                    if(seflag>=2) {seflag=1;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);mmed[10]=1;}

// Μετάβαση στην 1η κάρτα !!
                    dbcard=(unsigned short int) (metr+1);
METAB_PROT :
                    fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                    for (f=0;f<=dbfinum;f++) {
                        fread (memk[f] , 1, xlimk[f] , fpcard);
                        keimk=memk[f];
                        ceimk=memcp[f];
                        i=0;
                        if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                        else {
                            if(keimk[i]!=255) strcpy (ceimk,keimk); 
                            else ceimk[i]=255;
                        }
                    }
                    
                    if (dbcard1!=dbcard) {
                        for (f=0;f<=dbfinum;f++) {curk[f]=curk1[f]=0;}
                    }
                    
                    fread (&cardwhen,sizeof(time_t),1,fpcard);
                    if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                    dbdecor_show ();
                    dbrecs_show ();
                    _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                    sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                    _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                    _puticon (search_flagxt,topinfyt,mem_usersel,255);
                    refresh();
                    baserg=eisag; mmed[7]=2; big_t=2.0 ; gen_ergo=mmestr[7]; mmed[9]=0 ;mmed[3]=0; mmed[6]=1;
                    fidimundo_call(0,0);
                    break;
                    
                case 17:        // Inkualizer
                    tokyk=100;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    inkualizer (1,chxr , bkxr , slxr);
                    //inkualizer_spec(dbchxr , dbbkxr ,0,0);
                    //inkualizer_spec(dbchxr , dbbkxr ,1,1);
                    //inkualizer_spec(dbchxr , dbbkxr ,1,2);
                    break ;
                    
                case 18:        // Inqualizer Screen
                    tokyk=100;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    inkualizer (1,dbchxr , dbbkxr , dbslxr);
                    setrgbpalette(dbrecxr,dbchxr[0],dbchxr[1],dbchxr[2]);
                    setrgbpalette(dbscrxr,dbbkxr[0],dbbkxr[1],dbbkxr[2]);
                    setrgbpalette(dbselxr,dbslxr[0],dbslxr[1],dbslxr[2]);
                    // fseek 66
                    if (fpdb!=NULL) {
                        fseek(fpdb,66,0);
                        fwrite (dbchxr,4,3,fpdb);
                        fwrite (dbbkxr,4,3,fpdb);
                        fwrite (dbslxr,4,3,fpdb);
                        fdatasync (fide_fpdb);
                    }
                    dbdecor_show ();
                    dbrecs_show ();
                    // ΦΤΙΑΞΕ ΠΑΛΙ ΤΑ ΠΕΔΙΑ ΤΩΡΑ !!!
                    break;
                    
                case 19:        // INPUT !!! - Για Σημειώσεις...
                    tokyk=100;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    //bkxr[0]=87;bkxr[1]=200;bkxr[2]=0;
                    //chxr[0]=0;chxr[1]=0;chxr[2]=166;
                    //slxr[0]=69;slxr[1]=224;slxr[2]=237;
                    whouv=gouv;
                    bkxr[0]=31;bkxr[1]=14;bkxr[2]=95;
                    chxr[0]=60;chxr[1]=170;chxr[2]=101;
                    slxr[0]=72;slxr[1]=0;slxr[2]=157;
                    gouv=myfont[4];
                    
                    if ( (wasopdb) && (fpdb!=NULL) ) {
                        
                        fclose (fpdb);
                        fpdb=NULL;
                    }
                    
                    if ( (wasopca) && (fpcard!=NULL) ) {
                        
                        fclose (fpcard);
                        fpcard=NULL;
                    }
                    
                    if ( (wasopdo) && (fpdom!=NULL) ) {
                        
                        fclose (fpdom);
                        fpdom=NULL;
                    }                    
                    
                    
                    SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
                    metr=input(4, notes_str, &inpx, &inpy, &inpx1, &inpy1, 59999, -1);
                    while (metr==-10) metr=input(4,notes_str, &inpx, &inpy, &inpx1, &inpy1, 59999 , -1);
                    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
                    
                    
                        strcpy (file_1,path_name);
                        strcat (file_1,"draftnotes.dat");
                        fp=fopen(file_1,"wb");
                        if (fp!=NULL) {
                            fide_notes = fileno (fp) ;
                            i=0;
                            while (notes_str[i]!=255 && i<59999) i++;
                            notes_str[i]=255;
                            fwrite (notes_str,1,i+1,fp);
                            fsync(fide_notes);
                            fclose(fp);
                            fp=NULL;
                        }
                    
                    for (f=0;f<3;f++) {
                        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
                    }
                    gouv=whouv;
                    
                    if ( (wasopdb) && (fpdb==NULL) ) {
                        fpdb=fopen(LDdbfile,"r+b");
                        if (fpdb==NULL) {information (6-keyb_gr,LDdbfile,"Please .. Quit Now !!");}
                        else { fide_fpdb = fileno (fpdb); }
                    }
                    
                    if ( (wasopca) && (fpcard==NULL) ) {
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please .. Quit Now !!");}
                        else { fide_fpcard = fileno (fpcard); }
                    }
                    
                    if ( (wasopdo) && (fpdom==NULL) ) {
                        fpdom=fopen(Strdomfp,"r+b");
                        if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,"Please .. Quit Now !!");}
                        else { fide_fpdom = fileno (fpdom); } 
                    } 
                    
                break;
                
                case 20: // Δημιουργία Λίστας !
                    tokyk=100;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    if (rl){
                        if (keyb_gr) filehelp_show(4, "List_crGR.dat", "Λίστες Επιλογής", bmenuxt+(kyk%6)*80+80, bmenuyt+(kyk/6)*80, helpchxr , helpbkxr );
                        else filehelp_show(4, "List_crEN.dat", "Selection Lists", bmenuxt+(kyk%6)*80+80, bmenuyt+(kyk/6)*80, helpchxr , helpbkxr );
                        break ;
                    }
                    whouv=gouv;
                    bkxr[0]=0;bkxr[1]=0;bkxr[2]=0;
                    chxr[0]=40;chxr[1]=255;chxr[2]=229;
                    slxr[0]=0;slxr[1]=76;slxr[2]=0;
                    gouv=myfont[4];
                    mem1=malloc(60002);
                    if (!mem1) {information (2-keyb_gr,0,0); goto fyge20;}
                    list_str=mem1;
                    list_str[0]=255;
                    
                    if ( (wasopdb) && (fpdb!=NULL) ) {
                        //fsync (fide_fpdb);
                        fclose (fpdb);
                        fpdb=NULL;
                    }
                    
                    if ( (wasopca) && (fpcard!=NULL) ) {
                        //fsync (fide_fpcard);
                        fclose (fpcard);
                        fpcard=NULL;
                    }
                    
                    if ( (wasopdo) && (fpdom!=NULL) ) {
                        //fsync (fide_fpdom);
                        fclose (fpdom);
                        fpdom=NULL;
                    }                     
                    
                    SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
                    metr=input(4,list_str, &inpx, &inpy, &inpx1, &inpy1, 59998 , -2);
                    while (metr==-10) metr=input(4,list_str, &inpx, &inpy, &inpx1, &inpy1, 59998, -2 );
                    
                    if ( (wasopdb) && (fpdb==NULL) ) {
                        fpdb=fopen(LDdbfile,"r+b");
                        if (fpdb==NULL) {information (6-keyb_gr,LDdbfile,"Please .. Quit Now !!");}
                        else { fide_fpdb = fileno (fpdb); }
                    }
                    
                    if ( (wasopca) && (fpcard==NULL) ) {
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please .. Quit Now !!");}
                        else { fide_fpcard = fileno (fpcard); }
                    }
                    
                    if ( (wasopdo) && (fpdom==NULL) ) {
                        fpdom=fopen(Strdomfp,"r+b");
                        if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,"Please .. Quit Now !!");}
                        else { fide_fpdom = fileno (fpdom); } 
                    }                     
                    
                    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
                    what=list_str[0];
                    if (what==255) goto fyge20;
                    diaf1=0;
                    do{
                    str1024[0]=255;
                    if (keyb_gr) {
                    user_ans=input_alert (0,"Δώστε όνομα στο αρχείο (χωρίς κατάληξη). \nΘα σωθεί στο φάκελο.../Pedaba/Lists με κατάληξη (.inp)!", str1024 , 20);}
                    else {user_ans=input_alert (0,"Give a name for the file (without suffix).\nIt will be saved in the folder..../Pedaba/Lists as an (.inp) file!", str1024 , 20);}
                    
                    if (user_ans!=1) goto fyge20;

                        if (dbmaxbut>=0) {              // Έλεγχος μήπως είναι φορτωμένη κάποια λίστα με ίδιο όνομα !!
                            a=dbmaxbut+1;

                            i=0; f=0; a1=a; h=0;
                            // Μετράω μήκος του νέου ονόματος (i)  / m=i   - δεν περιλμβάνεται το 255 στο μήκος)
                            what=str1024[i];
                            while (what !=255 ) {what=str1024[++i];} 
                            m=i; i=0; 

                            // Γίνεται έλεγχος για ίδιο όνομα μέσα στο synolo....

                            while(a1) {
                                what=synolo_butstr[i];
                                f=0; w=m; h=0;
                                while(what!=255 && (w>0) ) {
                                    if (what==str1024[f++]) {h++; i++; w--; what=synolo_butstr[i];continue;}
                                    else break;}
                                    
                                    if (h==m && what==255) {
                                        if (keyb_gr) information(0,"Μία λίστα με το ίδιο όνομα είναι ήδη φορτω-μένη !","Δώστε ένα διαφορετικό όνομα για να συνεχί- σετε άμεσα\nή , διαγράψτε την ομώνυμη φορτωμένη λίστα και επανέλθετε.");
                                        else information(0,"A list with the same name is already loaded!","Give a different name to continue immediate- ly\nor, delete the  homonymous list  and  repeat the action."); 
                                        a1=11 ; break ;}
                                    else {while(what!=255) {what=synolo_butstr[++i];} what=synolo_butstr[++i];}
                                    a1--;
                                    }
                            if (a1!=11) diaf1=1; 
                            } 
                            else diaf1=1;
                            
                    }while (!diaf1);
                    
                        mytext_tonorm(str1024 , file_2 , 42);
                        ar=0;
                        while (what!=255) {what=list_str[++ar];}
                        sprintf(file_1,"%s%s%s%s",path_name,"Lists/",file_2,".inp");
                        fp=fopen(file_1,"wb");
                        if (fp==NULL) {goto fyge20;}
                        fide_rlist = fileno(fp) ;
                        fwrite (inp_pedaba,4,4,fp);
                        fwrite (&ar,2,1,fp);
                        fwrite (list_str, ar,1, fp);
                        if (ferror(fp)) {clearerr(fp); fclose(fp);fp=NULL; } else {fsync(fide_rlist); fclose(fp); fp=NULL;
                            if (keyb_gr) information(0,"Έτοιμη η λίστα σας !","Δοκιμάστε να τη φορτώσετε...");
                            else information(0,"Your list is ready !","Try to load it..");
                        }    
fyge20:
                    if (mem1) { free(mem1); mem1=0;}
                    for (f=0;f<3;f++) {
                        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
                    }
                    gouv=whouv;
                    break;
                    
                case 21: // Επιλογή Λίστας από ήδη φορτωμένες ή/και διαγραφή λίστας από μνήμη!!
                    tokyk=100;
                    if (mmed[21]) break;
                     baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    open_buts.butt_elem = button_show ( open_buts.mem_butt , open_buts.butt_data , open_buts.butt_ar , open_buts.butt_orio , open_buts.butt_name , &open_buts.butt_sorton , 1 );
                    
                    a1=open_buts.butt_elem;
                    if(a1<0) break ;                        // (kati<0) return - button_show
                    what=open_buts.butt_data[0];
                    if (what !=255) {                       // Επιλογή κάποιας λίστας (a1) για παρουσίαση !
                    dbbut[a1].butt_elem = button_show ( dbbut[a1].mem_butt , dbbut[a1].butt_data , dbbut[a1].butt_ar , dbbut[a1].butt_orio , dbbut[a1].butt_name , &dbbut[a1].butt_sorton , 0 );}
                    else {                                          // Επιλογή λίστας (a1) για διαγραφή από μνήμη !
                        
                        // Διαγραφή ονόματος της λίστας από το synolo_butstr και Αναδιάταξη του synolo_butstr

                        i=0; f=0;
                        
                        while (f<a1) {
                            what=synolo_butstr[i];
                            while (what!=255) {what=synolo_butstr[++i];}
                            i++; f++;
                        }
                        
                        f=i; // f = delete start
                        what=synolo_butstr[i];
                         
                        while (what!=255) {what=synolo_butstr[++i];} 
                        i++; // i = end of delete end + 1
                        what=synolo_butstr[i];
                        while (what!=254) {
                            synolo_butstr[f++] = what;
                            what = synolo_butstr[++i];
                        }
                        if (!f) {synolo_butstr[0]=255; synolo_butstr[1]=254;} else synolo_butstr[f]=254;
                        
                        // Υπολογισμός του νέου open_buts.butt_ar
                        f=0;
                        what=synolo_butstr[f];
                        while (what!=254) { what=synolo_butstr[++f]; }
                        open_buts.butt_ar=f;
                        
                        
                        free (dbbut[a1].mem_butt) ;
                        
                        // Αναδιάταξη στοιχείων δομών dbbut λόγω της διαγραφής !!!

                        for (f=a1 ; f<dbmaxbut ; f++) {
                            w=f+1;
                            dbbut[f].butt_orio = dbbut[w].butt_orio;
                            dbbut[f].butt_ar = dbbut[w].butt_ar;
                            for (i=0 ; i <128 ; i ++) {
                                dbbut[f].butt_name[i]=dbbut[w].butt_name[i];
                                dbbut[f].butt_data[i]=dbbut[w].butt_data[i];
                                }
                            dbbut[f].mem_butt = dbbut[w].mem_butt;
                            dbbut[f].butt_elem = dbbut[w].butt_elem;
                            dbbut[f].butt_sorton = dbbut[w].butt_sorton;
                            }
                            
                            // Now f=dbmaxbut !
                            dbbut[f].butt_orio = 50;
                            dbbut[f].butt_name[0]=255;
                            dbbut[f].butt_data[i]=255;
                            dbbut[f].mem_butt = 0;
                            dbbut[f].butt_sorton = 0;

                        dbmaxbut--;
                        if (dbmaxbut<0) { mmed[15]=mmed[21]=1; }

                    }
                    break;
                    
                case 22:   // Φόρτωση Νέας Λίστας !!
                    tokyk=100;
                    if (mmed[22]==2) break ;
                    baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, mmestr[kyk],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);refresh();
                    dbmaxbut++;
                    if (dbmaxbut==9) mmed[22]=2;
                    a=dbmaxbut;
                    dbbut[a].butt_orio=50;

                    dbbut[a].mem_butt = button_load(&dbbut[a].butt_orio, &dbbut[a].butt_ar, dbbut[a].butt_name);
                    if (!dbbut[a].mem_butt) { dbmaxbut--; break; }
                    
                    if (a) { // Έλεγχο για όνομα ήδη φορτωμένο.
                    i=0; f=0; a1=a; h=0;
                    // Μετράω μήκος του νέου ονόματος (i)  / m=i   - δεν περιλμβάνεται το 255 στο μήκος)
                    what=dbbut[a].butt_name[i];
                    while (what !=255 ) {what=dbbut[a].butt_name[++i];} 
                    m=i; i=0; 
                    
                    // Γίνεται έλεγχος για ίδιο όνομα μέσα στο synolo....
                    
                    while(a1) {
                        what=synolo_butstr[i];
                        f=0; w=m; h=0;
                        while(what!=255 && (w>0) ) {
                            if (what==dbbut[a].butt_name[f++]) {h++; i++; w--; what=synolo_butstr[i];continue;}
                            else break;}
                            
                            if (h==m && what==255) {
                                if (keyb_gr) information(0,"Η λίστα αυτή είναι ήδη φορτωμένη !",0);
                                else information(0,"This ready list is already loaded !",0);
                                free(dbbut[a].mem_butt) ; 
                                dbbut[a].mem_butt=0; dbbut[a].butt_orio=50; dbbut[a].butt_sorton=0; dbmaxbut-- ; a1=11 ; break ;}
                            else {
                                while(what!=255) {what=synolo_butstr[++i];} 
                                what=synolo_butstr[++i];
                            }
                            a1--;
                            }
                            if (a1==11) break ;
                        }
                    mmed[15]=0;
                    delon=0;
                    // Ενημέρωση του synolo_butstr , προσθέτω το νέο όνομα λίστας !
                    i=a;f=0;
                    while (i) {
                        what=synolo_butstr[f];
                        while(what!=255) {f++;what=synolo_butstr[f];}
                        f++; i--;
                    }
                    i=0;
                    what=dbbut[a].butt_name[i];
                    while (what!=255) {
                        synolo_butstr[f++]=what;
                        what=dbbut[a].butt_name[++i];
                    }
                    synolo_butstr[f]=255; synolo_butstr[f+1]=254;
                    open_buts.butt_ar=f+1;
                    mmed[21]=0; // Επιτρέπει την προβολή πίνακα με τις φορτωμένες λίστες για να διαλέγω ποια θέλω  !
                    dbbut[a].butt_elem = button_show ( dbbut[a].mem_butt , dbbut[a].butt_data , dbbut[a].butt_ar , dbbut[a].butt_orio , dbbut[a].butt_name , &dbbut[a].butt_sorton , delon );
                    break;
                    
                case 23:
                tokyk=100;
                
                default :
                continue;
                    
            } // TELOS switch kyk
            
            
            kyk=-1;
            piotop=topchxr;
             if (gen_ergo[0] != 255) 
                {  if (mmed[7]==2) baserg=eisag ;
                    else if ( (mmed[9]==2) || (mmed[10]==2) ) baserg=parous;
                    else if (mmed[3]==2) {
                        if (!diax_dec) {baserg=sxedom ;} 
                        else { baserg=etikbkxr; piotop=etikchxr; }
                    }
                    else if (dbplgr) { mmed[7]=2; baserg=eisag; big_t=2.0 ; gen_ergo=mmestr[7]; }
                    else baserg=klperg;
                    _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                    _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,piotop,baserg); } 
             
             else { _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,topbkxr); }
             
             refresh();
             
             if (mmed[7]==2 && gundo_sit) { eaninpundo(); }
             else if (mmed[3]==2) fidimundo_call(2,0);
                         
             if (alma==8) {alma=0; goto FLDSRCH ;}
            
        } // Telos MBUT

        else if ( proel!=-1 ) { // Κλίκ μέσα στο χώρο των στοιχείων έχοντας ένα στοιχείο επιλεγμένο
            
            a=0;
            setrgbcolor(dbtop); 
            for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
            if (mmed[3]==2) {
                do {
                    SDL_PollEvent(&sdlev);  
                    time(&metatime);
                    big_d=difftime(metatime,protime); 
                    if ( big_d >= big_t) {
                        i=db_elem[proel][0];
                        if (ptr_pedio[i]->ficode) {
                            mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                            str1024[0]=255;
                            input_alert (40-keyb_gr,str1kb, str1024 ,4);
                            f=(int) convert_str(4 , str1024);
                            if (ptr_pedio[i]->ficode != (short int) f ) {a=1; break;}}
                        if (db_elem[proel][1]) {
                            if (ptr_pedio[i]->fivar[1]) {a=1; break;}
                        }
                        else {
                            if (ptr_pedio[i]->fivar[5]) {a=1; break;}
                        }
                        
                        Cx1=dbx1[proel]; Cy1=dby1[proel]; 
                        Cx2=dbx2[proel]; Cy2=dby2[proel];   
                        f=change_dbpos(proel,mx1,my1,&Cx1,&Cy1,&Cx2,&Cy2);
                        if (f!=-1) {
                            i=db_elem[proel][0];
                            if(db_elem[proel][1]) {
                                ptr_pedio[i]->fixt=Cx1; ptr_pedio[i]->fiyt=Cy1;
                                ptr_pedio[i]->fiwid=Cx2-Cx1+1; ptr_pedio[i]->fihei=Cy2-Cy1+1;
                                }
                            else {
                                ptr_pedio[i]->filaxt=Cx1; ptr_pedio[i]->filayt=Cy1;
                                ptr_pedio[i]->filawid=Cx2-Cx1+1; ptr_pedio[i]->filahei=Cy2-Cy1+1;
                            }
                            fidimundo_call(1,proel);
                            dbx1[proel]=Cx1; dby1[proel]=Cy1; dbx2[proel]=Cx2 ; dby2[proel]=Cy2;
                            // dbpage_recs(1);
                            dx=(i*dbfisize)+104;
                            fseek(fpdb,dx,0);
                            fwrite (ptr_pedio[i],1,dbfisize,fpdb);
                            fdatasync (fide_fpdb);
                    
                        proel=-1;ektos=1;
                        dbdecor_show ();
                        dbrecs_show();
                        
                        }
                        ektos=1;
                        a=1; break;
                        }                      
                } while (sdlev.type !=SDL_MOUSEBUTTONUP);
                continue;
            }
            
            //  κλικ στα πεδια για εισαγωγή ή εμφάνιση
            if (!a) {
                
                if (mmed[7]==2) {
                
                fidimundo_call(0,0);
                if (!db_elem[proel][1]) continue ;
                putimage(ox1,oy1,mem_ouon,0); refresh();
                a1=proel; c=0;
                whouv=gouv;
                SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
                
                if ( (wasopdb) && (fpdb!=NULL) ) {
                    fsync (fide_fpdb);
                    fclose (fpdb);
                    fpdb=NULL;
                }
                
                if ( (wasopca) && (fpcard!=NULL) ) {
                    fsync (fide_fpcard);
                    fclose (fpcard);
                    fpcard=NULL;
                }
                
                if ( (wasopdo) && (fpdom!=NULL) ) {
                    fsync (fide_fpdom);
                    fclose (fpdom);
                    fpdom=NULL;
                } 
                
                
                do {
                    
                    
                    i=db_elem[proel][0];

                    if (ptr_pedio[i]->ficode) {
                        mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                        str1024[0]=255;
                        input_alert (40-keyb_gr,str1kb, str1024 ,4);
                        f=(int) convert_str(4 , str1024);
                        if (ptr_pedio[i]->ficode != (short int) f ) {c=0; break;}}
                    
                    
                    gouv=myfont[ptr_pedio[i]->fifont];
                    keimk=memk[i];
                    Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                    for (f=0;f<3;f++) {
                        chxr[f]=ptr_pedio[i]->fichxr[f];
                        bkxr[f]=ptr_pedio[i]->fibkxr[f];
                        slxr[f]=ptr_pedio[i]->fislxr[f];
                    }
                    switch (ptr_pedio[i]->fitype) {
                        case 0:
                            deimk=memcp[i];
                            
                            if (Cy2-Cy1+1 < 2*ptr_pedio[i]->fifo_hei + 2 ){
                            if (keyb_gr) show_help ("Πεδίο Κειμένου", dbx1[proel], dby2[proel]+2 , &hdhlpxt , &hdhlpyt) ;
                            else show_help ("Text Field", dbx1[proel], dby2[proel]+2 , &hdhlpxt , &hdhlpyt) ;
                            dx = new_text_input( i, keimk, Cx1+1, Cy1+1, Cx2-1, Cy2-1, (int) limk[i]-1 );
                            hide_help(hdhlpxt , hdhlpyt);
                            state=SDL_GetKeyboardState(NULL);
                            w = ( (state[SDL_SCANCODE_LSHIFT]) ) ? 1 : 0 ; 
                            }
                            else dx=-2;
                            if (dx==-2) {
                            if (keyb_gr) show_help_2 ("Πεδίο Κειμένου", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            else show_help_2 ("Text Field", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            
                            //_bareacls (xr+2,yt-1,xr+11,yb,dbbkxr);
                            bareacls (Cx2+2,Cy1,Cx2+11,Cy2-1,dbbkxr);
                            dx=new_input( (int) ptr_pedio[i]->fifont, keimk, &Cx1, &Cy1, &Cx2, &Cy2, (int) limk[i]-1 , (short int) i ,curk[i]);
                            while (dx==-10) dx=new_input( (int) ptr_pedio[i]->fifont, keimk, &Cx1, &Cy1, &Cx2, &Cy2, (int) limk[i]-1 , (short int) i ,0 );
                            state=SDL_GetKeyboardState(NULL);
                            w = ( (state[SDL_SCANCODE_LSHIFT]) ) ? 1 : 0 ; 
                            for (f=0;f<3;f++) {
                                chxr[f]=ptr_pedio[i]->fichxr[f];
                                bkxr[f]=ptr_pedio[i]->fibkxr[f];
                                slxr[f]=ptr_pedio[i]->fislxr[f];
                            }
                            
                            gouv=myfont[ptr_pedio[i]->fifont];
                            curk[i] = (dx>=0) ? (unsigned short int) dx : 0 ;
                            
                            _field_txt_show (i, keimk , curk[i] , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                            refresh();
                            hide_help_2(hdhlpxt_2 , hdhlpyt_2);
                            }
                            c= (dx==-9) ? 1 : 0 ;
                            curk1[i]=curk[i];
                            break;
                        
                        case 1:
                            if (mmed[15]) break;
                            if (keyb_gr) show_help_2 (" Πεδίο Κειμένου (Δυναμικές Λίστες) ", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            else show_help_2 (" Text Field (Ready Lists) ", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            open_buts.butt_elem = button_show ( open_buts.mem_butt , open_buts.butt_data , open_buts.butt_ar , open_buts.butt_orio , open_buts.butt_name , &open_buts.butt_sorton , 0 );
                            dx=open_buts.butt_elem;
                            if(dx<0) { hide_help_2(hdhlpxt_2 , hdhlpyt_2); break ; }                        // (kati<0) return - button_show
                            what=open_buts.butt_data[0];
                            if (what !=255) {                       // Επιλογή κάποιας λίστας (dx) για παρουσίαση !
                            dbbut[dx].butt_elem = button_show ( dbbut[dx].mem_butt , dbbut[dx].butt_data , dbbut[dx].butt_ar , dbbut[dx].butt_orio , dbbut[dx].butt_name , &dbbut[dx].butt_sorton , 0 );}
                            if (dbbut[dx].butt_elem>=0) {
                                mystrcpy_lim(keimk,dbbut[dx].butt_data,limk[i]-1);
                                //gouv=myfont[ptr_pedio[i]->fifont];
                                //_field_txt_show (i,keimk , 0 , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                            _bareacls (dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fibkxr);
                            _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                                refresh();
                            }
                            hide_help_2(hdhlpxt_2 , hdhlpyt_2);
                            break;
                            
                        case 2:
                            if (mmed[15]) break;
                            if (keyb_gr) show_help_2 (" Πεδίο Κειμένου (Δυναμική Λίστα) ", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            else show_help_2 (" Text Field (Ready List) ", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            dx=mypolystr(synolo_butstr,ptr_pedio[i]->filistname);
                            if (dx<0) { hide_help_2(hdhlpxt_2 , hdhlpyt_2);  break ;}
                            dbbut[dx].butt_elem = button_show ( dbbut[dx].mem_butt , dbbut[dx].butt_data , dbbut[dx].butt_ar , dbbut[dx].butt_orio , dbbut[dx].butt_name , &dbbut[dx].butt_sorton , 0 );
                            if (dbbut[dx].butt_elem>=0) {
                                mystrcpy_lim(keimk,dbbut[dx].butt_data,limk[i]-1);
                            _bareacls (dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fibkxr);
                            _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                                //gouv=myfont[ptr_pedio[i]->fifont];
                                //_field_txt_show (i,keimk , 0 , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                                refresh();
                            }
                            hide_help_2(hdhlpxt_2 , hdhlpyt_2); 
                            break;
                            
                        case 3:
                            if (!ptr_pedio[i]->mathtype) {
                                
                                if (keyb_gr) sprintf (str1kb,"Αριθμητικό πεδίο (Ακέραιος) F%u",i+1) ;
                                else sprintf (str1kb,"Numeric Field (Integer) F%u",i+1) ;
                                show_help(str1kb, dbx1[proel], dby2[proel]+2 , &hdhlpxt , &hdhlpyt) ;
                                bareacls (Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
                                dx=num_input(keimk, Cx1+1, Cy1+1, Cx2-1, Cy2-1, (int) limk[i]-1,2);
                                state=SDL_GetKeyboardState(NULL);
                                w = ( (state[SDL_SCANCODE_LSHIFT]) ) ? 1 : 0 ; 
                                hide_help(hdhlpxt , hdhlpyt); 
                                mystrcpy (file_3, keimk) ;
                                mynum_teleies (file_3 , ptr_pedio[i]->fitype );
                                _bareacls (Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
                                _outmystr_right_col(ptr_pedio[i]->fifont,file_3,Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                                refresh();
                                c= (dx==-9) ? 1 : 0 ;
                                ceimk=memcp[i];
                                if (! mystrcmp (ceimk,keimk) ) break ;
                                
                                    if (dpro>0) {
                                        for (f=0 ; f<enmath_1; f++) {
                                            i4=prot_calc[f];
                                            dfx = anal_parast (i4, alg_str[i4] , &alg_err , 0);
                                            check_orio_write_mathped(i4, ptr_pedio[i4]->fiorio, 1);
                                        
                                            for (dy=0;dy<dbar;dy++) {
                                                if (i4==db_elem[dy][0] && db_elem[dy][1]) {
                                                    _bareacls(dbx1[dy]+1,dby1[dy]+1,dbx2[dy]-1,dby2[dy]-1,ptr_pedio[i4]->fibkxr);
                                                    
                                                    if (!ptr_pedio[i4]->fivar[2]){
                                                    deimk=memk[i4];
                                                    if (deimk[0]==255) continue ;
                                                    mystrcpy (file_3, deimk) ;
                                                    mynum_teleies (file_3 , ptr_pedio[i4]->fitype );
                                                    _outmystr_right_col(ptr_pedio[i4]->fifont,file_3, dbx1[dy],dby1[dy],dbx2[dy],dby2[dy],ptr_pedio[i4]->fichxr, ptr_pedio[i4]->fibkxr);
                                                    
       
                                                    }
                                                }
                                            }
                                        }
                                        refresh();
                                    }
                            }
                            
                            break ;
                        
                        case 4:
                            if (!ptr_pedio[i]->mathtype){
                            
                            if (keyb_gr) sprintf (str1kb,"Αριθμητικό πεδίο (Δεκαδικός) F%u",i+1) ;
                            else sprintf (str1kb,"Numeric Field (Decimal) F%u",i+1) ;
                            show_help(str1kb, dbx1[proel], dby2[proel]+2 , &hdhlpxt , &hdhlpyt) ;
                            bareacls (Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
                            dx=num_input(keimk, Cx1+1, Cy1+1, Cx2-1, Cy2-1, (int) limk[i]-1,3); 
                            state=SDL_GetKeyboardState(NULL);
                            w = ( (state[SDL_SCANCODE_LSHIFT]) ) ? 1 : 0 ;
                            hide_help(hdhlpxt , hdhlpyt); 
                            mystrcpy (file_3, keimk) ;
                            mynum_teleies (file_3 , ptr_pedio[i]->fitype );
                            _bareacls (Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
                            _outmystr_right_col(ptr_pedio[i]->fifont,file_3,Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                            refresh();
                            c= (dx==-9) ? 1 : 0 ;
                            ceimk=memcp[i];
                            if (! mystrcmp (ceimk,keimk) ) break ;
                                
                                    if (dpro>0) {
                                        for (f=0 ; f<enmath_1; f++) {
                                            i4=prot_calc[f];
                                            dfx = anal_parast (i4, alg_str[i4] , &alg_err , 0);
                                            check_orio_write_mathped(i4, ptr_pedio[i4]->fiorio, 1);
                                        
                                            for (dy=0;dy<dbar;dy++) {
                                                if (i4==db_elem[dy][0] && db_elem[dy][1] ) {
                                                    _bareacls(dbx1[dy]+1,dby1[dy]+1,dbx2[dy]-1,dby2[dy]-1,ptr_pedio[i4]->fibkxr);
                                                    
                                                    if (!ptr_pedio[i4]->fivar[2]){
                                                    deimk=memk[i4];
                                                    if (deimk[0]==255) continue ;
                                                    mystrcpy (file_3, deimk) ;
                                                    mynum_teleies (file_3 , ptr_pedio[i4]->fitype );
                                                    _outmystr_right_col(ptr_pedio[i4]->fifont,file_3, dbx1[dy],dby1[dy],dbx2[dy],dby2[dy],ptr_pedio[i4]->fichxr, ptr_pedio[i4]->fibkxr);
                                                    

                                                    }
                                                }
                                            }
                                        }
                                        refresh();
                                    }
                                  
                            }
                            break;
                            
                        case 5 :
                                if (keyb_gr) show_help_2 ("Πεδίο Εικόνας", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                                else show_help_2 ("Image Field", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                                                       
                                if (keimk[0]!=255) {
                                    c=strlen(keimk);
                                    while (keimk[c] != '/') c-- ;
                                    for (f=0;f<=c;f++) photopath[f] = keimk[f];
                                    photopath[f]='\0';
                                }
                                else if (photopath[0]==255) {
                                    sprintf (photopath,"%s%s%s","/home/",user_name,"/");}
                                    
                            c=0;
                            if (keyb_gr) strcpy (file_1,"\"Eπιλέξτε Εικόνα (bmp)\"");
                            else strcpy (file_1,"\"Choose Image (bmp)\"");

                            sprintf(str1024,"zenity --file-selection --title=%s --filename=%s --file-filter='*.bmp' > %s%s",file_1,photopath, path_name,"zenity.txt");
                            system(str1024);
                            refresh();
                            sprintf (str1024,"%s%s",path_name,"zenity.txt");
                            fp = fopen(str1024,"r");
                            if (fp==NULL) {information (6-keyb_gr,str1024,0);  hide_help_2(hdhlpxt_2 , hdhlpyt_2); break;}
                            f=0;
                                do {
                                str1024[f]= (char) getc(fp);
                                f++;
                                }while ( (!feof(fp)) && (f<1000) );
                            fclose(fp);
                            if (f<3) {  hide_help_2(hdhlpxt_2 , hdhlpyt_2); break; }
                            f-=2; str1024[f]='\0';
                            c=strlen(str1024);
                            if ( !c || c>1000) {  hide_help_2(hdhlpxt_2 , hdhlpyt_2); break; }
                            ptr_char=strstr(str1024,".bmp");
                            if (!ptr_char) {
                                if (keyb_gr) information (0,"Πρέπει να είναι εικόνα τύπου .bmp","Προσπαθήστε πάλι..");
                                else information (0,"It must be a .bmp icon file!","Try again..");
                                hide_help_2(hdhlpxt_2 , hdhlpyt_2);
                                 break;}
                            strcpy(keimk,str1024);
                            f=c;
                            while (str1024[f] != '/') f-- ;
                            for (i=0;i<=f;i++) photopath[i] = str1024[i];
                            photopath[i]='\0';
                            readimagefile (keimk,Cx1+1, Cy1+1, Cx2-1, Cy2-1);
                            c=0;
                            i=db_elem[proel][0];
                            hide_help_2(hdhlpxt_2 , hdhlpyt_2);
                            break;
                            
                        case 6:
                            if (keyb_gr) show_help_2 ("Πεδίο Hμερομηνίας", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            else show_help_2 ("Date Field", dbx1[proel], dby2[proel]+2 , &hdhlpxt_2 , &hdhlpyt_2) ;
                            c=0;
                            ptr_ch=pedaba_calendar( (short int ) i );
                            if(!ptr_ch)  { hide_help_2(hdhlpxt_2 , hdhlpyt_2); break;}
                            
                            ptr_ch[24]=255;
                            mystrcpy (keimk,ptr_ch);
                            free ( (void *) ptr_ch ) ;
                            //normtext_tomy(str1024,keimk);
                            _bareacls (dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fibkxr);
                            _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                            //_field_txt_show (i,keimk , 0 , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                            refresh();
                            hide_help_2(hdhlpxt_2 , hdhlpyt_2);
                        } // Πέρας switch ..
                        
                        if (ptr_pedio[i]->fivar[2]) bareacls(Cx1+1, Cy1+1, Cx2-1, Cy2-1,ptr_pedio[i]->fibkxr);
                        
                        if (c)  { // Περίπτωση tab σε κάποια συνάρτηση input...
                            c=0;
                            if (w) {
                                
                                i=-1;
                                for (f=0 ; f<dbar ; f++) {
                                    if (proel==f) continue;
                                    if (!db_elem[f][1]) continue;
                                    cur=db_elem[f][0];
                                    if (ptr_pedio[cur]->ficode) continue;
                                    if (ptr_pedio[cur]->mathtype) continue ;
                                    if ( (ptr_pedio[cur]->fitype==1) ||  (ptr_pedio[cur]->fitype==2) ||  (ptr_pedio[cur]->fitype>=5) ) continue ;
                                    
                                    if (dby1[f] < dby1[proel]) {
                                        if (i==-1) {i=f; continue ;}
                                        if (dby1[i] > dby1[f]) continue ;
                                        else if (dby1[i] == dby1[f]) {
                                            if (dbx1[i] > dbx1[f]) continue ;
                                        }
                                        i=f; continue ;
                                    }
                                    else if (dby1[f] == dby1[proel]) {
                                        if (dbx1[f] > dbx1[proel]) continue ;
                                        if (i!=-1) {
                                            if (dby1[i] < dby1[f]) {i=f; continue ;}
                                            if (dbx1[i] < dbx1[f]) {i=f; continue ;}
                                        }
                                        else {i=f; continue ;}
                                        continue ;
                                    }
                                }
                                
                                if (i==-1) {
                                    my=0; 
                                    for (f=0 ; f<dbar; f++) {
                                        if (!db_elem[f][1]) continue;
                                        cur=db_elem[f][0];
                                        if (ptr_pedio[cur]->ficode) continue;
                                        if (ptr_pedio[cur]->mathtype) continue ;
                                        if ( (ptr_pedio[cur]->fitype==1) ||  (ptr_pedio[cur]->fitype==2) ||  (ptr_pedio[cur]->fitype>=5) ) continue ;
                                        if (dby1[f]>my) {my=dby1[f]; i=f;}
                                        else if (dby1[f]==my) {
                                            if (dbx1[i]>dbx1[f]) continue ;
                                            i=f;
                                        }
                                    }
                                }
                            }
                            else {
                                mx1=info.right; 
                                my1=info.bottom-info.top;
                                i=-1;
                                for (f=0 ; f<dbar ; f++) {
                                    if (proel==f) continue;
                                    if (!db_elem[f][1]) continue;
                                    cur=db_elem[f][0];
                                    if (ptr_pedio[cur]->ficode) continue;
                                    if (ptr_pedio[cur]->mathtype) continue ;
                                    if ( (ptr_pedio[cur]->fitype==1) ||  (ptr_pedio[cur]->fitype==2) ||  (ptr_pedio[cur]->fitype>=5) ) continue ;
                                    dy=dby1[f]- (unsigned short int) Cy1;
                                    if (dy<0) continue ;
                                    if ( (!dy) && (dbx1[f]<Cx1) )continue ;
                                    if (dy==my1) {
                                        if (mx1>dbx1[f]) {
                                            mx1=dbx1[f]; i=f;
                                        }
                                    }
                                    else if (dy<my1) {
                                        my1=dy;
                                        mx1=dbx1[f]; i=f;
                                    }
                                }
                                
                                if (i<0 ) {
                                    diaf1=info.bottom; mx1=info.right;
                                    for (f=0 ; f<dbar ; f++) {
                                        
                                        if (!db_elem[f][1]) continue;
                                        cur=db_elem[f][0];
                                        if (ptr_pedio[cur]->ficode) continue;
                                         if (ptr_pedio[cur]->mathtype) continue ;
                                        if ( (ptr_pedio[cur]->fitype==1) ||  (ptr_pedio[cur]->fitype==2) ||  (ptr_pedio[cur]->fitype>=5) ) continue ;
                                        if (diaf1>dby1[f]) { diaf1=dby1[f]; mx1=dbx1[f]; i=f; }
                                        else if (diaf1==dby1[f]) {
                                            if (mx1>dbx1[f]) {mx1=dbx1[f]; i=f;}
                                        }
                                    }
                                }
                            }
                            
                            if (i==proel) i=-1;
                            
                            if (i>=0) {
                                c=1;
                                f=dx=i;
                                cur=db_elem[f][0];
                                //setrgbcolor(dbwxr); rectangle (ox1, oy1, ox2 ,oy2) ; 
                                setrgbcolor(dbtop); if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0); refresh();}
                                for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
                                f=dx; 
                                //dbwxr = (ptr_pedio[cur]->fivar[0]) ? dbrecxr : dbscrxr ;

                                if (ptr_pedio[cur]->fivar[3]) {
                                    for (i=0;i<dbar;i++) {if (i==f) continue; if (db_elem[i][0]==cur) break;}
                                    getimage(dbx1[i]+1,dby1[i]+1,dbx1[i]+16,dby1[i]+16,mem_kato);
                                    _puticon(dbx1[i]+1,dby1[i]+1,mem_chain,255); i1=i;   
                                    }
                                    else i1=-1;
                                    
                                ox1=dbx1[f] ; oy1=dby1[f] ; ox2 = dbx2[f] ; oy2=dby2[f];
                                //setrgbcolor(dbmag);
                                //rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                                setrgbcolor(dbtop);
                                proel=f; 
                                refresh();
                            }
                        }
                    
                    } while (c) ;
                    
                    
                    if ( (wasopdb) && (fpdb==NULL) ) {
                        fpdb=fopen(LDdbfile,"r+b");
                        if (fpdb==NULL) {information (6-keyb_gr,LDdbfile,"Please .. Quit Now !!");}
                        else { fide_fpdb = fileno (fpdb); }
                    }
                    
                    if ( (wasopca) && (fpcard==NULL) ) {
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please .. Quit Now !!");}
                        else { fide_fpcard = fileno (fpcard); }
                    }
                    
                    if ( (wasopdo) && (fpdom==NULL) ) {
                        fpdom=fopen(Strdomfp,"r+b");
                        if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,"Please .. Quit Now !!");}
                        else { fide_fpdom = fileno (fpdom); } 
                    } 
                
                //if (proel != a1) {}
                SDL_EventState(SDL_DROPFILE, SDL_ENABLE);                
                gouv=whouv;
                for (f=0;f<3;f++) {
                    chxr[f]=chxr1[f];
                    bkxr[f]=bkxr1[f];
                    slxr[f]=slxr1[f];
                    }
                    if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0); refresh();}
                    proel=-1; ektos=1;
                    eaninpundo();
                    continue ;
                }
                
                else if (mmed[10]==2) { // Κλίκ κατά την παρουσίαση με ΚΡΙΤΗΡΙΑ εύρεσης !
                    
                    fidimundo_call(0,0);
                    if (!db_elem[proel][1]) continue ;
                    
                    i=db_elem[proel][0];
                    
                    if (ptr_pedio[i]->fivar[2]) {break;}
                    
                    keimk=memk[i];
                        
                    if (keimk[0]==255) { break;}

                    if (ptr_pedio[i]->ficode) {
                        mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                        str1024[0]=255;
                        input_alert (40-keyb_gr,str1kb, str1024 ,4);
                        f=(int) convert_str(4 , str1024);
                        if (ptr_pedio[i]->ficode != (short int) f ) { break;}}
                    
                    Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                   
                    if ( ptr_pedio[i]->fitype < 3 )  {
                        whouv=gouv;
                        gouv=myfont[ptr_pedio[i]->fifont];
                        if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0); }
                        putimage(ox1,oy1,mem_ouon,0); refresh();
                        
                        if (!multicr[i]->cron) {
                            if (!ptr_pedio[i]->fitype) {
                                curk[i] = field_txt_scroll(keimk , curk[i] , Cx1,Cy1,Cx2,Cy2, limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                                curk1[i] = curk[i];
                            }
                            else {
                                curk[i]=curk1[i]=0;
                                _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fibkxr); 
                                _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                                refresh();
                            }
                        }
                        else {
                            ptr_ch=convert_and_strstr( (short int) i , &how_many, &curk[i] );
                            if (ptr_ch) {
                            curk[i] = field_txt_scrollsearch ( (short int) i, curk[i] , Cx1 , Cy1 , Cx2 , Cy2 , limk[i]-1 , ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr, ptr_pedio[i]->fislxr);
                            free (multicr[i]->mem_ghost) ; multicr[i]->mem_ghost = 0 ;
                            curk1[i] = curk[i];
                            }
                            else {
                                if   (!ptr_pedio[i]->fitype) {curk[i] = field_txt_scroll(keimk , curk[i] , Cx1,Cy1,Cx2,Cy2, limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr ); curk1[i] = curk[i]; }
                                else {
                                    curk[i]=curk1[i]=0;
                                    _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fibkxr); 
                                    _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                                    refresh();
                                }
                            }
                        }
                        
                        ektos=1; gouv=whouv ;proel=-1;
                    }
                    continue; 
                }
                
                else if (mmed[9]==2) { // Κλίκ κατά την Απλή παρουσίαση - όχι κατά την εισαγωγή στοιχείων !
                
                fidimundo_call(0,0);
                if (!db_elem[proel][1]) continue ;
                
                
                i=db_elem[proel][0];
                
                if (ptr_pedio[i]->fivar[2]) {break;}
                
                if (ptr_pedio[i]->ficode) {
                    mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                    str1024[0]=255;
                    input_alert (40-keyb_gr,str1kb, str1024 ,4);
                    f=(int) convert_str(4 , str1024);
                    if (ptr_pedio[i]->ficode != (short int) f ) { break;}}
                    
                keimk=memk[i];
                if (keimk[0]==255) {break;}
                putimage(ox1,oy1,mem_ouon,0); refresh();
                whouv=gouv;
                gouv=myfont[ptr_pedio[i]->fifont];
                Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 

                if ( (ptr_pedio[i]->fitype <3)  && (multicr[i]->cron_1) ) {
                    
                        ptr_ch=convert_and_strstr( (short int) i , &how_many, &curk[i] );
                        if ( (ptr_ch) && (how_many) ) {
                        curk[i] = field_txt_scrollsearch ( (short int) i, curk[i] , Cx1 , Cy1 , Cx2 , Cy2 , limk[i]-1 , ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr, ptr_pedio[i]->fislxr);
                        free (multicr[i]->mem_ghost) ; multicr[i]->mem_ghost = 0 ; curk1[i] = curk[i];
                        }
                        else {
                                if   (!ptr_pedio[i]->fitype) {curk[i] = field_txt_scroll(keimk , curk[i] , Cx1,Cy1,Cx2,Cy2, limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr ); curk1[i] = curk[i]; }
                                else {
                                    curk[i]=curk1[i]=0;
                                    _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fibkxr); 
                                    _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                                    refresh();
                                }
                        }
                }                    

                else if (!ptr_pedio[i]->fitype)  {
                    curk[i] = field_txt_scroll(keimk , curk[i] , Cx1,Cy1,Cx2,Cy2, limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );  curk1[i] = curk[i]; 
                }
                
                else if (ptr_pedio[i]->fitype==1 || ptr_pedio[i]->fitype==2) {
                    curk[i]=curk1[i]=0;
                    _bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fibkxr); 
                    _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  Cx1+1,Cy1+1,Cx2-1,Cy2-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                    refresh();
                }
                if (i1>=0) { putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0); refresh();}
                ektos=1;
                gouv=whouv;proel=-1;
                continue;
            }
                
                continue;
            }
                
                continue ;
        }

        
        else if ( mmed[3]==2 && progvn!=-1 ) { // Ίσως εδώ να πρέπει να συμπεριληφθούν και οι ετικέτες (>100)
            
              // if (mmed[7]==2)   continue;
            
            
             i=db_elem[progvn][0];
             
            if (ptr_pedio[i]->ficode) {
                mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                str1024[0]=255;
                input_alert (40-keyb_gr,str1kb, str1024 ,4);
                f=(int) convert_str(4 , str1024);
                if (ptr_pedio[i]->ficode != (short int) f ) break;}
                
        if (db_elem[progvn][1]) {
            if (ptr_pedio[i]->fivar[1]) break;
        }
        else {
            if (ptr_pedio[i]->fivar[5]) break;
        }
            
            
          putimage(gx2-9,gy2-7,mem_progvn,0);
          refresh();
                    
            Cx1=dbx1[progvn]; Cy1=dby1[progvn]; 
            Cx2=dbx2[progvn]; Cy2=dby2[progvn];   
            f=change_dbdim(progvn, Cx1, Cy1 ,&Cx2 , &Cy2);
            if (f!=1) {
                
                i=db_elem[progvn][0];
                
                if(db_elem[progvn][1]) {
                    ptr_pedio[i]->fiwid=Cx2-Cx1+1; ptr_pedio[i]->fihei=Cy2-Cy1+1;
                    }
                else {
                    ptr_pedio[i]->filawid=Cx2-Cx1+1; ptr_pedio[i]->filahei=Cy2-Cy1+1;
                }
                fidimundo_call(1,progvn);
                dbx2[progvn]=Cx2 ; dby2[progvn]=Cy2;
                dx=(i*dbfisize)+104;
                fseek(fpdb,dx,0);
                fwrite (ptr_pedio[i],1,dbfisize,fpdb);
                fdatasync (fide_fpdb);
            dbdecor_show ();
            dbrecs_show();
            
            }
            progvn=-1;ektos=1;
            
            continue;
        }
        
        else if ( prodec!=-1  && mmed[3]==2) { // Κλίκ για αλλαγή θέσης ετικέτας
            
            setrgbcolor(dbtop); 
            for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}refresh();
            do {
            SDL_PollEvent(&sdlev);  
            
                time(&metatime);
                big_d=difftime(metatime,protime); 
                if ( big_d >= big_t) {
                    cur=dd_elem[prodec];
                    Cx1=dbdx1[prodec]; Cy1=dbdy1[prodec]; Cx2=dbdx2[prodec]; Cy2=dbdy2[prodec];   
                    dx=change_labpos(mx1,my1,&Cx1,&Cy1,&Cx2,&Cy2);
                    if (dx==1) {
                        
                        sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                        fpdec=fopen(str1024,"r+b");
                        if (fpdec==NULL) {information(6-keyb_gr,str1024,0); continue ;}
                        fide_fpdec = fileno (fpdec);
                        ptr_dec[cur].dext=Cx1; 
                        ptr_dec[cur].deyt=Cy1;
                        fidimundo_call(1,prodec);
                        dbdx1[prodec]=Cx1; dbdy1[prodec]=Cy1;
                        dbdx2[prodec]=Cx2 ; dbdy2[prodec]=Cy2;
                        fseek(fpdec , (cur*decorsize) ,0);
                        fwrite (&ptr_dec[cur] , decorsize, 1, fpdec);
                        fdatasync(fide_fpdec);
                        fsync(fide_fpdec);
                        fclose(fpdec);
                        prodec=-1;ektos=1;
                        dbdecor_show ();
                        dbrecs_show();
                    }
                            
                break;
                }                      
            } while (sdlev.type !=SDL_MOUSEBUTTONUP);
        }
        
        else if ( prodvn!=-1 && mmed[3]==2) { // ετικέτες prodvn
           
            cur=dd_elem[prodvn];
            putimage(gx2-9,gy2-7,mem_progvn,0);
            refresh();
                    
            Cx1=dbdx1[prodvn]; Cy1=dbdy1[prodvn]; Cx2=dbdx2[prodvn]; Cy2=dbdy2[prodvn];   
            dx=change_labdim(Cx1, Cy1 ,&Cx2 , &Cy2);
            if (dx==1) {

                sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                fpdec=fopen(str1024,"r+b");
                if (fpdec==NULL) {information(6-keyb_gr,str1024,0); continue ;}
                fide_fpdec = fileno (fpdec);
                ptr_dec[cur].dewid=Cx2-Cx1+1; 
                ptr_dec[cur].dehei=Cy2-Cy1+1;
                fidimundo_call(1,prodvn);
                dbdx2[prodvn]=Cx2 ; dbdy2[prodvn]=Cy2;
                fseek(fpdec , (cur*decorsize) ,0);
                fwrite (&ptr_dec[cur] , decorsize, 1, fpdec);
                fdatasync(fide_fpdec);
                fsync(fide_fpdec);
                fclose(fpdec);
                dbdecor_show ();
                dbrecs_show();
            }
            prodvn=-1;ektos=1;
            continue;
        }
        
        else if  (alter1_but && mmed[3]==2) {
            
                        alter1_but=0;
                        diax_dec=1-diax_dec ;
                        fidimundo_call(0,0);
                        if (!diax_dec) {
                            baserg=sxedom ;
                            sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                            normtext_tomy ( mmestr3c , mmestr[3]) ;
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, mmestr[3],topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                        }
                        else {
                            baserg=etikbkxr;
                            sprintf (mmestr3c , "%s - %s" , design_t , diaxetik);
                            normtext_tomy ( mmestr3c , mmestr[3]) ;
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,etikbkxr);
                            _outmystr_center_col (0, mmestr[3],topinfxt,topinfyt,topinfxb,topinfyt+18,etikchxr,etikbkxr);
                        }
                        refresh();
                        continue ;
            
        }
        
        else if (gundo_but && mmed[7]==2) {
            fields_undo();
            eaninpundo();
            continue ;
        }
        
        else if (fidim_but && mmed[3]==2 ) {
            fidimundo_call(3,0);
            continue ;
        }
        
        else if (fidim_redobut && mmed[3]==2 ) {
            fidimundo_call(4,0);
            continue ;
        }
        
        
        else if (dbpgup) {
DBPGUP:     
            
            if (dbcurpage==1) continue;
            proel=-1;
            dbcurpage--;
            if (memx1) {free(memx1); memx1=0;}
            if (memy1) {free(memy1); memy1=0;}
            if(memx2)  {free(memx2); memx2=0;}
            if(memy2)  {free(memy2); memy2=0;}
            
            dbrecs=0;
            _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
            sprintf(top_str,"%02d",dbcurpage);
            pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
            outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
            dbpage_decs();
            dbpage_recs(0);
            dbdecor_show ();
            dbrecs_show ();
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            continue;
        }
        
        else if (dbpgdn) {
DBPGDN:        

        if (dbcurpage==dbpg) continue;
        proel=-1;
        dbcurpage++;
        if (memx1) {free(memx1); memx1=0;}
        if (memy1) {free(memy1); memy1=0;}
        if(memx2)  {free(memx2); memx2=0;}
        if(memy2)  {free(memy2); memy2=0;}
   
        dbrecs=0;
        _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);
        sprintf(top_str,"%02d",dbcurpage);
        pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
        outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
        dbpage_decs();
        dbpage_recs(0);
        dbdecor_show ();
        dbrecs_show ();
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        continue;
        }
        
        else if (cardnewbut) {
MAKE_NEW_CARD:
           fidimundo_call(0,0);
            if (!dbplgr) break ;
            if (dbcard==dbplgr+1) break;
            rego=1;
            for (f=0 ; f<=dbfinum ; f++) {    
                keimk=memk[f];
                ceimk=memcp[f];
                
                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                else {
                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                    else dx=1;
                }
                if (dx) {savenow=1 ; break ;}
            }
            
            if (savenow) {
                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                switch (user_ans) {
                    
                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                        savenow=0;
                        break;
                        
                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                        continue ;
                    
                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                        savenow=0;
                        tokyk=100; rego=0;
                        continue ;
                }
            }
            tokyk=100; rego=0;
            
            
            if (dbcard>=65530) {
                if (keyb_gr) information (0,"Η χωρητικότητα της βάσης εξαντλείται.\nΔιαγράψτε καρτέλες, για να μπορείτε\nνα αποθηκεύσετε νέες!",0);
                else information (0,"The capacity of the data base is depleted.\nDelete cards, so you can save\nnew ones!",0);
            }
        
            if (dbplgr==65533) break ;
             dbcard = dbplgr+1 ;
             // H επόμενη καρτέλλα είναι νέα !!
                
                diax_dec=0;fidimundo_call(0,0);
                prodec=prodvn=-1;
                mmed[9]=mmed[3]=0;mmed[6]=1;
                sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                normtext_tomy ( mmestr3c , mmestr[3]) ;
                if (mmed[7]!=2) {
                mmed[7]=2; big_t=2.0 ;
                mmed[10]=1;if(seflag>=2) {seflag=1;_bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                baserg=eisag;
                gen_ergo=mmestr[7];
                _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                refresh();
                }
                else if (gundo_sit) {
                    gundo_sit=0; gundo_but=0;
                    bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
                }
                
                for (f=0;f<=dbfinum;f++) {
                keimk=memk[f]; keimk[0]=255;curk[f]=0; curk1[f]=0;
                ceimk=memcp[f]; ceimk[0]=255;
                    }

            if (dbcurpage!=1) {
            dbcurpage=1;
            if (memx1) {free(memx1); memx1=0;}
            if (memy1) {free(memy1); memy1=0;}
            if(memx2)  {free(memx2); memx2=0;}
            if(memy2)  {free(memy2); memy2=0;}
   
            dbrecs=0;
            dbpage_decs();
            dbpage_recs(0);
            }
            dbdecor_show ();
            dbrecs_show ();
            
            // _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
            _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
            _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
            sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
            sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
            pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
            _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
            _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
            refresh();
            
                 for (i=0 ; i<4 ; i++) {
                 puticon(cardnewxt,bmenuyt,mem_addcard,255);
                 for (f=0;f<150000;f++) continue;
                 putNOTicon(cardnewxt,bmenuyt,mem_addcard);
                 for (f=0;f<150000;f++) continue;   
                }
            
            continue;
            
        }
        
        else if (cardsabut) {
SVSE_TVRA : 
            
            if (!xmemk) continue;
            if (mmed[7]!=2) {
                if (keyb_gr) information(0,"Η εγγραφή καρτέλας στο δίσκο επιτρέπεται..\nμόνον σε κατάσταση εισαγωγής-επεξεργασίας !",0);
                else information(0,"Please select input-edit mode ..\nto be able for data card saving !",0);
                continue ;}
            if (gundo_sit) {
            gundo_sit=0; gundo_but=0;
            if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
            }
            a1=0;
            i=0;
            if (dbcard>dbplgr) { // Πρόκειται για νέα κάρτα
                if (dbplgr==65533) continue;
                a1=1; a=0;
                for (f=0;f<=dbfinum;f++) {
                    keimk=memk[f];
                    if (keimk[0]!=255) {a=1;break;}
                }
                if (!a) continue;
                if (dbplera) {
                sprintf(str1024,"%s%s",savedbpath,"era1.aba"); // Αρχείο Θέσεων Διαγραμμένων Δομών
                fpera=fopen(str1024,"r+b");
                if (fpera==NULL) {information(6-keyb_gr,str1024,NULL); break ;}
                fide_fpera = fileno (fpera) ;
                fseek(fpera,dbplera*2,0);
                fread(&thesi,2,1,fpera);
                dbplera--; i=1 ;
                rewind(fpera);
                fwrite(&dbplera,2,1,fpera);
                fsync (fide_fpera);
                if (ferror(fpera)) { information(2-keyb_gr,str1024,NULL); clearerr(fpera); fclose(fpera); fpera=NULL;}
                else {fclose(fpera); fpera=NULL;}
                }
                if (i) dx=fseek(fpcard,(thesi * dbcardsize),0);
                else dx=fseek(fpcard,(dbplgr * dbcardsize) ,0);
                if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
                dbplgr++;
                if (mmed[9]==1) mmed[9]=0;
                mmed[4]=mmed[12]=mmed[13]=mmed[14]=0 ;
                mmed[16]=0;
                mmed[6]=1;
                diax_dec=0;prodec=prodvn=-1;fidimundo_call(0,0);
                sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                normtext_tomy ( mmestr3c , mmestr[3]) ;
                dx=fseek(fpdb,62,0);
                fwrite (&dbplgr,2,1,fpdb);  
                fdatasync (fide_fpdb);
                if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);clearerr(fpdb); rewind(fpdb); goto SORTCL_FYGE_1;}
                if (ardom_mem) ardom_mem=realloc(ardom_mem,dbplgr*2);
                else ardom_mem=malloc(dbplgr*2);
                if (!ardom_mem) {information (2-keyb_gr,0,0); break; }
                ar_dom=ardom_mem;
                ar_dom[dbplgr-1]= (i) ? thesi : dbplgr-1;
                thesi = ar_dom[dbplgr-1] ;
            }
            
            else {  // Πρόκειται για κάρτα που υπήρχε και τροποποιήθηκε
                cur=thesi=ar_dom[dbcard-1];
                dx=fseek(fpcard,(cur*dbcardsize),0);
                if (dx) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); rewind (fpcard); break;}
            }
              
              // Εγγραφή Στοιχείων στο Δίσκο (σε κάθε περίπτωση - νέας ή παλιάς κάρτας πλην του cardwhen που δείχνει πότε ανοίχτηκε η κάρτα για πρώτη φορά) !!!
              
                for (f=0;f<=dbfinum;f++) {
                    fwrite(memk[f],1,xlimk[f],fpcard);
                    fdatasync (fide_fpcard);
                    keimk=memk[f];
                    ceimk=memcp[f];
                    i=0;
                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                    else {
                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                        else ceimk[i]=255;
                    }
                }
                
                if (a1) {
                    cardwhen=time(NULL);
                    fwrite(&cardwhen,sizeof(time_t),1,fpcard);
                    fdatasync (fide_fpcard);
                    if (dbplgr==1) {
                        for (f=0;f<=dbfinum;f++) {
                            if (ptr_pedio[f]->fitype!=5) {
                            multicr[f] = mem1= malloc ( sizeof (struct criterio) ) ; 
                            if (!multicr[f]) {information (2-keyb_gr,0,0) ; break ;}
                            else {multicr[f]->sample[0][0]=multicr[f]->sample[1][0]=multicr[f]->sample[2][0]=multicr[f]->sample_t[0]=multicr[f]->sample_tcode[0]=255; multicr[f]->cron=multicr[f]->cron_1=0; multicr[f]->mem_ghost=0;}
                            } 
                            else multicr[f]=0;
                        }
                        mem1=0;
                    }
                }
          
                 if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                
                // Ενημέρωση του array item και πιθανώς ΤΑΞΙΝΟΜΗΣΗ !!             

                    if (dbkey!=100) {
                        switch (ptr_pedio[dbkey]->fitype) {
                            
                            case 0 :
                            case 1 :
                            case 2 :
                                // cur=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                                if (!item_mem) item_mem=malloc(dbplgr*24);
                                else item_mem=realloc(item_mem,dbplgr*24);
                                if (!item_mem) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                item=item_mem;
                                
                                // Μετατροπή δείγματος από το sorting key field σε 24 bit item !
                                
                                cur=by=(ptr_pedio[dbkey]->fiorio > 24) ? 24 : ptr_pedio[dbkey]->fiorio;
                                keimk=memk[dbkey];
                                i=0;
                                what=keimk[i];
                                while ( (what!=255) && (by) ) { deigma[i]=what; by-- ; i++ ; what=keimk[i];}
                                deigma[i]=255;
                                
                                xitem[0].big=xitem[1].big=xitem[2].big=0;
                                i=0;by=23;
                                do {
                                    what=deigma[i];
                                    if (what>163) break;
                                    if (keyb_gr){
                                            switch (what) {

                                                case 96:
                                                case 101:
                                                case 104:
                                                case 107:
                                                case 116:
                                                case 122:
                                                case 129:
                                                case 132:
                                                case 137:
                                                case 140:
                                                case 143:
                                                case 151:
                                                case 157:
                                                case 163:
                                                what--;
                                                break;

                                                case 108:
                                                case 123:
                                                case 144:
                                                case 158:
                                                what-=2;
                                                break;


                                                case 109:
                                                case 124:
                                                what-=3;
                                                break;

                                                case 130:
                                                what=119;

                                            }

                                    }
                                rby=by%8; low=(2-(by/8));
                                xitem[low].sma[rby]=what;
                                by-- ; i++;
                                } while (by>=0);
                                
                                check_item.fg=xitem[0].big;
                                check_item.sg=xitem[1].big;
                                check_item.tg=xitem[2].big;

                                if (a1) { // Νέα καρτέλλα
                                
                                    item[dbplgr-1].fg=check_item.fg;
                                    item[dbplgr-1].sg=check_item.sg;
                                    item[dbplgr-1].tg=check_item.tg;
                                    
                                }
                                else
                                {              // Παλιά καρτέλλα
                                    
                                    cur=dbcard-1;
                                    if ( (check_item.fg==item[cur].fg) && (check_item.sg==item[cur].sg) && (check_item.tg==item[cur].tg) ) {
                                       goto SORT_FYGE ; } // Δεν χρειάζεται ταξινόμηση - δεν άλλαξε τίποτε στους 24 πρώτους χαρακτήρες !!
                                   
                                    item[cur].fg=check_item.fg;
                                    item[cur].sg=check_item.sg;
                                    item[cur].tg=check_item.tg;
                                    
                                }
                                
                                if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                
                                    pro_sort_24b(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                }
                                break ;
                                
                            // Αριθμός ως κλειδί !
                                
                            case 3: // Aκέραιος
                                if (!item_mem) item_mem=malloc(dbplgr*8);
                                else item_mem=realloc(item_mem,dbplgr*8);
                                if (!item_mem) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                Litem=item_mem;
                                
                                // Μετατροπή δείγματος !
                                
                                cur=limk[dbkey];
                                keimk=memk[dbkey];
                                lbig= (keimk[0]!=255) ? (long int) convert_str(cur , keimk) : 0 ;
                                
                                if (a1) { // Νέα καρτέλα
                                   Litem[dbplgr-1]=lbig; 
                                }
                                else {  // Παλιά καρτέλα 
                                    if (lbig==Litem[dbcard-1]) goto SORT_FYGE ;
                                    else Litem[dbcard-1]=lbig;
                                }
                                
                                 if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                
                                    pro_sort_signedlong(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                 }
                                break ;
                                
                            case 4:  // Δεκαδικός
                                if (!item_mem) item_mem=malloc(dbplgr*8);
                                else item_mem=realloc(item_mem,dbplgr*8);
                                if (!item_mem) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                Fitem=item_mem;
                                
                                // Μετατροπή δείγματος !
                                
                                cur=limk[dbkey];
                                keimk=memk[dbkey];
                                fbig= (keimk[0]!=255) ? (double) convert_str(cur , keimk) : 0 ;
                                
                                if (a1) { // Νέα καρτέλα
                                   Fitem[dbplgr-1]=fbig; 
                                }
                                else {  // Παλιά καρτέλα 
                                    if (fbig==Fitem[dbcard-1]) goto SORT_FYGE ;
                                    else Fitem[dbcard-1]=fbig;
                                }
                                
                                 if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                
                                    pro_sort_double(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                                 }
                                break;
                                
                            case 6:  // Date
                                
                                if (!item_mem) item_mem=malloc(dbplgr*4);
                                else item_mem=realloc(item_mem,dbplgr*4);
                                if (!item_mem) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                Gitem=item_mem;
                                
                                // Μετατροπή δείγματος !
                                
                                keimk=memk[dbkey];
                                cardiary.ldate=0;
                                
                                if (keimk[0]!=255) {
                                mytext_tonorm(keimk,str1024,50);
                                
                                // Μετατροπή Ημερομηνίας σε unsigned int (cardiary.ldate)
                                w=strlen(str1024);
                                for (i=0;i<4;i++) {
                                    nu[i]= (unsigned char) str1024[w-i-1] - '0' ;
                                }
                                
                                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                                //dysena.wotim -= 1900;
                                cardiary.mydate[3]=dysena.dyomikra[1];
                                cardiary.mydate[2]=dysena.dyomikra[0];

                                nu[0]= (unsigned char) str1024[w-6] - '0';
                                nu[1]= (unsigned char) str1024[w-7] - '0' ;
                                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                                nu[0]= (unsigned char) str1024[w-9] - '0' ;
                                nu[1]= (unsigned char) str1024[w-10] - '0' ;
                                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                
                                }
                              
                                  if (a1) { // Νέα καρτέλα
                                   Gitem[dbplgr-1]=cardiary.ldate; 
                                }
                                else {  // Παλιά καρτέλα 
                                    if (cardiary.ldate==Gitem[dbcard-1]) goto SORT_FYGE ;
                                    else Gitem[dbcard-1]=cardiary.ldate;
                                }
                              
                               if (dbplgr>1) {
                                    new_dom_vo = malloc (dbplgr*2);
                                    if (!new_dom_vo) {information (2-keyb_gr,0,0); goto SORT_FYGE; }
                                    new_dom=new_dom_vo;
                                    for (f=0 ; f<dbplgr ; f++) new_dom[f]=f;
                                
                                    pro_sort_uint(item_mem,new_dom,dbplgr);  // QUICK SORT !!!!!
                               }
                                break ;
                        }
                        
                        if (dbplgr==1) {
                       rewind (fpdom) ;
                       fwrite(&ar_dom[0],2,1,fpdom); 
                       fdatasync (fide_fpdom);
                       if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                       dbcard=1;
                        }
                        else {
                        // Αναδιάταξη των δεικτών ταξινόμησης και Save !
                        for (f=0;f<dbplgr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
                        ar_dom = new_dom;
                        free (ardom_mem);
                        ardom_mem=new_dom_vo;
                        new_dom_vo=0;
                        rewind(fpdom);
                        fwrite(ar_dom,2,dbplgr,fpdom);
                        fdatasync (fide_fpdom);
                        if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                        
                        // Αριθμός καρτέλας που προκύπτει μετά από ταξινόμηση !!
                        for (f=0;f<dbplgr;f++) {
                        if (ar_dom[f]==thesi) break ; } 
                        dbcard=f+1;
                        }
                    }
                    else {
                        if (a1) {
                            fseek(fpdom,(dbplgr-1)*2,0);
                            fwrite(&ar_dom[dbplgr-1],2,1,fpdom); 
                            fdatasync (fide_fpdom);
                            if (ferror(fpdom)) {sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpdom);}
                        }
                    }

SORT_FYGE:
                puticon(cardsaxt,bmenuyt,mem_savecard,255);
                for (i=0 ; i<4 ; i++) {
                    for (f=0;f<200000;f++) continue;
                    bareacls(cardsaxt,bmenuyt,cardsaxt+35,bmenuyt+17,topchxr);
                    for (f=0;f<200000;f++) continue;
                    putNOTicon(cardsaxt,bmenuyt,mem_savecard);
                    for (f=0;f<200000;f++) continue;   
                    bareacls(cardsaxt,bmenuyt,cardsaxt+35,bmenuyt+17,topbkxr);
                    for (f=0;f<200000;f++) continue;
                    puticon(cardsaxt,bmenuyt,mem_savecard,255);
                }
                _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                _bareacls(dbtotcardxt-1 , topinfyt+1, dbtotcardxb+1 , topinfyt+17,syncardbkxr);     // Συνολο Καρτελλών στη βάση
                sprintf(totcard_str,"%05u",dbplgr);  // Για σύνολο καρτελλών
                _outsouv_col(dbtotcardxt,topinfyt+1,totcard_str,0,syncardchxr,syncardbkxr);
                gen_ergo=mmestr[7];
                _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                refresh();
    if (tokyk!=100) { kyk=tokyk; goto PROS_EPILKYK; }
    switch (rego) {
        
        case 0: 
        continue ;
        
        case 1:
            rego=0;
            goto MAKE_NEW_CARD ;
            
        case 2 :
            rego=0;
            goto KARTEL_PIO_DEJIA ;
            
        case 3 :
            rego=0;
            goto KARTEL_PIO_ARISTERA ;
            
        case 4 :
            rego=0;
            goto PANE_SYGKEKR_KARTA ;
    }
    continue;
    
        }
        
        else if (cardribut) {
KARTEL_PIO_DEJIA :
            if (!dbplgr) break ;

            if ( (dbcard==dbplgr+1) && (!user_opts) ) break;
            rego=2;
            for (f=0 ; f<=dbfinum ; f++) {    
                keimk=memk[f];
                ceimk=memcp[f];
                
                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                else {
                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                    else dx=1;
                }
                if (dx) {savenow=1 ; break ;}
            }
            if (savenow) {
                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                switch (user_ans) {
                    
                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                        savenow=0;
                        break;
                        
                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                        continue ;
                    
                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                        savenow=0;
                        tokyk=100; rego=0;
                        continue ;
                }
            }
            tokyk=100;rego=0;
            
            if (gundo_sit) {
                gundo_sit=0; gundo_but=0;
                if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
            }
            
            if (user_opts) {
                cur = (dbcard>dbplgr) ? 1 : dbcard ;
                cur = ar_dom[cur-1];
                
                for (f=0 ; f<tot_opts ; f++) {
                    if (epil_pos[f]==cur) {f++; break; }
                }
                
                cur = (f<tot_opts) ? epil_pos[f] : epil_pos[0] ;
                
                a1=0;
                for (f=0;f<dbplgr;f++) {
                    if (ar_dom[f]==cur) {a1=1; dbcard=f+1;break ; }
                }
                if (!a1) {
                    mem3=epil_pos; 
                    free(mem3); mem3=epil_pos=0; tot_opts=0;
                    if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    break;}
                a1=0;
                goto CARD_CRIT_RIGHT ;
            }
            
            if (mmed[10]==2) {
                a1=0 ;
                for (f=dbcard ; f<dbplgr ; f++) {
                    if (crits[f]) {a1=1; dbcard=f+1;break ;}
                }
                
                if (!a1) {
                    dbcard = firstcrit+1;
                }
                a1=0;
                goto CARD_CRIT_RIGHT ;
            }
            
            a1=0;
            if (dbcard==65534) break ;
            dbcard++;
            if (dbcard>dbplgr) { // H επόμενη καρτέλλα είναι νέα !!
            
                if (dbcard>=65530) {
                    if (keyb_gr) information (0,"Η χωρητικότητα της βάσης εξαντλείται.\nΔιαγράψτε καρτέλες, για να μπορείτε\nνα αποθηκεύσετε νέες!",0);
                    else information (0,"The capacity of the data base is depleted.\nDelete cards, so you can save\nnew ones!",0);
                }
                
                a1=1;
                
                diax_dec=0;fidimundo_call(0,0);
                mmed[9]=mmed[3]=0;mmed[6]=1;
                prodec=prodvn=-1;
                sprintf (mmestr3c , "%s - %s" , design_t , diaxped);
                normtext_tomy ( mmestr3c , mmestr[3]) ;
                if (mmed[7]!=2) {
                mmed[7]=2; big_t=2.0 ;
                baserg=eisag;
                gen_ergo=mmestr[7];
                _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg);
                refresh();
                }
                mmed[10]=1;if(seflag>=2) {seflag=1;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                for (f=0;f<=dbfinum;f++) {
                keimk=memk[f]; keimk[0]=255;
                ceimk=memcp[f]; ceimk[0]=255;
                curk[f]=0; curk1[f]=0;
                    }
            }
            else {                      // Η επόμενη καρτέλλα πρέπει να διαβαστεί από το δίσκο !
CARD_CRIT_RIGHT : 
                fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                for (f=0;f<=dbfinum;f++) {
                    fread (memk[f] , 1, xlimk[f] , fpcard);
                    keimk=memk[f];
                    ceimk=memcp[f];
                    i=0;
                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                    else {
                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                        else ceimk[i]=255;
                    }
                curk[f]=0; curk1[f]=0;
                }
                fread (&cardwhen,sizeof(time_t),1,fpcard);
                if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
            }
                     
            if ( (a1) && (dbcurpage!=1) ) {
            dbcurpage=1;
            if (memx1) {free(memx1); memx1=0;}
            if (memy1) {free(memy1); memy1=0;}
            if(memx2)  {free(memx2); memx2=0;}
            if(memy2)  {free(memy2); memy2=0;}
            
            dbrecs=0;
            dbpage_decs();
            dbpage_recs(0);
            _bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
            sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
            pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
            _outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
            }
            dbdecor_show ();
            dbrecs_show ();
                       
            _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
            sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
            _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
            refresh();
            
            continue;
        }
        
        else if (cardlebut) {
KARTEL_PIO_ARISTERA :
             if (!dbplgr) break ;
             if ( (dbcard==1) && (!user_opts)  && (mmed[10]!=2) ) break;
             rego=3;
            for (f=0 ; f<=dbfinum ; f++) {    
                keimk=memk[f];
                ceimk=memcp[f];
                
                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                else {
                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                    else dx=1;
                }
                if (dx) {savenow=1 ; break ;}
            }
            if (savenow) {
                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                switch (user_ans) {
                    
                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                        savenow=0;
                        break;
                        
                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                        continue ;
                    
                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                        savenow=0;
                        tokyk=100;rego=0;
                        continue ;
                }
            }
            tokyk=100;rego=0;
            
            if (gundo_sit) {
                gundo_sit=0; gundo_but=0;
                if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
            }
        
            if (user_opts) {
                cur = (dbcard>dbplgr) ? dbplgr : dbcard ;
                cur = ar_dom[cur-1];
                
                for (f=0 ; f<tot_opts ; f++) {
                    if (epil_pos[f]==cur) {f--; break; }
                }
                
                if (f==tot_opts) {cur = epil_pos[tot_opts-1] ;}
                else { cur = (f>=0) ? epil_pos[f] : epil_pos[tot_opts-1] ; }
                
                a1=0;
                for (f=0;f<dbplgr;f++) {
                    if (ar_dom[f]==cur) {a1=1; dbcard=f+1;break ; }
                }
                if (!a1) {
                    mem3=epil_pos; 
                    free(mem3); mem3=epil_pos=0; tot_opts=0;
                     if (user_opts) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                    break;}
                goto CARD_CRIT_LEFT ;
            }
             
             if (mmed[10]==2) {
                 a1=0 ;
                for (f=dbcard-2 ; f>=0 ; f--) {
                    if (crits[f]) {a1=1; dbcard=f+1;break ;}
                }
                if (!a1) {
                    for (f=dbplgr-1 ; f>=0 ; f--) {
                        if (crits[f]) {dbcard=f+1;break ; }
                    }
                }
                goto CARD_CRIT_LEFT ;
            }

             dbcard--;
CARD_CRIT_LEFT:
              fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                for (f=0;f<=dbfinum;f++) {
                    fread (memk[f] , 1, xlimk[f] , fpcard);
                    keimk=memk[f];
                    ceimk=memcp[f];
                    i=0;
                    if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                    else {
                        if(keimk[i]!=255) strcpy (ceimk,keimk); 
                        else ceimk[i]=255;
                    }
                    curk[f]=0; curk1[f]=0;
                }
                fread (&cardwhen,sizeof(time_t),1,fpcard);
            
            if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
            dbdecor_show ();
            dbrecs_show ();
            
            // _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
            //_bareacls (toppgxt,topinfyt+1,toppgxt+26,topinfyt+17,topbkxr);        // Σελίδα
            _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
            sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
            //sprintf(top_str,"%02d",dbcurpage);  // Για σελίδα
            //pgchxr = (dbpg>dbcurpage) ? greenchxr : orangechxr ;
            //_outsouv_col(toppgxt,topinfyt+1,top_str,0,pgchxr,topbkxr);
            _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
            refresh();
            continue;
        }
        
        else if (cardareabut) { // Πηγαίνει σε συγκεκριμένη κάρτα !
PANE_SYGKEKR_KARTA :
            ektos=1;
            cardareabut=0;
            rego=4;
            if (dbplgr) {
                
            for (f=0 ; f<=dbfinum ; f++) {    
                keimk=memk[f];
                ceimk=memcp[f];
                
                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                else {
                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                    else dx=1;
                }
                if (dx) {savenow=1 ; break ;}
            }
            if (savenow) {
                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                switch (user_ans) {
                    
                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                        savenow=0;
                        break;
                        
                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                        continue ;
                    
                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                        savenow=0;
                        tokyk=100; rego=0;
                        continue ;
                }
            }
                tokyk=100; rego=0;
                if (gundo_sit) {
                    gundo_sit=0; gundo_but=0;
                    if (mmed[7]==2) bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
                }
                deigma[0]=255;
                user_ans=input_cardnum(deigma);
                if (user_ans==1) {

                cur = (unsigned short int) convert_str (5,deigma);
                    if (cur>0 && cur<=dbplgr){ 
                        
                        if (user_opts) {
    
                            p = ar_dom[cur-1];
                            i=0;
                            for (f=0 ; f<tot_opts ; f++) {
                                if (epil_pos[f]==p) {i=1 ; break; }
                            }
                            if (!i) {user_opts=0;bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);}
                        }
                        
                        else if (seflag==2) {
                            if (!crits[cur-1]){
                            seflag=3; 
                            mmed[10]=0; 
                            mmed[9]=2; big_t=2.0 ;
                            gen_ergo=mmestr[9];
                            _bareacls (search_flagxt,topinfyt,search_flagxt+36,topinfyt+18,topbkxr);
                            baserg=parous; 
                            _bareacls(topinfxt+1,topinfyt,topinfxb,topinfyt+17,baserg);
                            _outmystr_center_col (0, gen_ergo,topinfxt,topinfyt,topinfxb,topinfyt+18,topchxr,baserg); refresh();
                            }
                        }
                        dbcard=cur;
                         fseek(fpcard , (ar_dom[dbcard-1] * dbcardsize) , 0);
                        for (f=0;f<=dbfinum;f++) {
                            fread (memk[f] , 1, xlimk[f] , fpcard);
                            keimk=memk[f];
                            ceimk=memcp[f];
                            i=0;
                            if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
                            else {
                                if(keimk[i]!=255) strcpy (ceimk,keimk); 
                                else ceimk[i]=255;
                            }
                            curk[f]=0; curk1[f]=0;
                        }
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        if (ferror(fpcard)) {sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0); clearerr(fpcard);}
                        dbdecor_show ();
                        dbrecs_show ();
                         _bareacls(cardNoxt , topinfyt+1, cardNoxb , topinfyt+17,topbkxr );      // Καρτέλα Νο τάδε
                        sprintf(card_str,"%u",dbcard); normtext_tomy(card_str,0); // Για καρτέλα Νο τάδε
                        _outmystr_center_col(0,card_str,cardNoxt+1,topinfyt+1, cardNoxb, topinfyt+18,greenchxr,topbkxr);
                    }
                }
            }
            setrgbcolor (dbtop); line (cardareaxt,topinfyt+18,cardareaxb,topinfyt+18);refresh();
            continue ;
        }
        else {  // Κλίκ στον ελεύθερο χώρο !!
            
            
            if (!diax_dec) {
                if (dbfinum==-1) continue ;
                if (mmed[3]!=2) continue ;
                if (my1<=info.top) continue ;
                dx = multi_change_pos(mx1,my1);
                if (!dx) continue ;
                dbdecor_show ();
                dbrecs_show();
                continue;
            }
            
            if (diax_dec) {
                if (!decor) continue;
                if (mmed[3]!=2) continue ;
                if (my1<=info.top) continue ;
                dx = multi_decs_pos(mx1,my1);
                if (!dx) continue ;
                dbdecor_show ();
                dbrecs_show();
                continue;
            }
        }
    }                             // Πέρας του Button Left της Main !
        break ;

    case SDL_KEYDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        ch_scan=sdlev.key.keysym.scancode;
        do { SDL_PollEvent(&sdlev) ; } while ( (SDL_PollEvent(&sdlev)) && (sdlev.type == SDL_KEYDOWN) ) ;
        //ch1=sdlev.key.keysym.sym; 
        //ch_mod=SDL_GetModState();
        if ( proel!=-1  && mmed[3]==2 ) {
            
             i=db_elem[proel][0];              
                            
                a=0;
                
            switch (ch_scan) {
            
                case SDL_SCANCODE_LEFT :
                    dx=-1; dy=0; a=1;ektos=1;
                    break;
                
                case SDL_SCANCODE_RIGHT :
                     dx=1; dy=0; a=1;ektos=1;
                    break;
                 
                case SDL_SCANCODE_UP :
                    dx=0; dy=-1;a=1;ektos=1;
                    break;
                    
                case SDL_SCANCODE_DOWN :
                    dx=0; dy=1;a=1;ektos=1;
                    break;
                    
                case SDL_SCANCODE_PAGEUP :
                    if (dbcurpage==1) continue;
                    ektos=1;proel=-1;
                    goto DBPGUP ;
                    break;
                    
                case SDL_SCANCODE_PAGEDOWN :
                    if (dbcurpage==dbpg) continue;
                    ektos=1;proel=-1;
                    goto DBPGDN ; 
                    break;
                             
            }
            
            if (a) {  
                        
                        if (db_elem[proel][1]) {
                            if (ptr_pedio[i]->fivar[1]) continue;
                                }
                            else {
                                if (ptr_pedio[i]->fivar[5]) continue; }
                                
                        Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel];   
                        f=change_mikrodbpos(proel,dx,dy,&Cx1,&Cy1,&Cx2,&Cy2);
                        if ( (Cx1==dbx1[proel]) && (Cy1==dby1[proel]) ) continue;
                        if (f!=-1) {
                        
                       
                        
                        if(db_elem[proel][1]) {
                            ptr_pedio[i]->fixt=Cx1; ptr_pedio[i]->fiyt=Cy1;
                            ptr_pedio[i]->fiwid=Cx2-Cx1+1; ptr_pedio[i]->fihei=Cy2-Cy1+1;
                            }
                        else {
                            ptr_pedio[i]->filaxt=Cx1; ptr_pedio[i]->filayt=Cy1;
                            ptr_pedio[i]->filawid=Cx2-Cx1+1; ptr_pedio[i]->filahei=Cy2-Cy1+1;
                        }
                        
                        fidimundo_call(1,proel);
                        ox1=dbx1[proel]=Cx1; oy1=dby1[proel]=Cy1; ox2=dbx2[proel]=Cx2 ; oy2=dby2[proel]=Cy2;
                        dx=(i*dbfisize)+104;
                        fseek(fpdb,dx,0);
                        fwrite (ptr_pedio[i],1,dbfisize,fpdb);
                        fdatasync (fide_fpdb);
                    dbdecor_show ();
                    dbrecs_show();
                    getimage(ox1,oy1,ox2,oy2,mem_ouon);
                    setrgbcolor(dbmag);
                    rectangle (ox1,oy1,ox2,oy2);
                    refresh();
                    }
                    
                    
                    continue;
                }
                    
               continue ;
            } // Πέρας του proel!=-1 με ενεργή τη σχεδίαση της βάσης δεδομένων
            
        else if ( prodec!=-1  && mmed[3]==2 ) {
            
             cur=dd_elem[prodec];              
                            
                a=0;
                
            switch (ch_scan) {
            
                case SDL_SCANCODE_LEFT :
                    dx=-1; dy=0; a=1;ektos=1;
                    break;
                
                case SDL_SCANCODE_RIGHT :
                     dx=1; dy=0; a=1;ektos=1;
                    break;
                 
                case SDL_SCANCODE_UP :
                    dx=0; dy=-1;a=1;ektos=1;
                    break;
                    
                case SDL_SCANCODE_DOWN :
                    dx=0; dy=1;a=1;ektos=1;
                    break;
                    
                case SDL_SCANCODE_PAGEUP :
                    if (dbcurpage==1) continue;
                    ektos=1;prodec=-1;
                    goto DBPGUP ;
                    break;
                    
                case SDL_SCANCODE_PAGEDOWN :
                    if (dbcurpage==dbpg) continue;
                    ektos=1;prodec=-1;
                    goto DBPGDN ; 
                    break;
                             
            }
            
            if (a) {  
                                
                Cx1=dbdx1[prodec]; Cy1=dbdy1[prodec]; Cx2=dbdx2[prodec]; Cy2=dbdy2[prodec];   
                f=change_mikrolabpos(dx,dy,&Cx1,&Cy1,&Cx2,&Cy2);
                if ( (Cx1==dbdx1[prodec]) && (Cy1==dbdy1[prodec]) ) continue;
                if (f==1) {
                
                
                sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                fpdec=fopen(str1024,"r+b");
                if (fpdec==NULL) {information(6-keyb_gr,str1024,0); continue ;}
                fide_fpdec = fileno (fpdec);
                ptr_dec[cur].dext=Cx1; 
                ptr_dec[cur].deyt=Cy1;
                fidimundo_call(1,prodec);
                ox1=dbdx1[prodec]=Cx1; oy1=dbdy1[prodec]=Cy1; 
                ox2=dbdx2[prodec]=Cx2 ; oy2=dbdy2[prodec]=Cy2;
                fseek(fpdec , (cur*decorsize) ,0);
                fwrite (&ptr_dec[cur] , decorsize, 1, fpdec);
                fdatasync(fide_fpdec);
                fsync(fide_fpdec);
                fclose(fpdec);
                dbdecor_show ();
                dbrecs_show();
                getimage(ox1,oy1,ox2,oy2,mem_ouon);
                setrgbcolor(dbmag);
                rectangle (ox1,oy1,ox2,oy2);
                refresh();
                
                    }
                    
                    continue;
                }
                //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                //SDL_SetCursor(cursor);     
               continue ;
            } // Πέρας του prodec!=-1 για μικρομετακίνηση
            
            else if ( proel!=-1  && mmed[7]==2  )
            {
                i=db_elem[proel][0];

                
                 switch (ch_scan) {
                
                    case SDL_SCANCODE_PAGEUP :
                        if (dbcurpage==1) continue;
                        ektos=1;
                        goto DBPGUP ;
                        break;
                        
                    case SDL_SCANCODE_PAGEDOWN :
                        if (dbcurpage==dbpg) continue;
                        ektos=1;
                        goto DBPGDN ; 
                        break;
                        
                    case SDL_SCANCODE_RIGHT :
                        ektos=1;proel=-1;
                        goto KARTEL_PIO_DEJIA;
                        break;
                        
                    case SDL_SCANCODE_LEFT :
                        ektos=1; proel=-1;
                        goto KARTEL_PIO_ARISTERA;
                        break;
                    
                    case SDL_SCANCODE_DELETE :
                        
                        if (!db_elem[proel][1]) break;
                        keimk=memk[i];
                        if (keimk[0]==255) break;
                        ektos=1;
                        if (ptr_pedio[i]->ficode) {
                        mytext_tonorm ( ptr_pedio[i]->finame , str1kb , 60 );
                        str1024[0]=255;
                        input_alert (40-keyb_gr,str1kb, str1024 ,4);
                        f=(int) convert_str(4 , str1024);
                        if (ptr_pedio[i]->ficode != (short int) f ) break;}
                        
                        user_ans=alert(26-keyb_gr,0,0);
                        if (user_ans==1){
                        if (i1>=0) putimage(dbx1[i1]+1,dby1[i1]+1,mem_kato,0);
                        putimage(ox1,oy1,mem_ouon,0);
                        Cx1=dbx1[proel]; Cy1=dby1[proel]; Cx2=dbx2[proel]; Cy2=dby2[proel]; 
                        keimk[0]=255;
                        bareacls (Cx1+1,Cy1+1,Cx2-1,Cy2-1,ptr_pedio[i]->fibkxr);
                        proel=-1; ektos=1 ;
                        eaninpundo();
                        }
                        break;   
                
                 }
                 continue ;
                
            }
            else
            {
                 switch (ch_scan) {
                    case SDL_SCANCODE_PAGEUP :
                    if (dbcurpage==1) continue;
                    ektos=1;
                    goto DBPGUP ;
                    break;
                    
                case SDL_SCANCODE_PAGEDOWN :
                    if (dbcurpage==dbpg) continue;
                    ektos=1;
                    goto DBPGDN ; 
                    break;
                    
                case SDL_SCANCODE_RIGHT :
                    ektos=1;proel=-1;
                    goto KARTEL_PIO_DEJIA;
                    break;
                    
                case SDL_SCANCODE_LEFT :
                    ektos=1;proel=-1;
                    goto KARTEL_PIO_ARISTERA;
                    break;
                }
            }
                       
        break;

    case SDL_MOUSEWHEEL :
        
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if(sdlev.wheel.y > 0) // scroll up
        {
            if (dbcurpage==1) continue; 
            if ( win_id==getcurrentwindow() ) {proel=-1;ektos=1; goto DBPGUP ;} 
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
            if (dbcurpage==dbpg) continue;
            if ( win_id==getcurrentwindow() ) {proel=-1;ektos=1; goto DBPGDN ;} 
        }
        refresh();

        continue; 
        
    case SDL_QUIT :
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    
    
    while (SDL_PollEvent(&sdlev)) continue ;
    
    
    if (dbplgr) {
            for (f=0 ; f<=dbfinum ; f++) {    
                keimk=memk[f];
                ceimk=memcp[f];
                
                if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
                else {
                    if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
                    else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
                    else dx=1;
                }
                if (dx) {savenow=1 ; break ;}
            }
            if (savenow) {
                if (keyb_gr) user_ans=spec_alert(0,"Έχετε τροποποιήσει δεδομένα !!","Θέλετε να σωθούν οι αλλαγές ;","save_alert.ico",savebkxr);
                        else user_ans=spec_alert(0,"You have modified the data !!","Do you want to save the changes ?","save_alert.ico",savebkxr);
                switch (user_ans) {
                    
                    case 0 : // Δεν τρέχει τίποτε...συνέχισε δουλειά σου χωρίς να σώσεις !!
                        savenow=0;
                        break;
                        
                    case 1 : // ΣΩΣΕ ΤΩΡΑ
                        continue ;
                    
                    case 2 : // Μη σώσεις - μη συνεχίσεις εδώ...άσε να το ξαναδούμε....
                        savenow=0;
                        tokyk=100;
                        continue ;
                }
            }
    }
    tokyk=100;
    if (gundo_sit && mmed[7]==2) {
            gundo_sit=0; gundo_but=0;
            bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
    }
   fidimundo_call(0,0);
    if (dbmaxbut>-1) {
    sprintf (file_2,"%s%s",path_name,"Lists/usrLst.dat");
    if (keyb_gr) user_ans=alert(0,"Υπάρχουν φορτωμένες λίστες!","Θέλετε να φορτωθούν αυτόματα την επόμενη  φορά που θα ανοίξετε την εφαρμογή ;"); else user_ans=alert(0,"There are lists you have  loaded!","Do  you want  them to be  auto loaded next time ?");
    if (user_ans==2) continue ;
    if (user_ans==1) {
        
        fp = fopen(file_2,"wb");
        if (fp==NULL) {information (6-keyb_gr,file_2,0); goto LISTS_OUT;}
        fide_gen = fileno (fp) ;
        fwrite (&dbmaxbut,2,1,fp) ;
        i=0;
        while (synolo_butstr[i]!=254) i++;
        diaf1=i+1;
        fwrite (&diaf1,4,1,fp);
        
        fwrite (synolo_butstr,1,diaf1,fp);
        if (ferror(fp)) {information (6-keyb_gr,file_2,0);clearerr(fp) ; fclose(fp); fp=NULL; goto LISTS_OUT;} 
        else {fsync(fide_gen); fclose (fp);}
    }
    else {
        fp = fopen(file_2,"wb");
        if (fp==NULL) {information (6-keyb_gr,file_2,0); goto LISTS_OUT;}
        fide_gen = fileno (fp) ;
        dbmaxbut=-1;
        fwrite (&dbmaxbut,2,1,fp) ;
        if (ferror(fp)) {information (6-keyb_gr,file_2,0);clearerr(fp) ; fclose(fp); fp=NULL; goto LISTS_OUT;} 
        else {fsync(fide_gen);fclose (fp);}
    }
}
LISTS_OUT :
    qcls(0,0,0) ; if (mem1!=NULL) free(mem1); if (mem2!=NULL) free(mem2); free(sfalma); sfalma=0; goto gamidia;
    
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        refresh(); continue;
    
    default:
    continue;
}
}
gamidia:
if (mem_ouon) free (mem_ouon);
if (mem_cross) free (mem_cross);
if (sfalma) free (sfalma);
if (dbfds.mem_fd) free(dbfds.mem_fd) ;
if (dbfnt.mem_fn) free(dbfnt.mem_fn);
if(dbfdata.mem_fd) free(dbfdata.mem_fd);
if (mem_sarial) free(mem_sarial);
if (mem_times) free (mem_times) ;
if(mem_caviar) free(mem_caviar);
if(mem_impact) free (mem_impact);
if (greek_addr!=NULL) free(greek_addr);
if (souv_addr!=NULL) free(souv_addr);
if(mem_sans) free(mem_sans);
if(mem_sanser21) free(mem_sanser21) ;
if(mem_butmenu) free(mem_butmenu);
if(mem_pgup) free (mem_pgup);
if(mem_pgdn) free(mem_pgdn);
if(mem_chain) free(mem_chain);
if(mem_kato) free(mem_kato);
if(mem_rightcard) free(mem_rightcard);
if(mem_leftcard) free(mem_leftcard);
if(mem_savecard) free(mem_savecard);
if (mem_addcard) free (mem_addcard);
if(mem_sumdb) free(mem_sumdb);
if(mem_search) free(mem_search);
if(ardom_mem) free(ardom_mem);
if(item_mem) free(item_mem);
if(new_dom_vo) free(new_dom_vo);
if (mem_usersel) free(mem_usersel) ;
if(epil_pos) {mem1=epil_pos; free(mem1);}
for (f=0;f<10;f++) { if (dbbut[f].mem_butt) free( dbbut[f].mem_butt ); }
if(fpdb!=NULL) {fsync(fide_fpdb); fclose (fpdb);}
if(fpcard!=NULL) {fsync(fide_fpcard); fclose(fpcard);}
if(fpdom!=NULL) {fsync(fide_fpdom); fclose(fpdom);}
if(fpera!=NULL) {fsync(fide_fpera); fclose(fpera);}
if (dbfinum>=0) {for (f=0;f<=dbfinum;f++) {if(ptr_pedio[f]) {mem1=ptr_pedio[f]; free(mem1);}}}

for (f=0;f<100;f++) {
    if (memk[f]) free(memk[f]) ; 
    if (memcp[f]) free(memcp[f]) ;  
    if (multicr[f]) {mem1=multicr[f] ; free(mem1);} 
    if (alg_str[f]) {mem1=alg_str[f]; free (mem1);}
}
if (memx1) free(memx1);
if (memy1) free(memy1);
if(memx2) free(memx2);
if(memy2) free(memy2);
if (dmemx1) {free(dmemx1); }
if (dmemy1) {free(dmemy1); }
if(dmemx2)  {free(dmemx2); }
if(dmemy2)  {free(dmemy2); }
if(mem_progvn) free(mem_progvn);
                
if (empl_mem) {mem1=empl_mem; free(mem1);}
telos:
SDL_Quit();

if (fpsflalm!=NULL) {
fsync (fide_fpsflalm);
fclose(fpsflalm);
freopen ("/dev/tty", "a", stderr);}

if (fpout!=NULL) {
fsync (fide_fpout);
fclose(fpout);
freopen ("/dev/tty", "a", stdout);}

restorecrtmode();
exit(0);
}

long int inp_numb()
{
int i , len=0, asf=-1, ar ;
char str[80];
long int timh=0 , pol ;
while (!len) {
    for(i=0;i<80;i++) str[i]=0;
    scanf("%s",str);
    len=(int) strlen(str);
    if (!len) {printf("\r");continue;}
    if(str[0]=='-')
        if(len>1) asf=0;
        else len=0;
}
len--;
for(i=len,pol=1; i>asf; i-- , pol=pol*10) {
    ar=(int) str[i]-48;
    if (ar==-21) { my_esc=1;return 0; }
    if (ar<0 || ar>9) return 0;
    timh=timh+(ar*pol);
}
if(asf) return timh ;
return -timh;
}

void gotoxy(int x, int y) { printf("\x1B[%d;%df", y, x); }
 
void clrscr() { printf("\x1B[2J\x1B[0;0f"); }




void cls()
{
    register int i , f ;
    setcolor (COLOR(dbbkxr[0],dbbkxr[1],dbbkxr[2]));  
    for (i=info.left;i<=info.right;i++) {for (f=info.top ; f<=info.bottom; f++) _putpixel (i,f);}
    refresh();
    return;
}

void efecls (int x,int y,int w,int h,int kok,int pra,int mpl)
{
    int i , f ;
    int dx,dy,bx,by;
    int del ;
    
    setcolor (COLOR(kok,pra,mpl));  
    
    for (i=x,f=y ; ((i<w+x) && (f<h+y)) ; i++ , f++) {
        bx=1; by=1;
        dx=w+x-i; dy=h+y-f;
        _putpixel(i,f); 
        dx--;dy--;
        if (random(200) <8) refresh();
        
        while ((dx) && (dy)) {  
            _putpixel ((i+bx),f) ; bx++ ; dx-- ;
            _putpixel (i,(f+by));by++,dy-- ; }
            
        while (dx) {_putpixel ((i+bx),f) ; bx++ ; dx-- ;}
        while (dy) {_putpixel (i,(f+by)); by++ ; dy-- ;}
    }
    while(i<w+x) _putpixel(i++,f-1); 
    while(f<h+y) _putpixel(i-1,f++);
    refresh();
    return;
}

void qcls (int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=0;i<=info.right;i++) {for (f=0 ; f<=info.bottom; f++) _putpixel (i,f);}
    refresh();
    return;
}

void areacls (int x,int y,int r,int d,int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    refresh();
    return;
}

void bareacls (int x,int y,int r,int d,int *cbkxr)
{
    register int i , f ;
    setcolor (COLOR(cbkxr[0],cbkxr[1],cbkxr[2]));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    refresh();
    return;
}

void * prosouv()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/MySouv.dat");

fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
souv[i].who=elem[i].who;
souv[i].wid=elem[i].wid;
souv[i].hei=elem[i].hei;
souv[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font souv load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}

//************************************************************************************************************

int outsouv(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
}

void fidicls(int x, int y, int x1, int y1 , int red , int green, int blue)
{

int dx, dy, syn, ax, ay, ax1, ay1, metr ;

    ax=x ; ay=y ; ax1=x1 ; ay1=y1;
    syn=(x1-x+1) * (y1-y+1);
    metr = 0;
    setcolor ( COLOR (red,green,blue) );
     
    do {
        while (x<x1) {_putpixel(x,y); x++;metr++;}
     
        while (y<y1) {_putpixel (x,y);y++;metr++;}        
     
        while (x>ax) {_putpixel (x,y);metr++;x--;}
        ax++;
        if (random(200) <8) refresh();
        while (y>ay) {_putpixel (x,y);metr++;y--;}
        ay++; y++;
        x1-- ; y1-- ;
      
        } while (metr<syn) ;
    refresh();
    return ;
}


void proinput ()
{
register int i ,f ;
char ch , ch1 ;

/* Προυποθέτει αρχικές τιμές - καθολική μεταβλητή etm[22][3] 
extern unsigned char etm[22][3] =
{53 , '`' , '~' , 30 , '1' , '!' , 31 , '2', '@' , 32 , '3' , '#' , 33 , '4' , '$' , 34 , '5', '%' , 35 , '6' , '^' , 36 , '7' , '&' , 37 , '8' , '*' , 38 , '9' , '(' ,
39 , '0' , ')' , 45 , '-' , '_' , 46 , '=' , '+' , 47 , '[' , '{' , 48 , ']' , '}' , 49 , '\\' , '|' , 51 , ';' , ':' , 52 , '\'' , '\"' , 54 , ',' , '<', 55 , '.' , '>' ,
56 , '/' , '?' , 44, ' ' , ' ' }; 

Επίσης ...
extern struct fachars {
unsigned int scacod [57];
unsigned char faprint [57][2];
unsigned int sort [57][2]
} engl ;

ΚΑΙ να έχει γίνει η προετοιμασία της καθολικής struct fansouv
*/

for (f=0 ; f<57 ; f++) 
{
engl.scacod[f]=0 ;    
engl.faprint[f][0]= 0 ; 
engl.faprint[f][1]= 0 ; 
grek.scacod[f]= 0 ;    
grek.faprint[f][0]=0 ; 
grek.faprint[f][1]= 0; 
}

for (f=4 , ch='a' , ch1='A' ; f<30 ; f++,ch++,ch1++) 
{
engl.scacod[f]=f ;    
engl.faprint[f][0]=ch ; 
engl.faprint[f][1]=ch1; 
grek.scacod[f]=f ;    
grek.faprint[f][0]=ch ; 
grek.faprint[f][1]=ch1; 
}

grek.faprint[20][0] = ';' ;
grek.faprint[20][1] = ':' ;
grek.faprint[26][1] = 'S' ;

for (f=0 ; f<22 ; f++) 
{
i=etm[f][0];
engl.scacod[i]=i; 
engl.faprint[i][0]=etm[f][1] ; 
engl.faprint[i][1]=etm[f][2] ;
grek.scacod[i]=i; 
grek.faprint[i][0]=etm[f][1] ; 
grek.faprint[i][1]=etm[f][2] ;
}

grek.scacod[51]=0;
grek.faprint[51][0]= 0 ; 
grek.faprint[51][1]= 0 ;

for (f=0;f<95;f++) //gr_start=95 !!//
{
    for (i=0 ; i<57 ; i++)
    {
        if (engl.faprint[i][0]==souv[f].who) engl.sort[i][0]= f ;
        if (engl.faprint[i][1]==souv[f].who) engl.sort [i][1]=f ;
    }
}

for (f=0;f<43;f++) 
{
    for (i=0 ; i<57 ; i++)
    {
        if (grek.faprint[i][0]==souv[f].who) grek.sort[i][0]= f ;
        if (grek.faprint[i][1]==souv[f].who) grek.sort [i][1]=f ;
    }
}

for (f=95;f<164;f++) 
{
    if (souv[f].who == '*') continue ; 
    for (i=0 ; i<57 ; i++)
    {
        
        if (grek.faprint[i][0]==souv[f].who) grek.sort[i][0]= f ;
        if (grek.faprint[i][1]==souv[f].who) grek.sort [i][1]=f ;
    }
}
return ;
}


int bmptodisk (char *bmpname, unsigned int size_bytes,int width, int height)
{
union picols{
unsigned int ltimi;
unsigned char xro[4];
}col;
void *mem_start ;
int *mem_int, *mem_int0;
FILE *arxeio_fp;
long int good=width * height * 4 ;
int f ,i ,bad , transp_1;
char newname[150];
bad=size_bytes-good ;
mem_start = malloc (good+8);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}
//good=fread(mem_start,sizeof(short int),35,arxeio_fp);
//if(good != 35) {free(mem_start); fclose(arxeio_fp); return NULL;}
mem_int0=mem_start;
*mem_int0++ = width ; 
*mem_int0++ = height; 

for(f=height;f>0;f--) {
mem_int=mem_int0;
mem_int = mem_int + ((f-1)*width);
    for (i=0;i<width;i++) { 
        fread(&col.ltimi , sizeof(int) , 1, arxeio_fp);
         transp_1=col.xro[0]; 
         col.ltimi = col.ltimi >> 8;
        col.xro[3]= transp_1; 
        *mem_int++ = col.ltimi;
    }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"ico");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
i= (width*height*4) + 8 ;
fwrite (mem_start,1,i,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}

void *icontomem (char *filename,int transp)
{
void *mem_start ;
char *mem1;
int *mem_int;
FILE *fp;
int width , height ;
unsigned int size ;
register int f ;

fp = fopen(filename,"rb");
if (fp==NULL) {information(6-keyb_gr,filename,NULL); return NULL;}
fread(&width,4,1,fp);
fread(&height,4,1,fp);
size=( (width*height*4) + 8 );
mem_start = malloc (size);
if (mem_start==NULL) return NULL ;
mem_int=mem_start;
mem1=mem_start;
*mem_int++ = width ; 
*mem_int++ = height; 
size -= 8 ; size /= 4 ;
fread(mem_int,4,size,fp);
if(ferror(fp)) {clearerr(fp); information(6-keyb_gr,filename,NULL); free(mem_start); fclose(fp); return NULL;}
fclose(fp);
//mem1 += 7;
//for(f=0 ; f<size ; f++) {
//    mem1+=4;
//    if ((*mem1))  *mem1=(unsigned char) transp ;
//    }
return mem_start;
}

void *pronoto()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/Noto.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
nouv[i].who=elem[i].who;
nouv[i].wid=elem[i].wid;
nouv[i].hei=elem[i].hei;
nouv[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font notosans load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}

//************************************************************************************************************

int outnoto(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

int outnoto_big(int x, int y, char *str, int lang, int syntx , int synty)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w , w1, h1 ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid*syntx) > info.right ) { x = info.left ; y+=26*synty ; }
  if ( (y+26*synty) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
  
     for(h=0; h<nouv[i].hei ; h++) {
        for(w=0;w<nouv[i].wid;w++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
             
                for (h1=0 ; h1<synty ; h1++) {
                    for (w1=0 ; w1<syntx; w1++) {
                        _putpixel( (x+w*syntx+w1) , (y+h*synty+h1) ); }}}}
    x+=nouv[i].wid*syntx;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid*syntx) > info.right ) { x = info.left ; y+=26*synty ; }
  if ( (y+26*synty) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
    for(h=0; h<nouv[i].hei ; h++) {
        for(w=0;w<nouv[i].wid;w++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
             
                for (h1=0 ; h1<synty ; h1++) {
                    for (w1=0 ; w1<syntx; w1++) {
                        _putpixel( (x+w*syntx+w1) , (y+h*synty+h1) ); }}}}
    x+=nouv[i].wid*syntx;}}}
refresh();    
return 1;
}

int outnoto_sma(int x, int y, char *str, int lang)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ,w1 , h1 ;
register int i;
int *mem_int ;
char ch , ch1 ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid/2) > info.right ) { x = info.left ; y+=13 ; }
  if ( (y+13) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
  
   for(h=0; h<nouv[i].hei ; h++) {
     
       if (h%2) {mem_int+=nouv[i].wid ; continue; }
     for(w=0;w<nouv[i].wid;w++) {
      
     if (w%2) {mem_int++ ; continue; }
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w/2 , y+h/2);}}
     x+=nouv[i].wid/2;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid/2) > info.right ) { x = info.left ; y+=13 ; }
  if ( (y+13) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
    for(h=0; h<nouv[i].hei ; h++) {
       //h1=h/2;
       if (h%2) {mem_int+=nouv[i].wid ; continue; }
     for(w=0;w<nouv[i].wid;w++) {
      
     if (w%2) {mem_int++ ; continue; }
     co.lor = *mem_int++;
     if (!co.lor) continue;
     setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
      
     _putpixel(x+w/2 , y+h/2);}}
     x+=nouv[i].wid/2;}}}
        
refresh();    
return 1;
}

int Wbmptodisk (char *bmpname, unsigned int size_bytes,short int width, short int height)
{
unsigned int wtimi;
void *mem_start ;
short int *mem_word , *mem_word0 ;
FILE *arxeio_fp;
unsigned int good; 
int f ,i ,bad ;
char newname[150];
good = width * height * 2 ;
bad=size_bytes-good ;
mem_start = malloc (good+4);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}

mem_word0=mem_start;
*mem_word0++ = width ; 
*mem_word0++ = height; 

for(f=height;f>0;f--) {
mem_word=mem_word0;
mem_word += ( (f-1)*width );
    for (i=0;i<width;i++) { 
        fread(mem_word++ , 2 , 1, arxeio_fp);
     }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"icw");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
size_bytes= (width*height*2) + 4 ;
fwrite (mem_start,1,size_bytes,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}

void *icWtomem (char *filename)
{
void *mem_start ;
char *mem1;
short int *mem_int;
FILE *fp;
unsigned short int width , height ;
unsigned int size ;
register int f ;

fp = fopen(filename,"rb");
if (fp==NULL) {return NULL;}
fread(&width,2,1,fp);
fread(&height,2,1,fp);
size=( (width*height*2) + 4 );
mem_start = malloc (size);
if (mem_start==NULL) return NULL ;
mem_int=mem_start;
mem1=mem_start;
*mem_int++ = width ; 
*mem_int++ = height; 
size -= 4 ; size /= 2 ;
fread(mem_int,2,size,fp);
if(ferror(fp)) {clearerr(fp); printf("File Read Problem !"); free(mem_start); fclose(fp); return NULL;}
fclose(fp);
//mem1 += 7;
//for(f=0 ; f<size ; f++) {
//    mem1+=4;
//    if ((*mem1))  *mem1=(unsigned char) transp ;
//    }
return mem_start;
}

int puticW(int x, int y, void *mem_w)
{
unsigned short int w , h ,rval,gval,bval,wtimi;
short int *mem_w1;
register int f,i ;
mem_w1=mem_w;
w=*mem_w1++ ; h=*mem_w1++;

for (f=0 ; f<h ; f++) {
    for (i=0 ; i<w ; i++) {
        wtimi=*mem_w1++;
        if (!(wtimi / 32768)) continue ;
        wtimi=wtimi ^ 32768;
        rval=wtimi >> 7;
        gval = wtimi << 6 ;
        gval = gval >> 9 ;
        bval = wtimi << 11;
        bval = bval >>9;
        
        setcolor ( COLOR ( (int)rval,(int) gval, (int) bval) ) ; 
        _putpixel (x+i,y+f); }}
refresh();
return 1;
}

void fontoicW (int x , int y, int red, int green, int blue, void *mem1)
{
    
register int i,f;
unsigned short int w , h ,wtimi;
short int *memw;

setcolor (COLOR (red,green,blue) );  
memw=mem1;
w = *memw++; h=*memw++;
for (f=0 ; f<h ; f++) {
    for (i=0 ; i<w; i++) {
        wtimi=*memw++;
         if ((wtimi / 32768) ) continue ;
         _putpixel (x+i,y+f); }}
         refresh();
         return;
}

int pontik_rec(int *mxl, int *myt ,int *mxright , int *mybottom)
{
SDL_Cursor* cursor;
short int good =0;
int mxr , myb , prxr , pryb ,xl , yt ,xl1 , yt1 ;
unsigned char start = 0;
unsigned int size ;
void *mem1=NULL ;
void *mem_pos , *mem_und;
register int i,f ;

prxr=0 ; pryb=0 ;
strcpy (file_1,path_name);
strcat (file_1,"ICD/New_pos.icw");
mem_pos= icWtomem (file_1);
size=imagesize (0,0,93,57);
mem_und=malloc(size) ;
if (mem_und==NULL) {printf("Memory not enough") ; free (mem_pos); return -1;}

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEMOTION);
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
SDL_SetCursor(cursor);
do {
SDL_PollEvent(&sdlev);
xl = sdlev.motion.x ; yt = sdlev.motion.y ;
if (xl<info.left) xl=info.left;
if (xl>info.right) xl=info.right;
if (yt<info.top) yt=info.top;
if (yt>info.bottom) yt=info.bottom ;

if (!start) {
    start=1;
    getimage (xl,yt,xl+93,yt+57,mem_und);
    puticW(xl,yt,mem_pos);
    xl1=xl ; yt1=yt;
    continue ;
                }
    if ( (xl1==xl) && (yt1==yt) ) continue ;
    
    putimage (xl1,yt1,mem_und,0);
    getimage (xl,yt,xl+93,yt+57,mem_und);
    puticW(xl,yt,mem_pos);
    xl1=xl ; yt1=yt;
    
} while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;

putimage (xl1,yt1,mem_und,0); free (mem_pos);
refresh();
xl=xl1 ; yt=yt1;
*mxl=xl1 ; *myt=yt1 ;
start=0;
strcpy (file_1,path_name);
strcat (file_1,"ICD/Drag_Click.icw");
mem_pos= icWtomem (file_1);
if (mem_pos==NULL) {printf("Memory not enough") ; free (mem_und); return -1;}

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
  do {
       SDL_PollEvent(&sdlev);
       mxr = sdlev.motion.x ; myb = sdlev.motion.y ;
       if (mxr<=xl || myb<=yt) continue;
       if (mxr>info.right) mxr=info.right ;
       if (myb>info.bottom) myb=info.bottom;
       if (mxr==prxr && myb==pryb) continue;
       if (!start) {
           prxr=mxr ; pryb=myb;
           getimage (mxr,myb,mxr+93,myb+57,mem_und);
           
           size=imagesize (xl,yt,mxr,myb);
           mem1=malloc(size);
           if (mem1==NULL) {printf ("Memory Problem \n") ; free(mem_pos); free(mem_und); cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);return -1;}
           getimage (xl,yt,mxr,myb,mem1);
           setcolor (COLOR(255,0,0)) ;  
           rectangle (xl,yt,mxr,myb);
           setcolor (COLOR(255,255,0)) ;  
           for (i=yt+1;i<myb;i+=3) {for (f=xl+1 ; f<mxr; f+=3) _putpixel (f,i);}
           start=1;
           puticW(mxr,myb,mem_pos);
           continue ; }
        putimage (xl,yt,mem1,0); free(mem1); mem1=NULL;
        putimage (prxr,pryb,mem_und,0);
        getimage (mxr,myb,mxr+93,myb+57,mem_und);
        
        prxr=mxr ; pryb=myb;
        size=imagesize (xl,yt,mxr,myb);
        mem1=malloc(size);
        if (mem1==NULL) {printf ("Memory Problem \n") ; free(mem_pos); free(mem_und); cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor); return -1;}
        getimage (xl,yt,mxr,myb,mem1);
        setcolor (COLOR(255,0,0)) ;  
        rectangle (xl,yt,mxr,myb);
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<myb;i+=3) {for (f=xl+1 ; f<mxr; f+=3) _putpixel (f,i);}  puticW(mxr,myb,mem_pos);
       } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
putimage (prxr,pryb,mem_und,0);
free(mem_pos); free(mem_und);
if (mem1==NULL) {*mxright=xl ; *mybottom=yt ;cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);refresh(); return 0;}
putimage (xl,yt,mem1,0); free(mem1);
*mxright=prxr ; *mybottom=pryb ;
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
refresh();
return 1;
}

int change_dim(int xl, int yt ,int *mxright , int *mybottom)
{
SDL_Cursor* cursor;
int mxr , myb , prxr , pryb ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);

prxr=*mxright; pryb=*mybottom;
size=imagesize (xl,yt,info.right,info.bottom);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (xl,yt,prxr,pryb,mem1);
setcolor (COLOR(255,0,0)) ;  
rectangle (xl,yt,prxr,pryb);
setcolor (COLOR(255,255,0)) ;  
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<prxr; f+=3) _putpixel (f,i);}
refresh();

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       //SDL_GetRelativeMouseState (&mxr , &myb);
        mxr = sdlev.motion.x ; myb = sdlev.motion.y ;
       if (mxr<=xl || myb<=yt) continue;
       if (mxr>info.right) mxr=info.right ;
       if (myb>info.bottom) myb=info.bottom;
       if (mxr==prxr && myb==pryb) continue;
        putimage (xl,yt,mem1,0); 
        prxr=mxr ; pryb=myb;
        getimage (xl,yt,mxr,myb,mem1);
        setcolor (COLOR(255,0,0)) ;   
        //rectangle (xl,yt,mxr,myb);
        for(f=xl;f<=mxr;f++) {_putpixel(f,yt); _putpixel(f,myb);}
        for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxr,i);}
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxr; f+=4) _putpixel (f,i);} refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
     putimage (xl,yt,mem1,0); free(mem1);
    *mxright=prxr ; *mybottom=pryb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    
    return 1;
}

int change_pos(int *xl, int *yt ,int *xr , int *yb)
{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;
unsigned int dx , dy , sx ,sy ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
prxl=*xl; pryt=*yt;
dx=mxr-prxl; dy=myb-pryt;
size=imagesize (prxl,pryt,mxr,myb);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (prxl,pryt,mxr,myb,mem1);
setrgbpalette (2,255,0,0) ;  setrgbpalette (3,255,255,0) ;
setrgbcolor(2);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(3);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
       if (mxl<info.left ) mxl=info.left;
       if (mxl+dx>info.right) mxl=info.right-dx;
       if (myt<info.top) myt=info.top;
       if (myt+dy>info.bottom) myt=info.bottom-dy ;
       if (mxl==prxl && myt==pryt) continue;
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dx ; sy=myt+dy;
        getimage (mxl,myt,sx,sy,mem1);
         setrgbcolor(2);
       
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       setrgbcolor(3);
       //setcolor (COLOR(255,255,0)) ;  
        for (i=myt+1;i<sy;i+=4) {for (f=mxl+1 ; f<sx; f+=4) _putpixel (f,i);} refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
    putimage (prxl,pryt,mem1,0); free(mem1);
    *xl=prxl ; *yt=pryt ;*xr=prxl+dx ; *yb=pryt+dy;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return 1;
}

int puticon (int x1,int y1,void *mem1,int transp)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
    
    for(i=0 ; i < width; i++) {
    co.lor= *(mem_int++);
    if (co.rgb[3]>128) {
        setcolor (COLOR ( co.rgb[2],co.rgb[1],co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    refresh(); 
    return 1;
}

int outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
     setcolor(COLOR (red,green,blue));
   
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

int outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
unsigned short int neg;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
}

int rgb_choose (int *bkxr , int *chxr)
{
SDL_Cursor* cursor;
unsigned short int x ,y ,y1, x2 , x0, y0, x3 , y3 ,start ,wtimi ,wid , hei , wid_box, hei_box, y4 ;
unsigned int size ;
void *mem_menu , *mem0 ;
void *mem_efedr1;
short int *mem_int;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my;
char str[5];

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN);
wid_box=60; 
hei_box=60;
size=imagesize(0,0,359,189);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0);return 0;}
x=(info.right-info.left-359) / 2 ; y=(info.bottom-info.top-189) / 2 ;
getimage(x,y,x+359,y+189,mem0);

y1=y+70; x2=x+180; y4=y+30;
strcpy (file_1,path_name);
strcat (file_1,"ICD/RGB_choose.icw");
mem_menu= icWtomem (file_1);
areacls (x+1,y+1,x+358,y4-1,bkxr[0],bkxr[1],bkxr[2]);
areacls (x,y1,x+359,y1+119,128,128,128);
setcolor (0);
rectangle(x,y,x+359,y1-1);
line (x,y4,x+359,y4);
areacls(x+1,y4+1,x+358,y1-1,30,20,60);
setcolor(15);
line (x+1,y4+21,x+358,y4+21);
line(x+180,y4+1,x+180,y1-1);
line(x+179,y4+1,x+179,y1-1);

puticW(x,y1,mem_menu);
mem_int=mem_menu;
wid=*mem_int++;
// hei=*mem_int; // Δεν χρειαζόταν εδώ !

if (!keyb_gr) outnoto_col(x+125,y+1,"Make colors",0,chxr,bkxr); else outnoto_col(x+95,y+1,"Ftia'je xrv'mata",1,chxr,bkxr);

sprintf(str,"%03u",bkxr[0]); outsouv(x+15,y4+22,str,0);
sprintf(str,"%03u",bkxr[1]); outsouv(x+75,y4+22,str,0);
sprintf(str,"%03u",bkxr[2]);outsouv(x+135,y4+22,str,0);
sprintf(str,"%03u",chxr[0]);outsouv(x+195,y4+22,str,0);
sprintf(str,"%03u",chxr[1]);outsouv(x+255,y4+22,str,0);
sprintf(str,"%03u",chxr[2]);outsouv(x+315,y4+22,str,0);  
if (!keyb_gr) {outsouv(x+40,y4+1,"Background",0);
outsouv(x+255,y4+1,"Text",0);}
else {outsouv(x+72,y4+1,"Fo'nto",1);
outsouv(x+240,y4+1,"Proskh'nio",1);}
    

        do {
            kyk=-2; kyk1=-1; outmen=2;start=0;
             
              
        do {
        SDL_PollEvent(&sdlev);
        if (sdlev.type==SDL_KEYDOWN && sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) {kyk=-2; break;}
        if (sdlev.type==SDL_MOUSEWHEEL ) continue; 
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (mx>x && mx<x+360 && my>y1 && my < y1+120 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        x0=(mx-x)/60;
        y0=(my-y1)/60;
        kyk=(y0*6) + x0 ;
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (y0*wid*hei_box*2)+ (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+y0*hei_box+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; y3 = y0 ;
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(y3*wid*hei_box*2)+ (x3*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+y3*hei_box+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; y3 = y0 ;
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+(y0*wid*hei_box*2)+ (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+y0*hei_box+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(y3*wid*hei_box*2)+ (x3*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+y3*hei_box+f);}}
        start=0; kyk1=-1;refresh();} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen)) ;
        
         do {
            SDL_PollEvent(&sdlev);
            if (sdlev.type==SDL_KEYDOWN && sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE || kyk<0) {kyk=-2;break;}
            if (sdlev.button.button==SDL_BUTTON_RIGHT) {kyk=-2;break;}
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>x && mx<x+360 && my>y1 && my < y1+120 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
            outmen=0;
            x0=(mx-x)/60;
            y0=(my-y1)/60;
            kyk1=(y0*6) + x0 ;}
            else { outmen=1;  cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);}   
            
        switch (kyk) {
            case 0: if (bkxr[0]==255) continue; else {bkxr[0]++ ; sprintf(str,"%03u",bkxr[0]);areacls(x+15,y4+22,x+50,y1-1,30,20,60); outsouv(x+15,y4+22,str,0);break;}
            case 1: if (bkxr[1]==255) continue; else { bkxr[1]++ ; sprintf(str,"%03u",bkxr[1]);areacls(x+75,y4+22,x+115,y1-1,30,20,60); outsouv(x+75,y4+22,str,0);break;}
            case 2: if (bkxr[2]==255) continue; else { bkxr[2]++ ; sprintf(str,"%03u",bkxr[2]);areacls(x+135,y4+22,x+170,y1-1,30,20,60); outsouv(x+135,y4+22,str,0);break;}
            case 3: if (chxr[0]==255) continue; else {chxr[0]++ ; sprintf(str,"%03u",chxr[0]);areacls(x+195,y4+22,x+230,y1-1,30,20,60); outsouv(x+195,y4+22,str,0);break;}
            case 4: if (chxr[1]==255) continue; else {chxr[1]++ ; sprintf(str,"%03u",chxr[1]);areacls(x+255,y4+22,x+290,y1-1,30,20,60); outsouv(x+255,y4+22,str,0);break;}
            case 5: if (chxr[2]==255) continue; else {chxr[2]++ ; sprintf(str,"%03u",chxr[2]);areacls(x+315,y4+22,x+350,y1-1,30,20,60); outsouv(x+315,y4+22,str,0);break;}
            
            case 6: if (!bkxr[0]) continue ; else  { bkxr[0]-- ; sprintf(str,"%03u",bkxr[0]);areacls(x+15,y4+22,x+50,y1-1,30,20,60); outsouv(x+15,y4+22,str,0);break;}
            case 7: if (!bkxr[1]) continue ; else  { bkxr[1]-- ; sprintf(str,"%03u",bkxr[1]);areacls(x+75,y4+22,x+115,y1-1,30,20,60); outsouv(x+75,y4+22,str,0);break;}
            case 8: if (!bkxr[2]) continue ; else  { bkxr[2]-- ; sprintf(str,"%03u",bkxr[2]);areacls(x+135,y4+22,x+170,y1-1,30,20,60); outsouv(x+135,y4+22,str,0);break;}
            
            case 9: if (!chxr[0]) continue ; else  { chxr[0]-- ; sprintf(str,"%03u",chxr[0]);areacls(x+195,y4+22,x+230,y1-1,30,20,60); outsouv(x+195,y4+22,str,0);break;}
            case 10: if (!chxr[1]) continue ; else { chxr[1]-- ; sprintf(str,"%03u",chxr[1]);areacls(x+255,y4+22,x+290,y1-1,30,20,60); outsouv(x+255,y4+22,str,0);break;}
            case 11: if (!chxr[2]) continue ; else  { chxr[2]-- ; sprintf(str,"%03u",chxr[2]);areacls(x+315,y4+22,x+350,y1-1,30,20,60); outsouv(x+315,y4+22,str,0);break;}
            }
        areacls (x+1,y+1,x+358,y4-1,bkxr[0],bkxr[1],bkxr[2]);
        if (!keyb_gr) outnoto_col(x+125,y+1,"Make colors",0,chxr,bkxr); else outnoto_col(x+95,y+1,"Ftia'je xrv'mata",1,chxr,bkxr);
        refresh();
       
             
        } while (sdlev.type != SDL_MOUSEBUTTONUP && sdlev.button.button==SDL_BUTTON_LEFT && (!outmen) && kyk==kyk1);
          
        if (kyk>0){
         //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(y3*wid*hei_box*2)+ (x3*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+y3*hei_box+f);}}
        refresh();}
        
    } while (sdlev.button.button!=SDL_BUTTON_RIGHT && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;
    
putimage(x,y,mem0,0);
refresh();
free(mem0);
free(mem_menu);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return(1);
}

int alert (int id,char *seleo,char *seleo1)
{
SDL_Cursor* cursor;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int neg;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;
char file_10 [1024];

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

 do {
        if (!SDL_PollEvent(&sdlev)) continue ;
} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chrxr[0]=255;chrxr[1]=10;chrxr[2]=20;
size=imagesize(0,0,399,299);
mem0=malloc(size);
if (!mem0) {printf ("Alert Function - Out of memory !! \n"); return 0;}
x=(info.right-info.left-399) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+399,y+299,mem0);
xp=x;
y1=y+219;
x+=92;
strcpy (file_10,path_name);
strcat (file_10,"ICD/notif_1.ico");
mem_alert=icontomem (file_10,255);
strcpy (file_10,path_name);
strcat (file_10,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_10);

setcolor(14);
rectangle(xp,y,xp+399,y+299);
rectangle(xp+5,y+5,xp+394,y+294);
_areacls (xp+1,y+1,xp+398,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+395,y+5,xp+398,y+298,255,165,0);
_areacls (xp+5,y+295,xp+394,y+298,255,165,0);
cbkxr[0]=cbkxr[1]=20; cbkxr[2]=60;
_areacls (xp+6,y+6,xp+393,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+155,y+10,"A L E R T",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+156,y+10,"A L E R T",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+265,y+33);
line (xp+150,y+35,xp+260,y+35);
refresh();
}
else {
outnoto_col(xp+145,y+10,"P R O S O X H",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+146,y+10,"P R O S O X H",1,chrxr,cbkxr);
setcolor (4);
line (xp+135,y+33,xp+320,y+33);
line (xp+140,y+35,xp+315,y+35);
refresh();    
}
xr=xp+392;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! Μπορώ μέχρι και y4+80 (seleo1) (2 γραμμές) .
i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        chrxr[0]=120;chrxr[1]=181;chrxr[2]=117;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
        green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
        blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=255;chrxr[1]=142;chrxr[2]=63;

    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Alert Function - Out of memory !! \n"); free(mem0); return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
                yc+=16;xc=x4;
    }
    
    if (yc<=y4+80) {
        if (seleo1!=NULL)  {
        size=strlen(seleo1);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Alert Function - Out of memory !! \n"); free(mem0); return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo1[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo1[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo1[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo1[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo1[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo1[f];}}
            
            str[a]=255;
                        
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }}
    
refresh();
mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        if (sdlev.type==SDL_QUIT) {mx=x+170;my=y1+30;enter_go=1;break;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά

        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

fidicls(xp, y,xp+399,y+299, 65,80,225);  
putimage(xp,y,mem0,0);
refresh();
free(mem0);
free(mem_menu);
free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return((int)kyk);
}

void *sfalmata()
{
unsigned short int file_flag,ar,f;
FILE *fp;
int pedb[4] , pedc;
void *mem;

pedb[0]=358910; pedb[1]=762343; pedb[2]=4443; pedb[3]=2330;

// ΔΙΑΒΑΣΜΑ ΑΠΟ ΔΙΣΚO ΟΛΩΝ ΤΩΝ ΜΗΝΥΜΑΤΩΝ ΛΑΘΟΥΣ κλπ κλπ
file_flag=0;
strcpy (file_1,path_name);
strcat (file_1,"Errors.inp");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf ("Missing File ( %s ) \n",file_1);return NULL;}
for (f=0 ; f<4 ; f++) {
fread(&pedc,4,1,fp);
if (feof(fp)) { file_flag=1; break; }
if (pedc!=pedb[f]) {file_flag=1;break;}}
if (file_flag) {printf ("Bad File ( %s ) \n",file_1); return NULL;}
fread(&ar,2,1,fp);
mem=malloc(ar);
if (!mem) {printf ("Error Alerts Reading - Out of memory !! \n"); fclose (fp); return 0;}
fread(mem,1,ar,fp);
if (ferror(fp)) { clearerr(fp); fclose (fp); printf ("Probably Disk Error ( %s ) \n",file_1); return NULL;}
fclose (fp);
return mem;
}

void information (int id,char *seleo,char *seleo1)
{
SDL_Cursor* cursor;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, start , x4,y4,ymy,xc,yc,xr,a,hei_box;
unsigned int size ,wid ,neg ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1 , *mem_int ;
short int kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;
char file_10[1024];

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);


size=imagesize(0,0,399,299);
mem0=malloc(size);
if (!mem0) {printf ("Information Function - Out of memory !! \n"); return ;}
x=(info.right-info.left-399) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+399,y+299,mem0);
xp=x;
y1=y+219;
x+=162;
strcpy (file_10,path_name);
strcat (file_10,"ICD/info.ico");
mem_alert=icontomem (file_10,255);
strcpy (file_10,path_name);
strcat (file_10,"ICD/Sym_OK.ico");
mem_menu= icontomem (file_10,255);
hei_box=75;
setcolor(14);
rectangle(xp,y,xp+399,y+299);
rectangle(xp+5,y+5,xp+394,y+294);
_areacls (xp+1,y+1,xp+398,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+395,y+5,xp+398,y+298,255,165,0);
_areacls (xp+5,y+295,xp+394,y+298,255,165,0);
cbkxr[0]=55; cbkxr[1]=70; cbkxr[2]=220;
_areacls (xp+6,y+6,xp+393,y+293,55,70,220);

_puticon(xp+7,y+7,mem_alert,255);
_puticon(x,y1,mem_menu,255);
refresh();
chrxr[0]=0;chrxr[1]=0;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+165,y+10,"I N F O",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"I N F O",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+265,y+33);
line (xp+150,y+35,xp+260,y+35);
refresh();
}
else {
outnoto_col(xp+145,y+10,"P R O S O X H",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+146,y+10,"P R O S O X H",1,chrxr,cbkxr);
setcolor (4);
line (xp+135,y+33,xp+320,y+33);
line (xp+140,y+35,xp+315,y+35);
refresh();    
}
xr=xp+392;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! Μπορώ μέχρι και y4+80 (seleo1) (2 γραμμές) .

i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        chrxr[0]=162;chrxr[1]=255;chrxr[2]=105;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
        green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
        blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=255;chrxr[1]=153;chrxr[2]=105;
    
    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL && seleo[0]!='\0') {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Information Function - Out of memory !! \n"); free(mem0); return ;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
                yc+=16;xc=x4;
    }
    
    if (yc<=y4+80) {
        if (seleo1!=NULL && seleo1[0]!='\0')  {
        size=strlen(seleo1);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Information Function - Out of memory !! \n"); free(mem0); return ;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo1[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo1[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo1[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo1[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo1[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo1[f];}}
            
            str[a]=255;
                        
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }}
    
    refresh();

mem_int=mem_menu;
wid=*mem_int;

kyk=-2; outmen=2;start=0;
chrxr[0]=255;chrxr[1]=0;chrxr[2]=255;      
              
        do {
        SDL_PollEvent(&sdlev);
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        if (sdlev.type==SDL_QUIT)  {mx=x+60;my=y1+30;enter_go=1;}
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (sdlev.type==SDL_KEYDOWN && sdlev.key.keysym.scancode==SDL_SCANCODE_RETURN) {mx=x+60;my=y1+30;enter_go=1;}
        if (mx>x && mx<x+75 && my>y1 && my < y1+75 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά

        
        if (!start) {
        mem_efedr1 = mem_menu+8;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*4));
        for (i=0;i<wid-1;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (chrxr[0] * co.rgb[2]) / 255;
        green =  (chrxr[1] * co.rgb[1]) / 255;
        blue =  (chrxr[2] * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (x+i,y1+f);}}
        refresh();
        start=1;
       }
       kyk=0;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }
         continue ;    
        }
        else {
        if (start) {
        puticon(x,y1,mem_menu,255);
        start=0; kyk=-1;} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
           
fidicls(xp, y,xp+399,y+299, 65,80,225);  
putimage(xp,y,mem0,0);
refresh();
free(mem0);
free(mem_menu);
free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return;
}

int inkualizer (int gfont, int *chrxr , int *bkgxr, int *selxr)
{
FILE *fp , *fpera;
int fide_sort , fide_fpera , fide_doms ;
SDL_Cursor* cursor;
void *mem0 , *mem_zer, *mem_bal, *mem_ok ,*mem_anak , *mem_pick, *mem_propick , *mem_txt , *mem_sel , *mem_cu;
void *mem_arrs , *mem_top , *mem_save , *ef_mem ;
int *mem_int;
short int *ar_dom ;
int xt1,yt1,xb1,yb1;
unsigned short int xt,yt,xb,yb,xzer,yzer,xok,yok,xtepi,ytepi,xanak,yanak,zone,xseltxt,yseltxt,fyge=0,x1,y1;
unsigned short int probal , tyx, protyx, proenter, proanak , textor ,diak=0, marrs=0 , save_cols , xsave , ysave ,user_ans , plxr ,key ;
short int plera=0 ,thesi ;
int nowcol[3];
int fonto[3];
int chrpnt[3];
int cbrown[3];
char str[5];
int randchrxr[10][3];
int randbkgxr[10][3];
int testchrxr[3] , testbkgxr[3] ;
unsigned int a , a1 , time_metr=0;
int mx,my,mx1,my1,dx, dy,red,green,blue;
unsigned short int apejo=0;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union disk_bkxr{
    int dbkxr;
    unsigned char dbkrgb[4];
};

union disk_chxr{
    int dchxr;
    unsigned char dchrgb[4];
};

union disk_sexr{
    int dsexr;
    unsigned char dsergb[4];
};

struct disk_ink {
    union disk_bkxr dback;
    union disk_chxr dfront;
    union disk_sexr dsel;
} dink , dink1;

struct meter {
unsigned short int recxt;
unsigned short int recyt;
unsigned short int recxb;
unsigned short int recyb;
unsigned short int balxt;
unsigned short int balyt;
unsigned short int balxb;
unsigned short int balyb;
unsigned short int numxt;
unsigned short int numyt;
unsigned short int numxb;
unsigned short int numyb;
void *mem_bbal;
unsigned int curval;
unsigned int oldval;
} zer[6];

unsigned int testselxr[3];
unsigned int ef_curval[6];
int ef_testbkgxr[3];

int maxcol[6][3];
register int i,f;

unsigned char izer[16];
short int rizos;

rizos = 26 - myfont_hei[gfont];
textor=0;

zer[0].curval=chrxr[0] ; zer[1].curval=chrxr[1] ; zer[2].curval=chrxr[2] ;
zer[3].curval=bkgxr[0] ; zer[4].curval=bkgxr[1] ; zer[5].curval=bkgxr[2] ;

maxcol[0][0]=230 ; maxcol[0][1]=maxcol[0][2]=0;
maxcol[1][0]=0 ; maxcol[1][1]=230; maxcol[1][2]=0;
maxcol[2][0]=0 ; maxcol[2][1]=0; maxcol[2][2]=230;

maxcol[3][0]=230 ; maxcol[3][1]=maxcol[3][2]=0;
maxcol[4][0]=0 ; maxcol[4][1]=230; maxcol[4][2]=0;
maxcol[5][0]=0 ; maxcol[5][1]=0; maxcol[5][2]=230;

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrpnt[0]=150 ; chrpnt[1]=255 ; chrpnt[2]=177 ; 

mem0=malloc(601608); //400 x 376
if (mem0==NULL) {information(2-keyb_gr,NULL,NULL);return 0;}
mem_top=malloc(30408); // 19x19 
if (mem_top==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0); return 0;}
xt=(info.right-info.left-400) / 2 ; yt1=(info.bottom-info.top-395) / 2 ;
yt=yt1+19; xb=xt+399 ; yb=yt+375;


getimage(xt,yt,xb,yb,mem0);

strcpy (str1024,"Inkualizer..");
normtext_tomy(str1024,izer);

// EPIKEFALIDA
getimage(xt,yt1,xb,yt1+18,mem_top);  // putimage(xt,yt-19,mem_top,0);
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown);
setcolor(5);
rectangle (xt,yt1,xb,yt1+18) ; 
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_top); free(mem0); return 0;} 
puticon(xt+1,yt1+1,mem_arrs,255);

/*
mem_int=(mem_arrs +8) ; 
for (f=0;f<17;f++) {
  
  for(i=0 ; i < 17; i++) {
   co.lor= *(mem_int++);
   if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));        
   _putpixel (xt+1+i,yt1+1+f);}}} 
refresh(); 
*/

if (keyb_gr) {
a1=(xb-xt-88)/2;
outsouv_col(xt+a1,yt1+1,"XRVMATA",1,chrpnt,cbrown);} else { a1=(xb-xt-60)/2; outsouv_col(xt+a1,yt1+1,"COLORS",0,chrpnt,cbrown);}

// TELOS EPIKEFALIDAS

setcolor(5);
rectangle(xt,yt,xb,yb);


areacls(xt+1,yt+1,xb-1,yb-1,0,0,0);
fonto[0]= 20; fonto[1]=fonto[2]=100;
bareacls(xt+1,yt+61,xt+245,yt+76,fonto);
setcolor(5);
line (xt+1,yt+60,xt+246,yt+60);
// line (xt+1,yt+77,xb-1,yt+77);  //line (xt+1,yt+77,xt+246,yt+77);
line (xt+246,yt+1,xt+246,yb-1);
line (xt+1,yt+39,xt+246,yt+39);
line (xt+124,yt+40,xt+124,yb-1);   //line (xt+124,yt+40,xt+124,yt+76);
//rectangle (xt+2,yt+2,xt+244,yt+27);

xok=xt+362;
xseltxt=xt+248 ; yseltxt=yanak=yok=ysave=yb-36;
xanak = xt+286 ; 
xsave=xanak+39;
xzer=xt+2; yzer=yt+79;
xtepi=xt+247;ytepi=yt+77;
for (f=1;f<11;f++) line (xtepi,ytepi+f*26,xb-1,ytepi+f*26);

//setcolor(2);
//rectangle (xt+2,yt+2,xt+244,yt+27);
if (!keyb_gr) {
outnoto(xtepi+35,yt+15,"Random",0);
outnoto(xtepi+15,yt+40,"Suggestions",0);}
else {
outnoto(xtepi+35,yt+15,"Tyxai'ew",1);
outnoto(xtepi+30,yt+40,"Epiloge'w",1);}    


strcpy (file_1,path_name);
strcat (file_1,"ICD/xrolizer.ico");
mem_zer=icontomem (file_1,255);
if (mem_zer==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0); free(mem_arrs);free(mem_top); return 0;}
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); return 0;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/button_col.ico");
mem_bal= icontomem (file_1,255);
if (mem_bal==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_arrs);free(mem_top); return 0;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Repeat35.ico");
mem_anak= icontomem (file_1,255);
if (mem_anak==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_arrs);free(mem_top); return 0;}
strcpy (file_1,path_name);
strcat (file_1,"ICD/color-picker.ico");
mem_pick= icontomem (file_1,255);
if (mem_pick==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_arrs);free(mem_top); return 0;}

mem_propick=malloc(2508);
if (mem_propick==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_pick); free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); return 0;}
strcpy (file_1,path_name);
strcat (file_1,"ICD/text_cursor.ico");
mem_txt= icontomem (file_1,255);
if (mem_txt==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);return 0;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Save_35.ico");
mem_save= icontomem (file_1,255);
if (mem_save==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);return 0;}


_areacls(xzer,yzer,xzer+243,yzer+295,200,200,200);
_puticon(xzer,yzer,mem_zer,255);
setcolor(5);
line (xt+124,yt+40,xt+124,yb-1); 
line (xt+123,yt+40,xt+123,yb-1);
refresh();
free(mem_zer);

strcpy (file_1,path_name);
strcat (file_1,"ICD/th_text_curs.ico");
mem_sel= icontomem (file_1,255);
if (mem_sel==NULL) {information(2-keyb_gr,NULL,NULL); free(mem_save); free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick); free(mem_arrs);free(mem_top); return 0;}
mem_cu=malloc(1048);
if (mem_cu==NULL) {information(2-keyb_gr,NULL,NULL); free(mem_save); free(mem_sel); free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);free(mem_arrs);free(mem_top); return 0;}


zer[0].recxt=xzer+6; zer[0].recxb=zer[0].recxt+30;
zer[0].recyb=zer[1].recyb=zer[2].recyb=zer[3].recyb=zer[4].recyb=zer[5].recyb=yb-21; 
zer[1].recxt=zer[0].recxb+11 ; zer[1].recxb=zer[1].recxt+29;
zer[2].recxt=zer[1].recxb+10 ; zer[2].recxb=zer[2].recxt+31;
zer[3].recxt=zer[2].recxb+9 ; zer[3].recxb=zer[3].recxt+31;
zer[4].recxt=zer[3].recxb+9 ; zer[4].recxb=zer[4].recxt+31;
zer[5].recxt=zer[4].recxb+9 ; zer[5].recxb=zer[5].recxt+31;
zer[0].numyt=zer[1].numyt=zer[2].numyt=zer[3].numyt=zer[4].numyt=zer[5].numyt=yt+60;
zer[0].numyb=zer[1].numyb=zer[2].numyb=zer[3].numyb=zer[4].numyb=zer[5].numyb=yzer-3;


if (!keyb_gr) {outsouv(xt+134,yt+41,"Background",0);
outsouv(xt+50,yt+41,"Text",0);}
else {outsouv(xt+155,yt+41,"Fo'nto",1);
outsouv(xt+27,yt+41,"Proskh'nio",1);}
_puticon (xok,yok,mem_ok,255);
_puticon (xanak,yanak,mem_anak,255);
_puticon (xseltxt,yseltxt,mem_txt,255);
_puticon (xsave,ysave,mem_save,255);

for (f=0;f<6;f++) { 
    zer[f].recyt=zer[f].recyb-zer[f].curval;
   
    zer[f].oldval=zer[f].curval;
    switch (f) {
        case 0 :
        case 3 :
            nowcol[0]=zer[f].curval; nowcol[1]=nowcol[2]=0;break;
        case 1:
        case 4:
            nowcol[1]=zer[f].curval; nowcol[0]=nowcol[2]=0;break;
        case 2:
        case 5:
            nowcol[2]=zer[f].curval; nowcol[0]=nowcol[1]=0;
    }
    
    bareacls(zer[f].recxt,zer[f].recyt,zer[f].recxb,zer[f].recyb,nowcol);
    zer[f].balxt=zer[f].recxt-3;zer[f].balxb=zer[f].balxt+37;
    zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
    zer[f].mem_bbal=malloc(5784);
    if (zer[f].mem_bbal==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); return 0;}
    getimage (zer[f].balxt,zer[f].balyt,zer[f].balxb,zer[f].balyb, zer[f].mem_bbal);
    _puticon (zer[f].balxt,zer[f].balyt,mem_bal,255);
    zer[f].numxt=zer[f].recxt; zer[f].numxb=zer[f].numxt+33;
    sprintf(str,"%03u",zer[f].curval);
    _outsouv_col(zer[f].numxt,zer[f].numyt+1,str,0,&maxcol[f][0],fonto);
}

_bareacls (xt+3,yt+3,xt+243,yt+35,bkgxr);
//_outnoto_col(xt+76,yt+5,"Inkualizer..",0,chrxr,bkgxr);
_outmystr_col (gfont, izer , xt+76, yt+5+rizos, xt+243, chrxr,bkgxr);
refresh();

for (f=0;f<10;f++) {
    for (i=0;i<3;i++) {
    a=random(2);
    randchrxr[f][i]= (a) ? chrxr[i]+random(80) : chrxr[i] - random(80);
    if (randchrxr[f][i]<0) randchrxr[f][i]=255;
    if (randchrxr[f][i]>255) randchrxr[f][i]=0;
    
    randbkgxr[f][i]= (a) ? bkgxr[i]+random(80) : bkgxr[i] - random(80);
    if (randbkgxr[f][i]<0) randbkgxr[f][i]=255;
    if (randbkgxr[f][i]>255) randbkgxr[f][i]=0;
     }
    _bareacls (xtepi+1,ytepi+1+f*26,xb-1,ytepi+25+f*26,&randbkgxr[f][0]);
    if (!keyb_gr) {
    _outnoto_col (xtepi+20 , ytepi+2+f*26 , "Abcde.." , 0 , &randchrxr[f][0] , &randbkgxr[f][0]);}
    else {
   _outnoto_col (xtepi+20 , ytepi+2+f*26 , "Abgde.." , 1 , &randchrxr[f][0] , &randbkgxr[f][0]);}     
}
refresh();
zone=6;
probal=6;
protyx=10;
proenter = proanak = save_cols = 0 ;
for (f=0;f<3;f++) {
testchrxr[f]=chrxr[f]; // testchrxr[1]=chrxr[1]; testchrxr[2]=chrxr[2];
testbkgxr[f]=bkgxr[f]; // testbkgxr[1]=bkgxr[1]; testbkgxr[2]=bkgxr[2];
testselxr[f] = selxr[f] ;
}

do {
    
    if (textor==2) {
    time_metr++;
        if (time_metr>150000) {
            time_metr=0;
                if (diak) {
                putimage(xt+65, yt+5 , mem_cu , 0); 
                refresh();
                diak=0;
                }
        else {
        diak=1 ;
        // Ζωγραφίζει έναν text selector
        for (f=0;f<26;f++) {
        mem_int=(mem_sel +8 + (f*10*4));
        for (i=0;i<10;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        a1=255-co.rgb[2];
        red =  abs( (testbkgxr[0]*co.rgb[2]/255) - (testchrxr[0]*a1/255) );
        a1=255-co.rgb[1];
        green =  abs( (testbkgxr[1]*co.rgb[1]/255) - (testchrxr[1]*a1/255) );
        a1=255-co.rgb[0];
        blue =  abs( (testbkgxr[2]*co.rgb[0]/255) - (testchrxr[2]*a1/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel (xt+65+i , yt+5+f);}}
        refresh();
            }
        }
    }
    
   if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
   if (mx>xzer+3 && mx<xzer+240 && my>yzer+18 && my<yzer+296){  //Κίνηση εντός 6 ζωνών !!

       x1=mx-xzer-4; zone=x1/40; if (zone>5) zone=6;
       
       
       if (protyx!=10) {
           putimage (xtepi+120,ytepi+1+protyx*26,mem_propick,0);
            protyx=10;
            refresh();    
                                }
                                
        else if (textor==1) { textor = 0 ; _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); puticon(xseltxt,yseltxt,mem_txt,255);}
                            
        else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
        else if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}
        
        else if (save_cols==1) { save_cols = 0 ; puticon(xsave,ysave,mem_save,255);}
        
        else if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
       */
        
       if ( ((zone<3)  && (textor==2)) || (zone==6) ) { 
            if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
            if (apejo) continue;
            apejo=1;
           cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor); 
    
            continue ;}
            
       if (apejo) {
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);}
       apejo=0;
       a1= (textor==2) ? 3 :0 ;
       for (a=a1;a<6;a++) {
           if (mx>zer[a].balxt && mx<zer[a].balxb && my>zer[a].balyt && my<zer[a].balyb) {
               // KAPOIA MPALA AGGIZEI !!
                
               if (probal==6) {    // GIA PROTH FORA AGGIZEI MPALA
               
                    for (f=0;f<38;f++) {
                    mem_int=(mem_bal+8 + (f*38*4));
                    for (i=0;i<38;i++) {
                    co.lor = *mem_int++;
                    if (!co.rgb[3]) continue;
                    red =  abs(255-co.rgb[2]) ;
                    green = abs(255-co.rgb[1]) ;
                    blue =  abs(255-co.rgb[1]) ;
                    setcolor(COLOR (red,green,blue));
                    _putpixel (zer[a].balxt+i , zer[a].balyt+f);}}
                    refresh();
                    probal=a;
                   break ;
                }
                else 
                {
                if (probal==a) break; // PARAMENEI STHN IDIA MPALA
                puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
                // BAFEI NEA MPALA
                for (f=0;f<38;f++) {
                mem_int=(mem_bal+8 + (f*38*4));
                for (i=0;i<38;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  abs(255-co.rgb[2]) ;
                green = abs(255-co.rgb[1]) ;
                blue =  abs(255-co.rgb[1]) ;
                setcolor(COLOR (red,green,blue));
                _putpixel (zer[a].balxt+i , zer[a].balyt+f);}}
                refresh();
                probal=a;
                break;
                }
           }
           
       } // TELOS LOOP GIA TIS EJI MPALES
       if (a==6) { // ENTOS ZVNVN ALLA OXI SE MPALA
            if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
           }
           continue;
   } 
   else //  TO MOUSE EINAI EKTOS TVN 6 ZVNVN !!
   {
       zone=6;
       if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
   
    if (mx>xtepi && mx<xb && my>ytepi && my<ytepi+259) { // PONTIKI ENTOS 10 TYXAIVN EPILOGVN
        
    apejo=0;
    if (textor==1) { textor = 0 ; _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); puticon(xseltxt,yseltxt,mem_txt,255);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}
    else if (save_cols==1) { save_cols = 0 ; puticon(xsave,ysave,mem_save,255);}
    else if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
    */
        
    if (textor!=2) {

    y1=my-ytepi; tyx=y1/26;
    
    if (tyx==protyx) continue;
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    if (protyx==10) { // EPILEGV GIA PRVTH FORA KOYTI
        getimage (xtepi+120,ytepi+1+tyx*26,xtepi+144,ytepi+25+tyx*26,mem_propick);
        puticon(xtepi+120,ytepi+1+tyx*26,mem_pick,255);
        protyx=tyx;
        continue;
        }
        else {          // protyx != tyx
        putimage ((xtepi+120), (ytepi+1+protyx*26),mem_propick,0);
        getimage (xtepi+120,ytepi+1+tyx*26,xtepi+144,ytepi+25+tyx*26,mem_propick);
        puticon(xtepi+120,ytepi+1+tyx*26,mem_pick,255);
        protyx=tyx;
        continue;
        }
    }
    }
    // PONTIKI EKTOS 10 TYXAIVN EPILOGVN
     if (protyx!=10) {
     putimage ((int) (xtepi+120),(int) (ytepi+1+protyx*26),mem_propick,0);
     refresh();
     protyx=10;    
    }
    
     if (mx>xseltxt && mx<xseltxt+35 && my>yseltxt && my<yseltxt+35) { // PONTIKI STO SELECT TEXT (textor)
         
         if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
         else if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}
        else if (save_cols==1) { save_cols = 0 ; puticon(xsave,ysave,mem_save,255);}
         else if (marrs) {
        marrs=0;
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }

         if (apejo) {
         cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
         SDL_SetCursor(cursor);}
         apejo=0;
         if (textor) continue;
         
          // BAFEI SELECT CURSOR
        for (f=0;f<35;f++) {
        mem_int=(mem_txt +8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  abs(255-co.rgb[2]);
        green =  abs(255-co.rgb[1]);
        blue =  abs(255-co.rgb[0]) ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xseltxt+i , yseltxt+f);}}
        refresh();
        textor=1;
        continue; 
     }
     // PONTIKI EKTOS SELECT TEXT
     
     if (textor==1) { textor = 0 ; _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); puticon(xseltxt,yseltxt,mem_txt,255);}
     
     if (mx>xsave && mx<xsave+35 && my>ysave && my<ysave+35) { // PONTIKI STO SAVE
         
         apejo=0;
     
          if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
         else if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}
         else if (textor==1) { textor = 0 ; _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); puticon(xseltxt,yseltxt,mem_txt,255);}
         else if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}

        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
            
         if (save_cols) continue;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
         SDL_SetCursor(cursor);
         
        
         
          // BAFEI DISKETA
        for (f=0;f<35;f++) {
        mem_int=(mem_save +8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  abs(255-co.rgb[2]);
        green =  abs(255-co.rgb[1]);
        blue =  abs(255-co.rgb[0]) ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xsave+i , ysave+f);}}
        refresh();
        save_cols=1;
        continue; 
         
    }
    
    // PONTIKI EKTOS SAVE
    
    if (save_cols==1) { save_cols = 0 ; puticon(xsave,ysave,mem_save,255);}
         
    if (mx>xanak && mx<xanak+35 && my>yanak && my<yanak+35) { // PONTIKI STHN ANAKYKLVSH
    
     apejo=0;
     if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
     else if (marrs) {
        marrs=0;
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
     if (proanak) continue;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    
      // BAFEI ANAKYKLVSH
        for (f=0;f<35;f++) {
        mem_int=(mem_anak+8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (255 * co.rgb[2]) / 255;
        green =  (0 * co.rgb[1]) / 255;
        blue =  (255 * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xanak+i , yanak+f);}}
        refresh();
     proanak=1;
     continue;
    }
    // PONTIKI EKTOS ANAKYKLVSHS
    
    if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}

    
    if (mx>xok && mx<xok+35 && my>yok && my<yok+35) { // PONTIKI STO OK
        
        apejo=0;
        
        if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
        
        if (proenter) continue;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);

        //BAFEI ENTER
        for (f=0;f<35;f++) {
        mem_int=(mem_ok +8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (255 * co.rgb[2]) / 255;
        green =  (0 * co.rgb[1]) / 255;
        blue =  (255 * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xok+i , yok+f);}}
        refresh();
     proenter=1;
     continue;
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    
        apejo=0;
        if (!marrs) {

        marrs=1;
        putNOTicon(xt,yt-18,mem_arrs);
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        /*
        setcolor ( COLOR ( 255 , 255 , 0 ) );  
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR( co.rgb[2], co.rgb[1]+80, co.rgb[0]) ) ; _putpixel (xt+i,yt-18+f);}}} 
        refresh();
        */
        continue ;}
        else continue ;
        continue; }
        
        apejo=1;
        if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
    
}
          
        if (!apejo) continue;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
    
   continue;
            
           
   
    case SDL_MOUSEBUTTONDOWN:
        
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
            if (proanak) {
            if (keyb_gr) information(0,"Μπορείτε να βλέπετε τυχαία χρώματα φόντου και κειμένου. Κάνοντας κλικ προκύπτουν κάθε φορά άλλα χρώματα. Επιλέγοντας κάτι , το  περνάτε στον αναλυτή  χρωμάτων και  το δια- φοροποιείτε όπως θέλετε!",0);
            else information(0,"You can see random text and background co- lors. With every click you take different va- riations. If you choose a variation ,you pass the choice in the color analyzer to make it   as you prefer.",0); 
            
        }
           else if (textor) {
               if (keyb_gr) {information (0,"Εδώ καθορίζετε το χρώμα επιλογής κειμένου. Όσο ασχολείστε με αυτό , ένας δείκτης ανα - βοσβήνει αριστερά  από  το  δείγμα  ενώ,δεν μπορεί να επηρεασθεί το χρώμα του κειμένου ή του φόντου ! Όταν τελειώσετε με το  χρώ- μα επιλογής, κάνετε πάλι κλικ εδώ!",0);}
               else {information(0,"You can define the text selection color here.A cursor is blinking during this procedure.\nThe  text  and  the background colors\nare not affected.","After you fix the selection color , click here again.");}
               
        }


           continue ; } 
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if (probal!=6) {
           if ( (probal<3) && (textor==2) ) break ;
           cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
           SDL_SetCursor(cursor);

           fyge=0;
           do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           my1 = sdlev.button.y ;
           dy = my1- (int)(zer[probal].recyt) ;
           if (!dy) continue ;
           // if ((!dy) || (abs(dy)<4)) continue;
           
           if (dy>0){
               zer[probal].curval = (zer[probal].curval > dy) ? zer[probal].curval-dy : 0 ;
                    if ( (!zer[probal].oldval) && (!zer[probal].curval) ) break; 
                    }
            else { 
                zer[probal].curval+=abs(dy) ;
                if (zer[probal].curval>255) zer[probal].curval = 255;
                 if ( (zer[probal].oldval==255) && (zer[probal].curval==255) ) break;
                    }

         zer[probal].oldval =  zer[probal].curval ;            
        putimage (zer[probal].balxt , zer[probal].balyt , zer[probal].mem_bbal , 0 ); 
        // bareacls( zer[probal].numxt , zer[probal].numyt ,zer[probal].numxb , zer[probal].numyb , fonto );
        
                  setcolor ( COLOR (fonto[0],fonto[1],fonto[2]) );
        for (i=zer[probal].numxt;i<=zer[probal].numxb;i++) {
            for (f= zer[probal].numyt+1 ; f<=zer[probal].numyb; f++) _putpixel (i,f);}
            
        if (probal<3) {
        testchrxr[probal] = zer[probal].curval ; }
        else {
        testbkgxr[probal-3] = zer[probal].curval; }
        
        zer[probal].recyt=zer[probal].recyb-zer[probal].curval;
        
        
            switch (probal) {
                case 0 :
                case 3 :
                    nowcol[0]=zer[probal].curval; nowcol[1]=nowcol[2]=0;break;
                case 1:
                case 4:
                    nowcol[1]=zer[probal].curval; nowcol[0]=nowcol[2]=0;break;
                case 2:
                case 5:
                    nowcol[2]=zer[probal].curval; nowcol[0]=nowcol[1]=0;
            }
            
        //areacls(zer[probal].recxt,yzer+21,zer[probal].recxb,zer[probal].recyb,200,200,200);
        setcolor ( COLOR (200,200,200) );
        for (i=zer[probal].recxt;i<=zer[probal].recxb;i++) {
            for (f= yzer+20 ; f<=zer[probal].recyb; f++) _putpixel (i,f);}
            
        // bareacls(zer[probal].recxt, zer[probal].recyt, zer[probal].recxb , zer[probal].recyb,nowcol);
        
          setcolor ( COLOR (nowcol[0],nowcol[1],nowcol[2]) );
        for (i=zer[probal].recxt;i<=zer[probal].recxb;i++) {
            for (f= zer[probal].recyt ; f<=zer[probal].recyb; f++) _putpixel (i,f);}
        
        zer[probal].balyt=zer[probal].recyt-18; zer[probal].balyb=zer[probal].balyt+37;
        getimage (zer[probal].balxt,zer[probal].balyt,zer[probal].balxb,zer[probal].balyb, zer[probal].mem_bbal);
        puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255);
        sprintf(str,"%03u",zer[probal].curval);
        outsouv_col(zer[probal].numxt,zer[probal].numyt+1,str,0,&maxcol[probal][0],fonto);

        // bareacls (xt+3,yt+3,xt+243,yt+26,testbkgxr);
        if (textor!=2) { 
          setcolor ( COLOR (testbkgxr[0],testbkgxr[1],testbkgxr[2]) );
        for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}        
        
        //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr);}
        _outmystr_col (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);refresh();}
        else {
            setcolor ( COLOR (ef_testbkgxr[0],ef_testbkgxr[1],ef_testbkgxr[2]) );
            for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}
            
            //outnoto_colsel(xt+76,yt+5,"Inkualizer..",0,testchrxr,ef_testbkgxr,testbkgxr);
            _outmystr_colsel (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,ef_testbkgxr,testbkgxr);
            refresh();
            getimage (xt+65, yt+5 , xt+74, yt+30, mem_cu);
            diak=1 ; time_metr=0;
            
             // Ζωγραφίζει έναν text selector
            for (f=0;f<26;f++) {
            mem_int=(mem_sel +8 + (f*10*4));
            for (i=0;i<10;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            a1=255-co.rgb[2];
            red =  abs( (testbkgxr[0]*co.rgb[2]/255) - (testchrxr[0]*a1/255) );
            a1=255-co.rgb[1];
            green =  abs( (testbkgxr[1]*co.rgb[1]/255) - (testchrxr[1]*a1/255) );
            a1=255-co.rgb[0];
            blue =  abs( (testbkgxr[2]*co.rgb[0]/255) - (testchrxr[2]*a1/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel (xt+65+i , yt+5+f);}}
            refresh();
        }

        } while (sdlev.type != SDL_MOUSEBUTTONUP && (!fyge) );
        
        fyge=0;
        
        // BAFEI NEA MPALA
        for (f=0;f<38;f++) {
        mem_int=(mem_bal+8 + (f*38*4));
        for (i=0;i<38;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  abs(255-co.rgb[2]) ;
        green = abs(255-co.rgb[1]) ;
        blue =  abs(255-co.rgb[1]) ;
        setcolor(COLOR (red,green,blue));
        _putpixel (zer[probal].balxt+i , zer[probal].balyt+f);}}
        refresh();            
        continue;
       }
       
       else if (zone!=6) {  // KLIK SE ZONH (OXI SE MPALA)
 
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
           SDL_SetCursor(cursor);
           
           my1 = sdlev.button.y ;
           dy = my1- (int)(zer[zone].recyt) ;  

           if ((!dy) || (abs(dy)<4)) continue;

AUTO_dy :

           if (textor==2 && zone<3) break ;

           if (dy>0){
               
               zer[zone].curval = (zer[zone].curval > dy) ? zer[zone].curval-dy : 0 ;
               if ( (!zer[zone].oldval) && (!zer[zone].curval) ) break; 
                    }
            else { 
                zer[zone].curval+=abs(dy) ;
                if (zer[zone].curval>255) zer[zone].curval = 255;
                if ( (zer[zone].oldval==255) && (zer[zone].curval==255) ) break;
                    }
        zer[zone].oldval =  zer[zone].curval ; 
        putimage (zer[zone].balxt , zer[zone].balyt , zer[zone].mem_bbal , 0 ); 
        // bareacls( zer[probal].numxt , zer[probal].numyt ,zer[probal].numxb , zer[probal].numyb , fonto );
        
                  setcolor ( COLOR (fonto[0],fonto[1],fonto[2]) );
        for (i=zer[zone].numxt;i<=zer[zone].numxb;i++) {
            for (f= zer[zone].numyt+1 ; f<=zer[zone].numyb; f++) _putpixel (i,f);}
            
        if (zone<3) {
        testchrxr[zone] = zer[zone].curval ; }
        else {
        testbkgxr[zone-3] = zer[zone].curval; }
        
        zer[zone].recyt=zer[zone].recyb-zer[zone].curval;
        
        
            switch (zone) {
                case 0 :
                case 3 :
                    nowcol[0]=zer[zone].curval; nowcol[1]=nowcol[2]=0;break;
                case 1:
                case 4:
                    nowcol[1]=zer[zone].curval; nowcol[0]=nowcol[2]=0;break;
                case 2:
                case 5:
                    nowcol[2]=zer[zone].curval; nowcol[0]=nowcol[1]=0;
            }
            
        //areacls(zer[zone].recxt,yzer+21,zer[zone].recxb,zer[zone].recyb,200,200,200);
        setcolor ( COLOR (200,200,200) );
        for (i=zer[zone].recxt;i<=zer[zone].recxb;i++) {
            for (f= yzer+20 ; f<=zer[zone].recyb; f++) _putpixel (i,f);}
            
        // bareacls(zer[zone].recxt, zer[zone].recyt, zer[zone].recxb , zer[zone].recyb,nowcol);
        
          setcolor ( COLOR (nowcol[0],nowcol[1],nowcol[2]) );
        for (i=zer[zone].recxt;i<=zer[zone].recxb;i++) {
            for (f= zer[zone].recyt ; f<=zer[zone].recyb; f++) _putpixel (i,f);}
        
        zer[zone].balyt=zer[zone].recyt-18; zer[zone].balyb=zer[zone].balyt+37;
        getimage (zer[zone].balxt,zer[zone].balyt,zer[zone].balxb,zer[zone].balyb, zer[zone].mem_bbal);
        puticon (zer[zone].balxt,zer[zone].balyt,mem_bal,255);
        sprintf(str,"%03u",zer[zone].curval);
        outsouv_col(zer[zone].numxt,zer[zone].numyt+1,str,0,&maxcol[zone][0],fonto);

        // bareacls (xt+3,yt+3,xt+243,yt+26,testbkgxr);
        
        if (textor!=2) { 
          setcolor ( COLOR (testbkgxr[0],testbkgxr[1],testbkgxr[2]) );
        for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}        
        
        //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr);}
        _outmystr_col (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);refresh();}
        else {
            setcolor ( COLOR (ef_testbkgxr[0],ef_testbkgxr[1],ef_testbkgxr[2]) );
            for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}
            
            //outnoto_colsel(xt+76,yt+5,"Inkualizer..",0,testchrxr,ef_testbkgxr,testbkgxr);
            _outmystr_colsel (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,ef_testbkgxr,testbkgxr);
            refresh();
            getimage (xt+65, yt+5 , xt+74, yt+30, mem_cu);
            diak=1 ; time_metr=0;
            
                 // Ζωγραφίζει έναν text selector
            for (f=0;f<26;f++) {
            mem_int=(mem_sel +8 + (f*10*4));
            for (i=0;i<10;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            a1=255-co.rgb[2];
            red =  abs( (testbkgxr[0]*co.rgb[2]/255) - (testchrxr[0]*a1/255) );
            a1=255-co.rgb[1];
            green =  abs( (testbkgxr[1]*co.rgb[1]/255) - (testchrxr[1]*a1/255) );
            a1=255-co.rgb[0];
            blue =  abs( (testbkgxr[2]*co.rgb[0]/255) - (testchrxr[2]*a1/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel (xt+65+i , yt+5+f);}}
           refresh();
            
        }     
      
        /* BAFEI NEA MPALA
        for (f=0;f<38;f++) {
        mem_int=(mem_bal+8 + (f*38*4));
        for (i=0;i<38;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (80 * co.rgb[2]) / 255;
        green =  (150 * co.rgb[1]) / 255;
        blue =  (20 * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (zer[zone].balxt+i , zer[zone].balyt+f);}}
        refresh(); */            
        continue;           
    }
        
        else if (protyx!=10) { // KLIK SE TYXAIA EPILOGH
            if (textor==2) break ;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            for (f=0;f<6;f++) {
            putimage (zer[f].balxt , zer[f].balyt , zer[f].mem_bbal , 0 ); }
            
            _bareacls(xt+1,yt+61,xt+245,yt+76,fonto); // Καθαρίζει τους αριθμούς - τιμές !
            setcolor(5); line (xt+124,yt+40,xt+124,yt+77); line (xt+123,yt+40,xt+123,yt+77); 
            
            for (f=0;f<3;f++) {
            testchrxr[f] = zer[f].curval=randchrxr[protyx][f];
            testbkgxr[f] = zer[f+3].curval=randbkgxr[protyx][f];
            }
            
                      
            for (f=0;f<6;f++) { 
                zer[f].recyt=zer[f].recyb-zer[f].curval;
                
                zer[f].oldval =  zer[f].curval ; 
                switch (f) {
                    case 0 :
                    case 3 :
                        nowcol[0]=zer[f].curval; nowcol[1]=nowcol[2]=0;break;
                    case 1:
                    case 4:
                        nowcol[1]=zer[f].curval; nowcol[0]=nowcol[2]=0;break;
                    case 2:
                    case 5:
                        nowcol[2]=zer[f].curval; nowcol[0]=nowcol[1]=0;
                }
                
                _areacls(zer[f].recxt,yzer+20,zer[f].recxb,zer[f].recyb,200,200,200);
                _bareacls(zer[f].recxt,zer[f].recyt,zer[f].recxb,zer[f].recyb,nowcol);
                zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
                getimage (zer[f].balxt,zer[f].balyt,zer[f].balxb,zer[f].balyb, zer[f].mem_bbal);
                
                _puticon (zer[f].balxt,zer[f].balyt,mem_bal,255);
                
                sprintf(str,"%03u",zer[f].curval);
                 
                _outsouv_col(zer[f].numxt,zer[f].numyt+1,str,0,&maxcol[f][0],fonto);
                refresh(); 
            }
            _bareacls (xt+3,yt+3,xt+243,yt+35,testbkgxr);
            //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr);
            _outmystr_col (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);
            refresh();
            
            break ;
        }
        
        else if (save_cols) {
            if (!keyb_gr) {
            user_ans=(unsigned short int) alert (0,"Are you sure .. ?","Save Colors for background - text and sele- ction to disk");}
            else {user_ans=(unsigned short int) alert(0,"Είστε σίγουρος-η ...;","Αποθήκευση χρωμάτων παρασκηνίου - κειμέ-  νου και επιλογής στο δίσκο");}
            if (user_ans==1) {
                
                strcpy (file_1,path_name);      // ΦΟρτώνει πρώτα το αρχείο διαγραφών δομών χρωμάτων 
                strcat (file_1,"era_inks.dat");
                fpera=fopen(file_1,"r+b");
                if (fpera==NULL) {information(6-keyb_gr,file_1,NULL); break ;}
                fide_fpera = fileno(fpera);
                fread(&plera,2,1,fpera);
                if (plera>0) {
                    fseek(fpera,plera*2,0);
                    fread(&thesi,2,1,fpera);
                    if (thesi<0) { plera=0; information(2-keyb_gr,file_1,NULL);fclose(fpera);} 
                    if (ferror(fpera)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera);  break; }
                }
                else {
                plera=0;
                if (ferror(fpera)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera);  break; } else fclose(fpera); }
                
                // printf("plera=%d \n",plera);
                
                strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων για ανάγνωση
                strcat (file_1,"inks_sort.dat");
                fp=fopen(file_1,"rb");
                if (fp==NULL) {information(6-keyb_gr,file_1,NULL); if (plera) {fclose(fpera) ; } break ;}
                fread (&plxr,2,1,fp);
                
                fread (&key,2,1,fp);
                ef_mem = malloc ((plxr+1)*2);
                if (!ef_mem) {information(2-keyb_gr,NULL,NULL); fclose(fp); if (plera) {fclose(fpera) ; } break; }
                ar_dom=ef_mem;
                fread (ar_dom,2,plxr,fp);
                if (ferror(fp)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fp); fclose(fp); free(ef_mem);  if (plera) {fclose(fpera) ; } break; }
                else fclose(fp);
                
                
                strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δομών χρωμάτων για ανάγνωση - εγγραφή
                strcat (file_1,"inks_dom.dat");
                fp=fopen(file_1,"r+b");
                if (fp==NULL) {information(6-keyb_gr,file_1,NULL); free(ef_mem);  if (plera) {fclose(fpera) ; } break ;}
                fide_doms = fileno (fp) ;
                dink1.dfront.dchrgb[3]=dink1.dback.dbkrgb[3]=dink1.dsel.dsergb[3]= 0 ; 
                if (textor!=2) {
                for (f=0;f<3;f++) {
                dink1.dfront.dchrgb[f]=(unsigned char) testchrxr[f] ;
                dink1.dback.dbkrgb[f]=(unsigned char) testbkgxr[f] ;
                dink1.dsel.dsergb[f]=(unsigned char) testselxr[f] ; 
                }}
                else {
                for (f=0;f<3;f++) {
                dink1.dfront.dchrgb[f]=(unsigned char) testchrxr[f] ;
                dink1.dback.dbkrgb[f]=(unsigned char) ef_testbkgxr[f] ;
                dink1.dsel.dsergb[f]=(unsigned char) testbkgxr[f] ;
                }}
                if (!plera) fseek(fp,plxr*12,0); else fseek(fp,thesi*12,0);
                fwrite (&dink1,12,1,fp); // Γράφει τη νέα δομή στο τέλος ή , πάνω στην τελευταία διαγραφή !
                fdatasync (fide_doms);
                a=0;
                if (key) {  // Με κλειδί = 1 ταξινομεί βάσει dfront !
                for (f=0 ; f<plxr ; f++) {
                    fseek(fp,(ar_dom[f]*12),0);
                    fread (&dink,12,1,fp);
                    if (dink.dfront.dchxr > dink1.dfront.dchxr) {
                            a=1;
                            for (i=plxr ; i>f ; i--) {ar_dom[i]=ar_dom[i-1];}
                            ar_dom[f]=(plera) ? thesi : plxr; break;}
                            else continue ;} }
                            
                    else {
                        
                    for (f=0 ; f<plxr ; f++) {
                    fseek(fp,(ar_dom[f]*12),0);
                    fread (&dink,12,1,fp);
                    if (dink.dback.dbkxr > dink1.dback.dbkxr) {
                            a=1;
                            for (i=plxr ; i>f ; i--) {ar_dom[i]=ar_dom[i-1];}
                            ar_dom[f]=(plera) ? thesi : plxr; break; }
                            else continue ;} }
                            
                if (!a) {ar_dom[plxr]=(plera) ? thesi : plxr;}
                if (ferror(fp)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fp); fclose(fp); free(ef_mem); 
                    if (plera) {fclose(fpera) ; } break; }
                else {fsync(fide_doms); fclose(fp);}
                
                strcpy (file_1,path_name);      // Ξανα-φορτώνει το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων για εγγραφή.
                strcat (file_1,"inks_sort.dat");
                fp=fopen(file_1,"r+b");
                if (fp==NULL) {information(6-keyb_gr,file_1,NULL); free (ef_mem); if (plera) {fclose(fpera) ; } break ;}
                fide_sort = fileno (fp);
                plxr++;
                fwrite (&plxr,2,1,fp);
                fseek (fp,2,SEEK_CUR);
                fwrite (ar_dom,2,plxr,fp);
                if (ferror(fp)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fp); fclose(fp); free(ef_mem); 
                    if (plera) {fclose(fpera) ; } break; }
                else {fsync(fide_sort); fclose(fp);}
                free(ef_mem);
                
                if (plera>0) {
                    rewind (fpera);
                    plera--;
                    fwrite (&plera,2,1,fpera);
                    if (ferror(fpera)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera); break; }
                    else {fsync(fide_fpera); fclose(fpera);}
                }
            }
            break ;
        }
        
        else if (proanak) {
             cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
             SDL_SetCursor(cursor);
            for (f=0;f<10;f++) {
                for (i=0;i<3;i++) {
                a=random(2);
                randchrxr[f][i]= (a) ? testchrxr[i]+random(80) : testchrxr[i] - random(80);
                if (randchrxr[f][i]<0) randchrxr[f][i]=255;
                if (randchrxr[f][i]>255) randchrxr[f][i]=0;
                
                randbkgxr[f][i]= (a) ? testbkgxr[i]+random(80) : testbkgxr[i] - random(80);
                if (randbkgxr[f][i]<0) randbkgxr[f][i]=255;
                if (randbkgxr[f][i]>255) randbkgxr[f][i]=0;
                }
                _bareacls (xtepi+1,ytepi+1+f*26,xb-1,ytepi+25+f*26,&randbkgxr[f][0]);
                if (!keyb_gr) {
                _outnoto_col (xtepi+20 , ytepi+2+f*26 , "Abcde.." , 0 , &randchrxr[f][0] , &randbkgxr[f][0]);}
                else {
            _outnoto_col (xtepi+20 , ytepi+2+f*26 , "Abgde.." , 1 , &randchrxr[f][0] , &randbkgxr[f][0]);}     
            }
            refresh();
        break;
        }
        
        else if (proenter) {
            
                if (textor!=2) {
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =testbkgxr[f] ;
                selxr[f] = testselxr[f] ; 
                }}
                else {
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =ef_testbkgxr[f] ;
                selxr[f] = testbkgxr[f] ;
                }}
            fyge=1;
              
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255 ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            continue;
        }
        
    else if (marrs) {

            if ( (textor==2) && (diak) ) {
                time_metr=0;
                putimage(xt+65, yt+5 , mem_cu , 0); 
                refresh();
                diak=0;
            }
            
            xt1=xt; yt1=yt-19; xb1=xb; yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(632008);
            if (mem_zer==NULL) {information(2-keyb_gr,NULL,NULL); continue ;}
            getimage(xt,yt-19,xb,yb,mem_zer); // Αντιγράφει το inkualizer όπως είναι αυτήν τη στιγμή !
            putimage(xt,yt,mem0,0); // αποκαθιστά οθόνη
            putimage(xt,yt-19,mem_top,0);
            refresh();



            xt=xt1; yt=yt1+19;
            xb=xt+399 ; yb=yt+375;
            getimage(xt,yt1,xb,yt1+18,mem_top);
            getimage(xt,yt,xb,yb,mem0); //κλέβει οθόνη για να λερώσει μετά !
            putimage(xt,yt1,mem_zer,0);
            refresh();
            free(mem_zer);

            xok=xt+362;
            xseltxt=xt+248 ; yseltxt=yanak=yok=ysave=yb-36;
            xanak = xt+286 ; 
            xsave=xanak+39;
            xzer=xt+2; yzer=yt+79;
            xtepi=xt+247;ytepi=yt+77;

            zer[0].recxt=xzer+6; zer[0].recxb=zer[0].recxt+30;
            zer[0].recyb=zer[1].recyb=zer[2].recyb=zer[3].recyb=zer[4].recyb=zer[5].recyb=yb-21; 
            zer[1].recxt=zer[0].recxb+11 ; zer[1].recxb=zer[1].recxt+29;
            zer[2].recxt=zer[1].recxb+10 ; zer[2].recxb=zer[2].recxt+31;
            zer[3].recxt=zer[2].recxb+9 ; zer[3].recxb=zer[3].recxt+31;
            zer[4].recxt=zer[3].recxb+9 ; zer[4].recxb=zer[4].recxt+31;
            zer[5].recxt=zer[4].recxb+9 ; zer[5].recxb=zer[5].recxt+31;
            zer[0].numyt=zer[1].numyt=zer[2].numyt=zer[3].numyt=zer[4].numyt=zer[5].numyt=yt+60;
            zer[0].numyb=zer[1].numyb=zer[2].numyb=zer[3].numyb=zer[4].numyb=zer[5].numyb=yzer-3;

            for (f=0;f<6;f++) { 
                zer[f].recyt=zer[f].recyb-zer[f].curval;
                zer[f].balxt=zer[f].recxt-3;zer[f].balxb=zer[f].balxt+37;
                zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
                zer[f].numxt=zer[f].recxt; zer[f].numxb=zer[f].numxt+33;
            }

            break ;
            
        }
        
    else if (textor) {
        
        if (textor==1) {
            textor=2;

areacls (xt+133,yt+41,xt+230,yt+57,0,0,0);            
if (!keyb_gr) {outsouv(xt+148,yt+41,"Selector",0);}
else {outsouv(xt+155,yt+41,"Epilogh'",1);}
            
          // BAFEI SELECT CURSOR ENTONA
        _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); 
        for (f=0;f<35;f++) {
        mem_int=(mem_txt +8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  abs(255-co.rgb[2]);
        green =  abs(255-co.rgb[1]);
        blue =  abs(255-co.rgb[0]) ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xseltxt+i , yseltxt+f);}}
        refresh();
      
            // AN TYXON PONTIKI HTAN ENTOS 10 TYXAIVN EPILOGVN KAUARIZV 
            
     if (protyx!=10) {
     putimage ((int) (xtepi+120),(int) (ytepi+1+protyx*26),mem_propick,0);
     refresh();
     protyx=10;    
    }
    
        for (f=0;f<3;f++) { 
            ef_testbkgxr[f] = testbkgxr[f] ; 
            ef_curval[f+3] = zer[f+3].curval;
            zer[f+3].curval = testselxr[f];
        }
    
    for (f=3;f<6;f++) { 
        
        
        zer[f].oldval=zer[f].curval;
        putimage (zer[f].balxt , zer[f].balyt , zer[f].mem_bbal , 0 ); 
        bareacls( zer[f].numxt , zer[f].numyt+1 ,zer[f].numxb , zer[f].numyb , fonto );
        testbkgxr[f-3] = zer[f].curval;
        zer[f].recyt=zer[f].recyb-zer[f].curval;
   
            
            switch (f) {
                
                case 3 :
                    nowcol[0]=zer[f].curval; nowcol[1]=nowcol[2]=0;break;
                
                case 4:
                    nowcol[1]=zer[f].curval; nowcol[0]=nowcol[2]=0;break;
                
                case 5:
                    nowcol[2]=zer[f].curval; nowcol[0]=nowcol[1]=0;
            }
                
            areacls(zer[f].recxt,yzer+20,zer[f].recxb,zer[f].recyb,200,200,200);
            bareacls(zer[f].recxt, zer[f].recyt, zer[f].recxb , zer[f].recyb,nowcol);
            zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
            getimage (zer[f].balxt,zer[f].balyt,zer[f].balxb,zer[f].balyb, zer[f].mem_bbal);
            puticon (zer[f].balxt,zer[f].balyt,mem_bal,255);
            sprintf(str,"%03u",zer[f].curval);
            outsouv_col(zer[f].numxt,zer[f].numyt+1,str,0,&maxcol[f][0],fonto);
            
            }
    bareacls (xt+3,yt+3,xt+243,yt+35,ef_testbkgxr);
    
    //outnoto_colsel(xt+76,yt+5,"Inkualizer..",0,testchrxr,ef_testbkgxr,testbkgxr); 
    _outmystr_colsel (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,ef_testbkgxr,testbkgxr);
    refresh();
    getimage (xt+65, yt+5 , xt+74, yt+30, mem_cu);
    diak=1 ; time_metr=0;
    
     // Ζωγραφίζει έναν text selector
     for (f=0;f<26;f++) {
        mem_int=(mem_sel +8 + (f*10*4));
        for (i=0;i<10;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        a1=255-co.rgb[2];
        red =  abs( (testbkgxr[0]*co.rgb[2]/255) - (testchrxr[0]*a1/255) );
        a1=255-co.rgb[1];
        green =  abs( (testbkgxr[1]*co.rgb[1]/255) - (testchrxr[1]*a1/255) );
        a1=255-co.rgb[0];
        blue =  abs( (testbkgxr[2]*co.rgb[0]/255) - (testchrxr[2]*a1/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel (xt+65+i , yt+5+f);}}
        refresh();
        }
        
        else {//SBHNV TEXTOR - EPISTROFH STO APLO
            if (mx1>xseltxt && mx1<xseltxt+35 && my1>yseltxt && my1<yseltxt+35) {            
         textor=0;diak=0;

areacls (xt+133,yt+41,xt+230,yt+57,0,0,0);          
if (!keyb_gr) {outsouv(xt+134,yt+41,"Background",0);}
else {outsouv(xt+155,yt+41,"Fo'nto",1);}
         
          for (f=0;f<3;f++) { 
            // testbkgxr[f] = ef_testbkgxr[f] ;
            testselxr[f] = zer[f+3].curval ;
            zer[f+3].curval = ef_curval[f+3] ;
            
        }

    for (f=3;f<6;f++) { 
    zer[f].oldval =  zer[f].curval ;            
    putimage (zer[f].balxt , zer[f].balyt , zer[f].mem_bbal , 0 ); 
    bareacls( zer[f].numxt , zer[f].numyt+1 ,zer[f].numxb , zer[f].numyb , fonto );
    testbkgxr[f-3] = zer[f].curval;
    zer[f].recyt=zer[f].recyb-zer[f].curval;
    
        
        switch (f) {
            
            case 3 :
                nowcol[0]=zer[f].curval; nowcol[1]=nowcol[2]=0;break;
            
            case 4:
                nowcol[1]=zer[f].curval; nowcol[0]=nowcol[2]=0;break;
            
            case 5:
                nowcol[2]=zer[f].curval; nowcol[0]=nowcol[1]=0;
        }
            
        areacls(zer[f].recxt,yzer+20,zer[f].recxb,zer[f].recyb,200,200,200);
        bareacls(zer[f].recxt, zer[f].recyt, zer[f].recxb , zer[f].recyb,nowcol);
        zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
        getimage (zer[f].balxt,zer[f].balyt,zer[f].balxb,zer[f].balyb, zer[f].mem_bbal);
        puticon (zer[f].balxt,zer[f].balyt,mem_bal,255);
        sprintf(str,"%03u",zer[f].curval);
        outsouv_col(zer[f].numxt,zer[f].numyt+1,str,0,&maxcol[f][0],fonto);
        
        }
    _areacls (xseltxt,yseltxt,xseltxt+34,yseltxt+34,0,0,0); 
    puticon(xseltxt,yseltxt,mem_txt,255);
    bareacls (xt+3,yt+3,xt+243,yt+35,testbkgxr);
    //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr); 
    _outmystr_col (gfont, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);
    refresh();
            }
          }
       }       
    } // No pressed Button Left 
               
       continue;
       
      case SDL_KEYDOWN:
      
                     
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if (zone==6) break ; 
                dy=1;
                goto AUTO_dy;
                
            case SDL_SCANCODE_UP :
                 if (zone==6) break ; 
                dy=-1;
                goto AUTO_dy;
                
            case SDL_SCANCODE_PAGEDOWN :
                 if (zone==6) break ; 
                dy= 20;
                goto AUTO_dy;
                
            case SDL_SCANCODE_PAGEUP :
                 if (zone==6) break ; 
                dy=-20;
                goto AUTO_dy;
                
            case SDL_SCANCODE_RETURN :
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (textor!=2) {
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =testbkgxr[f] ;
                selxr[f] = testselxr[f] ; 
                }}
                else {
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =ef_testbkgxr[f] ;
                selxr[f] = testbkgxr[f] ;
                }}
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               continue;
               
            }
        
        break;
        
         case SDL_MOUSEWHEEL :
             
            if (zone==6) break ;
            
            if(sdlev.wheel.y > 0) // scroll up
        {
             dy=-3;
             goto AUTO_dy;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
             dy=3;
             goto AUTO_dy;
        }
        
         break;
         
    case SDL_WINDOWEVENT :
    refresh(); continue;
    
    case SDL_QUIT :
    fyge=1;
    continue;
         
     default :
        if (mx1<xt || mx1>xb || my1<ytepi || my1>yb) {
            
            if (apejo) continue;
            apejo=1;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            
        } else apejo=0;

    }  // TELOS TOY switch &sdlev.type
       
 } while (!fyge);

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
fidicls(xt,yt,xb,yb,bkgxr[0],bkgxr[1],bkgxr[2]);
putimage(xt,yt,mem0,0);
putimage(xt,yt-19,mem_top,0);
refresh();
for (f=0;f<6;f++) {free(zer[f].mem_bbal);}
free(mem_propick) ; free (mem_pick); free (mem_txt); free(mem_sel);free(mem_cu);free(mem_save);
free(mem0); free(mem_ok); free(mem_bal); free(mem_anak); free(mem_arrs);free(mem_top); return 1;
}



int outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=nouv[i].wid;} 
        }
}
refresh();    
return y;
}

double convert_str(short int len , char *str)
{
double f_num=0;
long int num_long=0;
short int f , a, ypo;
unsigned char i;
char num_str[len+1];

if (!len) return 0;
ypo=0;
f=0;a=0;
i=str[f];

    do {
        
        if ( (i==13) && (!a) ) { num_str[a]=45; a++ ; }
        else if ( (i==12) && (a) && (!ypo) ) {num_str[a]=46; ypo=1; a++;}
        else if ( (i>15) && (i<26) ) { num_str[a] = i+32; a++ ; }
        len--;f++;
        i=str[f];
        
    } while ( (i!=255) && (len) );

num_str[a]='\0';
if ( a && num_str[a-1]==46 ) num_str[a-1]='\0';
if (ypo) f_num=atof(num_str); else {
num_long=atol(num_str); f_num=(double) num_long ;}
return f_num;
}

int outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=souv[i].wid;} 
        }
}
refresh();    
return y;
} 

void create_colfiles () // Μόνον μια φορά να τρέξει αυτό !!
{

FILE * fp;    
unsigned short int plxr , key ,ardel ;
unsigned char back[4] , front [4], sel [4] ;

plxr=1;
key=0;
ardel=0;
back[3]=front[3]=sel[3]=0;
back[0]=back[1]=back[2]=0;
front[0]=front[1]=front[2]=255;
sel[0]=sel[1]=0 ; sel[2]=220;

strcpy (file_1,path_name);      // Δημιουργεί το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων 
strcat (file_1,"inks_sort.dat");
fp=fopen(file_1,"wb");
fwrite (&plxr,2,1,fp);
fwrite (&key,2,1,fp);
fwrite (&key,2,1,fp); // Γράφει το 0 ως αύξων αριθμό ταξινόμησης της 1ης δομής !!
fclose(fp);

strcpy (file_1,path_name);      // Δημιουργεί το αρχείο των δομών χρωμάτων 
strcat (file_1,"inks_dom.dat");
fp=fopen(file_1,"wb");
fwrite (back,1,4,fp);
fwrite (front,1,4,fp);
fwrite (sel,1,4,fp);
fclose (fp);

strcpy (file_1,path_name);      // Δημιουργεί το αρχείο διαγραφών δομών χρωμάτων 
strcat (file_1,"era_inks.dat");
fp=fopen(file_1,"wb");
fwrite (&ardel,2,1,fp);
fclose (fp);
return ;
} 

int readyinks (int *chrxr , int *bkgxr, int *selxr)
{

FILE *fps , *fpd=NULL , *fpera;
int fide_fpera , fide_sort , fide_fpd;
SDL_Cursor* cursor;
    void *mem0 , *ardom_mem=0, *mem_arrs , *mem_bar=0 , *mem_ok=0 , *mem_pick=0 , *mem_propick=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *mem_item=0 ,*mem_bar1 , *mem_zer ,  *new_dom_vo;
int *mem_int , *item ;
int testchrxr[3] , testbkgxr[3] , testselxr[3] ,user_ans ;
int cbrown[3] , chrprnt[3];
unsigned short int *ar_dom;
short int bima , plera , *new_dom ;
int xt1,yt1,xb1,yb1;
unsigned short int xt,yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb, bary1, bary2, y1, y2 , xfrba, yfrba , xsort , ysort ;
unsigned short int plxr , key , pano, kato , telos ,sort ,bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ,y3 ;
unsigned short int a1 , a , k ,prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , endj, proelem ,c ;
unsigned char klik ;
char deigma[10];

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union disk_bkxr{
    int dbkxr;
    unsigned char dbkrgb[4];
};

union disk_chxr{
    int dchxr;
    unsigned char dchrgb[4];
};

union disk_sexr{
    int dsexr;
    unsigned char dsergb[4];
};

struct disk_ink {
    union disk_bkxr dback;
    union disk_chxr dfront;
    union disk_sexr dsel;
} dink ;

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 

mem0=malloc(400008); //250 x 400
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=(info.right-info.left-250) / 2 ; yt1=(info.bottom-info.top-400) / 2 ;
yt=yt1+19; xb=xt+249 ; yb=yt1+399;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+12*26+1;
xok=xb-46 ; yok=ysort = ydel = yb-46;
xdel = xtepl+2 ; 
xfrba = xdel+58; yfrba = yb-52 ;
xsort = xfrba+53;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
areacls (xtepl,ytepl,xtepr,ytepr,0,0,0);


// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
puticon(xt+1,yt1+1,mem_arrs,255);

/*
mem_int=(mem_arrs +8) ; 
for (f=0;f<17;f++) {
  for(i=0 ; i < 17; i++) {
   co.lor= *(mem_int++);
   if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));        
   _putpixel (xt+1+i,yt1+1+f);}}} 
refresh(); 
*/

if (keyb_gr) {
a1=(xb-xt-162)/2;
outsouv_col(xt+a1,yt1+1,"EPILOGH XRVMATVN",1,chrprnt,cbrown);} else { a1=(xb-xt-120)/2; outsouv_col(xt+a1,yt1+1,"PICK COLORS",0,chrprnt,cbrown);}

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/color-picker.ico");
mem_pick= icontomem (file_1,255);
if (mem_pick==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
mem_propick=malloc(2508);
if (mem_propick==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Text_Front.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Text_back.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    
// ANOIGMA ARXEIVN

strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων για ανάγνωση
strcat (file_1,"inks_sort.dat");
fps=fopen(file_1,"rb");
if (fps==NULL) {information(6-keyb_gr,file_1,NULL); goto FYGE ;}
fread (&plxr,2,1,fps);
fread (&key,2,1,fps);
ardom_mem = malloc ((plxr+1)*2);
if (!ardom_mem) {information(2-keyb_gr,NULL,NULL); fclose(fps); goto FYGE ; }
ar_dom=ardom_mem;
fread (ar_dom,2,plxr,fps);
if (ferror(fps)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fps); fclose(fps); goto FYGE ; }
else fclose(fps);

strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δομών χρωμάτων για ανάγνωση - εγγραφή
strcat (file_1,"inks_dom.dat");
fpd=fopen(file_1,"r+b");
if (fpd==NULL) {information(6-keyb_gr,file_1,NULL); goto FYGE ;}
fide_fpd = fileno (fpd) ;


_areacls (xtepl,ytepl,xtepr,ytepr,0,0,0);

// EMFANISH EIKONIDIVN
_puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S0,255);

_puticon (xok,yok,mem_ok,255);

a=0;k=0; a1=plxr; telos=0 ; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); fclose(fpd); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;
do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
fseek(fpd,(ar_dom[a]*12),0);
fread (&dink,12,1,fpd);

for (f=0;f<3;f++) {
testchrxr[f] = (int) dink.dfront.dchrgb[f] ;
testbkgxr[f] = (int) dink.dback.dbkrgb[f] ;
testselxr[f] = (int) dink.dsel.dsergb[f] ;
}

_bareacls(xtepl,ytepl+k*26,xtepr,ytepl+k*26+26,testbkgxr);
endj=(sort) ? pano-k : pano+k;
sprintf (deigma," %05d ", endj);

  if (!keyb_gr) {
    _outnoto_col (xtepl+10 , ytepl+k*26 , "Abcde.." , 0 , testchrxr , testbkgxr ); 
    _outnoto_colsel (xtepl+130 , ytepl+k*26 , deigma , 0 , testchrxr , testbkgxr , testselxr); 
   }
    else {
   _outnoto_col (xtepl+10 , ytepl+k*26 , "Abgde.." , 1 , testchrxr , testbkgxr );
   _outnoto_colsel (xtepl+130 , ytepl+k*26 , deigma , 1 , testchrxr , testbkgxr , testselxr );     
    }

    a++; a1--;k++;
    
}while (a1 && k<12);

setcolor(5);
line(xtepl,ytepl+k*26+1,xtepr,ytepl+k*26+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plxr-kato-1; 
        }
    
    else {
    proyt=plxr-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plxr ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*12) / plxr ); y2+=y1;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}
    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;
protyx=tyx=12; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;

do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb) {  //Κίνηση εντός 12 επιλογών !!
        
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
    else if (profrba) {
        profrba=0 ;
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); }
    else if (probar) probar=0;
    

       
     tyx=(my-ytepl)/26;
    
         if (elem != -1) { // Έχω κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
     
             if (tyx>plxr-1) {
            
            if (protyx!=12) {
                putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
                refresh();
                protyx=12;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>11 ) continue ;
          
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==12) { // EPILEGV GIA PRVTH FORA KOYTI
        getimage (xtepl+100,ytepl+tyx*26,xtepl+124,ytepl+24+tyx*26,mem_propick);
        puticon(xtepl+100,ytepl+tyx*26,mem_pick,255);
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        putimage ((xtepl+100), (ytepl+protyx*26),mem_propick,0);
        getimage (xtepl+100,ytepl+tyx*26,xtepl+124,ytepl+24+tyx*26,mem_propick);
        puticon(xtepl+100,ytepl+tyx*26,mem_pick,255);
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 12 EPILOGVN
    
    if (protyx!=12 && elem==-1) {
           putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();    }
    
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); }
    else if (probar) probar=0;
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }
    
    if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή Front-Back Switch

    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); }
    else if (probar) probar=0;
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
        
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch

    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);

    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); }

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
      
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
        
    else if (probar) probar=0;
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    
        if (probar) probar=0;
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        /*
        setcolor ( COLOR ( 255 , 255 , 0 ) );  
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR( co.rgb[2], co.rgb[1]+80, co.rgb[0]) ) ; _putpixel (xt+i,yt-18+f);}}} 
        refresh();
        */
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);}
        /*
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));             
          _putpixel (xt+i,yt-18+f);}}} 
        refresh(); }
        */
        
    if (bar) {
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;
    
    case SDL_MOUSEBUTTONDOWN:
        
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (20-keyb_gr,0,0);
            else if (prosort) information(22-keyb_gr,0,0);
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=12) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) ) { // Επιλογή κάποιου από τα 12 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= (sort) ? pano-protyx : pano+protyx;
        if ( (elem==proelem) && (klik==1) ) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();
            continue ;
        }
        proelem=elem;
        fseek(fpd,(ar_dom[elem]*12),0);
        fread (&dink,12,1,fpd);
        

        for (f=0;f<3;f++) {
        testchrxr[f] = (int) dink.dfront.dchrgb[f] ;
        testbkgxr[f] = (int) dink.dback.dbkrgb[f] ;
        testselxr[f] = (int) dink.dsel.dsergb[f] ;
                                    }
        if (klik>1) goto RDYINKSGO ;
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=12) { 
            elem=proelem=-1 ; 
            protyx=12;
            }
        areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);    
        sort = abs (sort-1) ;
        if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plxr-1 ;
        telos=plxr ;
        goto emfan;
        }
                    
        else if (prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (plxr==1) {information(18-keyb_gr,0,0); continue; }
            user_ans=alert(26-keyb_gr,0,0);
            if (user_ans != 1) continue;
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);

            strcpy (file_1,path_name);      // ΦΟρτώνει το αρχείο διαγραφών δομών χρωμάτων 
            strcat (file_1,"era_inks.dat");
            fpera=fopen(file_1,"r+b");
            if (fpera==NULL) {information(6-keyb_gr,file_1,NULL); break ;}
            fide_fpera = fileno (fpera) ;
            fread(&plera,2,1,fpera);
            if (plera<0) {information(6-keyb_gr,file_1,NULL); fclose(fpera); break ;}
            if (plera) fseek(fpera,plera*2,1); // Αν π.χ. plera=1 (έχει ήδη μια θέση διαγραμμένη) πηδάει 2 bytes για να γράψει την επόμενη.
            fwrite(&ar_dom[elem],2,1,fpera); // Γράφεται η θέση της δομής χρωμάτων που δεν θα φαίνεται πλέον (σαν να διαγράφεται).
            rewind(fpera);
            plera++;
            fwrite (&plera,2,1,fpera);
            if (ferror(fpera)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fpera); fclose(fpera);  break; }
            else {fsync(fide_fpera); fclose (fpera);}
            plxr--;
            for (f=elem ; f<plxr ; f++) ar_dom[f]=ar_dom[f+1]; // Αναταξινόμηση δεικτών
            strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων
            strcat (file_1,"inks_sort.dat");
            fps=fopen(file_1,"r+b");
            if (fps==NULL) {information(6-keyb_gr,file_1,NULL); break;}
            fide_sort = fileno (fps) ;
            fwrite (&plxr,2,1,fps);
            fseek (fps,2,1); //Πηδάει το key...!!
            fwrite(ar_dom,2,plxr,fps); // Ξαναγράφει τους δείκτες.
            if (ferror(fps)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fps); fclose(fps);  break; }
            else {fsync(fide_sort); fclose (fps);}  
            protyx=12;elem=proelem=-1;
            c=pano;
            telos+=12;
            goto emfan ;
            
        }
        
        else if (profrba) {
            
            if (protyx!=12) { // Ακυρώνεται τυχόν επιλογή !
            elem=proelem=-1 ; 
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();
        }
        
            mem_item=malloc(plxr*4);

            if (!mem_item) {
                if (keyb_gr) information(2-keyb_gr,"Είναι αδύνατη η ταξινόμηση αυτήν τη στιγμή !",NULL);
                else information(2-keyb_gr,"Resorting is impossible this moment!",NULL);
                continue;
            }
            
            new_dom_vo = malloc (plxr*2);
             if (!new_dom_vo) {
                if (keyb_gr) information(2-keyb_gr,"Είναι αδύνατη η ταξινόμηση αυτήν τη στιγμή !",NULL);
                else information(2-keyb_gr,"Resorting is impossible this moment!",NULL);
                free (mem_item);
                continue;
            }
            
            new_dom=new_dom_vo;
            
            key=(1-key);
            _areacls(xfrba,yfrba,xfrba+43,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            item=mem_item;
            rewind (fpd);
            for (f=0;f<plxr;f++) {  // Μεταφέρονται στον πίνακα item όλα τα ΕΝΕΡΓΑ στοιχεία των δομών βάσει του sorting key
            fseek(fpd,(ar_dom[f]*12),0);
            fread(&dink,12,1,fpd);
            item[f]=(key) ? dink.dfront.dchxr : dink.dback.dbkxr ;
            new_dom[f]=f; // Αρχικοποίηση νέων δεικτών
            }
            
            pro_sort_int (item,new_dom,plxr); // QUICK SORT !!!!!
            
            free (mem_item);
            for (f=0;f<plxr;f++)  { new_dom[f] = ar_dom[new_dom[f]]; }
            ar_dom = new_dom;
            free (ardom_mem);
            ardom_mem=new_dom_vo;
            strcpy (file_1,path_name);      // Φορτώνει το αρχείο των δεικτών ταξινόμησης των δομών χρωμάτων
            strcat (file_1,"inks_sort.dat");
            fps=fopen(file_1,"r+b");
            if (fps==NULL) {information(6-keyb_gr,file_1,"Application exit !!"); goto FYGE ;}
            fide_sort = fileno (fps) ; 
            fseek (fps,2,0); //Πηδάει το plxr...!!
            fwrite (&key,2,1,fps); //Γράφει το νέο sorting key
            fwrite(ar_dom,2,plxr,fps); // Ξαναγράφει τους δείκτες.
            if (ferror(fps)) { information(2-keyb_gr,file_1,NULL); perror("Disk I/O Problem"); clearerr(fps); fclose(fps); }
            else {fsync(fide_sort); fclose(fps);}
            c = (sort) ? plxr-1 : 0 ;
            telos=plxr;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
RDYINKSGO :
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
            for (f=0;f<3;f++) {
            chrxr[f] = testchrxr[f] ;
            bkgxr[f] =testbkgxr[f] ;
            selxr[f] = testselxr[f] ; 
            continue ;
            } }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(400008);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το readyinks όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+249 ; yb=yt1+399;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+12*26+1;
            xok=xb-46 ; yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ; 
            xfrba = xdel+58; yfrba = yb-52 ;
            xsort = xfrba+53;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plxr ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*12) / plxr ); y2+=y1;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (probar) {
            
            if (protyx!=12) {
            elem=proelem=-1 ; 
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plxr-1) && (sort) ) continue ;
            c = pano-(bima*12); telos+=24;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plxr-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*12) / plxr )+y1;    
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*12) / plxr )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*12) / plxr );}
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plxr)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plxr-1-a1) ) continue ;
        telos=plxr-a1;
        if (!sort) c=a1; else c=plxr-a1-1; 
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
        
            if (protyx!=12) {
            elem=proelem=-1 ; 
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plxr-1) && (sort) ) continue ;
                c = pano-3*bima; telos+=15;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plxr-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos+=9;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
      
          if (protyx!=12) {
             
            putimage (xtepl+100,ytepl+protyx*26,mem_propick,0);
            protyx=12;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ;
                if ( (kato==plxr-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos+=11;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ;
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plxr-1) && (sort) ) continue ;
                c = pano-bima; telos+=13;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ;
                if ( (kato==plxr-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ;
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plxr-1) && (sort) ) continue ;
                c = pano-(bima*12); telos+=24;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
                _areacls (xtepl,ytepl,xtepr,ybarb,0,0,0);
                k=0;
                  
                if (!sort) {
                    if (c<0) {c=0 ; telos=plxr;}
                    else if ((c+11)>plxr-1) {
                        if ( (plxr-12)>=0)  { c=plxr-12 ; telos=12;} else {c=0 ; telos=plxr;} } }
                    
                else if (sort) {
                    if (c>plxr-1) {c=plxr-1 ; telos=plxr;}
                    else if ( (c-11)<0 ) { 
                        c=11; telos=12; 
                        if (plxr<12) {c=plxr-1; telos=plxr; }}}
                        
                pano=c;
                do {                                           
                fseek(fpd,(ar_dom[c]*12),0);
                fread (&dink,12,1,fpd);

                for (f=0;f<3;f++) {
                testchrxr[f] = (int) dink.dfront.dchrgb[f] ;
                testbkgxr[f] = (int) dink.dback.dbkrgb[f] ;
                testselxr[f] = (int) dink.dsel.dsergb[f] ;
                }

                _bareacls(xtepl,ytepl+k*26,xtepr,ytepl+k*26+26,testbkgxr);
                endj=(sort) ? pano-k : pano+k;
                sprintf (deigma," %05d ", endj);

                if (!keyb_gr) {
                    _outnoto_col (xtepl+10 , ytepl+k*26 , "Abcde.." , 0 , testchrxr , testbkgxr ); 
                    _outnoto_colsel (xtepl+130 , ytepl+k*26 , deigma , 0 , testchrxr , testbkgxr , testselxr); 
                }
                    else {
                _outnoto_col (xtepl+10 , ytepl+k*26 , "Abgde.." , 1 , testchrxr , testbkgxr );
                _outnoto_colsel (xtepl+130 , ytepl+k*26 , deigma , 1 , testchrxr , testbkgxr , testselxr );     
                    }

                    c+=bima ; telos--; k++;
                    
                }while (telos && k<12);

                setcolor(5);
                line(xtepl,ytepl+k*26+1,xtepr,ytepl+k*26+1);
                refresh();

                kato = (sort) ? c+1 : c-1;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plxr-kato-1; 
                        }

                    else {
                    proyt=plxr-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plxr ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*12) / plxr ); y2+=y1;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plxr-kato-1; 
                        }

                    else {
                    proyt1=plxr-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plxr ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*12) / plxr ); y2+=y1;    
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =testbkgxr[f] ;
                selxr[f] = testselxr[f] ; 
                } }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               continue;
               
            }
        elem=proelem=-1 ;
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
    refresh(); continue;
    
    case SDL_QUIT :
    fyge=1;
    continue;
                
     default :
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


fsync(fide_fpd); fclose(fpd); fpd=NULL;

FYGE :
if (fpd!=NULL) fclose (fpd);
if(mem0) fidicls(xt,yt1,xb,yb,bkgxr[0],bkgxr[1],bkgxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if (mem_pick) free (mem_pick);
if (mem_propick) free(mem_propick);
if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if(mem0) free (mem0); 
if(mem_arrs) free(mem_arrs);
refresh();
return 1 ;
}

int putNOTicon (int x1,int y1,void *mem1)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;
    for (f=0;f<height;f++) {
      for(i=0 ; i < width; i++) {
      co.lor= *(mem_int++);
      if (co.rgb[3]>128) {
        setcolor (COLOR ( 255-co.rgb[2], 255-co.rgb[1], 255-co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    refresh(); 
    return 1;
}

void pro_sort_int (int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_int(item,point,0,count-1);
}


void qui_sort_int (int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    int x,y;
    unsigned int y1;
    unsigned int p1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    p1=point[(left+right)/2];
    
    do {
        
        // while (item[i]<x && i<right) i++;
        while (i<right) {
        if ( item[i]<x ) i++; 
        else if (item[i]==x && point[i]<p1) i++;
        else break ;
        }
        
        // while (x<item[j] && j>left) j--;
        while (j>left) {
        if ( x<item[j] ) j--; 
        else if (x==item[j] && p1<point[j]) j--;
        else break ;
        } 
        
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_int(item,point,left,j);
    if (i<right) qui_sort_int(item,point,i,right);
}
    

int _putNOTicon (int x1,int y1,void *mem1)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;
    for (f=0;f<height;f++) {
      for(i=0 ; i < width; i++) {
      co.lor= *(mem_int++);
      if (co.rgb[3]>128) {
        setcolor (COLOR ( 255-co.rgb[2], 255-co.rgb[1], 255-co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    return 1;
}

int _outsouv_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<18) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<souv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=souv[i].wid;} 
        }
}  
return y;
} 

int _outnoto_colsel(int x, int y, char *str, int lang, int *chxr, int *bkxr, int *selxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i ,a ;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
   setcolor(COLOR (red,green,blue));
   _putpixel(x+w , y+h);}}
   while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) {setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;  _putpixel(x+w , y+h); continue ; }
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+w , y+h);}}
     while (h<26) {
         setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
         for(a=0;a<nouv[i].wid;a++) { _putpixel(x+a , y+h);} h++ ;}    
     x+=nouv[i].wid;} 
        }
}    
return y;
}

void _areacls (int x,int y,int r,int d,int kok,int pra,int mpl)
{
    register int i , f ;
    setcolor (COLOR(kok,pra,mpl));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    return;
}

void _bareacls (int x,int y,int r,int d,int *cbkxr)
{
    register int i , f ;
    setcolor (COLOR(cbkxr[0],cbkxr[1],cbkxr[2]));  
    for (i=x;i<=r;i++) {for (f=y ; f<=d; f++) _putpixel (i,f);}
    return;
}

int _outsouv_col(int x, int y, char *str, int lang,int *chxr,int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;
unsigned short int neg;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=souv[i].who) continue;
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==souv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=souv[i].who) || (souv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+souv[i].wid) > info.right ) { x = info.left ; y+=18 ; }
  if ( (y+18) > info.bottom ) return 0;
  mem_int=souv[i].where ;
   for(h=0; h<souv[i].hei ; h++) {
     for(w=0;w<souv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=souv[i].wid;} 
        }
}    
return y;
}

int _outnoto_col(int x, int y, char *str, int lang, int *chxr, int *bkxr)
{
union whatcols{
unsigned int lor;
unsigned char rgb[4];
} co ;
int mycol;
unsigned short int len , gr_start , f ,h , w, neg ;
register int i;
int *mem_int ;
char ch , ch1 ;
int red, green, blue ;

gr_start=95;
len=strlen(str);
if (!len) return 0;
if (!lang)  { 
  for (f=0;f<len;f++) {
  for (i=0;i<gr_start;i++) {
  if (str[f]!=nouv[i].who) continue;
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
   neg=255-co.rgb[0];
   red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
   green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
   blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
     setcolor(COLOR (red,green,blue));
   
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;}}}
else
{
    for (f=0;f<len;f++) {
        ch=str[f]; ch1=str[(f+1)];
        for (i=0;i<43;i++) if (ch==nouv[i].who) goto typegr;
            
        for(i=gr_start;i<164;i++) {
            if ( (ch!=nouv[i].who) || (nouv[i].who=='*') ) continue;
            if (ch1 != '\'') goto typegr;
              switch (ch) {
                case 'a' :
                case 'e' :               
                case 'h' :                  
                case 'i' :                    
                case 'o' :                    
                case 'y' :                   
                case 'v' :                   
                case 'A' :
                case 'E' :
                case 'H' :
                case 'I' :
                case 'O':
                case 'Y' :
                case 'V' : f++ ; i++;
                default : break ;
            }
  typegr:
  if ( (x+nouv[i].wid) > info.right ) { x = info.left ; y+=26 ; }
  if ( (y+26) > info.bottom ) return 0;
  mem_int=nouv[i].where ;
   for(h=0; h<nouv[i].hei ; h++) {
     for(w=0;w<nouv[i].wid;w++) {
     co.lor = *mem_int++;
     if (!co.lor) continue;
     neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
      
     _putpixel(x+w , y+h);}}
     x+=nouv[i].wid;} 
        }
}    
return y;
}

int _puticon (int x1,int y1,void *mem1,int transp)
{
int *mem_int;
register int f,i;
unsigned int width , height ;
union {
    unsigned int lor;
    unsigned char rgb[4];
} co ;
mem_int=mem1;
width=*mem_int++;
height = *mem_int++;

    for (f=0;f<height;f++) {
    
    for(i=0 ; i < width; i++) {
    co.lor= *(mem_int++);
    if (co.rgb[3]>127) {
        setcolor (COLOR ( co.rgb[2],co.rgb[1],co.rgb[0] ) );
        _putpixel (x1+i,y1+f);}}} 
    return 1;
}


int gen_menu()
{
SDL_Cursor* cursor;
void *mem_undrme , *mem_efedr1 ,*mem_mmenu;
register int f,i ;
int x1,y1,x2,y2,x3,y3,mx,my;
short int kyk,kyk1,esc_go,outmen,start;
int pras[3],galaz[3],kokin[3];
int cbrown[3];
int *chrpnt[3];
union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


int * mem_int;

// mx = sdlev.button.x ; my= sdlev.button.y ;
mem_undrme= malloc ( imagesize (0,0,479,340) );
if (!mem_undrme) {information (2-keyb_gr,0,0) ; return -1 ;}
strcpy(file_1,path_name);
strcat(file_1,"ICD/pedaba_db2.ico");
mem_mmenu=icontomem(file_1,255);
if (!mem_mmenu) {information (2-keyb_gr,0,0) ; free(mem_undrme); return -1 ;}
pras[0]=50; pras[1]=205; pras[2]=50;
galaz[0]=100; galaz[1]=149; galaz[2]=237;
kokin[0]=255; kokin[1]=0; kokin[2]=127;
chrpnt[0]=pras; chrpnt[1]=kokin; chrpnt[2]=galaz;
cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
x2=info.left+1;y2=info.top+1;
getimage (x2,y2,x2+479,y2+340,mem_undrme);
// ZVGRAFIZEI MENU
start=0;
_areacls (x2,y2,x2+479,y2+320,180,180,180);
setrgbpalette(18,180,180,180); // Color of area behind circles = 18
setrgbpalette(10,0,255,127) ; // Light Green=10
setrgbpalette(11,255,99,71) ; // Tomato=11
setrgbpalette(12,0,255,255) ; // Light Blue=12
_bareacls (x2+2,y2+321,x2+477,y2+338,cbrown); // Περιοχή κειμένου !!

mem_int=(mem_mmenu +8);
for (f=0;f<341;f++) {
    for(i=0 ; i < 480; i++) {
co.lor= *(mem_int++);
if (co.rgb[3]>128) {setcolor(COLOR (co.rgb[2],co.rgb[1],co.rgb[0]));
    
_putpixel (x2+i,y2+f);}}} 
refresh(); 

kyk1=-1; outmen=1;
esc_go=0;

do {
SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN);
do {
    SDL_PollEvent(&sdlev);
    switch (sdlev.type) {
        case SDL_MOUSEMOTION :
            mx=sdlev.motion.x ; my=sdlev.motion.y;
             if (mx<0 || my<0) continue ;
            break;
        case SDL_KEYDOWN :
            if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE ) {mx=x2+450;my=y2+290; esc_go=1;break;}
            else continue ;
        case SDL_MOUSEBUTTONDOWN:
            mx = sdlev.button.x ; my = sdlev.button.y ;
            if( sdlev.button.button==SDL_BUTTON_RIGHT) {
                if (mx<x2 || mx>x2+480 || my<y2 || my > y2+320 ) { mx=x2+450;my=y2+290;esc_go=1;break;}
                else break ;
            }
               else break;
        default :
            continue;
            }

    if (mx>x2 && mx<x2+480 && my>y2 && my < y2+320 ) {
        if (outmen) {
            outmen=0;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);}
        x1=(mx-x2)/80;
        y1=(my-y2)/80;
        kyk=(y1*6) + x1 ;

        if (!start) {
            setrgbcolor(10+mmed[kyk]);
            mem_efedr1 = mem_mmenu+8+ (y1*153600)+ (x1*320);
            for (f=0;f<79;f++) {
                mem_int=(mem_efedr1+(f*1920));
                    for (i=0;i<79;i++) {
                        
                    if ((*mem_int++)) continue;
                    _putpixel (x2+x1*80+i,y2+y1*80+f);}}
            refresh();
            kyk1=kyk;
            x3=x1 ; y3 = y1 ;
            start=1;
            _outmystr_center_col (0, mmestr[kyk], x2+3,y2+322,x2+477,y2+339,chrpnt[mmed[kyk]],cbrown);
            refresh();
            goto GIVE_HELP ;
            }

        if (kyk==kyk1) continue ;
        //EPANAFEREI XRVMA EPILOGHS
        setrgbcolor (18); 
        mem_efedr1 = mem_mmenu+8+(y3*153600)+ (x3*320);
        for (f=0;f<79;f++) {
                mem_int=(mem_efedr1+(f*1920));
                for (i=0;i<79;i++) {
                    if ((*mem_int++)) continue;
                    _putpixel (x2+x3*80+i,y2+y3*80+f);}}
        _bareacls (x2+2,y2+321,x2+477,y2+338,cbrown); // Περιοχή κειμένου !!
        if (mem_small) hide_help(hdhlpxt , hdhlpyt) ;

        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x1 ; y3 = y1 ;
        setrgbcolor (10+mmed[kyk]);
        mem_efedr1 = mem_mmenu+8+(y1*153600)+ (x1*320);
        for (f=0;f<79;f++) {
            mem_int=(mem_efedr1+(f*1920));
            for (i=0;i<79;i++) {
                if ((*mem_int++)) continue;
                _putpixel (x2+x1*80+i,y2+y1*80+f);}}
        _outmystr_center_col (0, mmestr[kyk], x2+3,y2+322,x2+477,y2+339,chrpnt[mmed[kyk]],cbrown);
        refresh();
        
GIVE_HELP :

        switch (kyk) {
            
            case 0:
                if (keyb_gr) show_help(" Αριστ. κλικ για Δημιουργία Νέας Βάσης Δεδομένων / ΔΕΞΙ κλικ για Γενικές Οδηγίες ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                else show_help(" Left click to create a New DB / RIGHT click for General Instructions ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ; 
                break;
                
            case 4:
                if ( (!mmed[4]) && (seflag) ) {
                    if (keyb_gr) show_help(" Αριστ. κλικ για καθορισμό κριτηρίων / ΔΕΞΙ κλικ για διαγραφή όλων των κριτηρίων ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                    else show_help(" Left click to define search criteria / RIGHT click to clear search criteria ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;} 
                    break;
                    
            case 6:
                if(mmed[3]!=2) {
                    if (keyb_gr) show_help(" Λειτουργία μόνον σε κατάσταση Σχεδίασης Δομής! ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                    else show_help(" Function only in \"Design the DB\" mode! ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;}
                    else {
                        if (!diax_dec) {
                        if (keyb_gr) show_help(" Αριστ. κλικ : Πρόσθεση Νέου Πεδίου & Διαχείριση Πεδίων / ΔΕΞΙ κλικ : Διαχείριση Ετικετών ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Left click : Add New Field & Fields' Management / RIGHT click : Labels' Management ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;}
                        else {
                        if (keyb_gr) show_help(" Αριστ. κλικ : Πρόσθεση Νέας Ετικέτας & Διαχείριση Ετικετών / ΔΕΞΙ κλικ : Διαχείριση Πεδίων ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Left click : Add New Label & Labels' Management / RIGHT click : Fields' Management ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                        }
                    }
                    break;
                    
            case 8:
                if (!mmed[8]) {
                    if (keyb_gr) {
                        if (dbkey!=100) {
                            mytext_tonorm (ptr_pedio[dbkey]->finame , file_1,40); 
                            file_2[0]='\0';
                            if (dbplgr && dbcard<=dbplgr) {
                                ptr_char=memk[dbkey];
                                mytext_tonorm(ptr_char,file_2,50);
                            }
                            sprintf(str1024," [%s] : %s / ΔΕΞΙ κλικ : Aλλαγή κλειδιού ταξινόμησης " , file_1,file_2);
                        }
                        else {
                            if (dbplgr && dbcard<=dbplgr) {
                            what_mytime (cardwhen, str1kb);
                            }
                            else str1kb[0]='\0';
                            sprintf(str1024," Tαξινόμηση με τη σειρά καταχώρησης [%s] / ΔΕΞΙ κλικ : Όρισε κλειδί ταξινόμησης " , str1kb);}
                    }
                    else {
                        if (dbkey!=100) {
                            mytext_tonorm (ptr_pedio[dbkey]->finame , file_1,30);
                            file_2[0]='\0';
                            if (dbplgr && dbcard<=dbplgr) {
                                ptr_char=memk[dbkey];
                                mytext_tonorm(ptr_char,file_2,25);
                            }
                            sprintf(str1024," [%s] : %s / RIGHT click : Change DB sorting key " , file_1,file_2);
                        }
                        else {
                            if (dbplgr && dbcard<=dbplgr) {
                            what_mytime (cardwhen, str1kb);
                            }
                            else str1kb[0]='\0';
                            sprintf(str1024," Sorting according the entry order [%s] / RIGHT click : Define DB key ",str1kb);}
                    }
                    ptr_char=0;
                    show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                    break;
                    
            case 10:
                if ( (!mmed[10]) && (seflag==3) ) {
                if (keyb_gr) sprintf(str1024,"Αριστ. κλικ .. για παρουσίαση %u συγκεκριμένων καρτελών (βάσει των κριτηρίων εύρεσης)" , gocards);    
                else  sprintf(str1024,"Left click.. for presentation of %u specific DB cards (according to the searching criteria)" , gocards);
                show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                break;
                    
            case 13:
                if (seflag==2) {
                if (keyb_gr) sprintf(str1024,"Αριστ. κλικ : %u καρτέλες προς διαγραφή (σύμφωνα με τα κριτήρια εύρεσης)" , gocards);    
                else  sprintf(str1024,"Left click : %u DB cards for deletion (according to the searching criteria)" , gocards);
                show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                else if(user_opts) {
                if (keyb_gr) sprintf(str1024," Αριστ. κλικ για διαγραφή της τρέχουσας καρτέλας / ΔΕΞΙ κλικ για διαγραφή %u καρτελών που έχετε ήδη επιλέξει " , tot_opts);    
                else  sprintf(str1024," Left click for deletion of current DB card / RIGHT click for deletion of %u DB cards you have already selected " , tot_opts);
                show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                break;
                    
            case 14:
                if (user_opts) {

                    if (keyb_gr) sprintf(str1024," Αριστ. κλικ : Εξαγωγή τρέχουσας καρτέλας / ΔΕΞΙ κλικ : Εξαγωγή %u καρτελών (επιλογές χρήστη) " , tot_opts);    
                    else  sprintf(str1024," Left click : Export current DB card / RIGHT click : Export %u DB Cards (user's selections) " , tot_opts);
                    show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                
                else if (seflag==2) {
                if (keyb_gr) sprintf(str1024," Αριστ.κλικ : Εξαγωγή %u καρτελών (κριτήρια εύρεσης) / ΔΕΞΙ κλικ : Εξαγωγή  Όλων " , gocards);    
                else  sprintf(str1024," Left click : Export %u DB cards (searching criteria) / RIGHT click : Export All " , gocards);
                show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                break ;
                }
                else if(dbplgr) {
                    if (keyb_gr) strcpy(str1024," Αριστ. κλικ : Εξαγωγή τρέχουσας καρτέλας / ΔΕΞΙ κλικ : Εξαγωγή Όλων ");    
                    else  strcpy(str1024," Left click : Export current DB card / RIGHT click : Export All ");
                    show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                break;
                
            case 16:
                if (epil_pos && user_opts) {
                    if (keyb_gr) sprintf(str1024," Έχετε επιλέξει %u καρτέλες ! Αριστ. κλικ για νέα επιλογή / ΔΕΞΙ κλικ για κατάργηση επιλογών χρήστη " , tot_opts);    
                    else  sprintf(str1024," You have selected %u DB cards! Left click to make a new selection / RIGHT click to remove users selection " , tot_opts);
                    show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                else if (epil_pos && !user_opts) {
                    if (keyb_gr) sprintf(str1024," Έχετε επιλέξει %u καρτέλες ! Αριστ. κλικ για νέα επιλογή / ΔΕΞΙ κλικ για παρουσίαση επιλογών χρήστη " , tot_opts);    
                    else  sprintf(str1024," You have selected %u DB cards! Left click to make a new selection / RIGHT click to show users selection" , tot_opts);
                    show_help(str1024,x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                }
                break;
                    
                case 20 :
                    if (keyb_gr) show_help(" Αριστ. κλικ για Δημιουργία Λίστας Δεδομένων / ΔΕΞΙ κλικ για Βοήθεια ", x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                      else show_help(" Left click to create a New Ready List / RIGHT Click for Help ",  x2+x1*80+74, y2+y1*80 , &hdhlpxt , &hdhlpyt) ;
                    break;
                    
            default :
                break;
                }
                
        continue ;    
        }
    else {

    if (start) {
        setrgbcolor(18);
        mem_efedr1 = mem_mmenu+8+(y3*153600)+ (x3*320);
        for (f=0;f<79;f++) {
        mem_int=(mem_efedr1+(f*1920));
        for (i=0;i<79;i++) {
        if ((*mem_int++)) continue;
        _putpixel (x2+x3*80+i,y2+y3*80+f);}}
        bareacls (x2+2,y2+322,x2+477,y2+338,cbrown); // Περιοχή κειμένου !!
        if (mem_small) hide_help(hdhlpxt , hdhlpyt) ;
        start=0; kyk1=-1;} 
    if (outmen) continue;
    outmen=1;
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    continue ;   
    }
} while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!esc_go) ) ;

if (mem_small) hide_help(hdhlpxt , hdhlpyt) ;
putimage (x2,y2,mem_undrme,0);   
free(mem_undrme); free (mem_mmenu);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
refresh();
if( esc_go ) return (-60) ;
else if (sdlev.button.button==SDL_BUTTON_LEFT) return (kyk) ;
else if (sdlev.button.button==SDL_BUTTON_RIGHT) {if (!kyk) kyk=-25; return (-kyk);}
else return (-60);
}

int input_alert (int id,char *seleo, char *inp_str, short int orio)
// Επιστρέφει 1 εάν συμφωνήσει ο χρήστης !
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int neg , trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;

whouv=gouv;
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
for (f=0;f<3;f++) {
    bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
}

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; 
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    gouv=whouv;
    return 0;
}
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/keyboard2.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0); goto FYGE;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0); goto FYGE;}

setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+200,y+10,"T y p e ..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+201,y+10,"T y p e ..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
refresh();
}
else {
outnoto_col(xp+165,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
refresh();    
}
xr=xp+492;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! 
i=0;f=0;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        chrxr[0]=120;chrxr[1]=181;chrxr[2]=117;
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
        green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
        blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    chrxr[0]=255;chrxr[1]=142;chrxr[2]=63;


    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
         if (!mem_efedr1) {printf ("Input Alert Function - Out of memory !! \n"); free(mem0); gouv=whouv; return 0;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+80) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+80) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }
refresh();
yc=y4+80; xc=x4;
setcolor(5);
rectangle (xc+1,yc+3,xr-2,yc+24);
gouv=myfont[0];
text_input(inp_str, xc+2, yc+4, xr-3, yc+23, (int) orio);
    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh(); continue;}
            case SDL_KEYDOWN : continue;
            case SDL_MOUSEMOTION : break;
            case SDL_MOUSEBUTTONDOWN : break;
            case SDL_QUIT : break ;
            default : continue;}
        break ;
    }
            

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;trik=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if ( sdlev.type==SDL_QUIT ) { mx=x+170;my=y1+30;enter_go=1;break;} 
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        trik=0;
        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if (trik) {
        if  (mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            qtext_input(inp_str, xc+2, yc+4, xr-3, yc+23, (int) orio);
            while (1) {
                SDL_PollEvent(&sdlev); 
                switch (sdlev.type) {
                case SDL_WINDOWEVENT : {refresh(); continue;}
                case SDL_KEYDOWN : continue;
                case SDL_MOUSEMOTION : break;
                case SDL_MOUSEBUTTONDOWN : break ;
                case SDL_QUIT : break ;
                default : continue;} 
                trik=0;
                break ;
            }
            }}

        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

fidicls(xp, y,xp+399,y+299, 65,80,225);  
FYGE :
putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if(mem_menu) free(mem_menu);
if(mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return((int)kyk);
}

int mytext_tonorm(unsigned char *mystr , char *normstr, int orio)
// Προσοχή το όριο σχετίζεται με τη χωρητικότητα του normstr !! 
{
unsigned char what ;
char cha,chb;
register int f=0, a=0 ;

  while (orio) {
    what=mystr[f];
    if (what<95) {
        normstr[a]=gouv[what].who; orio--;a++;}
    else if ( (what>94) && (what<164) ) {
        //if (!keyb_gr) {normstr[a]=32;a++;orio--;f++;continue;}
            if (orio<2) break;
        cha=((unico[what-95][0]/256)-255);
        chb = (unico[what-95][0] % 256);
        normstr[a]=cha; normstr[a+1]=chb; a+=2;orio-=2;}
    else if (what==200) {normstr[a]='\n' ; a++;orio--;}
    else if (what==255) break;
    f++;
  }
    normstr[a]='\0';
    return f; // Πόσοι δικοί μου χαρακτήρες μετατράπηκαν σε κανονικούς  
}

void what_time (char *str)
{
char month [12][12];
char day [7][10];
char *str1;
unsigned short int f;
char ch;

loctime=time(NULL);
diary=localtime(&loctime);

if (keyb_gr) {
strcpy (month[0],"Ιαν."); strcpy (month[1],"Φεβ."); strcpy (month[2],"Μαρ."); strcpy (month[3],"Απρ.");
strcpy (month[4],"Μάι."); strcpy (month[5],"Ιούν."); strcpy (month[6],"Ιούλ."); strcpy (month[7],"Αύγ.");
strcpy (month[8],"Σεπ."); strcpy (month[9],"Οκτ."); strcpy (month[10],"Νοε."); strcpy (month[11],"Δεκ.");

strcpy (day[1],"Δευ.");  strcpy (day[2],"Τρί."); strcpy (day[3],"Τετ."); strcpy (day[4],"Πέμ.");
strcpy (day[5],"Παρ."); strcpy (day[6],"Σαβ."); strcpy (day[0],"Κυρ.");


sprintf (str,"%s - %d %s %d - %02d:%02d" , day[diary->tm_wday] , diary->tm_mday , month[diary->tm_mon] , (diary->tm_year+1900) , diary->tm_hour , diary->tm_min);}
else
    {
    str1=asctime(diary);
    f=0;
    ch=str1[f];
    while (ch!='\0') {

        if (ch=='\n') break;
        str[f]=ch;
        f++;
        ch=str1[f];
            
        }
        str[f]='\0';
    }
}


int normtext_tomy(char *normstr , char *mystr) 
// Αν δεν υπάρχει ο δεύτερος δείκτης (*mystr) τότε, η μετατροπή θα αντικαταστήσει το κανονικό κείμενο !!
{
void *mem1 = 0;
unsigned short int ch1 ;
int a ;
register int f , i ;
char ch ;
char *str;

if (!mystr) {
mem1=malloc( strlen(normstr) +1 );
if (!mem1) {information(2-keyb_gr,0,0); return 0; }
str=mem1;}
else str = mystr ;

f=0 ; a=0 ;
ch=normstr[f];
while ( ch!='\0') {
    if (ch<0) {
        
        f++ ; ch1= ( (256*ch) + normstr[f] ) ;
            for (i=0 ; i<69 ; i++) {
                if (ch1==unico[i][0]) {
                    str[a]=unico[i][1];  a++; break;}}
        if (i==69) {str[a]=0 ; a++ ; f--; }
        f++; ch=normstr[f];continue;
         }
    else {
    if (ch=='\n') {str[a]=200; a++; f++; ch=normstr[f]; continue;}
    for(i=0;i<95;i++) {
        if (ch==souv[i].who) {
        str[a]=i ; a++ ; break;}}
    if (i==95) {str[a]=0 ; a++ ; }
    f++;ch=normstr[f];}
    
}
    
    str[a]=255;
    if (mem1) {
        for (f=0;f<=a;f++) normstr[f]=str[f];
        free(mem1);}
return a;
}

void _outfanis_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 , neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

    what=str[a];
    while (what!=255 && what!=200) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
}    

void _outfanis_center_col(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;


a=xr-x+1;
if (a<myfont_wid[font]) return ;
f=0;
neg=0;
what=str[f];
if (what==255) return ;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

if (neg>a) neg=a;
c=(a-neg)/2;
x+=c;

    a=0;
    what=str[a];
    while (what<164) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
    green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
    blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
}    

void _outfanis_colsel(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 , neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xr-gouv[what].wid) ) break;
    
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) {setcolor (COLOR(slxr[0],slxr[1],slxr[2])) ;  _putpixel(x+i , y+f); continue ; }
        neg=255-co.rgb[0];
        red =  abs( (chxr[0]*co.rgb[0]/255) - (bkxr[0]*neg/255) );
        green =  abs( (chxr[1]*co.rgb[0]/255) - (bkxr[1]*neg/255) );
        blue =  abs( (chxr[2]*co.rgb[0]/255) - (bkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
     while (f<myfont_hei[font]) {
        setcolor (COLOR(slxr[0],slxr[1],slxr[2])) ;
        for(i=0;i<gouv[what].wid;i++) { _putpixel(x+i , y+f);} f++ ;}
    x+=gouv[what].wid;
    what=str[++a];
    } 
   for (f=y; f<y+myfont_hei[font]; f++)  for (i=x; i<xr; i++)  _putpixel( i , f);
   gouv=trampa;
}    


void * button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *but_name) 
// Επιστρέφει την αρχή της μνήμης του δημιουργημένου string , περνάει στον ar το μέγεθος του αλφαριθμητικού πράγμα που χρειάζεται στην button show και τροποποιεί το orio προς τα κάτω , το όνομα του button τοποθετείται στο but_name σε μορφή κειμένου της input (περικόπτεται στους 20 χαρακτ. [20 χαρακτ. + 255] αλλά, να δίνω χώρο 64 chars στο but_name για να χωράει και τα ελληνικά σε πρώτη φάση από το zenity)! 
{
FILE *fp ;
SDL_Cursor* cursor;
void *mem ;
char *memc;
int *mem_int;
unsigned short int orio, orio1 , m ;
unsigned char what;
register int f ,i ;
char *loadfile ;
int pedaba[4] , pedaca , c ;
unsigned short int a ;
unsigned int size;

pedaba[0]=22111963; pedaba[1]=404976; pedaba[2]=99; pedaba[3]=167330;
mem=malloc(512);
if (!mem) {information (2-keyb_gr,0,0); return 0;}
loadfile=mem;

sprintf (file_2,"%s%s",path_name,"Lists/");
if (keyb_gr) strcpy (file_1,"\"Eπιλέξτε και ΦΟΡΤΩΣΤΕ\"");
else strcpy (file_1,"\"Choose and LOAD\"");

sprintf(loadfile,"zenity --file-selection --title=%s --filename=%s --file-filter='*.inp' > %s%s",file_1,file_2, path_name,"zenity.txt");
system(loadfile);
refresh();
sprintf (loadfile,"%s%s",path_name,"zenity.txt");
fp = fopen(loadfile,"r");
if (fp==NULL) {information (6-keyb_gr,0,0); free(mem); return 0;}
f=0;
    do {
    loadfile[f]= (char) getc(fp);
    f++;
    }while ( (!feof(fp)) && (f<512) );
fclose(fp);
if (f<3) {free(mem); return 0;}
f-=2; loadfile[f]='\0';
c=strlen(loadfile);
if ( !c ) {free(mem); return 0;}

c=0;
fp=fopen(loadfile,"rb");
if (fp==NULL) {information (6-keyb_gr,loadfile,0); free(mem) ; return 0;}

    for (f=0 ; f<4 ; f++) {
    fread(&pedaca,4,1,fp);
    if (feof(fp)) { c=1; break; }
    if (pedaca!=pedaba[f]) {c=1;break;}}

if (c) { fclose (fp) ; free(mem); return 0 ; } // PROSOXH ΨΕΥΤΙΚΟ ΑΡΧΕΙΟ .inp !!!!!!
fread(&c,2,1,fp); // Πετάω το (ar της input...)

// Ξεχωρίζω το όνομα του αρχείου από το path .
c=strlen(loadfile);
i=c-1;
while ( (loadfile[i]!='/') && (i>=0) ) i--;
if (i<0) {fclose (fp) ; free(mem); return 0 ;}
f=i+1;a=0;
while ( (loadfile[f]!='.') && (f<c) ) { but_name[a++]=loadfile[f++]; }
but_name[a]='\0';
// Μετατρέπω το όνομα αρχείου από normal στο στυλ της input
normtext_tomy(but_name , 0);
// Περικόπτω το όνομα στους 20 χαρακτήρες !
f=0;
    do {
        what=but_name[f]; 
        if (what==255) break;
        f++;
    } while (f<20);
    but_name [f]=255;

free(mem);    
size=1024;
mem=malloc(size);
if (!mem) {information(2-keyb_gr,0,0); fclose(fp); return 0;}
memc=mem;
orio=*ptr_orio;
i=0; orio1=0;m=0;

fread (&what,1,1,fp);
if (what==255) {fclose (fp); information(0,"Empty List",0); free(mem); return 0;}
    
do{
        
        if (what==200) { 
            if (m){ 
            if (orio1<m) orio1=m;
            m=0;
            memc[i++]=255;} 
            }
            
        else if (what<0 || what>163) break;
        
        else if (m==orio) {
                orio1=orio;m=0;
                memc[i++]=255;
                
                do{
                fread (&what,1,1,fp);
                if (feof(fp)) {rewind(fp); what=255; break;}
                } while (what!=200 && what!=255);
                if (what==255) break;
            }
        else {
            memc[i++]=what ;
            m++;
        }
        
        if (i>size-4) {
            size+=512;
            mem=realloc(mem,size);memc=mem;
            if (!mem) {information (2-keyb_gr,0,0); fclose(fp); return 0; }
        }
        
        fread (&what,1,1,fp);
        if (feof(fp)) {rewind(fp); break;}
    } while (what!=255) ;

    what=memc[i-1];    
    if (what!=255) {memc[i]=255;i++;if (orio1<m) orio1=m;}
    
    if (ferror(fp)) {information (6-keyb_gr,0,0);clearerr(fp) ; fclose(fp);free(mem); return 0; } else fclose (fp); 
 
*ptr_ar = (unsigned short int) i ;
*ptr_orio=orio1;
return (mem);
}

void pro_sort_ulong (unsigned long int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_ulong(item,point,0,count-1);
}


void qui_sort_ulong (unsigned long int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    unsigned long int x,y;
    unsigned short int y1;
    unsigned short int p1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    p1=point[(left+right)/2];
    
    do {
        
        //while (item[i]<x && i<right) i++;
        while (i<right) {
        if ( item[i]<x ) i++; 
        else if (item[i]==x && point[i]<p1) i++;
        else break ;
        }
        
        //while (x<item[j] && j>left) j--;
        while (j>left) {
        if ( x<item[j] ) j--; 
        else if (x==item[j] && p1<point[j]) j--;
        else break ;
        } 
        
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_ulong(item,point,left,j);
    if (i<right) qui_sort_ulong(item,point,i,right);
}

void pro_sort_24b (void *vitem,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_24b(vitem,point,0,count-1);
}


void qui_sort_24b(void *vitem , unsigned short int *point , int left , int right)
{
    struct XX4_byte {
    unsigned long int fg;
    unsigned long int sg;
    unsigned long int tg;
    };
    
    struct XX4_byte *item;
    
    register int i,j ;
    unsigned long int x[3] , y[3] ;
    unsigned short int y1 , ym ;
    short int res_i , res_j ;

    item=vitem;
    i=left ; j=right ;
    x[0]=item[(i+j)/2].fg;
    x[1]=item[(i+j)/2].sg;
    x[2]=item[(i+j)/2].tg;
    ym = point[((i+j)/2)];
    
    do {
        //1st strcmp
        do {
            if (item[i].fg < x[0]) res_i=-1;
            else if (item[i].fg > x[0]) res_i=1;
            else if (item[i].sg < x[1]) res_i=-1;
            else if(item[i].sg > x[1]) res_i=1;
            else if(item[i].tg < x[2]) res_i=-1;
            else if(item[i].tg > x[2]) res_i=1;
            else {
                
                res_i = (point[i]<ym) ? -1 : 1 ;
            }
        } while (res_i<0 && i++ < right) ;
        
        //2nd strcmp
        do{
            if(x[0] < item[j].fg) res_j=-1;
            else if(x[0] > item[j].fg) res_j=1;
            else if(x[1] < item[j].sg) res_j=-1;
            else if(x[1] > item[j].sg) res_j=1;
            else if(x[2] < item[j].tg) res_j=-1;
            else if(x[2] > item[j].tg) res_j=1;
            else {
                res_j = (ym<point[j]) ? -1 : 1 ;
            }
            
        }while (res_j<0 && j-- > left) ;
        
        if (i<=j) {
            y[0]=item[i].fg; y[1]=item[i].sg; y[2]=item[i].tg;
            y1=point[i];
            item[i].fg = item[j].fg ; item[i].sg = item[j].sg;  item[i].tg = item[j].tg;
            point[i]=point[j];
            item[j].fg = y[0];  item[j].sg = y[1];  item[j].tg = y[2]; 
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_24b(vitem,point,left,j);
    if (i<right) qui_sort_24b(vitem,point,i,right);
}


int mytext_toclipboard (char *data)
{
unsigned long int size;
register int i,f;
unsigned char what;
char cha,chb;
void *mem;
char *clipbo;
int a;


size=0;
i=0;
what=data[i];
while (what!=255) {
    if (what<95) size++;
    else if ( (what>94) && (what<164) ) size+=2;
    else size++;
    what=data[++i];    
    }
f=i;
size+=2;
mem=malloc(size);
if (!mem) {information(2-keyb_gr,NULL,NULL); return 0;}
clipbo=mem;
a=0;
for (i=0 ;i<f ;i++) {
    what=data[i];
    if (what<95) {
        clipbo[a]=gouv[what].who; a++;}
    else if ( (what>94) && (what<164) ) {
        cha=((unico[what-95][0]/256)-255);
        chb = (unico[what-95][0] % 256);
        clipbo[a]=cha; clipbo[a+1]=chb; a+=2;}
    else if (what==200) {clipbo[a]='\n' ; a++;}
        }
clipbo[a]='\0'; i=a;
a=SDL_SetClipboardText(clipbo);
if(a) { 
    if (keyb_gr) information (0,"Η αντιγραφή στον clipboard απέτυχε!",0);
    else information (0,"COPY to clipboard failed !" , 0);
    }
free(mem);
return i;
}


void * named_button_load(unsigned short int *ptr_orio, unsigned short int *ptr_ar, char *full_name) 
// BUTTON LOAD XVRIS ZENITY (Δίνουμε έτοιμο το πλήρες όνομα αρχείου (/home/fanisatt/Pedaba/.... και το όριο είναι μέχρι 50 .
//Μετά την επιστροφή όμως πρέπει να περαστεί το καθαρό όνομα (χωρίς path και σε μορφή δικού μου κειμένου) στην αντίστοιχη δομή των buttons).
// Επιστρέφει την αρχή της μνήμης του δημιουργημένου string , τροποποιεί το orio προς τα κάτω , υπολογίζει το ar και ενημερώνει τα στοιχεία της δομής.
{
FILE *fp ;
void *mem ;
char *memc;
unsigned short int orio, orio1 , m ;
unsigned char what;
register int f ,i ;
int pedaba[4] , pedaca , c ;
unsigned short int a ;
unsigned int size;

pedaba[0]=22111963; pedaba[1]=404976; pedaba[2]=99; pedaba[3]=167330;
c=0;
fp=fopen(full_name,"rb");
if (fp==NULL) {information (6-keyb_gr,full_name,0); return 0;}

    for (f=0 ; f<4 ; f++) {
    fread(&pedaca,4,1,fp);
    if (feof(fp)) { c=1; break; }
    if (pedaca!=pedaba[f]) {c=1;break;}}

if (c) { fclose (fp) ; return 0 ; } // PROSOXH ΨΕΥΤΙΚΟ ΑΡΧΕΙΟ .inp !!!!!!
fread(&c,2,1,fp); // Πετάω το (ar της input...)

size=1024;
mem=malloc(size);
if (!mem) {information(2-keyb_gr,0,0); fclose(fp); return 0;}
memc=mem;
orio=*ptr_orio;
i=0; orio1=0;m=0;

fread (&what,1,1,fp);
if (what==255) {fclose (fp); free(mem); return 0;}
    
do{
        
        if (what==200) { 
            if (m){ 
            if (orio1<m) orio1=m;
            m=0;
            memc[i++]=255;} 
            }
            
        else if (what<0 || what>163) break;
        
        else if (m==orio) {
                orio1=orio;m=0;
                memc[i++]=255;
                
                do{
                fread (&what,1,1,fp);
                if (feof(fp)) {rewind(fp); what=255; break;}
                } while (what!=200 && what!=255);
                if (what==255) break;
            }
        else {
            memc[i++]=what ;
            m++;
        }
        
        if (i>size-4) {
            size+=512;
            mem=realloc(mem,size);memc=mem;
            if (!mem) {information (2-keyb_gr,0,0); fclose(fp); return 0; }
        }
        
        fread (&what,1,1,fp);
        if (feof(fp)) {rewind(fp); break;}
    } while (what!=255) ;

    what=memc[i-1];    
    if (what!=255) {memc[i]=255;i++;if (orio1<m) orio1=m;}
    
    if (ferror(fp)) {information (6-keyb_gr,0,0);clearerr(fp) ; fclose(fp);free(mem); return 0; } else fclose (fp); 
    
*ptr_ar = (unsigned short int) i ;
*ptr_orio=orio1;
return (mem);
}


int add_edit_field (short int new,short int *_arped)
// Για new=dbfinum+1 προσθέτει νέο πεδίο - ενώ για new<=dbfinum , κάνει edit αρχίζοντας από το πεδίο υπ' αριθμόν new (από 0 και πάνω). 
// επιστρέφει τιμή 1 αν προστέθηκε κάποιο πεδίο στη μνήμη ,ή αν έγινε μια έγκυρη μεταβολή σε κάποιο πεδίο ! Τιμή 2 = άκυρο , τιμή 0 = κάτι δεν έγινε καλά . //Τιμή 3 σημαίνει ότι έγινε διαγραφή πεδίου με dbplgr=0, ο fpdb έκλεισε και απαιτείται πάλι ξεκίνημα της βάσης από την αρχή.
//Τιμή 4 σημαίνει ότι προστέθηκε πεδίο και ο dbplgr!=0 .
// στη διεύθυνση που δείχνει ο _arped βάζει την τιμή του αριθμού πεδίου όπου πατήθηκε οκ και γράφτηκαν στοιχεία (μεταβολές) στο δίσκο.
{
    
FILE *fp , *fp1card;
time_t cardwhen1 ;
int fide_fp1 , i1 ;
register int f,i ;
static int prev_code ;
SDL_Cursor* cursor;
struct fansouv *trampa ;
void *mem0=0 , *mem_form=0 , *mem_arrs=0 , *mem_ok=0 , *mem_ni=0 , *mem_ri=0 , *mem_le=0 , *mem_yel=0 , *mem_inkual=0 , *mem_rinks=0 , *mem=0 , *mem_del=0 , *mem1 , *mem_yk=0 , *mem_nk=0 , *mem_fyge=0 , *mem2=0 ;
void *mem_go=0 , *mem5;
int *mem_int ;
int mx,my,mx1,my1,dx,dy , dz, xt1,yt1,xb1,yb1 , user_ans , dx1, dy1 ;
unsigned short int arped ,stoxos , _prodbkey , old_li , old_xli , n ;
unsigned short int arrxt, arryt,finuxt,finuyt,finuxb,finuyb,finaxt,finayt,finaxb,finayb;
unsigned short int rixt, riyt, leyt, lext, xok, yok, rtxt, ltxt ,ltyb, rtyb , ltxb, rtxb ,xgo, ygo , keyxt, keyyt;
unsigned short int orchayt,keyloyt,listnayt,orchaxb,orchayb, keyloxb, keyloyb , listnaxb, listnayb , orchaxt ,keyloxt , listnaxt , delxt, delyt;
unsigned short int fontxt,fontyt,fontxb,fontyb;
unsigned short int datyt[7] , varyt[7] , datni[7] , varni[7] , kentroyt [4], kentro1yt[4];
unsigned short int Xxt, Xxb, Pxt, Pyt, Pyb , Pxb, lizext, lizeyt , inksxt, inksyt , fygex , fygey;
unsigned short int Xoxt, Xoxb;
short int ektos , fyge ,marrs , left , right, proenter , go_ri , go_le , kentro , kentro1, left_box, right_box, proleft , proright , prokentro , prokentro1 , kentro_box , kentro1_box , page_box , akyro , delfi , prokey , profyge ;
short int keylock, orioxar,fonter, onom_ped, onom_list, inklizer , rdyinks  ,epanorio ; 
char old_fitype ;
int pedbkxr[3] , nambkxr[3] , reccol[3], yelbkxr[3] ,selped[3], selnam[3], pedrgb, namrgb, yelrgb, recrgb;
int bluechxr [3] , proxchxr[3] , proxbkxr[3], proxslxr[3] ;
int efchxr[3] , efbkxr[3], efslxr[3] ;
unsigned char prox[10];
int red,green,blue;
unsigned char orio_char [7] , kvdikos[6] ;
int hoc=0 , hocl[7], hocm[7], hkvd=0;
char font_text[20];
unsigned char pedname[30], nameoflist [25] ,selida[4] ;
unsigned char what ;
unsigned char K[4][6], K1[4][6] ;
unsigned int ke[5] , ke1[5] , el_wid, el_hei ,selis ;
short int ep_font=1;
short int diat_mem=0 , adyn;
char *ptr_ch;
static int xt,yt,xb,yb ;
char *ptr_copy=0 , *ptr0;
short int a , b, g ;
char old_mathtype , new_mathtype;
short int calcbox , edcalcbox ;
unsigned short int calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb;
unsigned short int edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb;
unsigned char F_text[4] , E_text[6] , new_alg_str[1026];
char *ptr_alg;
short int all_alg=0 ; // Αλλαγή σε alg_str
short int dxm =0 , nem=0;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

short int cross=0 , proel , prodec ;
char intmenu[17][120];
char secmenu[17][120];


if(new<0) return 0;

if (keyb_gr) {
    strcpy (intmenu[0] , "Λήψη Συντεταγμένων ΠΕΔΙΟΥ (Άνω & Αριστερά)");
    strcpy (intmenu[1] , "Υπολογισμός Πλάτους-Ύψους ΠΕΔΙΟΥ (Κάτω & Δεξιά)");    
    strcpy (intmenu[2] , "Λήψη Συντεταγμ. ΟΝΟΜΑΤΟΣ Πεδίου (Άνω & Αριστερά)");
    strcpy (intmenu[3] , "Υπολογισ. διαστάσεων ΟΝΟΜΑΤΟΣ Πεδ.(Κάτω & Δεξιά)");
    strcpy (intmenu[4] , "Χρώμα σημείου ως φόντο");
    strcpy (intmenu[5] , "Στοιχείο για Οριζόντια Στοίχιση ΠΕΔΙΟΥ");
    strcpy (intmenu[6] , "Στοιχείο για Κάθετη Στοίχιση ΠΕΔΙΟΥ");
    strcpy (intmenu[7] , "Στοιχείο για οριζ. Στοίχιση ΠΕΔΙΟΥ στο μέσον");
    strcpy (intmenu[8] , "Αντέγραψε Διαστάσεις στοιχείου στο ΠΕΔΙΟ");
    strcpy (intmenu[9] , "Στοιχείο για Οριζόντια Στοίχιση ΟΝΟΜΑΤΟΣ Πεδίου");
    strcpy (intmenu[10] , "Στοιχείο για Κάθετη Στοίχιση ΟΝΟΜΑΤΟΣ Πεδίου");
    strcpy (intmenu[11] , "Στοιχείο για οριζ. Στοίχιση ΟΝΟΜ. Πεδίου στο μέσον");
    strcpy (intmenu[12] , "Αντέγραψε Διαστάσεις στοιχείου στο ΟΝΟΜΑ Πεδίου");
    strcpy (intmenu[13] , "Αντέγραψε χρώματα Στοιχείου");
    strcpy (intmenu[14] , "Αντέγραψε χρώματα Eτικέτας");
    strcpy (intmenu[15] , "Στοίχιση ΠEΔΙΟΥ οριζ. στο μέσον της ετικέτας");
    strcpy (intmenu[16] , "Στοίχιση ΟΝΟΜ. Πεδίου οριζ. στο μέσον της ετικέτας");
}
else {
    strcpy (intmenu[0] , "Get FIELD coordinates (Up & Left)");
    strcpy (intmenu[1] , "FIELD Width & Height Calculation (Down & Right)");    
    strcpy (intmenu[2] , "Get Field's NAME coordinates (Up & Left)");
    strcpy (intmenu[3] , "Field's NAME dimensions Calculat. (Down & Right)");
    strcpy (intmenu[4] , "Get pixel's color as background");
    strcpy (intmenu[5] , "Element for FIELD Horizontal Alignment");
    strcpy (intmenu[6] , "Element for FIELD Vertical Alignment");
    strcpy (intmenu[7] , "Element for hor. FIELD's Alignm. in the Middle");
    strcpy (intmenu[8] , "Copy Elements Dimensions to the FIELD");
    strcpy (intmenu[9] , "Element for Field's NAME Horizontal Alignment");
    strcpy (intmenu[10] , "Element for Field's NAME Vertical Alignment");
    strcpy (intmenu[11] , "Element for hor. Field's NAME Alignm. in the Middle");
    strcpy (intmenu[12] , "Copy Elements Dimensions to the NAME of the field");
    strcpy (intmenu[13] , "Copy Element's colors");
    strcpy (intmenu[14] , "Copy Labels's colors");
    strcpy (intmenu[15] , "Hor. FIELD's Alignm. in the Middle of the Label");
    strcpy (intmenu[16] , "Hor. Field's NAME Alignm. in the Middle of the Label");
    
}

for (f=0 ; f<5 ; f++) strcpy (secmenu[f] , intmenu[f]);

mem=malloc(dbfisize);
if (!mem) goto FYGE;
ptr_copy=mem; mem=0;
 if (mmed[7]==2 || mmed[9]==2 || mmed[10]==2) adyn=1 ; else adyn=0;
_prodbkey=dbkey;
normtext_tomy("F",F_text);
normtext_tomy("Edit",E_text);
fyge=0;
gouv=myfont[0];
pedbkxr[0]=nambkxr[0]=237;
pedbkxr[2]=nambkxr[2]=189;
pedbkxr[1]=240; nambkxr[1]=173;
yelbkxr[0]=yelbkxr[1]=255 ; yelbkxr[2]=0;
reccol[0]=255; reccol[1]=reccol[2]=0;
bluechxr[0] = bluechxr[1] = 0 , bluechxr[2] = 255; 
setrgbpalette(1100,pedbkxr[0],pedbkxr[1],pedbkxr[2]);
setrgbpalette(1101,nambkxr[0],nambkxr[1],nambkxr[2]);
setrgbpalette(1102,yelbkxr[0],yelbkxr[1],yelbkxr[2]);
setrgbpalette(1103,reccol[0],reccol[1],reccol[2]);
pedrgb=1100 ; namrgb=1101; yelrgb=1102; recrgb=1103 ;
selped[0]=153 ; selped[1]=255 ; selped[2]=selnam[2]=0;
selnam[0]=198 ; selnam[1]=191;
for (f=0;f<3;f++) {proxchxr[f]=255; proxbkxr[f]=0;} 
proxslxr[0]=proxslxr[1]=0 ; proxslxr[2]=210 ;

mem0=malloc(imagesize(0,0,757,384)); //758 x 385
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
if ( (!xt) && (!yt) && (!xb) && (!yb) ) {
xt=(info.right-info.left-758) / 2 ; yt=(info.bottom-info.top-385) / 2 ;
xb=xt+757 ; yb=yt+384;}
getimage(xt,yt,xb,yb,mem0);
if (keyb_gr) sprintf(str1024,"%s%s",path_name,"ICD/Pedia_gr.ico");
else sprintf(str1024,"%s%s",path_name,"ICD/Pedia_en.ico");
mem_form=icontomem(str1024,255);
if (!mem_form) {information(2-keyb_gr,str1024,NULL); goto FYGE;} 
puticon(xt,yt,mem_form,255);
free(mem_form);mem_form=0;

strcpy(file_1,path_name);
strcat(file_1,"ICD/arrows_18.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE; } 
//puticon(xt+3,yt+4,mem_arrs,255);

strcpy (file_1,path_name);
strcat (file_1,"ICD/Yel_ok_39.ico");
mem_ok= icontomem (file_1,255);
if (!mem_ok) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_21.ico");
mem_ni= icontomem (file_1,255);
if (!mem_ni) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_right.ico");
mem_ri = icontomem (file_1,255);
if (!mem_ri) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_left.ico");
mem_le = icontomem (file_1,255);
if (!mem_le) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

mem_yel=malloc(imagesize(0,0,22,22));
if (!mem_yel) {information(2-keyb_gr,0,NULL);goto FYGE ; }
getimage(xt+240,yt+107,xt+261,yt+128,mem_yel);

strcpy (file_1,path_name);
strcat (file_1,"ICD/inkual_26.ico");
mem_inkual = icontomem (file_1,255);
if (!mem_inkual) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/rinks_26.ico");
mem_rinks = icontomem (file_1,255);
if (!mem_rinks) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_40.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/field_del.ico");
mem_del = icontomem (file_1,255);
if (!mem_del) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Yes_Key.ico");
mem_yk = icontomem (file_1,255);
if (!mem_yk) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/No_Key.ico");
mem_nk = icontomem (file_1,255);
if (!mem_nk) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/go_36.ico");
mem_fyge = icontomem (file_1,255);
if (!mem_fyge) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

arrxt=xt+3 ; arryt=yt+3;
finuxt=xt+402 ; finuyt=yt+29 ; finuxb=xt+459 ; finuyb=finuyt+19 ;
finaxt=xt+275 ; finayt=yt+59 ; finaxb=xt+641 ; finayb=finayt+21 ;
rixt=xt+510 ; delxt=xt+690; riyt=leyt=yt+25; lext=xt+248; delyt=keyyt=yt+23; keyxt=xt+40;
xok=xt+680; ygo=yb-35; xgo=xt+23; fygex=xok-50; fygey=yb-36; yok=yb-37 ;

calcbox_xt = xt+25; calcbox_yt = edcalcbox_yt = yt+186;
calcbox_xb = calcbox_xt+22 ;
calcbox_yb = edcalcbox_yb = calcbox_yt+37;
edcalcbox_xt = calcbox_xb+2 ; 
edcalcbox_xb = edcalcbox_xt+33;

ltxt=xt+238; rtxt=xt+693; ltyb=rtyb=yt+280;  ltxb=ltxt+24; rtxb=rtxt+24; //left team - right team
datyt[0]=varyt[0]=yt+105;                                // Τύποι Δεδομένων και Άλλα στοιχεία
datni[0]=varni[0]=0;
    for (f=1 ; f<7 ; f++) {
        datyt[f] = datyt[f-1]+25;
        varyt[f] = varyt[f-1] +25;
        datni[f] = varni[f] =0 ;
    }

orchaxt = keyloxt = listnaxt = ltxt+2 ; 
orchayt=datyt[6]+27; keyloyt=orchayt+25; listnayt = keyloyt+25;
orchaxb=xt+317; orchayb=orchayt+20; keyloxb=xt+297 ; keyloyb=keyloyt+20;

listnaxb=xt+472 ; listnayb=listnayt+20;
Xxt=xt+322; // κοινό xt για κέντρο !
kentroyt[0]=kentro1yt[0]=yt+130;
Xxb=xt+383; // κοινό για κέντρο πλην Σελ. !

for(f=1;f<4;f++) {
    kentroyt[f]=kentroyt[f-1]+25;
    kentro1yt[f] = kentro1yt[f-1]+25;
}

Xoxt=xt+383; // κοινό xt για κέντρο1 !
Xoxb=xt+444; // κοινό για κέντρο1 πλην Σελ. !

Pxt=Xxt+3; Pyt=kentroyt[3] +27 ; Pyb=Pyt+20; Pxb=Xxt+31 ;       // Pxb να ρυθμιστεί για την input !
fontxt=xt+477; fontyt=yt+307; fontxb=xt+715; fontyb=fontyt+21;
lizext=xt+346; inksxt=xt+395; lizeyt=inksyt=yt+282;

_puticon(arrxt,arryt,mem_arrs,255);
_puticon(lext,leyt,mem_le,255);
_puticon(rixt,riyt,mem_ri,255);
_puticon(lizext,lizeyt,mem_inkual,255);
_puticon(inksxt,inksyt,mem_rinks,255);
_puticon(xok,yok,mem_ok,255);
_puticon(xgo,ygo,mem_go,255);
_puticon(delxt,delyt,mem_del,255);
_puticon(fygex,fygey,mem_fyge,255);

setcolor (0);
rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);
rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);
_bareacls (edcalcbox_xt+2,edcalcbox_yt+2,edcalcbox_xb-2,edcalcbox_yb-2,pedbkxr);
_outmystr_center_col(2,E_text, edcalcbox_xt+2,edcalcbox_yt+2,edcalcbox_xb-2,edcalcbox_yb-2,bluechxr,pedbkxr);

hocl[0]=hocl[1]=hocl[2]=hocl[3]=hocl[4]=1; hocl[5]=0; hocl[6]=24;
hocm[0]=65000; hocm[1]=hocm[2]=50; hocm[3]=hocm[4]=14; hocm[5]=0; hocm[6]=24;

new_alg_str[0]=255;
prox_alg_str[0]=255;
// Προετοιμασία σε κάθε περίπτωση του επόμενου πεδίου !
    if (dbfinum<99) {

            arped=dbfinum+1;
            mem = malloc (dbfisize);
            ptr_pedio[arped] = mem;
            if (!ptr_pedio[arped]) {information (2-keyb_gr,0,0); goto FYGE ;}
            varni[0] = varni[3] = varni[6] = 1 ; // Προτοποθέτηση των νι !
            ptr_pedio[arped]->fivar[0]=ptr_pedio[arped]->fivar[3]=ptr_pedio[arped]->fivar[6]=1;
            ptr_pedio[arped]->fivar[1]=ptr_pedio[arped]->fivar[2]=ptr_pedio[arped]->fivar[4]=ptr_pedio[arped]->fivar[5]=0;
            selis=dbpg;
            ptr_pedio[arped]->finame[0]=ptr_pedio[arped]->filistname[0]=255;
            // Pco[0]=dbpg+16;Pco[1]=255;
            ptr_pedio[arped]->finum=arped ; 
            ptr_pedio[arped]->fitype=7 ;  ptr_pedio[arped]->mathtype=0 ; 
            ptr_pedio[arped]->fixt = ptr_pedio[arped]->fiyt = ptr_pedio[arped]->fiwid = ptr_pedio[arped]->fihei=0;
            ptr_pedio[arped]->filaxt = ptr_pedio[arped]->filayt = ptr_pedio[arped]->filawid = ptr_pedio[arped]->filahei=0;
            ptr_pedio[arped]->fipg=dbpg;
            ptr_pedio[arped]->ficode=ptr_pedio[arped]->fiorio=0;
            ptr_pedio[arped]->fibkxr[0]=proxbkxr[0] ; ptr_pedio[arped]->fibkxr[1]=proxbkxr[1] ; ptr_pedio[arped]->fibkxr[2]=proxbkxr[2] ;
            ptr_pedio[arped]->fichxr[0]=proxchxr[0] ; ptr_pedio[arped]->fichxr[1]=proxchxr[1] ;  ptr_pedio[arped]->fichxr[2]=proxchxr[2] ;
            ptr_pedio[arped]->fislxr[0]=proxslxr[0] ;   ptr_pedio[arped]->fislxr[1]=proxslxr[1] ;  ptr_pedio[arped]->fislxr[2]=proxslxr[2] ;
            ptr_pedio[arped]->fiwhen=time(NULL);
            ptr_pedio[arped]->fifont=1;
            ptr_pedio[arped]->fifo_hei=myfont_hei[1]; ptr_pedio[arped]->fifo_wid=myfont_wid[1];
            }

     if (new>dbfinum) {  // Νέο Πεδίο !!
         
        if (dbfinum==99 ) {fyge=2; goto FYGE;}
        else if (adyn) {fyge=2; goto FYGE;}
        
        _puticon(keyxt,keyyt,mem_nk,255);
         for (f=0;f<3;f++) {
           chxr[f]=proxchxr[f] ; bkxr[f]=proxbkxr[f];
               }
        _puticon(rtxt+3,varyt[0]+4,mem_ni,255);
        _puticon(rtxt+3,varyt[3]+4,mem_ni,255);
        _puticon(rtxt+3,varyt[6]+4,mem_ni,255);
        sprintf (prox,"%03d",arped+1);
        _outsouv_col(finuxt,finuyt,prox,0,bluechxr,pedbkxr);
        _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
        sprintf (prox,"%d",dbpg);
        normtext_tomy(prox,selida);
        _outsouv_col(Pxt+1,Pyt+1,prox,0,bluechxr,pedbkxr);
        normtext_tomy(myfont_name[1],font_text);
       _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
        orio_char[0]=kvdikos[0]=pedname[0]=nameoflist[0]=255;
        
        new_mathtype=0;
        _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
        _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);

        
        for (f=0;f<4;f++) {
            _outsouv_col(Xxt+2,kentroyt[f]+2,"0",0,bluechxr,pedbkxr);
            _outsouv_col(Xoxt+2,kentro1yt[f]+2,"0",0,bluechxr,nambkxr);
            K[f][0]=K1[f][0]=16;
            K[f][1]=K1[f][1]=255;
            ke[f]=ke1[f]=0;
                }
        refresh();

        }
    else
    {
        arped=new;
        ptr0 = (char *) ptr_pedio[arped] ;
        for (f=0;f<dbfisize;f++) {ptr_copy[f] = ptr0[f];}
        if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255);
        else _puticon(keyxt,keyyt,mem_nk,255);
        
        if (ptr_pedio[arped]->ficode) {
            if ((short int) prev_code!=ptr_pedio[arped]->ficode) {
            prox[0]=255;
            input_alert (40-keyb_gr,0, prox ,4);
            prev_code=(int) convert_str(4 , prox);
            if (ptr_pedio[arped]->ficode != (short int) prev_code ) {fyge=2; goto FYGE ;}}
        }
        
        // Αριθμός Πεδίου
        sprintf (prox,"%03d",arped+1);
        _outsouv_col(finuxt,finuyt,prox,0,bluechxr,pedbkxr);

        // Ονομασία Πεδίου

        _bareacls(finaxt , finayt , finaxb, finayb,pedbkxr);
        mystrcpy(pedname,ptr_pedio[arped]->finame);
        _outmystr_col (0,pedname, finaxt+1  , finayt+1 , finaxb , bluechxr, pedbkxr);
        trampa=gouv;
        gouv=myfont[ptr_pedio[arped]->fifont];
        f=0;
        ke1[2]=0;
        what=pedname[f];
        while (what!=255) {
            ke1[2]+=gouv[what].wid;
            what=pedname[++f];
        }
        ke1[2]+=2;
        el_wid=ke1[2];
        ep_font=ptr_pedio[arped]->fifont;
        el_hei=ke1[3]=myfont_hei[ep_font]+2;
        gouv=trampa;

        // LEFT
        for (f=0;f<7;f++) {
        _puticon(ltxt+2,datyt[f]+2,mem_yel,255);
        datni[f]=0;
        }
        i=ptr_pedio[arped]->fitype;
        if (i>=0 && i<7) {datni[i]=1;
        _puticon(ltxt+3,datyt[i]+4,mem_ni,255);}
        
        // new_mathtype

        new_mathtype = ptr_pedio[arped]->mathtype ;
        
        if (new_mathtype) {
            mystrcpy (prox_alg_str, alg_str[arped]);
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,yelbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,reccol,yelbkxr);
        }
        else {
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
        }
        
        
        // KENTRO - KENTRO 1
        ke[0]=ptr_pedio[arped]->fixt;
        ke[1]=ptr_pedio[arped]->fiyt;
        ke[2]=ptr_pedio[arped]->fiwid;
        ke[3]=ptr_pedio[arped]->fihei;
        ke1[0]=ptr_pedio[arped]->filaxt;
        ke1[1]=ptr_pedio[arped]->filayt;
        ke1[2]= ptr_pedio[arped]->filawid;
        ke1[3]= ptr_pedio[arped]->filahei;
        for (f=0;f<4;f++) {
            _bareacls (Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22,pedbkxr);
            _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
            sprintf(prox,"%d",ke[f]); normtext_tomy(prox,K[f]);
            _outsouv_col(Xxt+2,kentroyt[f]+2,prox,0,bluechxr, pedbkxr);
            sprintf(prox,"%d",ke1[f]); normtext_tomy(prox,K1[f]);
            _outsouv_col(Xoxt+2,kentro1yt[f]+2,prox,0,bluechxr,nambkxr);
            }

        // Page
        selis=ptr_pedio[arped]->fipg;
        sprintf (prox,"%d",selis);
        normtext_tomy(prox,selida);
        _bareacls(Pxt,Pyt,Pxb,Pyb,pedbkxr);
        _outsouv_col(Pxt+1,Pyt+1,prox,0,bluechxr,pedbkxr);

        // RIGHT
        for (f=0;f<7;f++) {
            _puticon(rtxt+2,varyt[f]+2,mem_yel,255);
            }

        for (f=0;f<7;f++) {
            varni[f]=ptr_pedio[arped]->fivar[f];
            if (varni[f]) _puticon(rtxt+3,varyt[f]+4,mem_ni,255);
            }

        // Όριο Χαρακτήρων

        _bareacls(orchaxt , orchayt , orchaxb, orchayb ,pedbkxr);
        hoc=ptr_pedio[arped]->fiorio;
        sprintf (prox,"%u",hoc);
        if (hoc) {normtext_tomy(prox,orio_char) ; 
        _outsouv_col(orchaxt+1 , orchayt+1,prox,0,bluechxr,pedbkxr);}
        else orio_char[0]=255;

        // Κλείδωμα

        _bareacls(keyloxt  , keyloyt , keyloxb, keyloyb ,pedbkxr);
        hkvd=ptr_pedio[arped]->ficode;
        sprintf (prox,"%u",hkvd);
        if (hkvd) {normtext_tomy(prox,kvdikos) ; _outsouv_col(keyloxt+1 , keyloyt+1 , prox , 0 ,  bluechxr,pedbkxr);} 
         else kvdikos[0]=255;

        // Ονομα Λίστας

        _bareacls(listnaxt , listnayt , listnaxb, listnayb,pedbkxr);
        mystrcpy (nameoflist,ptr_pedio[arped]->filistname);
        for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
        if(nameoflist[0]!=255) _outfanis_center_col (0, nameoflist, listnaxt+1 , listnayt+1 , listnaxb);

        // Font - Colors

        // ep_font=ptr_pedio[arped]->fifont;
        
        for (f=0;f<3;f++) {
            chxr[f]=proxchxr[f]=ptr_pedio[arped]->fichxr[f] ; 
            bkxr[f]=proxbkxr[f]=ptr_pedio[arped]->fibkxr[f];
            proxslxr[f] = ptr_pedio[arped]->fislxr[f];
            }
        _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
        normtext_tomy(myfont_name[ep_font],font_text);
        _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
        refresh();
    }

for (f=0;f<3;f++) chxr[f]=bluechxr[f];
ektos=1; 
go_ri = go_le = kentro = left = kentro1= right = proenter = marrs= akyro=0;
proleft=proright=prokentro=prokentro1=-1;
keylock = orioxar = fonter = onom_ped = onom_list = inklizer = rdyinks = page_box = delfi = prokey = profyge=0 ;
calcbox = edcalcbox = 0;

do {
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
  
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev)) continue;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top || mx>info.right || my>info.bottom) continue ;
    setrgbcolor(dbtop); 
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
    sprintf(top_str,"%04d",mx); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",my); outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
    if (mx>ltxt && mx<ltxb && my>datyt[0] && my<ltyb) {  //Κίνηση εντός left team !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (right) {right=0; setrgbcolor(yelrgb); rectangle (rtxt+2,varyt[proright]+2,rtxb-2,varyt[proright]+22); refresh(); proright=-1;}
    else if (kentro) {kentro=0; setrgbcolor(pedrgb); rectangle (Xxt+2,kentroyt[prokentro]+2,Xxb-2,kentroyt[prokentro]+22); refresh();
        prokentro=-1;hide_help(hdhlpxt , hdhlpyt);}
    else if(kentro1) {kentro1=0; setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22); refresh();
        prokentro1=-1;hide_help(hdhlpxt , hdhlpyt);}
    else if (page_box) {page_box=0;setrgbcolor(pedrgb); rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();}
    else if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}   
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    
        left_box=(my-datyt[0])/26; if (left_box>6) left_box=6;
        
    if (left) {
        if (proleft==left_box) continue;
        //σβήνω κάτι στο proleft
        setrgbcolor(yelrgb); rectangle (ltxt+2,datyt[proleft]+2,ltxb-2,datyt[proleft]+22); refresh();
        // δίνω ένδειξη στο left_box
        proleft=left_box;
        setrgbcolor(recrgb); rectangle (ltxt+2,datyt[left_box]+2,ltxb-2,datyt[left_box]+22); refresh();
        }
        else {
        left=1;
        proleft=left_box;
        setrgbcolor(recrgb); rectangle (ltxt+2,datyt[left_box]+2,ltxb-2,datyt[left_box]+22); refresh();
        continue;
    }}
    
    if (left) {
        left=0; 
        //σβήνω κάτι στο proleft
        setrgbcolor(yelrgb); rectangle (ltxt+2,datyt[proleft]+2,ltxb-2,datyt[proleft]+22); refresh();
        proleft=-1;
    }
    
    if (mx>rtxt && mx<rtxb && my>varyt[0] && my<rtyb) {  //Κίνηση εντός right team !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (kentro) {kentro=0; setrgbcolor(pedrgb); rectangle (Xxt+2,kentroyt[prokentro]+2,Xxb-2,kentroyt[prokentro]+22); refresh();
        prokentro=-1;hide_help(hdhlpxt , hdhlpyt);}
    else if (kentro1) {kentro1=0; setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22); refresh();
        prokentro1=-1;hide_help(hdhlpxt , hdhlpyt);}
    else if (page_box) {page_box=0;setrgbcolor(pedrgb); rectangle (Xxt +2, Pyt , Xoxb-2, Pyb); refresh ();}
    else if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    
        right_box=(my-varyt[0])/26; if (right_box>6) right_box=6;
        
    if (right) {
        if (proright==right_box) continue;
        //σβήνω κάτι στο proright
        setrgbcolor(yelrgb); rectangle (rtxt+2,varyt[proright]+2,rtxb-2,varyt[proright]+22); refresh();
        // δίνω ένδειξη στο right_box
        proright=right_box;
        setrgbcolor(recrgb); rectangle (rtxt+2,varyt[right_box]+2,rtxb-2,varyt[right_box]+22); refresh();
        }
        else {
        right=1;
        proright=right_box;
        setrgbcolor(recrgb); rectangle (rtxt+2,varyt[right_box]+2,rtxb-2,varyt[right_box]+22); refresh();
        
        continue;        
    }}
    
    if (right) {
        right=0; 
        //σβήνω κάτι στο proleft
        setrgbcolor(yelrgb); rectangle (rtxt+2,varyt[proright]+2,rtxb-2,varyt[proright]+22); refresh();
        proright=-1;
    }

    if (mx>Xxt && mx<Xxb && my>kentroyt[0] && my<Pyt) {  //Κίνηση εντός kentro !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (kentro1) {kentro1=0; setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22); refresh();
        prokentro1=-1;hide_help(hdhlpxt , hdhlpyt);}
    else if (page_box) {page_box=0;setrgbcolor(pedrgb); rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();}
    else if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    
        kentro_box=(my-kentroyt[0])/26; if (kentro_box>3) kentro_box=3;
        
    if (kentro) {
        if (prokentro==kentro_box) continue;
        //σβήνω κάτι στο proright
        setrgbcolor(pedrgb); rectangle (Xxt+2,kentroyt[prokentro]+2,Xxb-2,kentroyt[prokentro]+22); refresh();
        // δίνω ένδειξη στο right_box
        prokentro=kentro_box;
        setrgbcolor(recrgb); rectangle (Xxt+2,kentroyt[kentro_box]+2,Xxb-2,kentroyt[kentro_box]+22); refresh();
        continue ;
        }
        else {
        kentro=1;
        prokentro=kentro_box;
        setrgbcolor(recrgb); rectangle (Xxt+2,kentroyt[kentro_box]+2,Xxb-2,kentroyt[kentro_box]+22); refresh();
        if (keyb_gr) show_help(" Η εισαγωγή στοιχείων εδώ είναι προαιρετική (πλην διαστάσεων εικόνων). Μπορείτε να τα ορίσετε αργότερα με το ποντίκι και τα πλήκτρα μετακίνησης ", Xxt, kentroyt[0]-60 , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Data entry here is optional (except images' dimensions). You can do it later with the mouse and the direction keys ", Xxt, kentroyt[0]-60 , &hdhlpxt , &hdhlpyt) ;
        continue;        
    }}
    
    if (kentro) {
        kentro=0; 
        setrgbcolor(pedrgb); rectangle (Xxt+2,kentroyt[prokentro]+2,Xxb-2,kentroyt[prokentro]+22); refresh();
        prokentro=-1;
        hide_help(hdhlpxt , hdhlpyt);
    }    

    if (mx>Xoxt && mx<Xoxb && my>kentro1yt[0] && my<Pyt) {  //Κίνηση εντός kentro1 !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (page_box) {page_box=0;setrgbcolor(pedrgb); rectangle (Xxt+2, Pyt , Xoxb-2, Pyb); refresh ();}
    else if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    
        kentro1_box=(my-kentro1yt[0])/26; if (kentro1_box>3) kentro1_box=3;
        
    if (kentro1) {
        if (prokentro1==kentro1_box) continue;
        setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22); refresh();
        prokentro1=kentro1_box;
        setrgbcolor(recrgb); rectangle (Xoxt+2,kentro1yt[kentro1_box]+2,Xoxb-2,kentro1yt[kentro1_box]+22); refresh();
        continue ;
        }
        else {
        kentro1=1;
        prokentro1=kentro1_box;
        setrgbcolor(recrgb); rectangle (Xoxt+2,kentro1yt[kentro1_box]+2,Xoxb-2,kentro1yt[kentro1_box]+22); refresh();
         if (keyb_gr) show_help(" Η εισαγωγή στοιχείων εδώ είναι προαιρετική . Μπορείτε να τα ορίσετε αργότερα με το ποντίκι και τα πλήκτρα μετακίνησης ", Xoxt, kentro1yt[0]-60 , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Data entry here is optional . You can do it later with the mouse and the direction keys ", Xoxt, kentro1yt[0]-60 , &hdhlpxt , &hdhlpyt) ;
        continue;        
    }}
    
    if (kentro1) {
        kentro1=0; 
        setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22); refresh();
        prokentro1=-1;
        hide_help(hdhlpxt , hdhlpyt);
    }
    

    if (mx>Xxt && mx<Xoxb && my>Pyt && my<Pyb) {  //Κίνηση εντός page_box !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (page_box) continue;
    setrgbcolor(recrgb); rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();
    page_box=1;
    continue;        
    }
    
    if (page_box) {page_box=0;setrgbcolor(pedrgb); rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();}


   if (mx>finaxt-2 && mx<finaxb+2 && my>finayt-2 && my<finayb+2) {  //Κίνηση εντός Ονομασίας πεδίου !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2]));rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (onom_ped) continue;
    setrgbcolor(recrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();
    onom_ped=1;
    continue;        
    }
    
    if (onom_ped) {onom_ped=0;setrgbcolor(pedrgb); rectangle (finaxt , finayt , finaxb, finayb); refresh ();}    

    
   if (mx>ltxt && mx<orchaxb+2 && my>orchayt-2 && my<orchayb+2) {  //Κίνηση εντός ορίου χαρακτήρων !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
    else if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (orioxar) continue;
    setrgbcolor(recrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();
    orioxar=1;
    continue;        
    }
    
    if (orioxar) {orioxar=0;setrgbcolor(pedrgb); rectangle (orchaxt , orchayt , orchaxb, orchayb); refresh ();}  
    
   if (mx>ltxt && mx<keyloxb+2 && my>keyloyt-2 && my<keyloyb+2) {  //Κίνηση εντός key lock !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (keylock) continue;
    setrgbcolor(recrgb); rectangle (keyloxt , keyloyt , keyloxb, keyloyb); refresh ();
    keylock=1;
    continue;        
    }
    
    if (keylock) {keylock=0;setrgbcolor(pedrgb); rectangle (keyloxt , keyloyt , keyloxb, keyloyb); refresh ();}  
    

   if (mx>ltxt && mx<listnaxb+2 && my>listnayt-2 && my<listnayb+2) {  //Κίνηση εντός List Name !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (onom_list) continue;
    setrgbcolor(recrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();
    onom_list=1;
    if (keyb_gr) show_help(" Το όνομα της λίστας μπορεί να επιλεγεί μόνον από ήδη φορτωμένες λίστες ", listnaxt, listnayt-18 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" The name of the list can only be selected from already loaded lists ", listnaxt, listnayt-18 , &hdhlpxt , &hdhlpyt) ;
    continue;        
    }
    
    if (onom_list) {onom_list=0;setrgbcolor(pedrgb); rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();hide_help(hdhlpxt , hdhlpyt);} 
    
    
   if (mx>fontxt-2 && mx<fontxb+2 && my>fontyt-2 && my<fontyb+2) {  //Κίνηση εντός Font Selection !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (inklizer) {inklizer=0; puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (fonter) continue;
    setrgbcolor(recrgb); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();
    fonter=1;
    continue;        
    }
    
    if (fonter) {fonter=0;setcolor(COLOR(proxbkxr[0],proxbkxr[1], proxbkxr[2])); rectangle (fontxt , fontyt , fontxb, fontyb); refresh ();} 
    
        
   if (mx>lizext && mx<lizext+28 && my>lizeyt && my<lizeyt+28) {  //Κίνηση στο inkualizer !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    
    if (inklizer) continue;
    putNOTicon (lizext,lizeyt,mem_inkual);
    inklizer=1;
    if (keyb_gr) show_help(" Διαμόρφωση χρώματος κειμένου - φόντου - επιλεγμένου κειμένου για το συγκεκριμένο πεδίο ", lizext,lizeyt-18 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" Color configuration for text - background - text selection for this field ", lizext,lizeyt-18 , &hdhlpxt , &hdhlpyt) ;
    continue;        
    }
    
    if (inklizer) {inklizer=0;puticon (lizext,lizeyt,mem_inkual,255);hide_help(hdhlpxt , hdhlpyt);} 
    

   if (mx>inksxt && mx<inksxt+28 && my>inksyt && my<inksyt+28) {  //Κίνηση στο ready inks !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (rdyinks) continue;
    putNOTicon (inksxt,inksyt,mem_rinks);
    rdyinks=1;
     if (keyb_gr) show_help(" Επιλογή χρωμάτων κειμένου - φόντου και επιλεγμένου κειμένου για το συγκεκριμένο πεδίο από λίστα  συνδυασμών ", inksxt,inksyt-18 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" Select colors for text - background and selected text for this field from a list of combinations ", inksxt, inksyt-18 , &hdhlpxt , &hdhlpyt) ;
    continue;        
    }
    
    if (rdyinks) {rdyinks=0; puticon (inksxt,inksyt,mem_rinks,255);hide_help(hdhlpxt , hdhlpyt);} 
    
 
    if (mx>lext && mx<lext+25 && my>leyt && my<leyt+25) {  //Κίνηση στο Left !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (go_le) continue;
    putNOTicon (lext,leyt,mem_le);
    go_le=1;
    continue;        
    }
    
    if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);} 
 
 
     if (mx>rixt && mx<rixt+25 && my>riyt && my<riyt+25) {  //Κίνηση στο Right !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (go_ri) continue;
    putNOTicon(rixt,riyt,mem_ri);
    go_ri=1;
    continue;        
    }
    
    if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);} 
 
 
     if (mx>arrxt && mx<arrxt+19 && my>arryt && my<arryt+19) {  //Κίνηση στο Marrs !!
    
    if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    else if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (marrs) continue;
    putNOTicon(arrxt,arryt,mem_arrs);
    marrs=1;
     if (keyb_gr) show_help(" Μετακίνηση παραθύρου ", arrxt,arryt-18 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" Move Window ", arrxt,arryt-18 , &hdhlpxt , &hdhlpyt) ;
    continue;        
    }
    
    if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}  
    
        
     if (mx>xok && mx<xok+54 && my>yok && my<yok+36) {  // Επιλογή στο Enter

    if (ektos) {
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    }
    
    ektos=0;
    if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
    else if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
    else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
    else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
    else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
    else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
    putNOTicon(xok,yok,mem_ok);
    continue ;
     }
     if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
     
     
      if (mx>xgo && mx<xgo+93 && my>ygo && my<ygo+36) {  // Επιλογή στο GO !
       
        if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
    
        ektos=0;
        if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
        else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
        else if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
        else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
        if (akyro) continue;
        putNOTicon(xgo,ygo,mem_go);
        akyro=1;
        continue;  
          
      }
      
      if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
      
      if (mx>fygex && mx<fygex+36 && my>fygey && my<fygey+36) {  // Επιλογή στο FYGE !
       
        if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
    
        ektos=0;
        if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
        else if (prokey)  {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
        else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
        if (profyge) continue;
        putNOTicon(fygex,fygey,mem_fyge);
        profyge=1;
        continue;  
          
      }
      
      if (profyge) {profyge=0 ; puticon(fygex,fygey,mem_fyge,255);}
      
      
      if(mx>delxt && mx<delxt+30 && my>delyt && my<delyt+30) { // Delete Field
          
        if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
    
        ektos=0;
        
        if (prokey) {prokey=0; if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);} 
        else if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        
        if(delfi) continue;
        delfi=1;
        putNOTicon(delxt,delyt,mem_del);
        continue;
    }
    
    if (delfi) {delfi=0 ; puticon(delxt,delyt,mem_del,255);}
     
    if(mx>keyxt && mx<keyxt+30 && my>keyyt && my<keyyt+30) { // Sorting Key Field
     
        if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }
    
       ektos=0;
       
        if (calcbox) {calcbox=0; setcolor(0);
            rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
            rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
        else if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);}
       
       if (prokey) continue;
       if ( (arped>dbfinum)  &&  (dbplgr) ) continue ;
       prokey=1;
       if (dbkey!=arped) { 
           _puticon(keyxt,keyyt,mem_yk,255);
           if (keyb_gr) show_help(" Επιλογή αυτού του πεδίου ως κλειδί ταξινόμησης της βάσης δεδομένων ", keyxt,keyyt-18 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Select this field as the database classification key ", keyxt,keyyt-18 , &hdhlpxt , &hdhlpyt) ;
       }
    else {
         _puticon(keyxt,keyyt,mem_nk,255);
         if (keyb_gr) show_help(" Αποεπιλογή αυτού του πεδίου για κλειδί ταξινόμησης της βάσης δεδομένων ", keyxt,keyyt-18 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Unselect this field for the database classification key ", keyxt,keyyt-18 , &hdhlpxt , &hdhlpyt) ;
    }
       continue;  
    }
    
   if (prokey) {prokey=0; if (dbkey==arped) puticon(keyxt,keyyt,mem_yk,255); else _puticon(keyxt,keyyt,mem_nk,255);hide_help(hdhlpxt , hdhlpyt);}  
   
   
    if(mx>calcbox_xt && mx<calcbox_xb && my>calcbox_yt && my<calcbox_yb) { // Calcbox
     
        if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }
    
        ektos=0;
        
        if (edcalcbox) {edcalcbox=0; setcolor(0);
            rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
            rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
            hide_help(hdhlpxt , hdhlpyt);} 
       
        if (calcbox) continue;
        if (!datni[3] && !datni[4]) continue ;
        if (arped<=dbfinum && dbplgr) continue ;
        calcbox=1;
        setcolor(5);
        rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
        rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);
     
        if (keyb_gr) show_help(" Πεδίο Aριθμητικών Yπολογισμών ", calcbox_xt,calcbox_yt-18 , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Numerical Calculations Field ", calcbox_xt,calcbox_yt-18 , &hdhlpxt , &hdhlpyt) ;
       
       continue;  
    }
    
   if (calcbox) {calcbox=0; setcolor(0);
        rectangle (calcbox_xt,calcbox_yt,calcbox_xb,calcbox_yb);
        rectangle (calcbox_xt+1,calcbox_yt+1,calcbox_xb-1,calcbox_yb-1);refresh(); 
        hide_help(hdhlpxt , hdhlpyt);} 
        
        
    if(mx>edcalcbox_xt && mx<edcalcbox_xb && my>edcalcbox_yt && my<edcalcbox_yb) { // Calculations Editor
     
        if (ektos) {
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        }
    
        ektos=0;
       
        if (edcalcbox) continue;
        if (!datni[3] && !datni[4]) continue ;
        if (!new_mathtype) continue ;
        edcalcbox=1;
        setcolor(5);
        rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
        rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);
     
        if (keyb_gr) show_help(" Εισαγωγή-Επεξεργασία Αριθμητικής Παράστασης ", edcalcbox_xt,edcalcbox_yt-18 , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Enter-Edit Numerical Calculations ", edcalcbox_xt,edcalcbox_yt-18 , &hdhlpxt , &hdhlpyt) ;
       
       continue;  
    }
    
   if (edcalcbox) {edcalcbox=0; setcolor(0);
        rectangle (edcalcbox_xt,edcalcbox_yt,edcalcbox_xb,edcalcbox_yb);
        rectangle (edcalcbox_xt+1,edcalcbox_yt+1,edcalcbox_xb-1,edcalcbox_yb-1);refresh(); 
        hide_help(hdhlpxt , hdhlpyt);} 
        
        
    if (mx>xb || mx<xt || my>yb || my<yt) {
        if (cross) continue;
        cross=1; ektos=1;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
        SDL_SetCursor(cursor); 
    }
    else if (cross) {
        cross=0;ektos=1;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        continue;
    }
    
     if (!ektos) {
         ektos=1;
         cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor); 
     }
    continue ;
    
       
    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    
    case SDL_MOUSEBUTTONDOWN:
         if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
        if (mx1<info.left || mx1>info.right || my1<info.top || my1>info.bottom) continue ;
        
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (mx<xb && mx>xt && my>yt && my<yb) continue ;
            if (adyn) continue;
            co.lor = getpixel(mx1,my1) ;
            Stx = mx1-6; b=15 ;
            if (Stx<info.left+1 || mx1+6>info.right-1) continue ;
            if ( (my1+(17*20+38)>info.bottom-60)) {
                if (my1+6>info.bottom-1) continue ;
                while (my1+b>info.bottom-1 && (b>0) ) b-- ;
                Sty=my1;
                getimage (Stx,Sty,mx1+6,my1+b,mem_cross);
                setcolor(5);
                line (mx1,my1+b,mx1,my1);
                line (mx1-1,my1+b,mx1-1,my1);
                line (mx1+1,my1+b,mx1+1,my1);
                _velos_up (mx1, mx1, my1) ; 
            }
            else {
                while ( my1-b<info.top+21  && (b>0) ) b-- ;
                Sty = my1-b-6;
                if (Sty<info.top) continue ;
                getimage (Stx,Sty,mx1+6,my1,mem_cross);
                setcolor(5);
                line (mx1,Sty,mx1,my1);
                line (mx1-1,Sty,mx1-1,my1);
                line (mx1+1,Sty,mx1+1,my1);
                _velos_down (mx1, mx1, my1) ; 
            }

            refresh();
            b=0;
            for (f=0 ; f<dbar; f++) {
                if (mx1>dbx1[f] && mx1<dbx2[f] && my1>dby1[f] && my1<dby2[f]) {b=1; break;}
            }
            if (b) { 
                proel = f ;
                strcpy (secmenu[13],intmenu[13]);
                if (fiornam) {
                    for (f=5 ; f<9 ; f++) strcpy (secmenu[f],intmenu[f]);
                }
                else {
                    for (f=5 ; f<9 ; f++) strcpy (secmenu[f],"-------------");
                }
                if (varni[3]) {
                    for (f=9 ; f<13 ; f++) strcpy (secmenu[f],intmenu[f]);
                }
                else {
                    for (f=9 ; f<13 ; f++) strcpy (secmenu[f],"-------------");
                }
            }
                else {
                    proel=-1;
                    for (f=5 ; f<14 ; f++) strcpy (secmenu[f],"-------------");
                } 
            
            b=0;
            for (i=0 ; i<dcar; i++) {
                if (mx1>dbdx1[i] && mx1<dbdx2[i] && my1>dbdy1[i] && my1<dbdy2[i]) {
                    b++ ;
                    if (b==1) {
                     dx=dbdx2[i]-dbdx1[i]+dbdy2[i]-dbdy1[i];
                     dy=mx1-dbdx1[i]+my1-dbdy1[i];
                     dz=i;
                     continue;
                    }
                    else {
                        dx1=dbdx2[i]-dbdx1[i]+dbdy2[i]-dbdy1[i];
                        dy1=mx-dbdx1[i]+my-dbdy1[i];
                        if (dx1<dx) { dx=dx1 ; dz=i; continue ; }
                        else if (dx1==dx) {
                            if (dy1<dy) {dy=dy1; dz=i;}
                        }
                    }
                }
            }
            if (b) { 
                prodec = dz ;
                a = dd_elem[prodec];
                dz = (ptr_dec[a].detype[6]) ? 1 : 0 ;
                if (!dz) strcpy(secmenu[14],intmenu[14]); else strcpy (secmenu[14],"-------------");
                if (fiornam) strcpy(secmenu[15],intmenu[15]); else strcpy (secmenu[15],"-------------");
                if (varni[3]) strcpy(secmenu[16],intmenu[16]); else strcpy (secmenu[16],"-------------");
            } else {
                prodec=-1;
                for (f=14;f<17;f++)  strcpy (secmenu[f],"-------------");
            }
                
            if (keyb_gr) sprintf (str1024 , "Επιλέξατε.."); 
            else sprintf (str1024 , "Choose..");
            normtext_tomy(str1024,0);
            dx = fastmenu_show(17, &secmenu[0][0], 120, str1024, (unsigned short) mx1, (unsigned short) my1 );
            putimage (Stx,Sty,mem_cross,0); refresh();
            while (!SDL_PollEvent(&sdlev)) continue ;
            mx = sdlev.button.x ; my = sdlev.button.y ;
            cross = (mx<xt || mx>xb || my<yt || my>yb) ? 1 : 0 ;
            if (!cross) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                }
            else {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
                SDL_SetCursor(cursor);
            } 
            if (dx<0) continue;
            
            switch (dx) {
                case 0 :
                // Συντεταγμένες Πεδίου (Άνω-Αριστερά)

                i=0;i1=0;
                ke[0]=mx1;
                ke[1]=my1;
                if (ke[0]<=info.left || ke[0]>=info.right) i=1;
                if (ke[1]<=info.top || ke[1]>=info.bottom) i1=1;
                if (ke[0]+ke[2] > info.right) ke[0] = info.right-ke[2];
                if (ke[1]+ke[3] > info.bottom) ke[1] = info.bottom-ke[3];

                sprintf(prox,"%d",ke[0]); normtext_tomy(prox,K[0]);
                _bareacls(Xxt+2,kentroyt[0]+2,Xxb-2,kentroyt[0]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[0]+2, prox, 0 , bluechxr , pedbkxr);

                sprintf(prox,"%d",ke[1]); normtext_tomy(prox,K[1]);
                _bareacls(Xxt+2,kentroyt[1]+2,Xxb-2,kentroyt[1]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[1]+2, prox, 0 , bluechxr , pedbkxr);


                if ((i) || (!ke[0]) ) {
                _bareacls(Xxt+2,kentroyt[0]+2,Xxb-2,kentroyt[0]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[0]+2,"0",0,bluechxr,pedbkxr);
                K[0][0]=16; K[0][1]=255;ke[0]=0;
                }

                if ((i1) || (!ke[1]) ) {
                _bareacls(Xxt+2,kentroyt[1]+2,Xxb-2,kentroyt[1]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[1]+2,"0",0,bluechxr,pedbkxr);
                K[1][0]=16; K[1][1]=255;ke[1]=0;
                }

                if (arped>dbfinum) {
                ptr_pedio[arped]->fixt=ke[0];
                ptr_pedio[arped]->fiyt=ke[1];  
                }
                break ;
                
                case 1:
                // Πλάτος - Ύψος Πεδίου
                if (mx1<ke[0] || my1<ke[1]) continue ;
                ke[2]=mx1-ke[0]+1;
                ke[3]=my1-ke[1]+1;
                i=0;i1=0;

                sprintf(prox,"%d",ke[2]); normtext_tomy(prox,K[2]);
                _bareacls(Xxt+2,kentroyt[2]+2,Xxb-2,kentroyt[2]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[2]+2, prox, 0 , bluechxr , pedbkxr);

                sprintf(prox,"%d",ke[3]); normtext_tomy(prox,K[3]);
                _bareacls(Xxt+2,kentroyt[3]+2,Xxb-2,kentroyt[3]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[3]+2, prox, 0 , bluechxr , pedbkxr);

                dx=info.right-info.left ;
                if (ke[2]>dx) i=1;

                if ( (!datni[5]) && (ke[3]) ) {
                    if (ke[3]<ptr_pedio[new]->fifo_hei+2) ke[3] = ptr_pedio[new]->fifo_hei+2;
                    _bareacls(Xxt+2,kentroyt[3]+2,Xxb-2,kentroyt[3]+22,pedbkxr);
                    sprintf(prox,"%d",ke[3]); normtext_tomy(prox,K[3]);
                    _outsouv_col(Xxt+2,kentroyt[3]+2, prox, 0 , bluechxr , pedbkxr);
                    i1=0;
                    }
                else {
                dy=info.bottom-info.top;
                if (ke[3]>dy) i1=1;
                }

                if ((i) || (!ke[2]) ) {
                _bareacls(Xxt+2,kentroyt[2]+2,Xxb-2,kentroyt[2]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[2]+2,"0",0,bluechxr,pedbkxr);
                K[2][0]=16; K[2][1]=255;ke[2]=0;
                }
                if ((i1) || (!ke[3]) ) {
                _bareacls(Xxt+2,kentroyt[3]+2,Xxb-2,kentroyt[3]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[3]+2,"0",0,bluechxr,pedbkxr);
                K[3][0]=16; K[3][1]=255;ke[3]=0;
                }
                if (arped>dbfinum) {
                    ptr_pedio[arped]->fiwid=ke[2];
                    ptr_pedio[arped]->fihei=ke[3];    
                }
                break ;
                
                case 2:
                // Συντεταγμένες Ετικέτας Πεδίου (Άνω-Αριστερά)
                ke1[0]=mx1;
                ke1[1]=my1;

                sprintf(prox,"%d",ke1[0]); normtext_tomy(prox,K1[0]);
                _bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[0]+2, prox, 0 , bluechxr , nambkxr);

                sprintf(prox,"%d",ke1[1]); normtext_tomy(prox,K1[1]);
                _bareacls(Xoxt+2,kentro1yt[1]+2,Xoxb-2,kentro1yt[1]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[1]+2, prox, 0 , bluechxr , nambkxr);

                if (ke1[0]<info.left || ke1[0]>info.right || (!ke1[0]) ) {
                    _bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                    _outsouv_col(Xoxt+2,kentro1yt[0]+2, "0", 0 , bluechxr , nambkxr);
                    ke1[0]=0; normtext_tomy("0",K1[0]);
                    }
                    
                if (ke1[1]<info.top || ke1[1]>info.bottom || (!ke1[1]) ) {
                    _bareacls(Xoxt+2,kentro1yt[1]+2,Xoxb-2,kentro1yt[1]+22,nambkxr);
                    _outsouv_col(Xoxt+2,kentro1yt[1]+2, "0", 0 , bluechxr , nambkxr);
                    normtext_tomy("0",K1[1]);
                    ke1[1]=0;
                }

                if (arped>dbfinum) {
                        
                    ptr_pedio[arped]->filaxt=ke1[0];
                    ptr_pedio[arped]->filayt=ke1[1];
                }
                break ;
                
                case 3:
                // Πλατος - Υψος Ετικέτας Πεδίου (Κατω δεξιά)

                if (mx1<ke1[0] || my1<ke1[1]) continue ;
                ke1[2]=mx1-ke1[0]+1;
                ke1[3]=my1-ke1[1]+1;
                
                sprintf(prox,"%d",ke1[2]); normtext_tomy(prox,K1[2]);
                _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
                
                sprintf(prox,"%d",ke1[3]); normtext_tomy(prox,K1[3]);
                _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
                
                dx=info.right-info.left ;
                if (ke1[2]>dx || ke1[2]<el_wid) {
                    _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                    sprintf(prox,"%d",el_wid);
                    normtext_tomy(prox,K1[2]);
                    _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
                    ke1[2]=el_wid; 
                }

                dy=info.bottom-info.top;
                if (ke1[3]>dy || ke1[3]<el_hei){
                    _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                    sprintf(prox,"%d",el_hei);
                    normtext_tomy(prox,K1[3]);
                    _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
                    ke1[3]=el_hei; 
                }
                        
                if (arped>dbfinum) {
                    ptr_pedio[arped]->filawid=ke1[2];
                    ptr_pedio[arped]->filahei=ke1[3];
                }
                break ;
                
                case 4:
                // Χρώμα από σημείο
                    proxbkxr[0] = co.rgb[2];
                    proxbkxr[1] = co.rgb[1];
                    proxbkxr[2] = co.rgb[0];
                    _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
                    if (arped>dbfinum) {
                        for (f=0;f<3;f++) {
                            //ptr_pedio[arped]->fichxr[f]=proxchxr[f];
                            ptr_pedio[arped]->fibkxr[f]=proxbkxr[f];
                            //ptr_pedio[arped]->fislxr[f]=proxslxr[f];
                        }
                    }
                _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
                break ;
                
                case 5:
                // Στοιχείο για οριζόντια στοίχιση ΠΕΔΙΟΥ
                if (proel==-1) continue ;

                ke[0]=dbx1[proel];
                if (ke[0]+ke[2] > info.right) ke[0] = info.right-ke[2];

                sprintf(prox,"%d",ke[0]); normtext_tomy(prox,K[0]);
                _bareacls(Xxt+2,kentroyt[0]+2,Xxb-2,kentroyt[0]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[0]+2, prox, 0 , bluechxr , pedbkxr);

                if (arped>dbfinum) {
                ptr_pedio[arped]->fixt=ke[0];
                }
                       
                break ;
                
                case 6:
                // Στοιχείο για κάθετη στοίχιση ΠΕΔΙΟΥ
                if (proel==-1) continue ;
                       
                ke[1]=dby1[proel];
                if (ke[1]+ke[3] > info.bottom) ke[1] = info.bottom-ke[3];

                sprintf(prox,"%d",ke[1]); normtext_tomy(prox,K[1]);
                _bareacls(Xxt+2,kentroyt[1]+2,Xxb-2,kentroyt[1]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[1]+2, prox, 0 , bluechxr , pedbkxr);

                if (arped>dbfinum) {
                ptr_pedio[arped]->fiyt=ke[1];  
                }
                       
                break ;
                

                case 9:
                // Στοιχείο για οριζόντια στοίχιση ΟΝΟΜΑΤΟΣ Πεδίου
                if (proel==-1) continue ;
                
                ke1[0]=dbx1[proel];

                sprintf(prox,"%d",ke1[0]); normtext_tomy(prox,K1[0]);
                _bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[0]+2, prox, 0 , bluechxr , nambkxr);

                if (arped>dbfinum) {
                        
                    ptr_pedio[arped]->filaxt=ke1[0];
                }
                
                break ;
                
                case 10:
                // Στοιχείο για κάθετη στοίχιση ΟΝΟΜΑΤΟΣ Πεδίου
                if (proel==-1) continue ;
                
                
                //ke1[0]=dbx1[proel];
                ke1[1]=dby1[proel];

                //sprintf(prox,"%d",ke1[0]); normtext_tomy(prox,K1[0]);
                //_bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                //_outsouv_col(Xoxt+2,kentro1yt[0]+2, prox, 0 , bluechxr , nambkxr);

                sprintf(prox,"%d",ke1[1]); normtext_tomy(prox,K1[1]);
                _bareacls(Xoxt+2,kentro1yt[1]+2,Xoxb-2,kentro1yt[1]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[1]+2, prox, 0 , bluechxr , nambkxr);

                if (arped>dbfinum) {
                        
                    //ptr_pedio[arped]->filaxt=ke1[0];
                    ptr_pedio[arped]->filayt=ke1[1];
                }
                break ;
                
                case 7 : // Στοίχιση πεδίου στο μέσον άλλου στοιχείου
    
                if (proel==-1) continue ;
                
                if (arped==db_elem[proel][0] && db_elem[proel][1]) {
                    
                    if (ke[2]) dy= ke[2];
                    else continue ;
                    dx = (info.right - info.left + 1 - dy) / 2 ;
                    ke[0]=info.left + dx ;
                }
                else {
                    dx = dbx1[proel] + ( (dbx2[proel]-dbx1[proel]+1)/2 ) ;
                    if (ke[2]) dy= ke[2]/2 ;
                    else continue  ;
                    if ((dx-dy)<info.left+3) continue ; 
                    if (dx-dy+ke[2] >= info.right) continue;
                    ke[0]= dx-dy ;
                }
                
                sprintf(prox,"%d",ke[0]); normtext_tomy(prox,K[0]);
                _bareacls(Xxt+2,kentroyt[0]+2,Xxb-2,kentroyt[0]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[0]+2, prox, 0 , bluechxr , pedbkxr);
                
                if (arped>dbfinum) {
                ptr_pedio[arped]->fixt=ke[0];
                }                    
                    
                break ;
                    
                    
                    
                case 11 : // Στοίχιση ονόματος πεδίου στο μέσον άλλου στοιχείου
                    
                if (proel==-1) continue ;
                
                if (arped==db_elem[proel][0] && (!db_elem[proel][1]) ) {
                    
                    if (ke1[2]) dy= ke1[2];
                    else continue  ;
                    dx = (info.right - info.left + 1 - dy) / 2 ;
                    ke1[0]=info.left + dx ;
                }
                else {
                    dx = dbx1[proel] + ( (dbx2[proel]-dbx1[proel]+1)/2 ) ;
                    if (ke1[2]) dy=ke1[2]/2;
                    else continue ;
                    if ((dx-dy)<info.left+3) continue ; 
                    if (dx-dy+ke1[2] >= info.right) continue;
                    ke1[0]= dx-dy ;
                }
                
                sprintf(prox,"%d",ke1[0]); normtext_tomy(prox,K1[0]);
                _bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[0]+2, prox, 0 , bluechxr , nambkxr);

                if (arped>dbfinum) {
                        
                    ptr_pedio[arped]->filaxt=ke1[0];
                }
                
                break ;
                
                
                case 8:
                // Αντέγραψε διαστάσεις στοιχείου στο ΠΕΔΙΟ
                    
                if (proel==-1) continue ;

                dx=dbx2[proel]-dbx1[proel]+1;
                dy=dby2[proel]-dby1[proel]+1;
                if (ke[0]+dx >= info.right) continue;
                if (ke[1]+dy >= info.bottom) continue;

                ke[2] = dx;
                ke[3] = dy;
                
                sprintf(prox,"%d",ke[2]); normtext_tomy(prox,K[2]);
                sprintf(prox,"%d",ke[3]); normtext_tomy(prox,K[3]);
                _bareacls(Xxt+2,kentroyt[2]+2,Xxb-2,kentroyt[2]+22,pedbkxr);
                _bareacls(Xxt+2,kentroyt[3]+2,Xxb-2,kentroyt[3]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[2]+2, prox, 0 , bluechxr , pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[3]+2, prox, 0 , bluechxr , pedbkxr);
                if (arped>dbfinum) {
                ptr_pedio[arped]->fiwid=ke[2];
                ptr_pedio[arped]->fihei=ke[3];
                }
                    
                    break ;
                    
                    
                case 12:
                // Αντέγραψε διαστάσεις στοιχείου στο ONOMA πεδίου
                
                if (proel==-1) continue ;
                
                dx=dbx2[proel]-dbx1[proel]+1;
                dy=dby2[proel]-dby1[proel]+1;
                if (ke1[0]+dx >= info.right) continue;
                if (ke1[1]+dy >= info.bottom) continue;

                ke1[2] = dx;
                ke1[3] = dy;

                sprintf(prox,"%d",ke1[2]); normtext_tomy(prox,K1[2]);
                _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);

                sprintf(prox,"%d",ke1[3]); normtext_tomy(prox,K1[3]);
                _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);

                if (arped>dbfinum) {
                        
                    ptr_pedio[arped]->filawid=ke1[2];
                    ptr_pedio[arped]->filahei=ke1[3];
                }
                    
                    break ;
                    

                case 13:
                // Αντέγραψε χρώματα στοιχείου
                if (proel==-1) continue ;
                i=db_elem[proel][0];
                proxbkxr[0] = ptr_pedio[i]->fibkxr[0];
                proxbkxr[1] = ptr_pedio[i]->fibkxr[1];
                proxbkxr[2] = ptr_pedio[i]->fibkxr[2];
                proxchxr[0] = ptr_pedio[i]->fichxr[0];
                proxchxr[1] = ptr_pedio[i]->fichxr[1];
                proxchxr[2] = ptr_pedio[i]->fichxr[2];
                _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
                if (arped>dbfinum) {
                    for (f=0;f<3;f++) {
                        ptr_pedio[arped]->fichxr[f]=proxchxr[f];
                        ptr_pedio[arped]->fibkxr[f]=proxbkxr[f];
                    }
                }
                _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
                break ;
                
                    
                    
                case 14:
                // Αντέγραψε χρώματα ετικέτας
                if ( prodec==-1 || (dz) ) continue ;
                       
                i=dd_elem[prodec];
                proxbkxr[0] = ptr_dec[i].debkxr[0];
                proxbkxr[1] = ptr_dec[i].debkxr[1];
                proxbkxr[2] = ptr_dec[i].debkxr[2];
                proxchxr[0] = ptr_dec[i].dechxr[0];
                proxchxr[1] = ptr_dec[i].dechxr[1];
                proxchxr[2] = ptr_dec[i].dechxr[2];
                _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
                if (arped>dbfinum) {
                    for (f=0;f<3;f++) {
                        ptr_pedio[arped]->fichxr[f]=proxchxr[f];
                        ptr_pedio[arped]->fibkxr[f]=proxbkxr[f];
                    }
                }
                _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
                
                break ;
                
                case 15 : // Στοίχιση πεδίου στο μέσον ετικέτας
    
                if (prodec==-1) continue ;

                    dx = dbdx1[prodec] + ( (dbdx2[prodec]-dbdx1[prodec]+1)/2 ) ;
                    if (ke[2]) dy= ke[2]/2 ;
                    else continue  ;
                    if ((dx-dy)<info.left+3) continue ; 
                    if (dx-dy+ke[2] >= info.right) continue;
                    ke[0]= dx-dy ;
                    
                
                sprintf(prox,"%d",ke[0]); normtext_tomy(prox,K[0]);
                _bareacls(Xxt+2,kentroyt[0]+2,Xxb-2,kentroyt[0]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[0]+2, prox, 0 , bluechxr , pedbkxr);
                
                if (arped>dbfinum) {
                ptr_pedio[arped]->fixt=ke[0];
                }                    
                    
                break ;
                    
                    
                case 16 : // Στοίχιση ονόματος πεδίου στο μέσον ετικέτας
                    
                if (prodec==-1) continue ;
                
                    dx = dbdx1[prodec] + ( (dbdx2[prodec]-dbdx1[prodec]+1)/2 ) ;
                    if (ke1[2]) dy=ke1[2]/2;
                    else continue ;
                    if ((dx-dy)<info.left+3) continue ; 
                    if (dx-dy+ke1[2] >= info.right) continue;
                    ke1[0]= dx-dy ;
               
                
                sprintf(prox,"%d",ke1[0]); normtext_tomy(prox,K1[0]);
                _bareacls(Xoxt+2,kentro1yt[0]+2,Xoxb-2,kentro1yt[0]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[0]+2, prox, 0 , bluechxr , nambkxr);

                if (arped>dbfinum) {
                        
                    ptr_pedio[arped]->filaxt=ke1[0];
                }
                
                break ;                

            }
            
            refresh();
            continue ;
    }
    
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        
        if (ektos) continue;
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>25 || dy>25) continue;
       
       if (calcbox) {
           if (arped<=dbfinum && dbplgr) { // Να το δω αυτό..ίσως και να γίνεται..
                if (keyb_gr) information (0,"Ο τύπος των πεδίων δεν τροποποιείται..\n..όσο η βάση έχει καρτέλες στοιχείων!\nΘα πρέπει να τις διαγράψετε όλες!",0);
                else information (0,"You can't modify data fields' type..\n..while the DB has data cards !\nYou have to delete them all!",0);
                continue; 
            }
        
           
           if (arped<=dbfinum) {
               if (ptr_pedio[arped]->fitype!=3 && ptr_pedio[arped]->fitype!=4) {
                   if (keyb_gr) information(0,"Το πεδίο δεν ήταν αριθμητικό!\nΤροποποιείστε τον τύπο με κλικ στο Yes..\n..και μετά επανέλθετε !",0);
                    else information(0,"The field type was not numeric!\nClick on Yes to modify it..\n..and then retry !",0);
                    continue ;
            }
        }
        
        if (arped<=dbfinum && ptr_pedio[arped]->fiorio!=hoc) {
            if (keyb_gr) information(0,"Κάντε κλικ στο Yes για να τροποποιηθεί..\n (κατ' αρχήν) το όριο χωρητικότητας του πεδίου!",0);
            else information (0,"Click on Yes to modify the capacity of..\n..the field formerly !",0);
            continue ;
        }
            new_mathtype = 1-new_mathtype ;
        
            if (new_mathtype) {
                _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,yelbkxr);
                _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,reccol,yelbkxr);
                refresh();
                
            }
            else {
                _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
                _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
                refresh();
                
            }
        
        if (arped>dbfinum) {
        
            ptr_pedio[arped]->mathtype = new_mathtype;
        }
       
    }
    
    
       else if (edcalcbox) {
           
            if (!new_mathtype) continue ;
            
                                 
            _bareacls (edcalcbox_xt+2,edcalcbox_yt+2,edcalcbox_xb-2,edcalcbox_yb-2,yelbkxr);
            _outmystr_center_col(2,E_text, edcalcbox_xt+2,edcalcbox_yt,edcalcbox_xb-2,edcalcbox_yb,reccol,yelbkxr);
            refresh();
            
            
            if (arped>dbfinum) {
                if (!ptr_pedio[arped]->fiorio) 
                {
                if (keyb_gr) information(0,"Καθορίστε τη χωρητικότητα του πεδίου!",0);
                else information (0,"Define the capacity of the field !",0);   
                goto KLEISE_EDCALBOX ;
                }
                
                ptr_alg=new_alg_str;
               
            }
            else {
                ptr_alg=prox_alg_str;
            }
            
            dx=alg_help (ptr_alg , arped);


KLEISE_EDCALBOX:

            _bareacls (edcalcbox_xt+2,edcalcbox_yt+2,edcalcbox_xb-2,edcalcbox_yb-2,pedbkxr);
            _outmystr_center_col(2,E_text, edcalcbox_xt+2,edcalcbox_yt,edcalcbox_xb-2,edcalcbox_yb,bluechxr,pedbkxr);
            refresh();

    }
    
       
       else if (prokey) { // Κλειδί Ταξινόμησης
           
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            if ( (ptr_pedio[arped]->fitype != 5) && (!datni[5]) ) {
                if ( (arped>dbfinum) && (dbplgr) ) {
                    if (keyb_gr) information (0,"Ένα νέο πεδίο στην παρούσα φάση..\n..δεν μπορεί να ορισθεί ως κλειδί ταξινόμησης!",0);
                    else information (0, "A new field at this stage ...\n..can't be defined as the sorting key!",0);
                    continue ;}
                if (dbkey!=arped) dbkey=arped; else dbkey=100;
            }
            else {
                 if (keyb_gr) information (0,"Το κλειδί ταξινόμησης δεν επιτρέπεται..\n..να είναι πεδίο εικόνας!",0);
                else information (0,"The DB sorting key can't be ..\n..an image field!",0);
            }
            continue;
    }

       else if (marrs) {
            mem_form=malloc(imagesize(0,0,757,384)); //758 x 385
            if (!mem_form) {information(2-keyb_gr,0,0); break;}
            getimage(xt,yt,xb,yb,mem_form);
            xt1=xt ; yt1=yt ; xb1=xb; yb1=yb;
            dx=change_pos (&xt1, &yt1, &xb1, &yb1);
            if (dx<0) {information(2-keyb_gr,0,0); free (mem_form); mem_form=0;break;}
            putimage (xt,yt,mem0,0);
            getimage (xt1,yt1,xb1,yb1,mem0);
            xt=xt1; yt=yt1; xb=xb1; yb=yb1;

            arrxt=xt+3 ; arryt=yt+3;
            finuxt=xt+402 ; finuyt=yt+29 ; finuxb=xt+459 ; finuyb=finuyt+19 ;
            finaxt=xt+275 ; finayt=yt+59 ; finaxb=xt+641 ; finayb=finayt+21 ;
            rixt=xt+510 ; delxt=xt+690; riyt=leyt=yt+25; lext=xt+248; delyt=keyyt=yt+23; keyxt=xt+40;
            xok=xt+680; ygo=yb-35; xgo=xt+23; fygex=xok-50; fygey=yb-36; yok=yb-37 ;
            calcbox_xt = xt+25; calcbox_yt = edcalcbox_yt = yt+186;
            calcbox_xb = calcbox_xt+22 ;
            calcbox_yb = edcalcbox_yb = calcbox_yt+37;
            edcalcbox_xt = calcbox_xb+2 ; 
            edcalcbox_xb = edcalcbox_xt+33;
            ltxt=xt+238; rtxt=xt+693; ltyb=rtyb=yt+280;  ltxb=ltxt+24; rtxb=rtxt+24; //left team - right team
            datyt[0]=varyt[0]=yt+105;                                // Τύποι Δεδομένων και Άλλα στοιχεία

                for (f=1 ; f<7 ; f++) {
                    datyt[f] = datyt[f-1]+25;
                    varyt[f] = varyt[f-1] +25;
                    
                }

            orchaxt = keyloxt = listnaxt = ltxt+2 ; 
            orchayt=datyt[6]+27; keyloyt=orchayt+25; listnayt = keyloyt+25;
            orchaxb=xt+317; orchayb=orchayt+20; keyloxb=xt+297 ; keyloyb=keyloyt+20;

            listnaxb=xt+472 ; listnayb=listnayt+20;
            Xxt=xt+322; // κοινό xt για κέντρο !
            kentroyt[0]=kentro1yt[0]=yt+130;
            Xxb=xt+383; // κοινό για κέντρο πλην Σελ. !

            for(f=1;f<4;f++) {
                kentroyt[f]=kentroyt[f-1]+25;
                kentro1yt[f] = kentro1yt[f-1]+25;
            }

            Xoxt=xt+383; // κοινό xt για κέντρο1 !
            Xoxb=xt+444; // κοινό για κέντρο1 πλην Σελ. !

            Pxt=Xxt+3; Pyt=kentroyt[3] +27 ; Pyb=Pyt+20; Pxb=Xxt+31 ;       // Pxb να ρυθμιστεί για την input !
            fontxt=xt+477; fontyt=yt+307; fontxb=xt+715; fontyb=fontyt+21;
            lizext=xt+346; inksxt=xt+395; lizeyt=inksyt=yt+282;

            putimage (xt,yt,mem_form,0);
            refresh();
            free(mem_form) ; mem_form=0;
            break ;
        }
        
        
        else if (proenter) {
            
            for(f=0;f<7;f++) {if (datni[f]) break ;} 
            
            if (pedname[0]==255 || f==7) { information (36-keyb_gr,0,0); break; }
            
            if ( (!datni[5]) && (!hoc) ) { information (36-keyb_gr,0,0); break; }
            
            if ( (datni[5]) && ( (!ke[2]) || (!ke[3]) ) ) { information (36-keyb_gr,0,0); break; }
            
            if ( (datni[2]) && (nameoflist[0]==255) ) {information (38-keyb_gr,0,0); break;}
            
            //if (arped<=dbfinum) {
            //    ptr_fitype = (void *)ptr_copy+32;
            //    old_fitype=*ptr_fitype;
            //}
            
            if ( (arped>dbfinum) && (dbplgr) ) {
                if (keyb_gr) strcpy (str1kb,"Θα προστεθεί νέο Πεδίο Δεδομένων στη Βάση!\nΘέλετε σίγουρα να γίνει τώρα;");
                else strcpy (str1kb,"A new Data Field will be added to the DB!\nDo you surely want to proceed now ?");
                user_ans=alert(0,str1kb,0);
                if (user_ans!=1) break ;
                cardwhen1=cardwhen ;
            }
            
            old_fitype=ptr_pedio[arped]->fitype;
            old_mathtype=ptr_pedio[arped]->mathtype;
            ptr_pedio[arped]->fitype=f;
            // mathtype ??
            ptr_pedio[arped]->mathtype=new_mathtype;
            //printf("old_fitype = %d\n" , old_fitype);
            //printf("new_fitype = %d\n" , ptr_pedio[arped]->fitype);

            
            f=arped;
            ptr_pedio[f]->finum=f ; 
            ptr_pedio[f]->fixt = ke[0]; 
            ptr_pedio[f]->fiyt = ke[1];
            ptr_pedio[f]->fiwid = ke[2];
            ptr_pedio[f]->fihei = ke[3];
            ptr_pedio[f]->filaxt = ke1[0];
            ptr_pedio[f]->filayt = ke1[1];
            ptr_pedio[f]->filawid = ke1[2];
            ptr_pedio[f]->filahei = ke1[3];
            ptr_pedio[f]->fipg=selis;
            for (i=0;i<3;i++) {
            ptr_pedio[f]->fibkxr[i]=proxbkxr[i] ; 
            ptr_pedio[f]->fichxr[i]=proxchxr[i] ; 
            ptr_pedio[f]->fislxr[i]=proxslxr[i] ;
                }
            ptr_pedio[f]->fiwhen=time(NULL);
            ptr_pedio[f]->fifont=ep_font;
            ptr_pedio[f]->fifo_hei=myfont_hei[ep_font]; ptr_pedio[f]->fifo_wid=myfont_wid[ep_font];
            ptr_pedio[f]->fiorio=hoc;
            ptr_pedio[f]->ficode = hkvd;
            mystrcpy (ptr_pedio[f]->finame , pedname);
            if (ptr_pedio[arped]->fitype==2) mystrcpy (ptr_pedio[f]->filistname , nameoflist);
            else {
                nameoflist[0]=ptr_pedio[f]->filistname[0]=255 ;
            }
            for (i=0;i<7;i++) {
            ptr_pedio[f]->fivar[i] = varni[i];
            }
            
            if (ptr_pedio[f]->fivar[3]) { i = field_coord(f , selis, 1 ); if (!i) break; }
            
            i = field_coord(f , selis, 0 );
            if (!i) break;
                  
            
            // Εγγραφή στοιχείων στο δίσκο !
            /*
            if (dbkey!=_prodbkey) {
                fseek(fpdb,102,0);
                fwrite (&dbkey,2,1,fpdb);
                fdatasync (fide_fpdb);
            }
            */
            dx=(arped*dbfisize);
            dx+=104;
            dy=fseek(fpdb,dx,0);
            if (dy) {information(6-keyb_gr,LDdbfile,0); break;} // αποτυχία !
            fwrite(ptr_pedio[f],1,dbfisize,fpdb);
            fdatasync (fide_fpdb);
            
            all_alg=0;
            if (arped>dbfinum && new_mathtype) {
                if (alg_str[arped]) free (alg_str[arped]);
                alg_str[arped]=0;
                mem5 = malloc (1026);
                if (!mem5) { information (2-keyb_gr,0,0); break ;}
                alg_str[arped]=mem5;
                mystrcpy (alg_str[arped] , new_alg_str);
                clear_alg(alg_str[arped]);
                dx=0;
                for (f=0 ; f<=dbfinum ; f++) {
                    if (ptr_pedio[f]->mathtype) { dx++; }
                }
                //printf ("dx must be 0 , dx = %d\n", dx);
                fseek(fpdb , math_alma+dx*1024 , 0);
                fwrite (alg_str[arped],1,1024,fpdb);
                fdatasync (fide_fpdb);
                all_alg=1; // Νέο πεδίο mathtype
            }
            else if (arped <= dbfinum && new_mathtype) {
                
                if (alg_str[arped]) { 
                    dx=mystrcmp (alg_str[arped] , prox_alg_str); 
                    if (!dx) all_alg=0 ; else all_alg=2;
                }
                else all_alg=3;
                
                // all_alg=2 : παλιό πεδίο mathtype με νέο alg_str
                // all_alg=3 : παλιό πεδίο μη mathtype που έγινε mathtype (παίζει μόνον με dbplgr=0!! )
                
                a=0;
                
                switch (all_alg) {
                    case 3 :
                        mem5 = malloc (1026);
                        if (!mem5) { information (2-keyb_gr,0,0); a=1 ; break ;}
                        alg_str[arped]=mem5;
                        
                        
                    case 2 :
                        mystrcpy (alg_str[arped] , prox_alg_str);
                        clear_alg(alg_str[arped]);
                        i=0;dy=0;
                        for (f=0; f<=dbfinum ; f++) {
                            if (f==arped) {dy=i; break ;}
                            if (ptr_pedio[f]->mathtype) { i++; }
                        }
                        fseek(fpdb , math_alma + dy*1024 , 0);
                        for (f=arped ; f<=dbfinum ; f++) {
                            if (ptr_pedio[f]->mathtype) {
                            fwrite (alg_str[f],1,1024,fpdb); 
                            fdatasync (fide_fpdb);
                            }
                        }
                }
                if (a) break ;
            }
            else if (arped <= dbfinum && !new_mathtype) {
                if (alg_str[arped]){
                    all_alg=4; //Ήταν mathtype και το καταργούμε !
                    mem5=alg_str[arped];
                    free(mem5);
                    alg_str[arped]=0;
                    i=0;
                    for (f=0; f<=dbfinum ; f++) {
                        if (f==arped) {dy=i; break ;}
                        if (ptr_pedio[f]->mathtype) { i++; }
                    }
                    fseek(fpdb , math_alma + dy*1024 , 0);
                    for (f=arped+1 ; f<=dbfinum ; f++) {
                        if (ptr_pedio[f]->mathtype) {
                        fwrite (alg_str[f],1,1024,fpdb); 
                        fdatasync (fide_fpdb);
                        }
                    }
                }
                else {all_alg=0;}
            }
            
            f=arped ;
            a=0;
            
            if ( (arped<=dbfinum) && (xmemk) && (!dbplgr) ) {
                if (old_fitype != ptr_pedio[f]->fitype) {
                    
                    keimk=memk[f] ; ceimk=memcp[f] ;
                    
                    if ( (old_fitype==3 || old_fitype==4) && (!ptr_pedio[f]->fitype) ) {curk[f]=0;curk1[f]=0;}                     
                    else if (old_fitype==3 && ptr_pedio[f]->fitype==4) { curk[f]=0;curk1[f]=0;}
                    else if ( (old_fitype==1 || old_fitype==2) && (!ptr_pedio[f]->fitype) ) {curk[f]=0;curk1[f]=0;}
                    else {keimk[0]=255; ceimk[0]=255;curk[f]=0;curk1[f]=0;}
                }
                
                if ( (ptr_pedio[f]->fitype!=5) && (limk[f]!=hoc+1) ) {a=1; limk[f]=xlimk[f]=hoc+1;}
                else if ( (ptr_pedio[f]->fitype==5) && (limk[f]!=1024) ) {a=1; limk[f]=xlimk[f]=1024;}
            }
            
            if (a) { 
                switch (ptr_pedio[f]->fitype) {
                    case 0 :
                        if ( xlimk[f] < 1000 ) xlimk[f] += (80 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 5000 ) xlimk[f] += (60 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 10000 ) xlimk[f] += (40 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 30000 ) xlimk[f] += (20 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 50000 ) xlimk[f] += (10 * xlimk[f] / 100) ;
                        break ;
                    case 1 :
                    case 2 :
                        xlimk[f]=51 ;
                        break;
                    case 3:
                    case 4:
                        xlimk[f]=15 ;
                        break;
                    case 5 :
                        break;
                    case 6:
                        xlimk[f]=25;
                }
                
             memk[f]=realloc(memk[f],xlimk[f]); keimk=memk[f] ; 
             memcp[f]=realloc(memcp[f],xlimk[f]); ceimk=memcp[f] ;
             
             if ( !memk[f] || !memcp[f] ) {information (2-keyb_gr,0,0) ; break;}
             else {
             sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
             fp=fopen(str1024,"r+b");
             if (fp==NULL) {information (6-keyb_gr,str1024,0);} 
             
             else
             {
                 fide_lims = fileno (fp) ;
                 dy=fseek (fp,(2*f),0);
                 if (dy) {information (6-keyb_gr,str1024,0);} 
                 fwrite (&xlimk[f],2,1,fp);
                 if  (ferror(fp) )    {information (6-keyb_gr,str1024,0);} 
                 dy=fsync (fide_lims);
                 if (dy) {information (6-keyb_gr,str1024,0);} 
                 fclose (fp) ; fp = NULL ;
            } } 
            
            if (ptr_pedio[f]->fitype!=5) {
                 keimk[hoc] = ceimk[hoc] = 255 ;
            }
            else {
                keimk[1023] = ceimk[1023] = '\0';
            }
            dbcardsize=alma_deigma=0;
            for (f=0;f<=dbfinum;f++) {
                if (f==dbkey) alma_deigma=dbcardsize;
                dbcardsize+=xlimk[f];
                }
                 if (dbkey==100) alma_deigma=dbcardsize; 
                dbcardsize += sizeof (time_t);
                
            }
            

            if ( (dbplgr) && (arped<=dbfinum)  &&   (limk[arped]!=hoc+1)  && (ptr_pedio[arped]->fitype<5) ) {
                all_alg=0;
                f=arped;
                epanorio=0; n=0 ;
                cardwhen1=cardwhen ;
                allorio=0;
                
                old_li=limk[f] ; old_xli=xlimk[f] ;

                if (keyb_gr) strcpy (str1kb,"Έχετε αλλάξει το όριο χαρακτήρων πεδίου!\nΘα απαιτηθεί αναδιάταξη της Βάσης.\nΘέλετε σίγουρα να γίνει τώρα;");
                else strcpy (str1kb,"You changed the chars' limit for a field!\nA DB reordering has to be done.\nDo you surely want to proceed now ?");
                user_ans=alert(0,str1kb,0);
                
                if (user_ans!=1) {
                    epanorio=1;
                    goto EPANAFORIO ;
                }
               
                limk[f]=xlimk[f]=hoc+1;
                switch (ptr_pedio[f]->fitype) {
                    case 0 :
                        if ( xlimk[f] < 1000 ) xlimk[f] += (80 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 5000 ) xlimk[f] += (60 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 10000 ) xlimk[f] += (40 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 30000 ) xlimk[f] += (20 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 50000 ) xlimk[f] += (10 * xlimk[f] / 100) ;
                        break ;
                    case 1 :
                    case 2 :
                        xlimk[f]=51 ;
                        break;
                    case 3:
                    case 4:
                        xlimk[f]=15 ;
                        break;
                }

                    mem2 = malloc (xlimk[f]);
                    if (!mem2) {
                        information (2-keyb_gr,0,0) ;
                        if (keyb_gr) information (0 , "H τροποποίηση του ορίου χαρακτήρων..\n..δεν είναι δυνατή τώρα!",0);
                        else information (0,"The characters' limit modification..\n..is impossible now!",0);
                        epanorio=1;
                        goto EPANAFORIO ;
                    }
                    
                    ceimk=mem2;
                    
                    sprintf(str1024,"%s%s",savedbpath,"NEW_Data1.aba"); // Νέο Αρχείο Καρτελλών
                    fp1card=fopen(str1024,"wb");
                    if (fp1card==NULL) {
                        information(6-keyb_gr,str1024,0); 
                        free(mem2); mem2=0;
                        if (keyb_gr) information (0 , "H τροποποίηση του ορίου χαρακτήρων..\n..δεν είναι δυνατή τώρα!",0);
                        else information (0,"The characters' limit modification..\n..is impossible now!",0);
                        epanorio=1;
                        goto EPANAFORIO ;
                    }

                    fide_fp1= fileno (fp1card) ;
                    rewind(fpcard) ;
                    
                    if (keyb_gr) strcpy (str1kb,"Αναδιάταξη Βάσης Δεδομένων..");
                    else strcpy (str1kb,"Data Base Reordering..");
                    user_ans = proodos(  str1kb, 0, dbplgr+dbplera,0) ;
                    
                    dx=dy=0; keimk=memk[arped];
                    for (i1=0 ; i1<(dbplgr+dbplera); i1++) {
                        if (user_ans) { proodos(  0, i1, dbplgr+dbplera,0) ;}
                        for (f=0; f<=dbfinum; f++) {
                            if (f==arped) {
                                fread(memk[f],1,old_xli,fpcard);
                                if (ferror(fpcard)) {dx=1 ; break ;}
                                i=0;
                                if (xlimk[arped]<old_xli) {
                                    while (  (i<limk[arped]-1) && (keimk[i]!=255) ) {ceimk[i]=keimk[i] ; i++ ; }
                                    ceimk[i]=255;
                                }
                                else {
                                    while ( (i<old_li-1) && (keimk[i]!=255) ) {ceimk[i]=keimk[i] ; i++ ; }
                                    ceimk[i]=255;
                                }
                                fwrite(mem2,1,xlimk[f],fp1card);
                                if ( (ferror(fp1card) ) ) { dx = 1 ; break ;}
                                dy=fdatasync (fide_fp1);
                                if (dy) break ;
                            }
                            else {
                            fread(memk[f],1,xlimk[f],fpcard);
                            fwrite(memk[f],1,xlimk[f],fp1card);
                            if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                            dy=fdatasync (fide_fp1);
                            if (dy) break ;
                            }
                        }
                        if ( (dx) || (dy) ) { dx=1;  break ; }
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        fwrite (&cardwhen,sizeof(time_t),1,fp1card);
                        dy=fdatasync (fide_fp1);
                        if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                        if (dy) break ;
                    }
                    
                    free(mem2); mem2=0;
                    
                    if (dx || dy) {
                        proodos(  0, i1, dbplgr+dbplera,1) ;
                        information (6-keyb_gr,"Please Close the DB and ..","..CHECK your disk!");
                        rewind (fpcard); rewind(fp1card);fclose(fp1card);
                        if (keyb_gr) information (0 , "H τροποποίηση του ορίου χαρακτήρων..\n..δεν είναι δυνατή τώρα!",0);
                        else information (0,"The characters' limit modification..\n..is impossible now!",0);
                        epanorio=1; 
                        n=1 ;                      // Πρέπει να αποκαταστήσει τα memk...
                        goto EPANAFORIO ;
                    }
                    
                    fsync (fide_fp1);
                    fclose(fp1card);
                    fclose(fpcard);
                    wasopca=0 ;
                    fpcard=NULL;
                    
                    dx=remove (Strcardfp) ;
                    
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s removal!" ,  Strcardfp) ;
                        information(0,str1kb,"Abort");
                        
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please Quit - Check the disk !!");}
                        else { fide_fpcard = fileno (fpcard);  wasopca=1; }           
                        if (keyb_gr) information (0 , "H τροποποίηση του ορίου χαρακτήρων..\n..δεν είναι δυνατή τώρα!",0);
                        else information (0,"The characters' limit modification..\n..is impossible now!",0);
                        epanorio=1; 
                        n=1 ;                      // Πρέπει να αποκαταστήσει τα memk...
                        goto EPANAFORIO ;
                    }
                    
                    dx=rename (str1024 , Strcardfp);
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s renaming!" ,  str1024) ;
                        sprintf (str1024,"Try to rename it as %s", Strcardfp);
                        information(0,str1kb,str1024);
                    }
                    
                    allorio=1;
                    f=arped;
                    sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                    fp=fopen(str1024,"r+b");
                    if (fp==NULL) {information (6-keyb_gr,str1024,0);}
                    else {
                        fide_lims = fileno (fp) ;
                        dy=fseek(fp,(2*f),0);
                        if (dy) {information (6-keyb_gr,str1024,0);}
                        fwrite (&xlimk[f],2,1,fp);
                        if ( ferror(fp) ) {information (6-keyb_gr,str1024,0); clearerr(fp); }
                        dy=fsync (fide_lims);
                        if (dy) {information (6-keyb_gr,str1024,0);}
                        fclose (fp); fp=NULL;
                    }  

EPANAFORIO :
                if (epanorio) {
                    epanorio=0;
                    f=arped ;
                    ptr_pedio[f]->fiorio=old_li-1;
                    limk[f]=old_li;
                    xlimk[f]=old_xli;
                    dx=(f*dbfisize);
                    dx+=104;
                    dy=fseek(fpdb,dx,0);
                    if (dy) {information(6-keyb_gr,LDdbfile,0);}
                    fwrite(ptr_pedio[f],1,dbfisize,fpdb);
                    dy=fdatasync (fide_fpdb);
                    if ( (ferror(fpdb)) || (dy) ) {information(6-keyb_gr,LDdbfile,0); clearerr(fpdb); rewind(fpdb);} 
                    
                    if (n) {                           // Κάτι δεν πήγε (επίσης) καλά με τα fpcard - fp1card !!
                        n=0;
                        cardwhen=cardwhen1 ;
                        for (f=0;f<=dbfinum;f++) {
                            keimk=memk[f];
                            ceimk=memcp[f];
                            i=0;
                            if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                            else {
                                if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                                else keimk[i]=255;
                            }
                        }
                        hoc=old_li-1;
                        _bareacls(orchaxt , orchayt , orchaxb, orchayb,pedbkxr);
                        sprintf(str1024,"%u",hoc);
                        _outsouv_col(orchaxt+1 , orchayt+1, str1024, 0 , bluechxr , pedbkxr);
                        normtext_tomy(str1024,orio_char);
                        refresh();
                        continue ;
                    }
                }
            }
            
            
            
            if ( (arped<=dbfinum) && (!dbplgr) &&  (all_alg==2 || all_alg==3) && (xmemk) ) {
                    dx=check_pediaola_math();
                    if (dx<0) {information (2-keyb_gr,0,0);}
                    dpro = proter_calc_pedivn();
                    if (dpro>0) {
                        for (f=0 ; f<enmath_1; f++) {
                            a=prot_calc[f];
                            dfx = anal_parast (a, alg_str[a] , &alg_err , 0);
                            check_orio_write_mathped(a, ptr_pedio[a]->fiorio, 1);
                        }
                    }                    
            }
                 
            f=arped;
            
            if ( (arped>dbfinum) && (!dbplgr) ) {
                dbfinum++; 
                diat_mem=1;
                dy=fseek(fpdb,58,0);
                if (dy) {information(6-keyb_gr,LDdbfile,0); rewind(fpdb); break;} // αποτυχία !
                fwrite (&dbfinum,2,1,fpdb); fdatasync (fide_fpdb);
                
                if ( (xmemk) && (!dbplgr) ){
                    xlimk[f]=ptr_pedio[f]->fiorio+1;
                    switch (ptr_pedio[f]->fitype) {
                        case 0 :
                            if ( xlimk[f] < 1000 ) xlimk[f] += (80 * xlimk[f] / 100) ;
                            else if ( xlimk[f] < 5000 ) xlimk[f] += (60 * xlimk[f] / 100) ;
                            else if ( xlimk[f] < 10000 ) xlimk[f] += (40 * xlimk[f] / 100) ;
                            else if ( xlimk[f] < 30000 ) xlimk[f] += (20 * xlimk[f] / 100) ;
                            else if ( xlimk[f] < 50000 ) xlimk[f] += (10 * xlimk[f] / 100) ;
                            break ;
                        case 1 :
                        case 2 :
                            xlimk[f]=51 ;
                            break;
                        case 3:
                        case 4:
                            xlimk[f]=15 ;
                            break;
                        case 5 :
                            xlimk[f]=1024 ;
                            break;
                        case 6:
                            xlimk[f]=25;
                }

                    limk[f]= (ptr_pedio[f]->fitype != 5) ? ptr_pedio[f]->fiorio+1 : 1024 ;
                    memk[f]=malloc(xlimk[f]); keimk=memk[f] ; 
                    memcp[f]=malloc(xlimk[f]); ceimk=memcp[f] ;
                    if (!memk[f] || !memcp[f]) {information (2-keyb_gr,0,0) ; break; }
                    keimk[0]=255;  ceimk[0]=255; curk[f]=0;curk1[f]=0;
                    
                
            sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
            fp=fopen(str1024,"r+b");
            if (fp==NULL) {information (6-keyb_gr,str1024,0);}
            else {
                fide_lims = fileno (fp) ;
                dy=fseek(fp,(2*f),0);
                if (dy) {information (6-keyb_gr,str1024,0);}
                fwrite (&xlimk[f],2,1,fp);
                if ( (ferror(fp)) ) {information (6-keyb_gr,str1024,0);}
                dy= fsync (fide_lims);
                 if (dy) {information (6-keyb_gr,str1024,0);}
                fclose (fp); fp=NULL;
            }  
                
            dbcardsize=alma_deigma=0;
            for (f=0;f<=dbfinum;f++) {
            if (f==dbkey) alma_deigma=dbcardsize;
            dbcardsize+=xlimk[f];
                }
             if (dbkey==100) alma_deigma=dbcardsize; 
            dbcardsize += sizeof (time_t);
                
                } 
            
                if (all_alg==1) {
                    dx=check_pediaola_math();
                    if (dx<0) {information (2-keyb_gr,0,0); break;}
                    dfx = anal_parast (arped, alg_str[arped] , &alg_err , 1);
                    check_orio_write_mathped(arped, ptr_pedio[arped]->fiorio, 1);
                }
            }
            
            f=arped ;
                
            if ( (arped>dbfinum) && (dbplgr) ) {

                dbfinum++; 
                diat_mem=0;
                addped=1;
                dy=fseek(fpdb,58,0);
                if (dy) {information(6-keyb_gr,LDdbfile,0); rewind(fpdb); addped=0; break;} // αποτυχία !
                fwrite (&dbfinum,2,1,fpdb); fdatasync (fide_fpdb);
                //f=arped;                
                xlimk[f]=ptr_pedio[f]->fiorio+1;
                switch (ptr_pedio[f]->fitype) {
                    case 0 :
                        if ( xlimk[f] < 1000 ) xlimk[f] += (80 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 5000 ) xlimk[f] += (60 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 10000 ) xlimk[f] += (40 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 30000 ) xlimk[f] += (20 * xlimk[f] / 100) ;
                        else if ( xlimk[f] < 50000 ) xlimk[f] += (10 * xlimk[f] / 100) ;
                        break ;
                    case 1 :
                    case 2 :
                        xlimk[f]=51 ;
                        break;
                    case 3:
                    case 4:
                        xlimk[f]=15 ;
                        break;
                    case 5 :
                        xlimk[f]=1024 ;
                        break;
                    case 6:
                        xlimk[f]=25;
            }

                limk[f]= (ptr_pedio[f]->fitype != 5) ? ptr_pedio[f]->fiorio+1 : 1024 ;
                if (!mem2) mem2 = malloc(xlimk[f]);
                
                dx=1;
                 if (all_alg==1) {
                    dx=check_pediaola_math();
                    if (dx<0) {  if (mem2) free(mem2); mem2=0; }
                }
                
                if ( !mem2  || dx<0 ) {
                    information (2-keyb_gr,0,0) ; 
                    addped=0; 
                    fseek(fpdb,58,0);
                    dbfinum--;
                    fwrite (&dbfinum,2,1,fpdb); 
                    fdatasync (fide_fpdb);
                    break; 
                }
                keimk=mem2 ; keimk[0]=255; 
                if (all_alg==1) memk[arped]=mem2;
                //sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); // Αρχείο Καρτελλών

                sprintf(str1024,"%s%s",savedbpath,"NEW_Data1.aba"); // Νέο Αρχείο Καρτελλών
                fp1card=fopen(str1024,"wb");
                if (fp1card==NULL) {
                    information(6-keyb_gr,str1024,0); 
                    addped=0;
                    free(mem2); mem2=0;
                    fseek(fpdb,58,0);
                    dbfinum--;
                    fwrite (&dbfinum,2,1,fpdb); 
                    fdatasync (fide_fpdb);
                    goto ADDPED_SPASE ;
                }
                
                fide_fp1= fileno (fp1card) ;
                rewind(fpcard) ;

                
                if (keyb_gr) strcpy (str1kb,"Αναδιάταξη Βάσης Δεδομένων..");
                else strcpy (str1kb,"Data Base Reordering..");
                user_ans = proodos(  str1kb, 0, dbplgr+dbplera,0) ;
                
                dx=dy=0;
                for (i=0 ; i<(dbplgr+dbplera); i++) {
                    if (user_ans) { proodos(  0, i, dbplgr+dbplera,0) ;}
                    for (f=0; f<dbfinum; f++) {
                        fread(memk[f],1,xlimk[f],fpcard);
                        fwrite(memk[f],1,xlimk[f],fp1card);
                        if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                        dy=fdatasync (fide_fp1);
                        if (dy) break ;
                    }
                    if ( (dx) || (dy) ) {
                        dx=1;
                        break ;
                    }
                    if (all_alg==1) {
                        dfx = anal_parast (arped, alg_str[arped] , &alg_err , 0);
                        check_orio_write_mathped(arped, ptr_pedio[arped]->fiorio, 1);
                    }
                    fwrite (mem2,1,xlimk[f],fp1card);
                     if ( (ferror(fp1card)) ) { dx = 1 ; break ;}
                    fread (&cardwhen,sizeof(time_t),1,fpcard);
                    fwrite (&cardwhen,sizeof(time_t),1,fp1card);
                    dy=fdatasync (fide_fp1);
                    if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                    if (dy) break ;
                }
                memk[arped]=0;
                
                if (dx || dy) {
                    proodos(  0, i, dbplgr+dbplera,1) ;
                    information (6-keyb_gr,"Please Close the DB and ..","..CHECK your disk!");
                    rewind (fpcard); rewind(fp1card);fclose(fp1card);
                    addped=0;
                    free(mem2); mem2=0;
                    fseek(fpdb,58,0);
                    dbfinum--;
                    fwrite (&dbfinum,2,1,fpdb); 
                    fdatasync (fide_fpdb);
                    goto ADDPED_SPASE ;
                }
                
                fsync (fide_fp1);
                fclose(fp1card);
                fclose(fpcard);
                wasopca=0 ;
                fpcard=NULL;
                
                dx=remove (Strcardfp) ;
                
                if (dx) {
                    sprintf (str1kb , "Problem with file %s removal!" ,  Strcardfp) ;
                    information(0,str1kb,"Abort");
                    addped=0;
                    
                    fpcard=fopen(Strcardfp,"r+b");
                    if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please Quit - Check the disk !!");}
                    else { fide_fpcard = fileno (fpcard);  wasopca=1; }
                    
                    free(mem2); mem2=0 ;
                    fseek(fpdb,58,0);
                    dbfinum--;
                    fwrite (&dbfinum,2,1,fpdb); 
                    fdatasync (fide_fpdb);
                    goto ADDPED_SPASE ;
                }
                
                dx=rename (str1024 , Strcardfp);
                if (dx) {
                    sprintf (str1kb , "Problem with file %s renaming!" ,  str1024) ;
                    sprintf (str1024,"Try to rename it as %s", Strcardfp);
                    information(0,str1kb,str1024);
                }
                
                //fpcard=fopen(Strcardfp,"r+b"); // Αρχείο ΚΑΡΤΕΛΛΩΝ !!                  
                //if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,0); gen_ergo=&ch3 ; break ;}
                //fide_fpcard = fileno (fpcard) ; wasopca=1 ;
                
                if (!mem2) free(mem2);
                mem2=0;
                
                f=arped;
                sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                fp=fopen(str1024,"r+b");
                if (fp==NULL) {information (6-keyb_gr,str1024,0);}
                else {
                    fide_lims = fileno (fp) ;
                    dy = fseek(fp,(2*f),0);
                    if (dy) {information (6-keyb_gr,str1024,0);}
                    fwrite (&xlimk[f],2,1,fp);
                    if ( ferror(fp) ) {information (6-keyb_gr,str1024,0); clearerr(fp); }
                    dy=fsync (fide_lims);
                    if (dy) {information (6-keyb_gr,str1024,0);}
                    fclose (fp); fp=NULL;
                }  
            }
            
            a=0;
            if ( (dbplgr) && (all_alg==2) && (arped<=dbfinum) ) a=1;
            
            if (dbkey != _prodbkey) {
                if ( (!addped) && (!allorio) && (!a) ) {
                fseek(fpdb,102,0);
                fwrite (&dbkey,2,1,fpdb);
                fdatasync (fide_fpdb);
                }
                else {
                    dbkey=_prodbkey;
                    if (keyb_gr) information (0,"Tροποποίηση κλειδιού ταξινόμησης..\n..δεν μπορεί να γίνει τώρα ! \nΠροσπαθήστε εκ νέου..",0);
                    else information (0,"Sorting key modification..\n..is not feasible now ! \nTry again ..",0);
                }
            }

            if (selis>dbpg) { 
                dbpg=selis ;
             dy=fseek(fpdb,64,0);
            if (dy) {information(6-keyb_gr,LDdbfile,0); rewind(fpdb); 
                if (dbplgr) { dbfinum--; goto ADDPED_SPASE ;} 
                else break;} // αποτυχία !
            fwrite (&dbpg,2,1,fpdb); fdatasync (fide_fpdb);  
            }
            else {
                stoxos=1;
                for (f=0;f<=dbfinum;f++) {
                    if (ptr_pedio[f]->fipg > stoxos) stoxos=ptr_pedio[f]->fipg;
                }

                if (stoxos<dbpg) {
                    dbpg=stoxos;
                    dy=fseek(fpdb,64,0);
                    if (dy) {information(6-keyb_gr,LDdbfile,0); rewind(fpdb); 
                        if (dbplgr) { dbfinum--; goto ADDPED_SPASE ;}
                        else break;}
                    fwrite(&dbpg,2,1,fpdb); fdatasync (fide_fpdb);
                }
                if (dbcurpage>dbpg) { dbcurpage=dbpg; dbpage_decs(); }  
            }
            
            if ( (!addped) && (!allorio) ) {
                // Συνάρτηση για ενημέρωση πίνακα συντατεγμένων των στοιχείων της τρέχουσας σελίδας !
                dbpage_recs(1);
                if (a) fyge=11 ;
                else { fyge = (dbkey == _prodbkey) ? 1 : 10;}
                *_arped=arped;
            }
            else {
                fyge=4;
                f=fsync(fide_fpdb);
                i=fclose (fpdb) ; 
                if (i || f) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind (fpdb); fclose (fpdb);} 
                fpdb = NULL ; wasopdb=0;
                if (addped) dbfinum--;
                dbcard_opt = (user_opts) ? dbcard : 0 ;
            }
            
            continue;
            
ADDPED_SPASE :
            addped=0;
            cardwhen=cardwhen1 ;
            for (f=0;f<=dbfinum;f++) {
                keimk=memk[f];
                ceimk=memcp[f];
                i=0;
                if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                else {
                    if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                    else keimk[i]=255;
                }
            }
            
            continue ;
            
        }
        
        else if (go_ri) {
            
            if (arped>dbfinum) continue;
            
            if ( arped==dbfinum ) {
                if (adyn)  continue;
            }
               
            if (arped<dbfinum) {
            if (ptr_pedio[arped+1]->ficode) {
            if ((short int) prev_code!=ptr_pedio[arped+1]->ficode) {
            prox[0]=255;
            input_alert (40-keyb_gr,0, prox ,4);
            prev_code=(int) convert_str(4 , prox);
            if (ptr_pedio[arped+1]->ficode != (short int) prev_code ) continue;}
        }}
        
        ptr0 = (char *) ptr_pedio[arped] ;
        for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
        
        fiornam = 1 ;
        
        if (prorec) {  // Κρύβει το παράθυρο - Αποκαθιστά τέως επιλεγμένο πεδίο ή όνομα 
            mem_form=malloc(imagesize(0,0,757,384)); //758 x 385
            if (!mem_form) {information(2-keyb_gr,0,0); prorec=0; proi1=0; goto SYNEX_GORI;}
            getimage(xt,yt,xb,yb,mem_form);
            putimage (xt,yt,mem0,0);
            refresh();
            putimage (trecx,trecy,mem_ouon,0);refresh();
            if (proi1) { putimage (chainx,chainy,mem_kato,0); refresh();}
        }
        
SYNEX_GORI:

        arped++;
        
        if (arped<=dbfinum) {
            
            ptr0 = (char *) ptr_pedio[arped] ;
            for (f=0;f<dbfisize;f++) {ptr_copy[f] = ptr0[f];}
            
            dx=0;
            for (f=0 ; f<dbar; f++) {
                if ( db_elem[f][0]==arped && (db_elem[f][1]) ) {dx=1; break;} 
            }
            if (dx) {
                if (!prorec) {
                    mem_form=malloc(imagesize(0,0,757,384)); //758 x 385
                    if (!mem_form) {information(2-keyb_gr,0,0); goto SYNEX_GORI_1;}
                    getimage(xt,yt,xb,yb,mem_form);
                    putimage (xt,yt,mem0,0);
                    refresh();
                    prorec=1;
                }
                getimage(dbx1[f],dby1[f],dbx2[f],dby2[f],mem_ouon);
                setrgbcolor(dbmag);
                rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                trecx=dbx1[f] ; trecy=dby1[f];
                dy=0; 
                for (f=0; f<dbar; f++) {
                    if ( db_elem[f][0]==arped && (!db_elem[f][1]) ) {dy=1;break;} 
                    }
                
                if (dy) { 
                    proi1=1;
                    chainx=dbx1[f]+1; chainy=dby1[f]+1;
                    getimage(chainx,chainy,dbx1[f]+16,dby1[f]+16,mem_kato);
                    _puticon(chainx,chainy,mem_chain,255);
                } else proi1=0;
                
                refresh();
                getimage(xt,yt,xb,yb,mem0);
                putimage(xt,yt,mem_form,0);
                refresh();
                free(mem_form); mem_form=0;
                
            }
            else {
                if (prorec) {
                    getimage(xt,yt,xb,yb,mem0);
                    putimage(xt,yt,mem_form,0);
                    refresh();
                    free(mem_form); mem_form=0;
                }
                prorec=0; proi1=0;
            }
            
        }
        else {
            if (prorec) { // Επαναφέρει το παράθυρο
                getimage(xt,yt,xb,yb,mem0);
                putimage(xt,yt,mem_form,0);
                refresh();
                free(mem_form); mem_form=0;
            }
            prorec=0; proi1=0;
        }
        
SYNEX_GORI_1:

        if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255);
            else _puticon(keyxt,keyyt,mem_nk,255);
                    
        // Αριθμός Πεδίου
        sprintf (prox,"%03d",arped+1);
        _bareacls(finuxt,finuyt,finuxt+45,finuyt+19,pedbkxr);
        _outsouv_col(finuxt,finuyt,prox,0,bluechxr,pedbkxr);

        // Ονομασία Πεδίου

        _bareacls(finaxt , finayt , finaxb, finayb,pedbkxr);
        mystrcpy(pedname,ptr_pedio[arped]->finame);
        _outmystr_col (0,pedname, finaxt+1  , finayt+1 , finaxb , bluechxr, pedbkxr);
        trampa=gouv;
        gouv=myfont[ptr_pedio[arped]->fifont];
        f=0;
        ke1[2]=0;
        what=pedname[f];
        while (what!=255) {
            ke1[2]+=gouv[what].wid;
            what=pedname[++f];
        }
        ke1[2]+=2;
        el_wid=ke1[2];
        ep_font=ptr_pedio[arped]->fifont;
        el_hei=ke1[3]=myfont_hei[ep_font]+2;
        gouv=trampa;
        
        // LEFT
        for (f=0;f<7;f++) {
        _puticon(ltxt+2,datyt[f]+2,mem_yel,255);
        datni[f]=0;
        }
        i=ptr_pedio[arped]->fitype;
        if (i>=0 && i<7) { datni[i]=1;
        _puticon(ltxt+3,datyt[i]+4,mem_ni,255);}
        
        // new_mathtype

        new_mathtype = ptr_pedio[arped]->mathtype ;
        if (new_mathtype) {
            if (arped<=dbfinum) mystrcpy (prox_alg_str, alg_str[arped]);
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,yelbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,reccol,yelbkxr);
        }
        else {
            if (arped<=dbfinum) prox_alg_str[0]=255;
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
        }
        
        // KENTRO - KENTRO 1
        ke[0]=ptr_pedio[arped]->fixt;
        ke[1]=ptr_pedio[arped]->fiyt;
        ke[2]=ptr_pedio[arped]->fiwid;
        ke[3]=ptr_pedio[arped]->fihei;
        ke1[0]=ptr_pedio[arped]->filaxt;
        ke1[1]=ptr_pedio[arped]->filayt;
        ke1[2]= ptr_pedio[arped]->filawid;
        ke1[3]= ptr_pedio[arped]->filahei;
        for (f=0;f<4;f++) {
            _bareacls (Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22,pedbkxr);
            sprintf(prox,"%d",ke[f]); normtext_tomy(prox,K[f]);
            _outsouv_col(Xxt+2,kentroyt[f]+2,prox,0,bluechxr, pedbkxr);
            
            _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
            sprintf(prox,"%d",ke1[f]); normtext_tomy(prox,K1[f]);
            _outsouv_col(Xoxt+2,kentro1yt[f]+2,prox,0,bluechxr,nambkxr);
            }

        // Page
        selis=ptr_pedio[arped]->fipg;
        sprintf (prox,"%d",selis);
        normtext_tomy(prox,selida);
        _bareacls(Pxt,Pyt,Pxb,Pyb,pedbkxr);
        _outsouv_col(Pxt+1,Pyt+1,prox,0,bluechxr,pedbkxr);

        // RIGHT
        for (f=0;f<7;f++) {
            _puticon(rtxt+2,varyt[f]+2,mem_yel,255);
            }

        for (f=0;f<7;f++) {
            varni[f]=ptr_pedio[arped]->fivar[f];
            if (varni[f]) _puticon(rtxt+3,varyt[f]+4,mem_ni,255);
            }

        // Όριο Χαρακτήρων

        _bareacls(orchaxt , orchayt , orchaxb, orchayb ,pedbkxr);
        hoc=ptr_pedio[arped]->fiorio;
        sprintf (prox,"%u",hoc);
        if (hoc) {normtext_tomy(prox,orio_char) ; _outsouv_col(orchaxt+1 , orchayt+1,prox,0,bluechxr,pedbkxr);} 
        else orio_char[0]=255;

        // Κλείδωμα

        _bareacls(keyloxt  , keyloyt , keyloxb, keyloyb ,pedbkxr);
        hkvd=ptr_pedio[arped]->ficode;
        sprintf (prox,"%d",hkvd);
         if (hkvd) {normtext_tomy(prox,kvdikos) ; _outsouv_col(keyloxt+1 , keyloyt+1 , prox , 0 ,  bluechxr,pedbkxr);}
         else kvdikos[0]=255;

        // Ονομα Λίστας

        _bareacls(listnaxt , listnayt , listnaxb, listnayb,pedbkxr);
        mystrcpy (nameoflist,ptr_pedio[arped]->filistname);
        for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
        if(nameoflist[0]!=255) _outfanis_center_col (0, nameoflist, listnaxt+1 , listnayt+1 , listnaxb);

        // Font - Colors

        // ep_font=ptr_pedio[arped]->fifont;
        
        for (f=0;f<3;f++) {
            chxr[f]=proxchxr[f]=ptr_pedio[arped]->fichxr[f] ; 
            bkxr[f]=proxbkxr[f]=ptr_pedio[arped]->fibkxr[f];
            proxslxr[f] = ptr_pedio[arped]->fislxr[f];
            }
        _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
        normtext_tomy(myfont_name[ep_font],font_text);
        _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
        for (f=0;f<3;f++) chxr[f]=bluechxr[f];
        refresh();
        break ;
        } 
        
        else if (go_le) {
            if (!arped) continue;

            if (ptr_pedio[arped-1]->ficode) {
            if ((short int) prev_code!=ptr_pedio[arped-1]->ficode) {
            prox[0]=255;
            input_alert (40-keyb_gr,0, prox ,4);
            prev_code=(int) convert_str(4 , prox);
            if (ptr_pedio[arped-1]->ficode != (short int) prev_code ) continue; }
            }
        
            if (arped<=dbfinum) {
                ptr0 = (char *) ptr_pedio[arped] ;
                for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
            }
            arped--;
            ptr0 = (char *) ptr_pedio[arped] ;
            for (f=0;f<dbfisize;f++) {ptr_copy[f] = ptr0[f];}
            
            fiornam = 1 ;
            
            if (prorec) {  // Κρύβει το παράθυρο - Αποκαθιστά τέως επιλεγμένο πεδίο ή όνομα 
                mem_form=malloc(imagesize(0,0,757,384)); //758 x 385
                if (!mem_form) {information(2-keyb_gr,0,0); prorec=0; proi1=0; goto SYNEX_LEFT;}
                getimage(xt,yt,xb,yb,mem_form);
                putimage (xt,yt,mem0,0);
                refresh();
                putimage (trecx,trecy,mem_ouon,0);refresh();
                if (proi1) { putimage (chainx,chainy,mem_kato,0); refresh();}
            }
            
            dx=0;
            for (f=0 ; f<dbar; f++) {
                if ( db_elem[f][0]==arped && (db_elem[f][1]) ) {dx=1; break;} 
            }
            if (dx) {
                if (!prorec) {
                    mem_form=malloc(imagesize(0,0,757,384)); //758 x 385
                    if (!mem_form) {information(2-keyb_gr,0,0); goto SYNEX_LEFT;}
                    getimage(xt,yt,xb,yb,mem_form);
                    putimage (xt,yt,mem0,0);
                    refresh();
                    prorec=1;
                }
                getimage(dbx1[f],dby1[f],dbx2[f],dby2[f],mem_ouon);
                setrgbcolor(dbmag);
                rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                rectangle (dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                trecx=dbx1[f] ; trecy=dby1[f];
                dy=0; 
                for (f=0; f<dbar; f++) {
                    if ( db_elem[f][0]==arped && (!db_elem[f][1]) ) {dy=1;break;} 
                    }
                
                if (dy) { 
                    proi1=1;
                    chainx=dbx1[f]+1; chainy=dby1[f]+1;
                    getimage(chainx,chainy,dbx1[f]+16,dby1[f]+16,mem_kato);
                    _puticon(chainx,chainy,mem_chain,255);
                } else proi1=0;
                
                refresh();
                getimage(xt,yt,xb,yb,mem0);
                putimage(xt,yt,mem_form,0);
                refresh();
                free(mem_form); mem_form=0;
                
            }
            else {
                if (prorec) {
                    getimage(xt,yt,xb,yb,mem0);
                    putimage(xt,yt,mem_form,0);
                    refresh();
                    free(mem_form); mem_form=0;
                }
                prorec=0; proi1=0;
            }
            
SYNEX_LEFT:
        
        if (dbkey==arped) _puticon(keyxt,keyyt,mem_yk,255);
            else _puticon(keyxt,keyyt,mem_nk,255);
            
        // Αριθμός Πεδίου
        sprintf (prox,"%03d",arped+1);
        _bareacls(finuxt,finuyt,finuxt+45,finuyt+19,pedbkxr);
        _outsouv_col(finuxt,finuyt,prox,0,bluechxr,pedbkxr);

        // Ονομασία Πεδίου

        _bareacls(finaxt , finayt , finaxb, finayb,pedbkxr);
        mystrcpy(pedname,ptr_pedio[arped]->finame);
        _outmystr_col (0,pedname, finaxt+1  , finayt+1 , finaxb , bluechxr, pedbkxr);
            trampa=gouv;
            gouv=myfont[ptr_pedio[arped]->fifont];
            f=0;
            ke1[2]=0;
            what=pedname[f];
            while (what!=255) {
                ke1[2]+=gouv[what].wid;
                what=pedname[++f];
            }
            ke1[2]+=2;
            el_wid=ke1[2];
            ep_font=ptr_pedio[arped]->fifont;
            el_hei=ke1[3]=myfont_hei[ep_font]+2;
            gouv=trampa;
            
        // LEFT
        for (f=0;f<7;f++) {
        _puticon(ltxt+2,datyt[f]+2,mem_yel,255);
        datni[f]=0;
        }
        i=ptr_pedio[arped]->fitype;
        if (i>=0 && i<7) { datni[i]=1;
        _puticon(ltxt+3,datyt[i]+4,mem_ni,255);}
        
        // new_mathtype

        new_mathtype = ptr_pedio[arped]->mathtype ;
        if (new_mathtype) {
            mystrcpy (prox_alg_str, alg_str[arped]);
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,yelbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,reccol,yelbkxr);
        }
        else {
            prox_alg_str[0]=255;
            _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
            _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
        }
        

        // KENTRO - KENTRO 1
        ke[0]=ptr_pedio[arped]->fixt;
        ke[1]=ptr_pedio[arped]->fiyt;
        ke[2]=ptr_pedio[arped]->fiwid;
        ke[3]=ptr_pedio[arped]->fihei;
        ke1[0]=ptr_pedio[arped]->filaxt;
        ke1[1]=ptr_pedio[arped]->filayt;
        ke1[2]= ptr_pedio[arped]->filawid;
        ke1[3]= ptr_pedio[arped]->filahei;
        for (f=0;f<4;f++) {
            _bareacls (Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22,pedbkxr);
             sprintf(prox,"%d",ke[f]); normtext_tomy(prox,K[f]);
            _outsouv_col(Xxt+2,kentroyt[f]+2,prox,0,bluechxr, pedbkxr);
            
            _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
            sprintf(prox,"%d",ke1[f]); normtext_tomy(prox,K1[f]);
            _outsouv_col(Xoxt+2,kentro1yt[f]+2,prox,0,bluechxr,nambkxr);
            }

        // Page
        selis=ptr_pedio[arped]->fipg;
        sprintf (prox,"%d",selis);
        normtext_tomy(prox,selida);
        _bareacls(Pxt,Pyt,Pxb,Pyb,pedbkxr);
        _outsouv_col(Pxt+1,Pyt+1,prox,0,bluechxr,pedbkxr);

        // RIGHT
        for (f=0;f<7;f++) {
            _puticon(rtxt+2,varyt[f]+2,mem_yel,255);
            }

        for (f=0;f<7;f++) {
            varni[f]=ptr_pedio[arped]->fivar[f];
            if (varni[f]) _puticon(rtxt+3,varyt[f]+4,mem_ni,255);
            }

        // Όριο Χαρακτήρων

        _bareacls(orchaxt , orchayt , orchaxb, orchayb ,pedbkxr);
        hoc=ptr_pedio[arped]->fiorio;
        sprintf (prox,"%u",hoc);
        if (hoc) {normtext_tomy(prox,orio_char) ; 
        _outsouv_col(orchaxt+1 , orchayt+1,prox,0,bluechxr,pedbkxr);}
        else orio_char[0]=255;

        // Κλείδωμα

        _bareacls(keyloxt  , keyloyt , keyloxb, keyloyb ,pedbkxr);
        hkvd=ptr_pedio[arped]->ficode;
        sprintf (prox,"%u",hkvd);
         if (hkvd) {normtext_tomy(prox,kvdikos) ; _outsouv_col(keyloxt+1 , keyloyt+1 , prox , 0 ,  bluechxr,pedbkxr);} 
         else kvdikos[0]=255;

        // Ονομα Λίστας

        _bareacls(listnaxt , listnayt , listnaxb, listnayb,pedbkxr);
        mystrcpy (nameoflist,ptr_pedio[arped]->filistname);
        for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
        if(nameoflist[0]!=255) _outfanis_center_col (0, nameoflist, listnaxt+1 , listnayt+1 , listnaxb);

        // Font - Colors

        //ep_font=ptr_pedio[arped]->fifont;
        
        for (f=0;f<3;f++) {
            chxr[f]=proxchxr[f]=ptr_pedio[arped]->fichxr[f] ; 
            bkxr[f]=proxbkxr[f]=ptr_pedio[arped]->fibkxr[f];
            proxslxr[f] = ptr_pedio[arped]->fislxr[f];
            }
        _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
        normtext_tomy(myfont_name[ep_font],font_text);
        _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
        for (f=0;f<3;f++) chxr[f]=bluechxr[f];
        refresh();
        break ;
        }
        
        else if (left) { // rectangle (ltxt+2,datyt[proleft]+2,ltxb-2,datyt[proleft]+22);}
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            if ( (dbplgr) && (arped<=dbfinum) ){ 
                if (keyb_gr) information (0,"Ο τύπος των πεδίων δεν τροποποιείται..\n..όσο η βάση έχει καρτέλες στοιχείων!\nΘα πρέπει να τις διαγράψετε όλες!",0);
                else information (0,"You can't modify data fields' type..\n..while the DB has data cards !\nYou have to delete them all!",0);
                continue; 
            }

            if ( (dbkey==arped)  &&  (!datni[5]) && (proleft==5) ) {
                if (keyb_gr) information (0,"Το κλειδί ταξινόμησης δεν επιτρέπεται..\n..να είναι πεδίο εικόνας!",0);
                else information (0,"The DB sorting key can't be ..\n..an image field!",0); 
                continue ;}
            
            for (f=0;f<7;f++) {
              if (datni[f]) {
               _puticon(ltxt+2,datyt[f]+2,mem_yel,255);
               datni[f]=0;
               if (f==3 || f==4 && new_mathtype) {
                    new_mathtype=0;
                    _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
                    _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
                    refresh ();
            }
               if (arped>dbfinum) { ptr_pedio[arped]->fitype=7; ptr_pedio[arped]->mathtype=0; }
               bareacls(orchaxt , orchayt , orchaxb, orchayb,pedbkxr);
               hoc=0 ; orio_char[0]=255;
                break;
                    }
                }  
        if ( f==7 ) {
            _puticon(ltxt+3,datyt[proleft]+4,mem_ni,255); datni[proleft]=1;
            if (arped>dbfinum) ptr_pedio[arped]->fitype=proleft;
        }
        else if ( (f!=7) && (f!=proleft) ) {
            _puticon(ltxt+3,datyt[proleft]+4,mem_ni,255); datni[proleft]=1;
            if (f==3 || f==4 && new_mathtype) {
                if (proleft!=3 && proleft!=4) {
                    new_mathtype=0;
                    _bareacls (calcbox_xt+2,calcbox_yt+2,calcbox_xb-2,calcbox_yb-2,pedbkxr);
                    _outmystr_center_col(4,F_text, calcbox_xt+2,calcbox_yt,calcbox_xb-2,calcbox_yb,bluechxr,pedbkxr);
                    refresh();
                    if (arped>dbfinum) { ptr_pedio[arped]->mathtype=new_mathtype;  }
                }
            }
            if (arped>dbfinum) ptr_pedio[arped]->fitype=proleft;
        }
        if (f==2) {_bareacls (listnaxt , listnayt , listnaxb, listnayb,pedbkxr);}
        setrgbcolor(recrgb); rectangle (ltxt+2,datyt[proleft]+2,ltxb-2,datyt[proleft]+22);
        if (datni[6]) {
        hoc=24;
        sprintf(str1024,"%d",hoc);
        _outsouv_col(orchaxt+1 , orchayt+1, str1024, 0 , bluechxr , pedbkxr);}
        refresh();
        continue;
        }
        
        else if (right) { // (rtxt+2,varyt[proright]+2,rtxb-2,varyt[proright]+22); refresh(); proright=-1;}
            
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            // if (proright==6) continue ; // Προς το παρόν προκαθορισμένο font
            if (varni[proright]){
                
                varni[proright]=0;
                if (arped>dbfinum) ptr_pedio[arped]->fivar[proright]=0;
                _puticon(rtxt+2,varyt[proright]+2,mem_yel,255);
                refresh();
                if (proright==3) {
                    for (f=0;f<4;f++){
                        _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
                        _outsouv_col(Xoxt+2,kentro1yt[f]+2,"0",0,bluechxr,nambkxr);
                        K1[f][0]=16;
                        K1[f][1]=255;
                        ke1[f]=0;
                    }
                     if (arped>dbfinum) ptr_pedio[arped]->filaxt = ptr_pedio[arped]->filayt = ptr_pedio[arped]->filawid = ptr_pedio[arped]->filahei=0;
                }
                setrgbcolor(recrgb); rectangle (rtxt+2,varyt[proright]+2,rtxb-2,varyt[proright]+22);
            }
            else {
                varni[proright]=1;
                if (arped>dbfinum) ptr_pedio[arped]->fivar[proright]=1;
                 _puticon(rtxt+3,varyt[proright]+4,mem_ni,255);
                refresh();
                if (proright==3) {
                    if (pedname[0]!=255) {
                        trampa=gouv;
                        gouv=myfont[ep_font];
                        f=0;
                        ke1[2]=0;
                        what=pedname[f];
                        while (what!=255) {
                            ke1[2]+=gouv[what].wid;
                            what=pedname[++f];
                        }
                        ke1[2]+=2;
                        el_wid=ke1[2];
                        el_hei=ke1[3]=myfont_hei[ep_font]+2;
                        gouv=trampa;
                        
                        _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                        sprintf (prox,"%d",el_wid);
                        normtext_tomy(prox,K1[2]);
                        _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
                        _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                        sprintf (prox,"%d",el_hei);
                        normtext_tomy(prox,K1[3]);
                        _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
                        
                        if (arped>dbfinum) {
                            ptr_pedio[arped]->filawid=ke1[2];
                            ptr_pedio[arped]->filahei=ke1[3];
                                }
                            }
                    }
                else if (proright==6) {
                    ep_font=1;
                    _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
                    normtext_tomy(myfont_name[ep_font],font_text);
                    for (f=0;f<3;f++) {chxr[f]=proxchxr[f] ; bkxr[f]=proxbkxr[f];}
                    _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
                    refresh();
                    if (arped>dbfinum) {
                        ptr_pedio[arped]->fifont=ep_font;
                        ptr_pedio[arped]->fifo_hei=myfont_hei[ep_font]; 
                        ptr_pedio[arped]->fifo_wid=myfont_wid[ep_font];
                    }
                     for (f=0;f<3;f++) chxr[f]=bluechxr[f];
                     
                    if ( pedname[0]!=255 ) {
                        trampa=gouv;
                        gouv=myfont[ep_font];
                        f=0;
                        ke1[2]=0;
                        what=pedname[f];
                        while (what!=255) {
                            ke1[2]+=gouv[what].wid;
                            what=pedname[++f];
                        }
                        ke1[2]+=2;
                        el_wid=ke1[2];
                        el_hei=ke1[3]=myfont_hei[ep_font]+2;
                        gouv=trampa;

                        _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                        _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                        sprintf (prox,"%d",el_wid);
                        normtext_tomy(prox,K1[2]);
                        _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
                        sprintf (prox,"%d",el_hei);
                        normtext_tomy(prox,K1[3]);
                        _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
                        if (arped>dbfinum) {
                            ptr_pedio[arped]->filawid=ke1[2];
                            ptr_pedio[arped]->filahei=ke1[3];
                        }
                    }
                }
            }
            refresh();
            continue;
        }
        
        else if (kentro) { //kentro=0; setrgbcolor(pedrgb); rectangle (Xxt+2,kentroyt[prokentro]+2,Xxb-2,kentroyt[prokentro]+22);
            
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            f=prokentro;
            setrgbcolor(pedrgb);rectangle(Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22); refresh ();
            for (i=0;i<3;i++) {chxr[i]=bluechxr[i];bkxr[i]=pedbkxr[i]; slxr[i]=selped[i];}
KOLPO1:
            user_ans=num_input(K[f], Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22, 4, 0);
            ke[f] = (int) convert_str(4 , K[f]);
            i=0;
            switch (f) {
                case 0:
                    if (ke[f]<=info.left || ke[f]>=info.right) i=1;
                    break;
                case 1 :
                    if (ke[f]<=info.top || ke[f]>=info.bottom) i=1;
                    break;
                case 2 :
                    dx=info.right-info.left ;
                    if (ke[f]>dx) i=1;
                    break ;
                case 3:
                    if ( (!datni[5]) && (ke[f]) ) {
                        if (ke[f]<ptr_pedio[new]->fifo_hei+2) ke[f] = ptr_pedio[new]->fifo_hei+2;
                        _bareacls(Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22,pedbkxr);
                        sprintf(prox,"%d",ke[f]); normtext_tomy(prox,K[f]);
                        _outsouv_col(Xxt+2,kentroyt[f]+2, prox, 0 , bluechxr , pedbkxr);
                        i=0;
                        break;
                    }
                    
                    dy=info.bottom-info.top;
                    if (ke[f]>dy) i=1;
            }
            
            if ((i) || (!ke[f]) ) {
                _bareacls(Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22,pedbkxr);
                _outsouv_col(Xxt+2,kentroyt[f]+2,"0",0,bluechxr,pedbkxr);
                K[f][0]=16; K[f][1]=255;ke[f]=0;
                    }
            
            if (arped>dbfinum) {
             switch (f) {
       
                 case 0 :
                     ptr_pedio[arped]->fixt=ke[f];
                     break;
                     
                 case 1 :
                     ptr_pedio[arped]->fiyt=ke[f];
                     break;
                     
                 case 2 :
                ptr_pedio[arped]->fiwid=ke[f];
                break;
                
                case 3 :
                ptr_pedio[arped]->fihei=ke[f];
                break;
                
                }
            }
                
            
            if (user_ans==-9) {f++; if (f>3) f=0; goto KOLPO1;}
            f=prokentro;
            setrgbcolor(recrgb);rectangle(Xxt+2,kentroyt[f]+2,Xxb-2,kentroyt[f]+22); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
            
            }
            
        else if(kentro1) { //kentro1=0; setrgbcolor(namrgb); rectangle (Xoxt+2,kentro1yt[prokentro1]+2,Xoxb-2,kentro1yt[prokentro1]+22);
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            if (!varni[3]) continue;
            f=prokentro1;
            setrgbcolor(namrgb);rectangle(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22); refresh ();
            for (i=0;i<3;i++) {chxr[i]=bluechxr[i];bkxr[i]=nambkxr[i]; slxr[i]=selped[i];}
KOLPO2:
            user_ans=num_input(K1[f], Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22, 4, 0);
            ke1[f] = (int) convert_str(4 , K1[f]);
            
            switch (f) {
                case 0:
                    if (ke1[f]<info.left || ke1[f]>info.right || (!ke1[f]) ) {
                        _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
                        _outsouv_col(Xoxt+2,kentro1yt[f]+2, "0", 0 , bluechxr , nambkxr);
                        ke1[f]=0; normtext_tomy("0",K1[f]);
                     }
                    break;
                case 1 :
                    if (ke1[f]<info.top || ke1[f]>info.bottom || (!ke1[f]) ) {
                        _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
                        _outsouv_col(Xoxt+2,kentro1yt[f]+2, "0", 0 , bluechxr , nambkxr);
                        normtext_tomy("0",K1[f]);
                        ke1[f]=0;
                    }
                    break;
                case 2 :
                    dx=info.right-info.left ;
                    if (ke1[f]>dx || ke1[f]<el_wid) {
                        _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
                        sprintf(prox,"%d",el_wid);
                        normtext_tomy(prox,K1[f]);
                        _outsouv_col(Xoxt+2,kentro1yt[f]+2, prox, 0 , bluechxr , nambkxr);
                        ke1[f]=el_wid; 
                    }
                    break ;
                case 3:
                    dy=info.bottom-info.top;
                    if (ke1[f]>dy || ke1[f]<el_hei){
                        _bareacls(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22,nambkxr);
                        sprintf(prox,"%d",el_hei);
                        normtext_tomy(prox,K1[f]);
                        _outsouv_col(Xoxt+2,kentro1yt[f]+2, prox, 0 , bluechxr , nambkxr);
                        ke1[f]=el_hei; 
                    }
            }
            
            if (arped>dbfinum) {
             switch (f) {
       
                 case 0 :
                     ptr_pedio[arped]->filaxt=ke1[f];
                     break;
                     
                 case 1 :
                     ptr_pedio[arped]->filayt=ke1[f];
                     break;
                     
                 case 2 :
                ptr_pedio[arped]->filawid=ke1[f];
                break;
                
                case 3 :
                ptr_pedio[arped]->filahei=ke1[f];
                break;
                
                }
            }
            if (user_ans==-9) {f++ ; if (f==4) f=0; goto KOLPO2;}
            f=prokentro1;
            setrgbcolor(recrgb);rectangle(Xoxt+2,kentro1yt[f]+2,Xoxb-2,kentro1yt[f]+22); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
        }
        
        
        else if (page_box) { //page_box=0;setrgbcolor(pedrgb); rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();
            
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            setrgbcolor(pedrgb);rectangle (Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();
            for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
            num_input(selida, Pxt+1  , Pyt+1 , Pxb, Pyb, 2, 0);
            selis = (int) convert_str(2 , selida);
            if ( selis>dbpg+1 ) {
                if (dbpg<99) selis=dbpg+1; else selis=99;
                sprintf (prox,"%d",selis);
                normtext_tomy(prox,selida);
                _bareacls(Pxt  , Pyt , Pxb, Pyb,pedbkxr);
                _outsouv_col(Pxt+1  , Pyt+1, prox, 0 , bluechxr , pedbkxr);
            }
            else if (!selis) {
                selis=1;
                sprintf (prox,"%d",selis);
                normtext_tomy(prox,selida);
                _bareacls(Pxt  , Pyt , Pxb, Pyb,pedbkxr);
                _outsouv_col(Pxt+1  , Pyt+1, prox, 0 , bluechxr , pedbkxr);
            }
            
            if (arped>dbfinum) ptr_pedio[arped]->fipg=selis;
            setrgbcolor(recrgb);rectangle(Xxt+2 , Pyt , Xoxb-2, Pyb); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
        }
        
        
        else if (onom_ped) { // (finaxt , finayt , finaxb, finayb);
            
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            setrgbcolor(pedrgb);rectangle (finaxt , finayt , finaxb, finayb); refresh ();
            for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
            text_input(pedname, finaxt+1  , finayt+1 , finaxb, finayb, 29);
            setrgbcolor(recrgb);rectangle(finaxt , finayt , finaxb, finayb); 
            if (pedname[0]!=255) {
            trampa=gouv;
            gouv=myfont[ep_font];
            f=0;
            ke1[2]=0;
            what=pedname[f];
            while (what!=255) {
                ke1[2]+=gouv[what].wid;
                what=pedname[++f];
            }
            ke1[2]+=2;
            el_wid=ke1[2];
            el_hei=ke1[3]=myfont_hei[ep_font]+2;
            gouv=trampa;
            
            _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
            _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
            sprintf (prox,"%d",el_wid);
            normtext_tomy(prox,K1[2]);
            _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
            sprintf (prox,"%d",el_hei);
            normtext_tomy(prox,K1[3]);
            _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
            
            }
            else {
                ke1[2]=ke1[3]=0;
                K1[2][0]= K1[3][0] = 16;
                K1[2][1] = K1[3][1] = 255;
                _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[2]+2, "0", 0 , bluechxr , nambkxr);
                _outsouv_col(Xoxt+2,kentro1yt[3]+2, "0", 0 , bluechxr , nambkxr);
            }
            
            if (arped>dbfinum) {
                mystrcpy(ptr_pedio[arped]->finame,pedname);
                ptr_pedio[arped]->filawid=ke1[2];
                ptr_pedio[arped]->filahei=ke1[3];
                }
            refresh();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
            
        }
        
        else if (orioxar){ // (orchaxt , orchayt , orchaxb, orchayb); refresh ();}
            if (adyn) {information (42-keyb_gr,0,0); continue;}
             for (f=0;f<7;f++) {if (datni[f]) break;else continue;}
            if (f==7) continue;
            if (f==5 || f==6) continue;
            setrgbcolor(pedrgb);rectangle(orchaxt , orchayt , orchaxb, orchayb); refresh ();
            for (i=0;i<3;i++) {chxr[i]=bluechxr[i];bkxr[i]=pedbkxr[i]; slxr[i]=selped[i];}
            num_input(orio_char, orchaxt+1 , orchayt+1 , orchaxb, orchayb, 5, 0);
            hoc = (int) convert_str(5 , orio_char);
            if (hoc<hocl[f] || hoc>hocm[f]) {
            if (hoc<hocl[f]) hoc=hocl[f]; else hoc=hocm[f];
            //if ( (dbplgr) && (arped<=dbfinum) ) {
            //    if (hoc>xlimk[arped]-2) {hoc= (xlimk[arped]-1) ? xlimk[arped]-1 : 1 ;}
            //}
            _bareacls(orchaxt , orchayt , orchaxb, orchayb,pedbkxr);
            sprintf(str1024,"%u",hoc);
            _outsouv_col(orchaxt+1 , orchayt+1, str1024, 0 , bluechxr , pedbkxr);
            normtext_tomy(str1024,orio_char);
            }
            ///if ( (dbplgr)  && (arped<=dbfinum) ) information(46-keyb_gr,0,0);
            if (arped>dbfinum) ptr_pedio[arped]->fiorio=hoc;
            setrgbcolor(recrgb);rectangle(orchaxt , orchayt , orchaxb, orchayb); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
        }
        
        else if (keylock) { // (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();}
            
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            setrgbcolor(pedrgb);rectangle (keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();
            for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
            num_input(kvdikos, keyloxt+1  , keyloyt+1 , keyloxb, keyloyb, 4, 0);
            hkvd = (int) convert_str(4 , kvdikos);
            if (!hkvd) {_bareacls (keyloxt , keyloyt , keyloxb, keyloyb, pedbkxr); kvdikos[0]=255;}
            if (arped>dbfinum) ptr_pedio[arped]->ficode=hkvd;
            
            setrgbcolor(recrgb);rectangle(keyloxt  , keyloyt , keyloxb, keyloyb); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
        }
        
        else if (onom_list) { // (listnaxt , listnayt , listnaxb, listnayb); refresh ();}
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            if (!datni[2]) continue ;
            
        // Επιλογή Λίστας από ήδη φορτωμένες !
        if (mmed[21]) {
            if (keyb_gr) information (0,"Η επιθυμητή λίστα πρέπει να είναι φορτωμένη !",0); else information (0,"The specific list have to be previously loaded!",0);
            continue;
            }
        
        open_buts.butt_elem = button_show ( open_buts.mem_butt , open_buts.butt_data , open_buts.butt_ar , open_buts.butt_orio , open_buts.butt_name , &open_buts.butt_sorton , 0 );

        if(open_buts.butt_elem<0) continue ;                        // (kati<0) return - button_show
        setrgbcolor(pedrgb);rectangle (listnaxt , listnayt , listnaxb, listnayb); refresh ();
        for (f=0;f<3;f++) {chxr[f]=bluechxr[f]; bkxr[f]=pedbkxr[f]; slxr[f]=selped[f];}
        f=0;
        what=open_buts.butt_data[f];
        if (what !=255) {                       // Αντιγραφή ονόματος λίστας

            do {
            nameoflist[f++]=what;
            what=open_buts.butt_data[f];
            } while (what!=255);
            nameoflist[f]=255;
            if (arped>dbfinum) mystrcpy(ptr_pedio[arped]->filistname , nameoflist);
            _bareacls (listnaxt , listnayt , listnaxb, listnayb,pedbkxr);
            _outfanis_center_col (0, nameoflist, listnaxt+1 , listnayt+1 , listnaxb);
        }
        else  // Δεν επέλεξα τίποτε τελικά... 
        {
            _bareacls(listnaxt , listnayt , listnaxb, listnayb,pedbkxr);
            nameoflist[0]=255;
            if (arped>dbfinum) ptr_pedio[arped]->filistname[0]=255;
        }
       
            setrgbcolor(recrgb);rectangle(listnaxt , listnayt , listnaxb, listnayb); refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            continue;
            
        }
        
        
        else if (fonter) { // (fontxt , fontyt , fontxb, fontyb); refresh ();}   
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            if (varni[6]) continue ;
            dx=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, proxchxr,proxbkxr,proxslxr );    
            if (dx<0) continue;
            ep_font=(short int) dx ;
            _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
            normtext_tomy(myfont_name[ep_font],font_text);
            for (f=0;f<3;f++) {chxr[f]=proxchxr[f] ; bkxr[f]=proxbkxr[f];}
            _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
            refresh();
            if (arped>dbfinum) {
                ptr_pedio[arped]->fifont=ep_font;
                ptr_pedio[arped]->fifo_hei=myfont_hei[ep_font]; 
                ptr_pedio[arped]->fifo_wid=myfont_wid[ep_font];
            }
                for (f=0;f<3;f++) chxr[f]=bluechxr[f];
                if (pedname[0]!=255) {
                    trampa=gouv;
                    gouv=myfont[ep_font];
                    f=0;
                    ke1[2]=0;
                    what=pedname[f];
                    while (what!=255) {
                        ke1[2]+=gouv[what].wid;
                        what=pedname[++f];
                    }
                    ke1[2]+=2;
                    el_wid=ke1[2];
                    el_hei=ke1[3]=myfont_hei[ep_font]+2;
                    gouv=trampa;

                    _bareacls(Xoxt+2,kentro1yt[2]+2,Xoxb-2,kentro1yt[2]+22,nambkxr);
                    _bareacls(Xoxt+2,kentro1yt[3]+2,Xoxb-2,kentro1yt[3]+22,nambkxr);
                    sprintf (prox,"%d",el_wid);
                    normtext_tomy(prox,K1[2]);
                    _outsouv_col(Xoxt+2,kentro1yt[2]+2, prox, 0 , bluechxr , nambkxr);
                    sprintf (prox,"%d",el_hei);
                    normtext_tomy(prox,K1[3]);
                    _outsouv_col(Xoxt+2,kentro1yt[3]+2, prox, 0 , bluechxr , nambkxr);
                    if (arped>dbfinum) {
                        ptr_pedio[arped]->filawid=ke1[2];
                        ptr_pedio[arped]->filahei=ke1[3];
                    }
                }
        
             setrgbcolor(recrgb);rectangle (fontxt , fontyt , fontxb, fontyb);  refresh ();
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
        continue;
        }
        
        else if (inklizer) {
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            inkualizer(ep_font,proxchxr,proxbkxr,proxslxr);
            _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
            for (f=0;f<3;f++) {
                chxr[f]=proxchxr[f] ; 
                bkxr[f]=proxbkxr[f];
                if (arped>dbfinum) {
                    ptr_pedio[arped]->fichxr[f]=proxchxr[f];
                    ptr_pedio[arped]->fibkxr[f]=proxbkxr[f];
                    ptr_pedio[arped]->fislxr[f]=proxslxr[f];
                }
            }
            _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
            for (f=0;f<3;f++) chxr[f]=bluechxr[f];
            refresh();
            continue ;
        }
        
        else if (rdyinks) {
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            readyinks(proxchxr,proxbkxr,proxslxr);
            _bareacls (fontxt-2,fontyt-2,fontxb+2,fontyb+1,proxbkxr);
            for (f=0;f<3;f++) {
                chxr[f]=proxchxr[f] ; 
                bkxr[f]=proxbkxr[f];
                if (arped>dbfinum) {
                    ptr_pedio[arped]->fichxr[f]=proxchxr[f];
                    ptr_pedio[arped]->fibkxr[f]=proxbkxr[f];
                    ptr_pedio[arped]->fislxr[f]=proxslxr[f];
                }
            }
            _outmystr_center_col(ep_font,font_text, fontxt, fontyt-2, fontxb,fontyb+2,proxchxr,proxbkxr);
            for (f=0;f<3;f++) chxr[f]=bluechxr[f];
            refresh();
            continue;
        } 
        
        else if (delfi) {
            if (adyn) {information (42-keyb_gr,0,0); continue;}
            
            if (arped==dbfinum+1) continue;
            
            if ( (dbplgr) && (!dbfinum) ) {
                
            if (keyb_gr) strcpy (str1kb,"Το πεδίο θα διαγραφεί μόνιμα..\n..σε όλες τις καρτέλες της βάσης!\nΘέλετε σίγουρα να διαγραφεί ;");
            else strcpy (str1kb,"The field will be permanently erased..\n..for all the DB Cards!\nAre you sure that you want to delete it ?");
            user_ans=alert(0,str1kb,0);
            if (user_ans!=1) continue;
            
                dbplgr=0 ; 
                if (alg_str[0]) {free (alg_str[0]); alg_str[0]=0;} 
                if (fpdom!=NULL) fclose(fpdom); 
                if (fpcard!=NULL) fclose(fpcard);
                
                sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); // Αρχείο Καρτελλών
                fpcard=fopen(str1024,"wb");
                if (fpcard==NULL) {information(6-keyb_gr,str1024,0); wasopca=0; continue ;}
                fide_fpcard = fileno (fpcard) ;
                fwrite (&dbplgr,2,1,fpcard);
                fsync(fide_fpcard);
                fclose(fpcard); fpcard=NULL; wasopca=0 ;

                sprintf(str1024,"%s%s",savedbpath,"Doms1.aba"); // Αρχείο Δεικτών σειράς Ταξινόμησης
                fpdom=fopen(str1024,"wb");
                if (fpdom==NULL) {information(6-keyb_gr,str1024,0); wasopdo=0 ; continue ;}
                fide_fpdom = fileno (fpdom) ;
                fwrite (&dbplgr,2,1,fpdom);
                fsync(fide_fpdom);
                fclose(fpdom); fpdom=NULL; wasopdo=0 ;                  

                dbkey=100; dbfinum=-1;
                
                dx=fseek(fpdb,58,0);
                fwrite (&dbfinum,2,1,fpdb);
                fdatasync (fide_fpdb);
                if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);}  
                
                dx=fseek(fpdb,62,0);
                fwrite (&dbplgr,2,1,fpdb);  
                fdatasync (fide_fpdb) ;
                if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);}
                
                // PROSOXH εάν είχε ετικέτες θα έπρεπε να γίνει έλεγχος για τις σελίδες !!
                dbpg=1 ;
                dx=fseek(fpdb,64,0);
                fwrite (&dbpg,2,1,fpdb);  
                fdatasync (fide_fpdb) ;
                if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);}
                
                dx=fseek(fpdb,102,0);
                fwrite (&dbkey,2,1,fpdb);
                fdatasync (fide_fpdb);
                if ( (dx) || (ferror(fpdb)) ) {information (6-keyb_gr,LDdbfile,0);}
                
                i=fclose (fpdb) ; 
                if (i) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind (fpdb); fclose (fpdb);} 
                fpdb = NULL ; wasopdb=0;
                xmemk=0; xlim=0;
                
                fyge=6;
                continue ;
            }
            
            if ( (dbplgr) && ( (dbkey==arped) || (_prodbkey==arped) ) ) {
                if (keyb_gr) strcpy (str1kb,"Το πεδίο αυτό ήταν/είναι κλειδί ταξινόμησης!\nΤαξινομείστε τη βάση πάνω σε άλλο πεδίο..\n..και επανέλθετε για τη διαγραφή!");
                else strcpy (str1kb,"This data field was/is the sorting key!\nResort the DB on a differentand field..\n ..and then delete this one!");
                information (0,str1kb,0);
                continue ;
            }
            
            if (keyb_gr) strcpy (str1kb,"Το πεδίο θα διαγραφεί μόνιμα..\n..σε όλες τις καρτέλες της βάσης!");
            else strcpy (str1kb,"The field will be permanently erased..\n..for all the DB Cards!");
            
            if (!dbplgr) user_ans=alert(26-keyb_gr,0,0);
            else user_ans=alert(26-keyb_gr,str1kb,0);
            
            delped=0;
            
            if (user_ans==1) {
                nem=0;
                dxm=0; dy=0; a=0 ;
                for (f=0 ; f<=dbfinum ; f++) {
                    if (arped==f) {
                        if (ptr_pedio[arped]->mathtype) {
                            a=1 ; dy=dxm; dxm++;
                            continue ;
                        }
                        continue ;
                    }
                    if (ptr_pedio[f]->mathtype) dxm++;
                }
                
                if (alg_str[arped]) {free (alg_str[arped]) ; alg_str[arped]=0 ;}
                
                if (!dxm || (dxm==1 && a==1) ) {dxm=0; goto AFTERNOMATH ;}
                
                if (dxm) { // Υπάρχουν mathtype και ίσως επηρεάζονται από την επικείμενη διαγραφή
                    
                    zero_pediaola_math(arped);
                    meion_pediaola_math(arped);
                                  
                }
                
                if ( a ) { //Τροποίηση θέσεων και εγγραφή των alg_str στο δίσκο
                    dx = fseek(fpdb , math_alma+dy*1024 , 0);
                    if (dx) {information(6-keyb_gr,LDdbfile,0); continue;}
                    for (f=arped+1 ; f<=dbfinum ; f++) {
                        if (ptr_pedio[f]->mathtype) {
                            fwrite (alg_str[f] , 1 , 1024 , fpdb);
                            fdatasync (fide_fpdb);
                        }
                    }
                 }
                else {  // Εγγραφή των alg_str στο δίσκο στις ίδιες θέσεις..
                    dx = fseek(fpdb , math_alma , 0);
                    if (dx) {information(6-keyb_gr,LDdbfile,0); continue;}
                    for (f=0 ; f<=dbfinum ; f++) {
                        if (f==arped) continue ;
                        if (ptr_pedio[f]->mathtype) {
                            fwrite (alg_str[f] , 1 , 1024 , fpdb);
                            fdatasync (fide_fpdb);
                        }
                    }
                }
                
                for (f=arped ; f<dbfinum ; f++) {
                    alg_str[f]=alg_str[f+1];
                }
                alg_str[dbfinum]=0;
                
                // Για το αν θα απαιτηθούν επανυπολογισμοί ή όχι
                if ( dxm && ( ptr_pedio[arped]->fitype==3 || ptr_pedio[arped]->fitype==4 ) ) dxm=1;
                else dxm=0;

AFTERNOMATH :
                if (dbplgr && !dxm) {
                    cardwhen1=cardwhen ;
                    sprintf(str1024,"%s%s",savedbpath,"NEW_Data1.aba"); // Νέο Αρχείο Καρτελλών
                    fp1card=fopen(str1024,"wb");
                    if (fp1card==NULL) {
                        information(6-keyb_gr,str1024,0); 
                        continue ;
                    }
                    
                    fide_fp1= fileno (fp1card) ;
                    rewind(fpcard) ;
                    
                    if (keyb_gr) strcpy (str1kb,"Αναδιάταξη Βάσης Δεδομένων..");
                    else strcpy (str1kb,"Data Base Reordering..");
                    user_ans = proodos(  str1kb, 0, dbplgr+dbplera,0) ;
                    
                    dx=dy=0;
                    for (i=0 ; i<(dbplgr+dbplera); i++) {
                        if (user_ans) { proodos(  0, i, dbplgr+dbplera,0) ;}
                        for (f=0; f<=dbfinum; f++) {
                            fread(memk[f],1,xlimk[f],fpcard);
                            if (arped==f) {
                                if ( ferror(fpcard) ) { dx = 1 ; break ;}
                                continue ;}
                            fwrite(memk[f],1,xlimk[f],fp1card);
                            if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                            dy=fdatasync (fide_fp1);
                            if (dy) break ;
                        }
                        
                        if ( (dx) || (dy) ) {
                            dx=1;
                            break ;
                        }
                        
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        fwrite (&cardwhen,sizeof(time_t),1,fp1card);
                        dy=fdatasync (fide_fp1);
                        if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                        if (dy) break ;
                    }
                    
                    if (dx || dy) {
                        proodos(  0, i, dbplgr+dbplera,1) ;
                        information (6-keyb_gr,"Please Close the DB and ..","..CHECK your disk!");
                        rewind (fpcard); rewind(fp1card);fclose(fp1card);
                        goto DELFI_SPASE ;
                    }
                    
                    fsync (fide_fp1);
                    fclose(fp1card);
                    fclose(fpcard);
                    wasopca=0 ;
                    fpcard=NULL;
                    
                    dx=remove (Strcardfp) ;
                    
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s removal!" ,  Strcardfp) ;
                        information(0,str1kb,"Abort");
                                                
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please Quit - Check the disk !!");}
                        else { fide_fpcard = fileno (fpcard);  wasopca=1; }
                        goto DELFI_SPASE ;
                    }
                    
                    delped=1;
                    dx=rename (str1024 , Strcardfp);
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s renaming!" ,  str1024) ;
                        sprintf (str1024,"Try to rename it as %s", Strcardfp);
                        information(0,str1kb,str1024);
                    }
                    
                }
            else if (dbplgr && dxm) {
                a = _prodbkey ; 
                if ( (arped < _prodbkey) && ( _prodbkey!=100 ) ) {
                    a = _prodbkey-1;
                }

                    dx=check_pediaola_rem_math(arped);
                    if (dx<0) {information (2-keyb_gr,0,0); continue;}
                    dpro = proter_calc_pedivn();
                    metataj=0;
                    if (dpro>0 && a!=100) {
                        for (f=0 ; f<enmath_1; f++) {
                            if (a==prot_calc[f]) { metataj=1; break; }
                        }
                    }
                    
                    nem=0; a=0 ;
                    for (f=0 ; f<=dbfinum ; f++) {
                        Nemk[nem]=0;
                        if (arped==f) continue;
                        if (ptr_pedio[f]->fitype==3 || ptr_pedio[f]->fitype==4) {
                            mem5=malloc(xlimk[f]);
                            if (!mem5) {information(2-keyb_gr,str1024,0); a=1; break ; }
                            Nemk[nem]=mem5; nem++;
                        }
                        else {nem++;}
                    }
                    
                    if (a) { 
                        for (f=0 ; f<nem ; f++) {
                        if (Nemk[f]) { mem5=Nemk[f]; free(mem5); Nemk[f]=0; }
                    }}
                    
                    
                    cardwhen1=cardwhen ;
                    sprintf(str1024,"%s%s",savedbpath,"NEW_Data1.aba"); // Νέο Αρχείο Καρτελλών
                    fp1card=fopen(str1024,"wb");
                    if (fp1card==NULL) {
                        information(6-keyb_gr,str1024,0); 
                        for (f=0 ; f<nem ; f++) {
                        if (Nemk[f]) { mem5=Nemk[f]; free(mem5); Nemk[f]=0; }
                        }
                        continue ;
                    }
                    
                    fide_fp1= fileno (fp1card) ;
                    rewind(fpcard) ;
                    
                    if (keyb_gr) strcpy (str1kb,"Αναδιάταξη Βάσης Δεδομένων-Επανυπολογισμοί..");
                    else strcpy (str1kb,"Data Base Reordering-Recalculations..");
                    user_ans = proodos(  str1kb, 0, dbplgr+dbplera,0) ;
                    
                    dx=dy=0;
                    for (i=0 ; i<(dbplgr+dbplera); i++) {
                        if (user_ans) { proodos(  0, i, dbplgr+dbplera,0) ;}
                        a=0;
                        for (f=0; f<=dbfinum; f++) {
                            
                            if (f==arped) {
                                dx = fseek(fpcard, xlimk[f], SEEK_CUR);
                                if (dx) break;
                               continue ;
                            }
                            
                            if (ptr_pedio[f]->fitype!=3 && ptr_pedio[f]->fitype!=4) {
                            fread(memk[f],1,xlimk[f],fpcard); a++;
                            }
                            else { fread(Nemk[a],1,xlimk[f],fpcard); a++;}
                               
                            if ( ferror(fpcard) ) { dx = 1 ; break ;}
                        }
                        
                         if ( dx ) { break ; }
                        
                        if (dpro>0) {
                            for (g=0 ; g<enmath_1; g++) {
                                a=prot_calc[g];
                                dfx = anal_parast_rem (a, alg_str[a] , &alg_err , arped);
                                check_orio_write_math_rem(a, 1, arped);
                            }
                        }
                        
                        a=0;
                        for (f=0; f<=dbfinum; f++) {
                            
                            if (f==arped) {
                               continue ;
                            }
                            
                            if (ptr_pedio[f]->fitype!=3 && ptr_pedio[f]->fitype!=4) {
                            fwrite(memk[f],1,xlimk[f],fp1card); a++;
                            }
                            else { fwrite(Nemk[a],1,xlimk[f],fp1card); a++;}
                               
                            if ( ferror(fp1card) ) { dx = 1 ; break ;}
                            dy=fdatasync (fide_fp1);
                            if (dy) break ;
                        }
                                
                        
                        if ( (dx) || (dy) ) {
                            dx=1;
                            break ;
                        }
                        
                        fread (&cardwhen,sizeof(time_t),1,fpcard);
                        fwrite (&cardwhen,sizeof(time_t),1,fp1card);
                        dy=fdatasync (fide_fp1);
                        if ( (ferror(fp1card)) || (ferror(fpcard)) ) { dx = 1 ; break ;}
                        if (dy) break ;
                    }

                    
                    if (dx || dy) {
                        proodos(  0, i, dbplgr+dbplera,1) ;
                        information (6-keyb_gr,"Please Close the DB and ..","..CHECK your disk!");
                        rewind (fpcard); rewind(fp1card);fclose(fp1card);
                        goto DELFI_SPASE ;
                    }
                    
                    for (f=0 ; f<nem ; f++) {
                    if (Nemk[f]) { mem5=Nemk[f]; free(mem5); Nemk[f]=0; }}
                        
                    fsync (fide_fp1);
                    fclose(fp1card);
                    fclose(fpcard);
                    wasopca=0 ;
                    fpcard=NULL;
                    
                    dx=remove (Strcardfp) ;
                    
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s removal!" ,  Strcardfp) ;
                        information(0,str1kb,"Abort");
                                                
                        fpcard=fopen(Strcardfp,"r+b");
                        if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please Quit - Check the disk !!");}
                        else { fide_fpcard = fileno (fpcard);  wasopca=1; }
                        goto DELFI_SPASE ;
                    }
                    
                    delped=1;
                    dx=rename (str1024 , Strcardfp);
                    if (dx) {
                        sprintf (str1kb , "Problem with file %s renaming!" ,  str1024) ;
                        sprintf (str1024,"Try to rename it as %s", Strcardfp);
                        information(0,str1kb,str1024);
                    }
            }
                
            if ( (dbkey!=_prodbkey) && (delped) ) {        
                
                dbkey=_prodbkey;
                if (keyb_gr) information (0,"Tροποποίηση κλειδιού ταξινόμησης..\n..δεν μπορεί να γίνει τώρα ! \nΠροσπαθήστε εκ νέου..",0);
                else information (0,"Sorting key modification..\n..is not feasible now ! \nTry again ..",0);
                
            }
                
                
                stoxos=1;
                for (f=0;f<=dbfinum;f++) {
                    if (arped==f) continue;
                    if (ptr_pedio[f]->fipg > stoxos) stoxos=ptr_pedio[f]->fipg;
                }

                if (stoxos<ptr_pedio[arped]->fipg) {
                    dbpg=stoxos;
                    dy=fseek(fpdb,64,0);
                    if (dy) {information(6-keyb_gr,LDdbfile,0); rewind(fpdb); 
                        if (dbplgr) goto DELFI_SPASE; else continue ;}
                    fwrite(&dbpg,2,1,fpdb); fdatasync (fide_fpdb);
                }
                if (dbcurpage>dbpg) dbcurpage=dbpg;
                
                if (arped<dbfinum) {

                    dx=(arped*dbfisize);
                    dx+=104;
                    dy=fseek(fpdb,dx,0);
                    if (dy) {information(6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind(fpdb); 
                        if (dbplgr) goto DELFI_SPASE; else continue ; } // αποτυχία !
                    for (f=arped+1; f<=dbfinum ; f++) {
                        ptr_pedio[f]->finum -= 1;
                        fwrite(ptr_pedio[f],1,dbfisize,fpdb);
                        if (ferror(fpdb)) {information (6-keyb_gr,LDdbfile,0);}
                        dy=fdatasync (fide_fpdb);
                        if (dy) {information (6-keyb_gr,LDdbfile,0);}
                    }
                }
                
                dbfinum--;
                
                dy=fseek(fpdb,58,0);
                
                if (dy) {
                    information(6-keyb_gr,LDdbfile,0);
                    rewind(fpdb); 
                    if (dbplgr) { dbfinum++; goto DELFI_SPASE; }
                    else continue ;}
                    
                fwrite (&dbfinum,2,1,fpdb);  
                dy=fdatasync (fide_fpdb);
                
                if ( (ferror(fpdb)) || (dy) ) {
                    dbfinum++;
                    information (6-keyb_gr,LDdbfile,0); 
                    clearerr(fpdb) ; rewind (fpdb);
                    if (dbplgr) goto DELFI_SPASE;
                    else continue ;}
                    
                dbfinum++;
                
                if (!dbplgr) {
                    if (arped==dbkey) {
                        dbkey=100;
                        dy=fseek(fpdb,102,0);
                        if (dy) {information(6-keyb_gr,LDdbfile,0);rewind(fpdb); continue ;}
                        fwrite (&dbkey,2,1,fpdb); 
                        dy=fdatasync (fide_fpdb);
                        if ( (ferror(fpdb)) || (dy) ) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind (fpdb);continue ; }
                    }
                }
                
                if ( (arped<dbkey) && (dbkey!=100) ) {
                    dbkey--;
                    dy=fseek(fpdb,102,0);
                    if (dy) {information(6-keyb_gr,LDdbfile,0);
                        rewind(fpdb);
                        if (dbplgr) goto DELFI_SPASE;
                        else continue ;
                    }
                    fwrite (&dbkey,2,1,fpdb); 
                    dy=fdatasync (fide_fpdb);
                    if ( (ferror(fpdb)) || (dy) ) {
                        information (6-keyb_gr,LDdbfile,0); 
                        rewind (fpdb);
                        if (dbplgr) goto DELFI_SPASE;
                        else continue ; }
                }
                
                    fsync (fide_fpdb) ; dy=fclose (fpdb) ; 
                    if (dy) {information (6-keyb_gr,LDdbfile,0); clearerr(fpdb) ; rewind (fpdb); fclose (fpdb);} 
                    fpdb = NULL ; wasopdb=0;
                
                if ( (xmemk) && (!dbplgr) ) {
                    f=arped ;
                    free (memk[arped]); memk[arped]=0;
                    free (memcp[arped]); memcp[arped]=0;
                    limk[f] = xlimk[f] = curk[f] = 0 ; curk1[f]=0;
                    for (f=arped ; f<dbfinum ; f++) {
                        memk[f]=memk[f+1]; memcp[f]=memcp[f+1]; 
                        memk[f+1]=0;  memcp[f+1]=0; 
                        limk[f]=limk[f+1];
                        xlimk[f] = xlimk[f+1];
                        curk[f] = curk[f+1]; curk1[f] = curk1[f+1];
                        }
                    if (!memk[0] || !memcp[0]) { xmemk=0; xlim=0; }
                    if (xmemk) {
                        sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                        fp=fopen(str1024,"r+b");
                        if (fp==NULL) {information (6-keyb_gr,str1024,0);} 
                        else 
                        { 
                        fide_lims = fileno (fp) ;
                        fwrite (xlimk , 2, dbfinum+1, fp);
                        if (ferror(fp))  {information (6-keyb_gr,str1024,0);} 
                        dy=fsync (fide_lims);
                        if (dy)  {information (6-keyb_gr,str1024,0);} 
                        fclose(fp); fp=NULL; }
                        if (dxm) {
                            dxm=0;
                            mem5=ptr_pedio[arped];
                            for (f=arped ; f<dbfinum ; f++) {
                                ptr_pedio[f]=ptr_pedio[f+1];
                            }
                            ptr_pedio[dbfinum]=mem5;
                            dbfinum--;
                            dx=check_pediaola_math();
                            if (dx<0) {information (2-keyb_gr,0,0);}
                            dpro = proter_calc_pedivn();

                            if (dpro>0) {
                                for (f=0 ; f<enmath_1; f++) {
                                    a=prot_calc[f];
                                    dfx = anal_parast (a, alg_str[a] , &alg_err , 0);
                                    check_orio_write_mathped(a, ptr_pedio[a]->fiorio, 1);
                                }
                            }
                            dbfinum++;
                        }
                    }
                    
                }
                
                if (delped && dbplgr) {
                    sprintf (str1024 , "%s%s",savedbpath,"limits.dat");
                    fp=fopen(str1024,"r+b");
                    if (fp==NULL) {information (6-keyb_gr,str1024,0);} 
                    else 
                    {
                    fide_lims = fileno (fp) ;
                    f=arped ;
                    limk[f] = xlimk[f] = curk[f] = 0 ; curk1[f]=0;
                    for (f=arped ; f<dbfinum ; f++) {
                        limk[f]=limk[f+1];
                        xlimk[f] = xlimk[f+1];
                        curk[f] = curk[f+1]; curk1[f] = curk1[f+1];
                        }
                    
                    fwrite (xlimk , 2, dbfinum+1, fp);
                    if (ferror(fp))  {information (6-keyb_gr,str1024,0);} 
                    dy=fsync (fide_lims);
                    if (dy)  {information (6-keyb_gr,str1024,0);}
                    fclose(fp); fp=NULL; }
                }
                if (delped) { fyge=5; dbcard_opt = (user_opts) ? dbcard : 0 ; }
                else fyge = 3 ;
                
                continue;
                
DELFI_SPASE :
            for (f=0 ; f<nem ; f++) {
            if (Nemk[f]) { mem5=Nemk[f]; free(mem5); Nemk[f]=0; }
            }
            cardwhen=cardwhen1 ;
            for (f=0;f<=dbfinum;f++) {
                keimk=memk[f];
                ceimk=memcp[f];
                i=0;
                if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                else {
                    if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                    else keimk[i]=255;
                }
            }
            
            continue ;
                
            }
            else continue ;
        }
        
        else if (akyro) {
            if (dbkey!=_prodbkey) dbkey=_prodbkey;
            fyge=2;
           if ( arped<=dbfinum ) {
            ptr0 = (char *) ptr_pedio[arped] ;
            for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
        }
            continue;
        }
        
       else if (profyge) {
        if (dbkey!=_prodbkey) dbkey=_prodbkey;
            fyge=2;
           if ( arped<=dbfinum ) {
            ptr0 = (char *) ptr_pedio[arped] ;
            for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
        }
            continue;
        }
        
        break ;
       
            } // End of Button Left
            
        case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (sdlev.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {

                if (dbkey!=_prodbkey) dbkey=_prodbkey;
                fyge=2;
                if ( arped<=dbfinum ) {
                    ptr0 = (char *) ptr_pedio[arped] ;
                    for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
                }
            }
            continue ;
        
        case SDL_WINDOWEVENT :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            refresh(); 
            continue; 
            
        case SDL_QUIT:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (dbkey!=_prodbkey) dbkey=_prodbkey;
            fyge=2;
           if ( arped<=dbfinum ) {
            ptr0 = (char *) ptr_pedio[arped] ;
            for (f=0;f<dbfisize;f++) {ptr0[f] = ptr_copy[f];}
        }
            continue;
        
        } // end of switch sdlev
    } while (!fyge);

       
FYGE :

if (mem_ok) free (mem_ok);
if (mem_ni) free (mem_ni);
if (mem_ri) free(mem_ri);
if (mem_le) free(mem_le);
if (mem_yel) free (mem_yel);
if (mem_arrs) free(mem_arrs);
if (mem_rinks) free(mem_rinks);
if(mem_inkual) free(mem_inkual);
if(mem_del) free(mem_del);
if (mem_go) free (mem_go);
if (mem_yk) free (mem_yk);
if (mem_nk) free (mem_nk);
if (mem_fyge) free (mem_fyge) ;
if ( (mem) && (!diat_mem) ) free (mem);
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
if (fyge!=1) fidicls(xt,yt,xb,yb,0,0,0);
if (mem0) { putimage(xt,yt,mem0,0); free(mem0);}//EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
refresh();
if (ptr_copy) { mem=ptr_copy; free(mem); } 
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return fyge ;
}

int mystrcpy (unsigned char *str1 , unsigned char * str2)
// Αποκλειστικά για δικά μου αλφαριθμητικά που τελειώνουν σε 255 - αντιγραφή από str2 sto str1  !!
{
    register int i;
    
    i=0;
    while (str2[i]!=255) {str1[i]=str2[i]; i++;}
    str1[i]=255;
    return i;
}


int field_coord(int new , int page, int lab )
// An to lab=1 ejetazei to xvro gia to onoma pedioy - an einai 0 ejetazei gia to pedio
// To new είναι ο αριθμός πεδίου - μπορεί να είναι νέος ή παλιός.
// Αν επιστρέψει 0 είχαμε αποτυχία - διαφορετικά έχει δώσει κανονικά συντεταγμένες - πλάτος - υψος!
{
void *_memx1=0 , *_memy1=0 , *_memx2 =0 , *_memy2=0 ;
int mw,mh , plaped , heiped, realpla , room ;
unsigned int ola;
unsigned short int xt,yt,xb,yb, a, su ,dw, dh , ar ,p ,per , dwel ;
unsigned short int *x1,*y1,*x2,*y2 ; 
register int f,i;

ola = 4*(dbfinum+1) + 2 ;
_memx1=malloc(ola) ;
_memy1=malloc(ola);
_memx2=malloc(ola);
_memy2=malloc(ola);
if ( (!_memx1) || (!_memy1) || (!_memx2) || (!_memy2) ) {information (2-keyb_gr,0,0); goto MPAMIA ;}
x1=_memx1; y1=_memy1 ; x2=_memx2 ; y2=_memy2;

i=0;

if (lab) {
    dwel = (ptr_pedio[new]->fitype) ? 6 : 14 ;
    x1[i]= (ptr_pedio[new]->fixt>=info.left+3) ? ptr_pedio[new]->fixt : info.left+3 ; 
    y1[i]= (ptr_pedio[new]->fiyt>=info.top+3) ? ptr_pedio[new]->fiyt : info.top+3 ;
    x2[i]=x1[i]+ptr_pedio[new]->fiwid+dwel ; 
    y2[i]=y1[i]+ptr_pedio[new]->fihei+7;
    i++; 
    }
else
    {
    if (ptr_pedio[new]->fivar[3]) {
        dwel=6 ;
        x1[i]= (ptr_pedio[new]->filaxt>=info.left+3) ? ptr_pedio[new]->filaxt : info.left+3 ;
        y1[i]= (ptr_pedio[new]->filayt>=info.top+3) ? ptr_pedio[new]->filayt : info.top+3 ;
        x2[i]=x1[i]+ptr_pedio[new]->filawid + dwel ; y2[i]=y1[i]+ptr_pedio[new]->filahei+7;
        i++;
        }
    }
    
    
for (f=0; f<=dbfinum ; f++) {
    if (f==new) continue;
    if (ptr_pedio[f]->fipg == page) {
    x1[i]=ptr_pedio[f]->fixt ; y1[i]=ptr_pedio[f]->fiyt;
    x2[i]=(ptr_pedio[f]->fitype) ? x1[i]+ptr_pedio[f]->fiwid+6 : x1[i]+ptr_pedio[f]->fiwid+14 ; 
    y2[i]=y1[i]+ptr_pedio[f]->fihei+7;
    i++; 
    if (ptr_pedio[f]->fivar[3]) {
        x1[i]=ptr_pedio[f]->filaxt ; y1[i]=ptr_pedio[f]->filayt;
        x2[i]=x1[i]+ptr_pedio[f]->filawid +6 ; y2[i]=y1[i]+ptr_pedio[f]->filahei+7;
        i++;
        }
    }
}


ar=i;
mw=info.right-info.left+1 ; mw-=30; // max width (mw)
mh=info.bottom-info.top+1 ; mh-=30 ; // max height (mh)
                        
if (!lab) {
    dwel = (ptr_pedio[new]->fitype) ? 6 : 14 ;
    xt=(ptr_pedio[new]->fixt>=info.left+3) ? ptr_pedio[new]->fixt : info.left+3; 
    yt=(ptr_pedio[new]->fiyt>=info.top+3) ? ptr_pedio[new]->fiyt : info.top+3;
    per = (3 * ptr_pedio[new]->fifo_wid) / 4 ; per ++ ;
    realpla = (ptr_pedio[new]->fitype != 5) ? ( (ptr_pedio[new]->fiorio * per) + 3) : ptr_pedio[new]->fiwid;

    if (ptr_pedio[new]->fiorio<5000) {
        p=ptr_pedio[new]->fiorio/1000; p++;dw=6;
        dh=(5000/500)+1;
    }  else {p=9 ; dw=10; dh=(ptr_pedio[new]->fiorio > 20000) ? 15 : 20 ; }
    //dw=14-p;  dh=p+2; // dw : διαιρέτης του mw , mh : πολλπλασιαστής του font hei


        if (!ptr_pedio[new]->fiwid)  // Δεν έχει δοθεί πλάτος
            {
            plaped= (realpla<mw) ? realpla : mw*p/dw ;
            while ( (xt+plaped+dwel>=info.right) && (xt>info.left+2) ) xt--;
            xb=xt+plaped+dwel;
            } 
        else {
            //plaped= (ptr_pedio[new]->fiwid>realpla) ? realpla : ptr_pedio[new]->fiwid;
            
            plaped = ptr_pedio[new]->fiwid;
            if (plaped < ptr_pedio[new]->fifo_wid+3) plaped = ptr_pedio[new]->fifo_wid+3;
            while ( ((xt+plaped+dwel)>=info.right) && (xt>info.left+2) ) xt--;
            while ( (xt+plaped+dwel) >=info.right ) plaped--;
            xb=xt+plaped+dwel;
            }
        
        if (!ptr_pedio[new]->fihei) { // Δεν έχει καθοριστεί ύψος
            
            heiped = (realpla<mw) ? ptr_pedio[new]->fifo_hei+2 : (dh*ptr_pedio[new]->fifo_hei)+2;
            while ( ((yt+heiped+7)>info.bottom-25) && (yt>info.top+2) ) yt--;
            yb=yt+heiped+7;
            }
            else
            {   // Έχει καθοριστεί ύψος..
                
                heiped=ptr_pedio[new]->fihei;
                if (heiped>mh) heiped=mh;
                if (ptr_pedio[new]->fitype!=5) {
                    /*
                    
                    f=heiped / ptr_pedio[new]->fifo_hei ;
                    i=heiped % ptr_pedio[new]->fifo_hei ;
                    if (f) {
                        i= (i>ptr_pedio[new]->fifo_hei/2) ? 1 : 0 ;
                        f+=i;
                        heiped= (f*ptr_pedio[new]->fifo_hei) ;
                        }
                    else {heiped= ptr_pedio[new]->fifo_hei;}
                    
                    i = (plaped-3) / ptr_pedio[new]->fifo_wid; i++;
                    room= i * (heiped / ptr_pedio[new]->fifo_hei);
                    
                    while ( (room>ptr_pedio[new]->fiorio) && (heiped>ptr_pedio[new]->fifo_hei) ) {
                    
                        heiped-=ptr_pedio[new]->fifo_hei;
                        room= i * (heiped / ptr_pedio[new]->fifo_hei);
                        }
                    heiped+=2;
                */
                    if (heiped<ptr_pedio[new]->fifo_hei+2) heiped=ptr_pedio[new]->fifo_hei+2;
                    }
                            
                while ( ((yt+heiped+7)>info.bottom-25) && (yt>info.top+2) ) yt--;
                yb=yt+heiped+7;
            }
}
else {
        dwel=6;
        xt=ptr_pedio[new]->filaxt ; yt = ptr_pedio[new]->filayt;
        if (xt<info.left+3) xt=info.left+3;
        if (yt<info.top+3) yt=info.top+3;
        if (ptr_pedio[new]->filawid>mw) ptr_pedio[new]->filawid=mw;
        if (ptr_pedio[new]->filahei>mh) ptr_pedio[new]->filahei=mh;  
        if (ptr_pedio[new]->filawid < ptr_pedio[new]->fifo_wid+3) ptr_pedio[new]->filawid = ptr_pedio[new]->fifo_wid+3;
        while ( (xt+ptr_pedio[new]->filawid+dwel >= info.right) && (xt>info.left+2) ) xt--;
        xb=xt+ptr_pedio[new]->filawid+dwel;
        while ( (yt+ptr_pedio[new]->filahei+7 >= info.bottom-25)  && (yt>info.top+2) ) yt--;
        yb=yt+ptr_pedio[new]->filahei+7;
        plaped=ptr_pedio[new]->filawid ; heiped = ptr_pedio[new]->filahei;
        }

su=0; a=0;

for (f=0 ; f<ar ; f++) { 

    if ( (xt>x2[f]) || (yt>y2[f]) || (xb<x1[f]) || (yb<y1[f]) ) continue ; else { a=1; break; }
}

if (!a) {
    su=1;
    if (lab) {
        ptr_pedio[new]->filaxt = xt;
        ptr_pedio[new]->filayt = yt;
        }
    else
        {
        ptr_pedio[new]->fixt = xt;
        ptr_pedio[new]->fiyt = yt;
        ptr_pedio[new]->fiwid = plaped;
        ptr_pedio[new]->fihei = heiped;
        }
        goto MPAMIA ;
    }

xt=info.left+3; yt=info.top+3;
xb=xt+plaped+dwel ; yb=yt+heiped+7;    
su=0;

do {
    a=0; 
    for (f=0 ; f<ar ; f++) {
            if ( (xt>x2[f]) || (yt>y2[f]) || (xb<x1[f]) || (yb<y1[f]) ) continue ; else { a=1; break;}
    }    

        if (a) { 
            xt++; xb++;
            if (xb<info.right) continue;
            else { 
                xt=info.left+3; xb=xt+plaped+dwel; 
                yt++ ; yb++; 
                continue;
                }
            }
            else {su=1; break ;} // ZHTO to brhkame}
        } while (yb<=info.bottom-25) ; 

if (su) {
    if (lab) {
        ptr_pedio[new]->filaxt = xt;
        ptr_pedio[new]->filayt = yt;
        }
    else
        {
        ptr_pedio[new]->fixt = xt;
        ptr_pedio[new]->fiyt = yt;
        ptr_pedio[new]->fiwid = plaped;
        ptr_pedio[new]->fihei = heiped;
        }
    }
else {
    if (keyb_gr) information (0,"Ανεπαρκής o χώρος στη σελίδα !\nΔοκιμάστε σε άλλη σελίδα ή ..","..περιορίστε το μέγεθος του στοιχείου !"); else 
        information(0,"No roomy this page!\nTry an other one or..","..make the element smaller !");
    }
    
MPAMIA :
if (_memx1) free (_memx1);
if (_memy1) free (_memy1);
if (_memx2) free (_memx2);
if (_memy2) free (_memy2);
return (int) su;
}


int dbpage_recs(int ergo)
{
register int i,f;

// ergo=0 σημαίνει τρέχει για πρώτη φορα στην αρχή !
// ergo=1 σημαίνει προστέθηκε ή τροποποιήθηκε πεδίο
// ergo=2 σημαίνει προστέθηκε ή τροποποιήθηκε ετικέτα

dbar=0;

if (!ergo) {
dbrecs = 4*(dbfinum+1); // Τα rectangles...
    if (dbrecs) {
        memx1=malloc(dbrecs) ;
        memy1=malloc(dbrecs);
        memx2=malloc(dbrecs);
        memy2=malloc(dbrecs);
        if ( (!memx1) || (!memy1) || (!memx2) || (!memy2) ) {information (2-keyb_gr,0,0);return 0;}
        }
        else return 0;
    }
else if (ergo==1 || ergo==2) {
    if (!dbrecs){
        dbrecs = 4*(dbfinum+1) ;
        memx1=malloc(dbrecs) ;
        memy1=malloc(dbrecs);
        memx2=malloc(dbrecs);
        memy2=malloc(dbrecs);
            }
    else {
        dbrecs = 4*(dbfinum+1) ;
        memx1=realloc(memx1,dbrecs);
        memy1=realloc(memy1,dbrecs);
        memx2=realloc(memx2,dbrecs);
        memy2=realloc(memy2,dbrecs);
        }
    if ( (!memx1) || (!memy1) || (!memx2) || (!memy2) ) {information (2-keyb_gr,0,0);return 0;}
    }
    dbx1=memx1 ;  dby1=memy1 ; dbx2=memx2 ; dby2=memy2 ;
    // Εξίσωση των dbx με τα memx σε κάθε realloc !!
    i=0; 
    for (f=0; f<=dbfinum ; f++) {
        
        if (ptr_pedio[f]->fipg == dbcurpage) {
            db_elem[i][0]=f; db_elem[i][1]=1;
            dbx1[i]=ptr_pedio[f]->fixt ; dby1[i]=ptr_pedio[f]->fiyt;
            dbx2[i]=dbx1[i]+ptr_pedio[f]->fiwid-1 ; dby2[i]=dby1[i]+ptr_pedio[f]->fihei-1;
            i++; 
            if (ptr_pedio[f]->fivar[3]) {
                    db_elem[i][0]=f; db_elem[i][1]=0;
                    dbx1[i]=ptr_pedio[f]->filaxt ; dby1[i]=ptr_pedio[f]->filayt;
                    dbx2[i]=dbx1[i]+ptr_pedio[f]->filawid-1 ; dby2[i]=dby1[i]+ptr_pedio[f]->filahei-1;
                    i++;
                    }
            }
    }


    dbar=i; // Ο αριθμός των recs στην current page που πρέπει να επανυπολογίζεται κατά περίπτωση με την παραπάνω διαδικασία !!
return dbar;
}

void _outmystr_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 , neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xri-gouv[what].wid+1) ) break;
    
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue ; 
        neg=255-co.rgb[0];
        red =  abs( (xxr[0]*co.rgb[0]/255) - (bbk[0]*neg/255) );
        green =  abs( (xxr[1]*co.rgb[0]/255) - (bbk[1]*neg/255) );
        blue =  abs( (xxr[2]*co.rgb[0]/255) - (bbk[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    } 
   gouv=trampa;
}    

void dbrecs_show ()
{
register int i,f ;
struct fansouv *whouv1;

if (!dcar) {
    setrgbcolor(dbscrxr);
    for (i=info.left;i<=info.right;i++) {for (f=info.top ; f<=info.bottom; f++) _putpixel (i,f);}   
    refresh();
}

for (f=0 ; f<dbar ; f++) {
    i=db_elem[f][0];

        _bareacls(dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1,ptr_pedio[i]->fibkxr);
        if (!db_elem[f][1]) { // Αν το element αφορά στο όνομα του πεδίου ..
            _outmystr_center_col(ptr_pedio[i]->fifont, ptr_pedio[i]->finame ,  dbx1[f]+1, dby1[f]+1,dbx2[f]-1, dby2[f]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
            if (ptr_pedio[i]->fivar[4])  { // Αν το όνομα πεδίου μπαίνει σε πλαίσιο !
                setrgbcolor(dbrecxr);
                rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                }
        }
        else // To element αφορά στα δεδομένα του πεδίου.
        {
            if (ptr_pedio[i]->fivar[0])  { // Αν τα δεδομένα πεδίου μπαίνουν σε πλαίσιο !
            setrgbcolor(dbrecxr);
            rectangle (dbx1[f],dby1[f],dbx2[f],dby2[f]);
                }
            if ( xmemk) { // Αν έχουν ενεργοποιηθεί σωστά οι μνήμες κατά πεδίο
                if (!ptr_pedio[i]->fivar[2]){
                    keimk=memk[i];
                    if (keimk[0]==255) continue ;
                    switch (ptr_pedio[i]->fitype){
                        case 0 :
                        
                             whouv1=gouv;
                            gouv=myfont[ptr_pedio[i]->fifont];
                                              
                           _field_txt_show (i,keimk , curk[i] , dbx1[f],dby1[f],dbx2[f],dby2[f], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                           //refresh(); 
                           gouv=whouv1;
                            // _outmystr_col(ptr_pedio[i]->fifont, keimk ,  dbx1[f]+1,dby1[f]+1,dbx2[f]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                        break;
                        
                        case 1:
                        case 2:
                             _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                             break ;
                        
                        case 3:
                        case 4:
                            mystrcpy (file_3, keimk) ;
                            mynum_teleies (file_3 , ptr_pedio[i]->fitype );
                             _outmystr_right_col(ptr_pedio[i]->fifont,file_3,dbx1[f],dby1[f],dbx2[f],dby2[f],ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                             //refresh();
                            break ;
                    
                        case 5:
                            fpch=fopen(keimk,"r");
                            if (fpch!=NULL) {
                                fclose (fpch) ;
                                readimagefile (keimk,dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1);
                            }
                            else _outmystr_center_col(2,missing,dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                            break ;
                            
                        case 6:
                            _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[f]+1,dby1[f]+1,dbx2[f]-1,dby2[f]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr); 
                      }
                    
                    }
                }
            }

    }
    refresh();
}

int change_dbpos(short int proel, int mx, int my, int *xl, int *yt ,int *xr , int *yb)
// Ελέγχει αν το rectangle βρίσκει με άλλα ... 
// Επιστρέφει 0 αν επιτρέπεται η αλλαγή θέσης και περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ,dx, dy , dwproel ,dwel  ;
short int c , shift , d , e , xm , ym ;
short int a;
const Uint8 *state ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dx=mx-prxl; 
dy=my-pryt; 
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}
//dwproel = (db_elem[proel][1]) ? 15 : 7 ;
if (!db_elem[proel][1]) dwproel=7;
else { dwproel = (ptr_pedio[db_elem[proel][0]]->fitype) ? 7 : 15 ; }
getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(dbgreen);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);
shift=0;
xm=dxa+dwproel ; ym=dya+25;

 do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEMOTION  &&  SDL_PollEvent(&sdlev) ); 
        mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
        if (mxl<0 || myt<0) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) { refresh(); continue ;}
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=-1;break;}
         if (sdlev.type==SDL_QUIT)  {a=-1;break;}
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
        
        //if ((!mxl) || (!myt) ) continue ;
        mxl -=dx; myt-=dy;
        if (mxl+dx<info.left || myt+dy<info.top || mxl>info.right || myt>info.bottom) continue ;
        e=d=0;

        
       if (mxl<info.left+2) { mxl=info.left+2; d=1; } 
       if (myt<info.top+2) { myt=info.top+2; e=1; } 
               
       if (shift) {
           if (!d) {
                c=mxl-3; c=c%8 ;
                if (c) mxl += (8-c) ;
                if (mxl+xm>info.right) {
                    mxl=info.right-xm;
                    c=mxl-3; c=c%8 ;
                    mxl -= c ;
                }
            }
            if (!e) {
                c = myt-3; c=c%8; 
                if (c) myt += (8-c );
                if (myt>info.bottom-ym) {
                    myt=info.bottom-ym;
                    c=myt-3; c=c%8 ;
                    myt -= c;
                }
            }
            shift=0;
        }
        else { 
            if (mxl+xm>info.right) mxl=info.right-xm;
            if (myt>info.bottom-ym) myt=info.bottom-ym;
        }
       
       if (mxl==prxl && myt==pryt) continue;
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
       
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);
        a=0; 
        for (f=0 ; f<dbar ; f++) {
            if (f==proel) continue;
            //dwel = (db_elem[f][1]) ? 15 : 7 ;
            if (!db_elem[f][1]) dwel=7;
            else { dwel = (ptr_pedio[db_elem[f][0]]->fitype) ? 7 : 15 ; }
            if ( (mxl>dbx2[f]+dwel) || (pryt>dby2[f]+8) || (sx+dwproel<dbx1[f]) || (sy+8<dby1[f]) ) continue ; else { a=2; break;}
            }    

        //c = (a) ? dbred : dbgreen ;
        
        if (!a) {
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       // setrgbcolor(c);
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=4-a) {for (f=mxl+1 ; f<sx; f+=4-a) _putpixel (f,i);}}
        else
        {
         setrgbcolor(dbred);   
         for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
         for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
         bar(mxl+1,myt+1,sx-1,sy-1);   
        }
        
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
    putimage (prxl,pryt,mem1,0); free(mem1);
    *xl=fxl ; *yt=fyt ;*xr=fxl+dxa ; *yb=fyt+dya;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int change_dbdim(short int proel, int xl, int yt ,int *mxright , int *mybottom)
// Επιστρέφει 0 αν εγκρίνει τη μεταβολή διαστάσεων !
// Επιστρέφει 2 αν δεν εγκρίνει ! Επιστρέφει 1 αν πατηθεί δεξί κλικ.
// Περνάει την τελευταία εγκεκριμένη θέση στα *mxright - *mybottom

{
SDL_Cursor* cursor;
int mxr , myb , prxr , pryb ,fxr, fyb;
void *mem1=NULL ;
register int i,f ;
unsigned short int a, dwproel ,dwel ;
const Uint8 *state ;
short int shift , b ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
SDL_SetCursor(cursor);
fxr=prxr=*mxright; fyb=pryb=*mybottom;
mem1=malloc( imagesize (xl,yt,info.right,info.bottom) );
if (!mem1) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);return -1;}
//dwproel = (db_elem[proel][1]) ? 15 : 7 ;
if (!db_elem[proel][1]) dwproel=7;
else { dwproel = (ptr_pedio[db_elem[proel][0]]->fitype) ? 7 : 15 ; }
getimage (xl,yt,prxr,pryb,mem1);
setrgbcolor(dbrecxr);
rectangle (xl,yt,prxr,pryb);
setrgbcolor(dbgreen);
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<prxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       if (sdlev.type==SDL_WINDOWEVENT) refresh();
       if (sdlev.type==SDL_QUIT)  {a=1;break;}
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=1;break;}
       mxr = sdlev.motion.x ; myb = sdlev.motion.y ;
       if (mxr<0 || myb<0 || mxr>info.right || myb>info.bottom) continue ;
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
       
       if (shift) { 
           b=mxr%8;
           mxr = (b>4) ? mxr+8-b : mxr-b ;
           b=myb%8;
           myb = (b>4) ? myb+8-b : myb-b ;
        }
       
       if (mxr<=xl || myb<=yt) continue;
       if (mxr+dwproel>info.right) mxr=info.right-dwproel ;
       if (myb>info.bottom-25) myb=info.bottom-25;
       if (mxr==prxr && myb==pryb) continue;
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxr); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myb); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
        putimage (xl,yt,mem1,0); 
        prxr=mxr ; pryb=myb;
        getimage (xl,yt,mxr,myb,mem1);
        
        a=0; 
        for (f=0 ; f<dbar ; f++) {
            if (f==proel) continue;
            //dwel = (db_elem[f][1]) ? 15 : 7 ;
            if (!db_elem[f][1]) dwel=7;
            else { dwel = (ptr_pedio[db_elem[f][0]]->fitype) ? 7 : 15 ; }
            if ( (xl>dbx2[f]+dwel) || (yt>dby2[f]+8) || (mxr+dwproel<dbx1[f]) || (myb+8<dby1[f]) ) continue ; else { a=2; break;}
            }
            
            if ( (mxr-xl+1)< (ptr_pedio[db_elem[proel][0]]->fifo_wid + 3) ) a=2;
            else if ( (myb-yt+1)< (ptr_pedio[db_elem[proel][0]]->fifo_hei + 2) ) a=2;
            
        if (!a) {
            setrgbcolor(dbrecxr);
            fxr=mxr; fyb=myb;
            for(f=xl;f<=mxr;f++) {_putpixel(f,yt); _putpixel(f,myb);}
            for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxr,i);}
            setrgbcolor(dbgreen);
            for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxr; f+=4) _putpixel (f,i);} 
            }
        else
            {
            setrgbcolor(dbred);  
            for(f=xl;f<=mxr;f++) {_putpixel(f,yt); _putpixel(f,myb);}
            for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxr,i);}
            bar(xl+1,yt+1,mxr-1,myb-1);
            }
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
     
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
     putimage (xl,yt,mem1,0); free(mem1);
    *mxright=fxr ; *mybottom=fyb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}

int _outmystr_center_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr)

// Επιστρέφει 0 αν δεν χωράει ΚΑΘΟΛΟΥ το κείμενο μέσα στο rectangle
// Επιστρέφει 1 αν το κείμενο δεν χώρεσε κατά μήκος αλλά γράφτηκε μέρος αυτού !
// Επιστρέφει 2 αν όλα πήγαν καλά !

{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, dy, neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;


a=xr-x+1;
if (a<myfont_wid[font]) return 0;
dy=yb-y+1;
if (dy<myfont_hei[font]) return 0;
dy=(dy-myfont_hei[font])/2 ;
f=0;
neg=0;
what=str[f];
if (what==255) return 0;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

if (neg>a) neg=a;
c=(a-neg)/2;
x+=c;
y+=dy;
dy=2;

    a=0;
    what=str[a];
    while (what<164 ) {
    if ( x> (xr-gouv[what].wid) +1 ) {dy=1;break;}
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
    green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
    blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
    return (int) dy;
}    


int mypolystr (unsigned char *mega , unsigned char *mikro)
// To πρώτο στρινγκ (mega) πρέπει να τελειώνει σε 255 , 254 !!
// Το δεύτερο στρινγκ πρέπει να τελειώνει σε 255.
// Επιστρέφει -1 αν το μεγάλο στρινγκ είναι κενό !
// Επιστρέφει -2 αν το μικρό στριγκ είναι κενό !
// Επιστρέφει -3 αν το μικρό στριγκ δεν βρέθηκε μέσα στο μεγάλο.
// Επιστρέφει 0 ή θετικό αριθμό ανάλογα με τη θέση του μικρού στριγκ μέσα στο μεγάλο !!
{

register int f,i ;
int b;
unsigned short int a , m , s ;

if ( mega[0]==255 ) return -1;
f=0;
while (mikro[f]!=255) f++;
if (!f) return -2;
m=f; // Μήκος μικρού στρινκγ (m)
f=i=s=0; b=-1;
    while (mega[f]!=254) {
        a=0;
        if (mega[f]!=mikro[i]) {
            while (mega[f]!=255) f++;
            b++;f++;continue;
        }
        a=1;i++;f++;
        while ( (mega[f]!=255) && (mikro[i]!=255) ) {
            if (mega[f]==mikro[i]) {
                f++;i++;a++;continue;
            }
            else{
                a=0;break;
            }
        }
        if ( (a==m) && (mega[f]==255) ) {b++;s=1;break;}
        else i=0;
    }
if (s) return b ; else return -3 ;
}


int change_mikrodbpos(short int proel, int dx, int dy, int *xl, int *yt ,int *xr , int *yb)
// Ελέγχει αν το rectangle βρίσκει με άλλα ... 
// Επιστρέφει 0 αν επιτρέπεται η αλλαγή θέσης και περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ ή αν δεν επιτρέπεται από τον χρήστη η αλλαγή.

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ,dwproel ,dwel ;
unsigned short int c ;
short int a;


cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}
//dwproel = (db_elem[proel][1]) ? 15 : 7 ;
if (!db_elem[proel][1]) dwproel=7;
else { dwproel = (ptr_pedio[db_elem[proel][0]]->fitype) ? 7 : 15 ; }
getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setfillstyle(8,4);


       mxl = prxl+dx ; myt = pryt+dy;  

       if (mxl<info.left+3) mxl=info.left+3;
       else if (mxl+dxa+dwproel>info.right) mxl=info.right-dxa-dwproel;
       if (myt<info.top+3) myt=info.top+3;
       else if (myt+dya>info.bottom-25) myt=info.bottom-dya-25 ;
       
       if (mxl==prxl && myt==pryt) {free (mem1) ; mem1=0; return -1; }
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
             
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);
        a=0; 
        for (f=0 ; f<dbar ; f++) {
            if (f==proel) continue;
            //dwel = (db_elem[f][1]) ? 15 : 7 ;
            if (!db_elem[f][1]) dwel=7;
            else { dwel = (ptr_pedio[db_elem[f][0]]->fitype) ? 7 : 15 ; }
            if ( (mxl>dbx2[f]+dwel) || (pryt>dby2[f]+8) || (sx+dwproel<dbx1[f]) || (sy+8<dby1[f]) ) continue ; else { a=2; break;}
            }    

          
        if (!a) {
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       // setrgbcolor(c);
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=2-a) {for (f=mxl+1 ; f<sx; f+=2-a) _putpixel (f,i);}}
        else
        {
         setrgbcolor(dbred);   
         for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
         for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
         bar(mxl+1,myt+1,sx-1,sy-1);   
        }
        
        refresh(); 
        for(f=1;f<200000;f++) continue ;
    
    putimage (prxl,pryt,mem1,0); free(mem1); mem1=0;
    *xl=fxl ; *yt=fyt ;*xr= fxl+dxa ; *yb= fyt+dya;
    //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    //SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}



int info_dbfds()
// Ενημερώνει τη δομή για το button με όλα τα ονόματα πεδίων.
{
register int i,f ;
void *mem;
unsigned short int s;
unsigned int m;
unsigned char what ;

mem=synolo_fds;
if (!mem) { mem=malloc(size_fds) ; synolo_fds=mem; }
if (!mem) {dbfds.mem_fd=0; return 0;}

m=0;s=0;
dbfds.fd_orio=0;

if (dbfinum>=0) {
    for (f=0;f<=dbfinum;f++) {
        
        if ( (m+31) > (size_fds-40) ) {
            size_fds+=256;
            mem=realloc(mem,size_fds);
            if (!mem) return 0;
            synolo_fds=mem;
        }
        
            for (i=0;i<31;i++) {
                what=ptr_pedio[f]->finame[i];
                synolo_fds[s] = what ;
                m++; s++;
                if (what==255) break;
            }
            if (dbfds.fd_orio<i) dbfds.fd_orio=i;
    }
}

if (s) {
    dbfds.fd_ar = s ;
    synolo_fds[s]=254;
}
else {
synolo_fds[0]=255;
synolo_fds[1]=254;
dbfds.fd_ar=0;
}
dbfds.mem_fd = (void*) synolo_fds;
dbfds.fd_data[0]=255;
//dbfds.fd_sorton=0;
return 1;
}


void pro_sort_signedlong (long int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_signedlong(item,point,0,count-1);
}

void qui_sort_signedlong (long int *item , unsigned short int *point , int left , int right)
{
    register int i , j ;
    long int x,y;
    unsigned short int y1;
    unsigned short int p1 ;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    p1 = point[(left+right)/2];
    
    do {
        
        //while (item[i]<x && i<right) i++;
        while (i<right) {
        if ( item[i]<x ) i++; 
        else if (item[i]==x && point[i]<p1) i++;
        else break ;
        }      
        
        //while (x<item[j] && j>left) j--;
        while (j>left) {
        if ( x<item[j] ) j--; 
        else if (x==item[j] && p1<point[j]) j--;
        else break ;
        }
        
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_signedlong(item,point,left,j);
    if (i<right) qui_sort_signedlong(item,point,i,right);
}

void pro_sort_double (double *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_double(item,point,0,count-1);
}

void qui_sort_double (double *item , unsigned short int *point , int left , int right)
{
    register int i , j ;
    double x,y;
    unsigned short int y1;
    unsigned short int p1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    p1=point[(left+right)/2];
    
    do {
        //while (item[i]<x && i<right) i++;
        while (i<right) {
        if ( item[i]<x ) i++; 
        else if (item[i]==x && point[i]<p1) i++;
        else break ;
        } 
        
        //while (x<item[j] && j>left) j--;
        while (j>left) {
        if ( x<item[j] ) j--; 
        else if (x==item[j] && p1<point[j]) j--;
        else break ;
        } 
        
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_double(item,point,left,j);
    if (i<right) qui_sort_double(item,point,i,right);
}

void pro_sort_uint (unsigned int *item,unsigned short int *point,int count)
{
    if (count<2) return;
    qui_sort_uint(item,point,0,count-1);
}


void qui_sort_uint (unsigned int *item , unsigned short int *point , int left , int right)
{
    register int i,j ;
    unsigned int x,y;
    unsigned int y1 ;
    unsigned short int p1;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    p1 = point[(left+right)/2];
    
    do {
    
        while (i<right) {
        if ( item[i]<x ) i++; 
        else if (item[i]==x && point[i]<p1) i++;
        else break ;
        } 
            
        //while (x<item[j] && j>left) j--;
        
    
        while (j>left) {
        if ( x<item[j] ) j--; 
        else if (x==item[j] && p1<point[j]) j--;
        else break ;
        } 
        
        if (i<=j) {
            y=item[i];
            y1=point[i];
            item[i]=item[j];
            point[i]=point[j];
            item[j]=y;
            point[j]=y1;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_uint(item,point,left,j);
    if (i<right) qui_sort_uint(item,point,i,right);
}

void pro_sort_usint (unsigned short int *item,int count)
{
    if (count<2) return;
    qui_sort_usint(item,0,count-1);
}


void qui_sort_usint (unsigned short int *item , int left , int right)
{
    register int i,j ;
    unsigned short int x,y;
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            item[i]=item[j];
            item[j]=y;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_usint(item,left,j);
    if (i<right) qui_sort_usint(item,i,right);
}


unsigned short int field_txt_scroll (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan; 
short int wrap , enbar ;
int diaf1, diaf2 ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue, neg ;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
rectangle (xl,yt,xr,yb);
_bareacls (xr+2,yt-1,xr+11,yb,dbbkxr);refresh();
xl++ ; yt++ ; xr-- ; yb--;
if (xr+13>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+2,yt-1,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (0); }
getimage (xr+2,yt-1,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; goto stokalo ; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
/*            
        if (wherp) {
        f=0;
        while (pos[wherp-f][0] != xl) f++;
        wherp-=f;
        diaf1=(pos[wherp][1]-yt);
        for (i=0;i<=ar;i++) pos[i][1]-=diaf1;}
        while (pos[cur][1]>=ektos) {
            f=wherp;
            while (pos[f][1]==yt) f++;
            wherp=f;
                for (i=0;i<=ar;i++) pos[i][1]-=bh;}
*/            
        x1=xl; y1=yt;
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
        x=pos[cur][0] ; y=pos[cur][1];
        
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+2,yt-1,xr+13,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
         if (mx<info.left || my<info.top) continue ;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;

        continue ;
        
        case SDL_MOUSEWHEEL :
            while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();

                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
    
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }
                my= sdlev.button.y ;
                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar-1][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
            }                                       // END bar !!
            continue ;                      // END Case buttondown
        }                                     // END Button Left
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
            refresh();

            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) continue;

            if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            refresh();
                            
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();

                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+2,yt-1,xr+13,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
        
        case SDL_QUIT :
            fyge=1 ; break ;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :

if (cur) {
    i=cur;
    while (pos[i][1]>yt) i--;
    if(i) {
        while (pos[i][0]>xl) i--;}

    cur=i;
}
if (bar==1) { putimage (xr+2,yt-1,mem_bar,0); refresh(); }
if (mem_bar) free (mem_bar);
if (ar) {
        xr++;
        
        if (pos[0][1]<yt) {
            
        setrgbcolor(dbmag);
        line(xr+6,yt-1,xr+6,yt+10);
        line(xr+7,yt-1,xr+7,yt+10);
        line(xr+2,yt+3,xr+6,yt-1);
        line(xr+2,yt+4,xr+6,yt);
        line(xr+2,yt+5,xr+6,yt+1);
        line(xr+11,yt+5,xr+7,yt+1);
        line(xr+11,yt+4,xr+7,yt);
        line(xr+11,yt+3,xr+7,yt-1);
        
        }
        //else {_bareacls (xr+2,yt-1,xr+11,yt+10,dbbkxr);}

                
        if (pos[ar-1][1]>=ektos) {
        setrgbcolor(dbmag);
        line(xr+6,yb-10,xr+6,yb);
        line(xr+7,yb-10,xr+7,yb);
        line(xr+2,yb-6,xr+6,yb-2);
        line(xr+2,yb-5,xr+6,yb-1);
        line(xr+2,yb-4,xr+6,yb);
        line(xr+11,yb-6,xr+7,yb-2);
        line(xr+11,yb-5,xr+7,yb-1);
        line(xr+11,yb-4,xr+7,yb);
        }
refresh();
}
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
return cur ;
}


/*

struct {
    unsigned short int fd_orio;
    unsigned int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
    short int fd_sort_type ;
    short int fd_arped ;
} dbfdata;
*/

int info_dbfdata(short int arped , unsigned short int *ar_dom)
// Ενημερώνει τη δομή dbfdata για το button που δείχνει όλα τα στοιχεία συγκεκριμένου πεδίου.
// Τα στοιχεία διαβάζονται από το δίσκο με τη σειρά που επιβάλλει η υφιστάμενη ταξινόμηση της βάσης δεδομένων !!! Για αυτό το λόγο διαβιβάζεται ο δείκτης της ar_dom !
// Όταν επιστρέφει 0 τότε κάτι δεν πήγε καλά , δηλαδή ακυρώθηκε και δεν επιτρέπεται να καλέσουμε την dbfield_show_button !!
{
register int i,f,a ;
unsigned int jump;
short int cur;
void *mem;
unsigned int s;
unsigned char deigma[48];
unsigned char what ;

if (ptr_pedio[arped]->fitype == 5) return 0;
if(dbfdata.mem_fd) free(dbfdata.mem_fd);
dbfdata.mem_fd=0;
size_fdata=2048;
mem=malloc(size_fdata) ; synolo_fdata=mem; 
if (!mem) return 0;

s=0;
cur =(ptr_pedio[arped]->fiorio > 45) ? 45 : ptr_pedio[arped]->fiorio;
mystrcpy(dbfdata.fd_name,ptr_pedio[arped]->finame);
dbfdata.fd_sort_type = ptr_pedio[arped]->fitype ;
dbfdata.fd_orio = 0; jump = 0 ;

for (f=0 ; f<=dbfinum ; f++) {
    
    if (arped==f) break;
    jump+=xlimk[f];
}

for (f=0;f<dbplgr;f++) {
    i=fseek(fpcard , ((ar_dom[f] * dbcardsize) + jump) , 0);
    if (i) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; return 0 ;}
    fread(deigma,1,cur,fpcard);
    deigma[cur]=255;
    a=0; i=s; 
    what=deigma[a];
     while (what!=255) {
        synolo_fdata[i]=what;
        i++; a++;
        what=deigma[a];
    }
    if (dbfdata.fd_orio < a) dbfdata.fd_orio = a;
    synolo_fdata[i]=255;
    s = i+1;  
    
     if ( s > (size_fdata-60) ) {
            size_fdata+=1024;
            mem=realloc(mem,size_fdata);
            if (!mem) return 0;
            synolo_fdata=mem;
        }
    
}
dbfdata.fd_data[0]=255;
if (s) {
    dbfdata.fd_ar = s ;
    synolo_fdata[s]=254;
    dbfdata.mem_fd= mem;
    dbfdata.fd_arped=arped;
}
else {
synolo_fdata[0]=255;
synolo_fdata[1]=254;
dbfdata.fd_ar=0;
dbfdata.mem_fd=0;
}

return 1;
}

int input_cardnum(unsigned char *inp_str)
// Επιστρέφει 1 εάν συμφωνήσει ο χρήστης !
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int neg , trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }
whouv=gouv;

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; 
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;
}
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0); goto FYGE;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0); goto FYGE;}

setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+200,y+10,"T y p e ..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+201,y+10,"T y p e ..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
refresh();
}
else {
outnoto_col(xp+165,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"Plhktrologei'ste..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
refresh();    
}
xr=xp+492;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! 
i=0;f=0;

if (keyb_gr) sprintf (str1024," Εισάγετε τον αριθμό Καρτέλας ..");
else sprintf (str1024," Enter the Data Card number ..");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, y4, xr,chrxr,cbkxr);

if (keyb_gr) sprintf (str1024,"...από 1 έως %u ." , dbplgr);
else sprintf (str1024,"...from 1 to %u ." , dbplgr);

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ymy, xr,chrxr,cbkxr);

yc=y4+80; xc=x4;
setcolor(5);
rectangle (xc+1,yc+3,xr-2,yc+24);
gouv=myfont[0];
refresh();
num_input(inp_str, xc+2, yc+4, xr-3, yc+23, 5 , 0);

    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh(); continue;}
            case SDL_KEYDOWN : continue;
            case SDL_MOUSEMOTION : break;
            case SDL_MOUSEBUTTONDOWN : break;
            case SDL_QUIT : break ;
            default : continue;}
        break ;
    }
            

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;trik=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if(sdlev.type==SDL_QUIT) {mx=x+170;my=y1+30;enter_go=1;break; }
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        trik=0;
        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if (trik) {
        if  (mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            qnum_input(inp_str, xc+2, yc+4, xr-3, yc+23, 5 , 0);
            while (1) {
                SDL_PollEvent(&sdlev); 
                switch (sdlev.type) {
                case SDL_WINDOWEVENT : {refresh(); continue;}
                case SDL_KEYDOWN : continue;
                case SDL_MOUSEMOTION : break;
                case SDL_MOUSEBUTTONDOWN : break ;
                case SDL_QUIT : break ;
                default : continue;} 
                trik=0;
                break ;
            }
            }}

        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
FYGE :
if(mem0) putimage(xp,y,mem0,0);
refresh();
if (mem0) free(mem0);
if(mem_menu) free(mem_menu);
if (mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
return((int)kyk);
}

int input_dbsearch_num(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str, short int type , short int arped)
// Επιστρέφει 1 εάν τελικά συμφωνήσει ο χρήστης !
// type=3 ακέραιος , type=4 δεκαδικός !
// Γεμίσει τα iso_str , meg_str , mik_str ... κατά περίπτωση για να διευκολυνθεί η περαιτέρω αναζήτηση αριθμού.
// Με βάση αυτά τα στρίγκς θα εξετασθεί είτε η ισότητα στοιχείου της βάσης δεδομένων με το εισαγόμενο συγκεκριμένο στοιχείο iso_str, είτε το αν βρίσκεται το στοιχείο (ας πούμε χ) της βάσης δεδομένων μέσα στο εύρος  meg_str>χ>mik_str 
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int x ,xp, y ,y1, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,xr;
unsigned short int ryt[3] , rxt , delxt ;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert , *mem_delete;
void *mem_efedr1;
int *mem_int1;
short int *mem_int , c ;
unsigned short int neg , trik ,del[3] ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char *str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;

whouv=gouv;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;}

x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Delete_18.ico");
mem_delete=icontomem (file_1,255);
if (!mem_delete) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

del[0]=del[1]=del[2]=0;
setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;
xr=xp+492;

if (!keyb_gr) {

outnoto_col(xp+220,y+10,"Search..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+221,y+10,"Search..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
_outmystr_center_col(1, ptr_pedio[arped]->finame ,  xp, y+40, xr,y+70, chrxr, cbkxr);
refresh();
}
else {
outnoto_col(xp+195,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+196,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
_outmystr_center_col(1, ptr_pedio[arped]->finame ,  xp, y+40, xr,y+70, chrxr, cbkxr);
refresh();    
}

x4=xp+2;
rxt=x4+160; 
ryt[0]=y+100;
ryt[1]=ryt[0]+25;
ryt[2]=ryt[1]+25;
delxt=xr-20;
i=0;f=0;

if (keyb_gr) sprintf (str1024," Ίσο (=)");
else sprintf (str1024," Equal (=)");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[0],xr-22,ryt[0]+20);
_puticon(delxt,ryt[0],mem_delete,255);

if (keyb_gr) sprintf (str1024," Μεγαλ. από (>)");
else sprintf (str1024," Bigger than (>)");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[1],xr-22,ryt[1]+20);
_puticon(delxt,ryt[1],mem_delete,255);

if (keyb_gr) sprintf (str1024," Μικρότ. από (<)");
else sprintf (str1024," Less than (<)");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[2],xr-22,ryt[2]+20);
_puticon(delxt,ryt[2],mem_delete,255);
gouv=myfont[0];
refresh();

switch (type) {
    
    case 3 : // Ακέραιος
        
        if(iso_str[0]!=255) _outmystr_col(0, iso_str , rxt+1, ryt[0]+1, xr-23 ,chrxr,cbkxr);
        if(meg_str[0]!=255) _outmystr_col(0, meg_str , rxt+1, ryt[1]+1, xr-23 ,chrxr,cbkxr);
        if(mik_str[0]!=255)  _outmystr_col(0, mik_str , rxt+1, ryt[2]+1, xr-23 ,chrxr,cbkxr);
        refresh();
        
        do{
            i=qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 2);
            if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 2);
            else break;
            if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 2);
            else break;
        } while (i==-9);
        break;
        
    case 4 : // Δεκαδικός
        
        if(iso_str[0]!=255) _outmystr_col(0, iso_str , rxt+1, ryt[0]+1, xr-23 ,chrxr,cbkxr);
        if(meg_str[0]!=255) _outmystr_col(0, meg_str , rxt+1, ryt[1]+1, xr-23 ,chrxr,cbkxr);
        if(mik_str[0]!=255)  _outmystr_col(0, mik_str , rxt+1, ryt[2]+1, xr-23 ,chrxr,cbkxr);
        refresh();
        
         do{
        i=qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 3);
        if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 3);
        else break;
        if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 3);
        else break;
        } while (i==-9);
        break;
}
          
          do {
        SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=0; start=0;trik=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_QUIT) { mx=x+170;my=y1+30;enter_go=1;break; }
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
            
            if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            else if (del[0]) {del[0]=0 ; puticon(delxt,ryt[0],mem_delete,255);}
          
            trik=0;
            x0=(mx-x)/60;
            kyk=x0 ;
            if (!outmen) {
            outmen=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);}
            
            if (!start) {
            setcolor ( COLOR (255,255,0) );
            mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x0*wid_box+i,y1+f);}}
            refresh();
            kyk1=kyk;
            x3=x0 ; 
            start=1;
        continue ;}
            
            if (kyk==kyk1) continue ;
            
            //EPANAFEREI XRVMA EPILOGHS
            setcolor ( COLOR (128,128,128) ) ; 
            mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x3*wid_box+i,y1+f);}}
            
                
            // XRVMATIZEI NEA EPILOGH
            kyk1=kyk ; x3=x0 ; 
            setcolor ( COLOR (255,255,0) );
            mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x0*wid_box+i,y1+f);}}
            refresh();
            continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[0] && my<ryt[0]+19) {
        
            if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
        
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del[0]) goto TRIKY ;
            del[0]=1;
            putNOTicon(delxt,ryt[0],mem_delete);
            continue;
            
        }
        
        if(del[0]) {del[0]=0 ; puticon(delxt,ryt[0],mem_delete,255);}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[1] && my<ryt[1]+19) {

            if(del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
                
            if (outmen==2) {
                outmen=1;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (del[1]) goto TRIKY ;
            del[1]=1;
            putNOTicon(delxt,ryt[1],mem_delete);
            continue;            
            
        }
        
        if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            
        if (mx>delxt && mx<delxt+19 && my>ryt[2] && my<ryt[2]+19) {
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del[2]) goto TRIKY ;
            del[2]=1;
            putNOTicon(delxt,ryt[2],mem_delete);
            continue;              
            
        }
        
        if(del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
        
        what=255;
        for (f=0 ; f<3 ; f++) {
            if  (mx>=rxt && mx<xr-22 && my>=ryt[f] && my < ryt[f]+19 ) {
                what=0;
                if (!outmen) {
                    outmen=2;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}
                    
                break ;
            }
        }
        
        if (!what && !trik) continue;

TRIKY :      
        if (trik) {
            trik=0;
            do {
            SDL_PollEvent(&sdlev);
            } while (sdlev.type != SDL_MOUSEBUTTONUP) ;
            
            if (del[0]) {iso_str[0]=255 ; bareacls (rxt+1,ryt[0]+1, xr-23, ryt[0]+19,cbkxr); continue;}
            else if (del[1]) {meg_str[0]=255 ; bareacls (rxt+1,ryt[1]+1, xr-23, ryt[1]+19,cbkxr); continue;}
            else if (del[2]) {mik_str[0]=255 ; bareacls (rxt+1,ryt[2]+1, xr-23, ryt[2]+19,cbkxr); continue;}
            
           
            if  (mx>=rxt && mx<xr-22 && my>=ryt[0] && my < ryt[0]+19 ) { // Επιλογή ισότητας !!
                
                if (!outmen) {
                    outmen=3;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}
                    
                switch (type) {
                    
                    case 3 : // Ακέραιος
                        do{
                        i=qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 2);
                        if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 2);
                        else break;
                        if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 2);
                        else break;
                        } while (i==-9);
                        break;
                        
                    case 4 : // Δεκαδικός
                        do{
                        i=qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 3);
                        if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 3);
                        else break;
                        if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 3);
                        else break;
                        } while (i==-9);
                        break;
                        
                }
                do {
                SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);
                continue ;
            }
            
            else if (mx>=rxt && mx<xr-22 && my>=ryt[1] && my < ryt[1]+19 ) { // Επιλογή μεγαλύτερο από !!
                
                if (!outmen) {
                    outmen=3;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}
                
                switch (type) {
                    
                    case 3 : // Ακέραιος
                        do{
                        i=qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 2);
                        if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 2);
                        else break;
                        if (i==-9) i = qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 2);
                        else break;
                        } while (i==-9);
                        break;
                        
                    case 4 : // Δεκαδικός
                        do{
                        i=qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 3);
                        if (i==-9) i = qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 3);
                        else break;
                        if (i==-9) i = qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 3);
                        else break;
                        } while (i==-9);
                        break;
                }
                
                do {
                SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);
                continue ;
            }
            
                else if (mx>=rxt && mx<xr-22 && my>=ryt[2] && my < ryt[2]+19 ) { // Επιλογή μικρότερο από !!
                    
                if (!outmen) {
                    outmen=3;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}
                
                switch (type) {
                    
                    case 3 : // Ακέραιος
                        do{
                        i=qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 2);
                        if (i==-9) i = qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 2);
                        else break;
                        if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 2);
                        else break;
                        } while (i==-9);
                        break;
                        
                    case 4 : // Δεκαδικός
                        do{
                        i=qnum_input(mik_str, rxt+1, ryt[2]+1, xr-23, ryt[2]+19, 14 , 3);
                        if (i==-9) i = qnum_input(iso_str, rxt+1, ryt[0]+1, xr-23, ryt[0]+19, 14 , 3);
                        else break;
                        if (i==-9) i = qnum_input(meg_str, rxt+1, ryt[1]+1, xr-23, ryt[1]+19, 14 , 3);
                        else break;
                        } while (i==-9);
                        break;
                        
                    }
                
                do {
                SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);
                    continue ;
                }
                    
        }
    
        if (del[0] || del[1] || del[2]) continue ;

        if (!outmen) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=0;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen!=1) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
EJODOS:
if(mem0) putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if(mem_menu) free(mem_menu);
if(mem_alert) free(mem_alert);
if (mem_delete) free (mem_delete); 
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
return((int)kyk);
}

int input_dbsearch_date(unsigned char *iso_str , unsigned char *meg_str, unsigned char *mik_str , short int arped)
// Επιστρέφει 1 εάν τελικά συμφωνήσει ο χρήστης !
// Γεμίσει τα iso_str , meg_str , mik_str ... κατά περίπτωση για να διευκολυνθεί η περαιτέρω αναζήτηση.
// Με βάση αυτά τα στρίγκς θα εξετασθεί είτε η ισότητα στοιχείου της βάσης δεδομένων με το εισαγόμενο συγκεκριμένο στοιχείο iso_str, είτε το αν βρίσκεται το στοιχείο (ας πούμε χ) της βάσης δεδομένων μέσα στο εύρος  meg_str>χ>mik_str 
{
SDL_Cursor* cursor;
FILE *fp ;
struct fansouv *whouv;
unsigned short int x ,xp, y ,y1, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,xr,del0=0,del1=0,del2=0;
unsigned short int ryt[3] , rxt ,delxt ;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert , *mem_delete;
void *mem_efedr1;
int *mem_int1;
short int *mem_int , c , a ;
unsigned short int neg , trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
unsigned char *pio_str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;

whouv=gouv;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }
kyk=0;


 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; goto EJODOS ;
}

x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Delete_18.ico");
mem_delete=icontomem (file_1,255);
if (!mem_delete) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+200,y+10,"Search..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+201,y+10,"Search..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
refresh();
}
else {
outnoto_col(xp+165,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+166,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
refresh();    
}
xr=xp+492;
x4=xp+2;
rxt=x4+160; 
ryt[0]=y+100;
ryt[1]=ryt[0]+25;
ryt[2]=ryt[1]+25;
delxt=xr-20;

i=0;f=0;

if (keyb_gr) sprintf (str1024," Σαν σήμερα");
else sprintf (str1024," Anniversary");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[0], rxt-5,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[0],xr-22,ryt[0]+20);
_puticon(delxt,ryt[0],mem_delete,255);

if (keyb_gr) sprintf (str1024," Μετά την .. (>)");
else sprintf (str1024," After .. (>) ");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[1], rxt-5 ,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[1],xr-22,ryt[1]+20);
_puticon(delxt,ryt[1],mem_delete,255);

if (keyb_gr) sprintf (str1024," Πριν από (<)");
else sprintf (str1024," Before (<)");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ryt[2],rxt-5,chrxr,cbkxr);

setcolor(5);
rectangle (rxt,ryt[2],xr-22,ryt[2]+20);
_puticon(delxt,ryt[2],mem_delete,255);

gouv=myfont[0];

        if(iso_str[0]!=255) _outmystr_col(0, iso_str , rxt+1, ryt[0]+1, xr-22 ,chrxr,cbkxr);
        if(meg_str[0]!=255) _outmystr_col(0, meg_str , rxt+1, ryt[1]+1, xr-22 ,chrxr,cbkxr);
        if(mik_str[0]!=255)  _outmystr_col(0, mik_str , rxt+1, ryt[2]+1, xr-22 ,chrxr,cbkxr);
        
refresh();

/*
    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh(); continue;}
            case SDL_KEYDOWN : continue;
            case SDL_MOUSEMOTION : break;
            case SDL_MOUSEBUTTONDOWN : break;
            default : continue;}
        break ;
    }
*/

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=a=-1; outmen=2;start=0;trik=0;
      
              
do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_QUIT) { mx=x+170;my=y1+30;enter_go=1;break;  } 
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
            trik=0;
            x0=(mx-x)/60;
            kyk=x0 ;
            
            if(del0) {del0=0 ; puticon(delxt,ryt[0],mem_delete,255);}
            else if(del1) {del1=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del2) {del2=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            
            if (outmen) {
                outmen=0;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
            
            if (!start) {
                setcolor ( COLOR (255,255,0) );
                mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
                for (f=0;f<hei_box-1;f++) {
                mem_int=(mem_efedr1+(f*wid*2));
                for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
                if (wtimi/32768) continue;
                _putpixel (x+x0*wid_box+i,y1+f);}}
                refresh();
                kyk1=kyk;
                x3=x0 ; 
                start=1;
            continue ;}
            
            if (kyk==kyk1) continue ;
            
            //EPANAFEREI XRVMA EPILOGHS
            setcolor ( COLOR (128,128,128) ) ; 
            mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x3*wid_box+i,y1+f);}}
            
                
            // XRVMATIZEI NEA EPILOGH
            kyk1=kyk ; x3=x0 ; 
            setcolor ( COLOR (255,255,0) );
            mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x0*wid_box+i,y1+f);}}
            refresh();
            continue ;    
            }
    
        if (start) {
            setcolor ( COLOR (128,128,128) ) ; 
            mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;   
            if (wtimi/32768) continue;
            _putpixel (x+x3*wid_box+i,y1+f);}}
            start=0; kyk1=-1;refresh();}
            
        
        if (mx>delxt && mx<delxt+19 && my>ryt[0] && my<ryt[0]+19) {
        
            if(del1) {del1=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del2) {del2=0 ; puticon(delxt,ryt[2],mem_delete,255);}
        
            if (outmen) {
                outmen=0;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del0) goto TRIKY ;
            del0=1;
            putNOTicon(delxt,ryt[0],mem_delete);
            continue;
            
        }
        
        if(del0) {del0=0 ; puticon(delxt,ryt[0],mem_delete,255);}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[1] && my<ryt[1]+19) {

            if(del2) {del2=0 ; puticon(delxt,ryt[2],mem_delete,255);}
                
            if (outmen) {
                outmen=0;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (del1) goto TRIKY ;
            del1=1;
            putNOTicon(delxt,ryt[1],mem_delete);
            continue;            
            
        }
        
        if(del1) {del1=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            
        if (mx>delxt && mx<delxt+19 && my>ryt[2] && my<ryt[2]+19) {
            
            if (outmen) {
                outmen=0;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del2) goto TRIKY ;
            del2=1;
            putNOTicon(delxt,ryt[2],mem_delete);
            continue;              
            
        }
        
        if(del2) {del2=0 ; puticon(delxt,ryt[2],mem_delete,255);}
        
        what=255;
        for (f=0 ; f<3 ; f++) {
            if  (mx>=rxt && mx<xr-2 && my>=ryt[f] && my < ryt[f]+19 ) {
                what=0;
                if (outmen) {
                    outmen=0;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}
                    
                break ;
            }
        }
        
        if (!what && !trik) continue;

TRIKY :        
        if (trik) {
            a=-1;
            trik=0;
            do {
            SDL_PollEvent(&sdlev);
            } while (sdlev.type != SDL_MOUSEBUTTONUP) ; 
            
            if  (mx>=rxt && mx<xr-22 && my>=ryt[0] && my < ryt[0]+19 ) a=0 ;
            else if (mx>=rxt && mx<xr-22 && my>=ryt[1] && my < ryt[1]+19) a=1;
            else if (mx>=rxt && mx<xr-22 && my>=ryt[2] && my < ryt[2]+19) a=2 ;
            else if (del0) {iso_str[0]=255 ; bareacls (rxt+1,ryt[0]+1, xr-23, ryt[0]+19,cbkxr);continue;}
            else if (del1) {meg_str[0]=255 ; bareacls (rxt+1,ryt[1]+1, xr-23, ryt[1]+19,cbkxr);continue;}
            else if (del2) {mik_str[0]=255 ; bareacls (rxt+1,ryt[2]+1, xr-23, ryt[2]+19,cbkxr);continue;}
        
            if (a!=-1) {
            
                if (outmen) {
                    outmen=0;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);}

                
                ptr_char=pedaba_calendar( -1 );
                if(!ptr_char) continue;
                ptr_char[24]=255;
                
                if (!a) pio_str=iso_str;
                else if (a==1) pio_str=meg_str;
                else if (a==2) pio_str=mik_str;

                mystrcpy (pio_str,ptr_char);
                free ( (void *) ptr_char ) ;
                //normtext_tomy(str1024,pio_str);
                _bareacls(rxt+1, ryt[a]+1,xr-23,ryt[a]+19,cbkxr);
                _outmystr_col(0,pio_str,rxt+1, ryt[a]+1, xr-23 , chrxr ,cbkxr );
                refresh();
                continue;
            }
    }
    
        if (del0 || del1 || del2) continue ;
        
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        
} while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;


if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  

EJODOS:
if(mem0) putimage(xp,y,mem0,0);
refresh();
if (mem0) free(mem0);
if (mem_menu) free(mem_menu);
if (mem_alert) free(mem_alert);
if (mem_delete) free(mem_delete);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;

return((int)kyk);
}

int input_dbsearch_text(unsigned char *inp_str , short int arped)
// Επιστρέφει 1 εάν συμφωνήσει ο χρήστης !
// Αν ο arped είναι αρνητικός αριθμός πάλι θα κάνει τη δουλειά της η συνάρτηση....
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int neg , trik ;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
int cbkxr[3];
unsigned char what , enter_go=0;
char string[32];
char *str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;

whouv=gouv;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }
    
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
slxr[0]=slxr[2]=0; slxr[1]=120;
size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ; 
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;
}
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0); goto FYGE;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0); goto FYGE;}

if (arped<0) {
    if (keyb_gr) strcpy (string , "Αλφαριθμητικού");
    else strcpy (string,"Alphanumeric");
    normtext_tomy(string,0);
}
setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
xr=xp+492;
chrxr[0]=200;chrxr[1]=200;chrxr[2]=0;

if (!keyb_gr) {
outnoto_col(xp+220,y+10,"Search ..",0,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+221,y+10,"Search ..",0,chrxr,cbkxr);
setcolor (4);
line (xp+145,y+33,xp+360,y+33);
line (xp+150,y+35,xp+355,y+35);
if (arped>=0) _outmystr_center_col(1, ptr_pedio[arped]->finame ,  xp, y+40, xr,y+70, chrxr, cbkxr);
else _outmystr_center_col(1, string ,  xp, y+40, xr,y+70, chrxr, cbkxr);
refresh();
}
else {
outnoto_col(xp+200 ,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
chrxr[0]=255;chrxr[1]=0;chrxr[2]=0;
outnoto_col(xp+201,y+10,"Anazh'thsh..",1,chrxr,cbkxr);
setcolor (4);
line (xp+155,y+33,xp+370,y+33);
line (xp+160,y+35,xp+365,y+35);
if (arped>=0) _outmystr_center_col(1, ptr_pedio[arped]->finame ,  xp, y+40, xr,y+70, chrxr, cbkxr);
else _outmystr_center_col(1, string ,  xp, y+40, xr,y+70, chrxr, cbkxr);
refresh();    
}

x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! 
i=0;f=0;

if (keyb_gr) sprintf (str1024," Εισάγετε Κείμενο ..");
else sprintf (str1024," Enter Text ..");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, y4, xr,chrxr,cbkxr);

if (keyb_gr) sprintf (str1024,"..μέχρι 20 χαρακτήρες.");
else sprintf (str1024,"..up to twenty chars.");

normtext_tomy(str1024,0);
_outmystr_col(0, str1024 , x4, ymy, xr,chrxr,cbkxr);

yc=y4+80; xc=x4;
setcolor(5);
rectangle (xc+1,yc+3,xr-2,yc+24);
gouv=myfont[0];
refresh();
text_input(inp_str, xc+2, yc+4, xr-3, yc+23, 20);

    while (1) {
        SDL_PollEvent(&sdlev); 
        switch (sdlev.type) {
            case SDL_WINDOWEVENT : {refresh(); continue;}
            case SDL_KEYDOWN : continue;
            case SDL_MOUSEMOTION : break;
            case SDL_MOUSEBUTTONDOWN : break;
            case SDL_QUIT : break ;
            default : continue;}
        break ;
    }
            

mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;trik=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_QUIT) { mx=x+170;my=y1+30;enter_go=1;break;  }
        
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
        trik=0;
        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        if (trik) {
        if  (mx>=xc && mx<xr-2 && my>=yc && my < yc+22 ) {
            qtext_input(inp_str, xc+2, yc+4, xr-3, yc+23, 20);
            while (1) {
                SDL_PollEvent(&sdlev); 
                switch (sdlev.type) {
                case SDL_WINDOWEVENT : {refresh(); continue;}
                case SDL_KEYDOWN : continue;
                case SDL_MOUSEMOTION : break;
                case SDL_MOUSEBUTTONDOWN : break ;
                case SDL_QUIT : break ;
                default : continue;} 
                trik=0;
                break ;
            }
            }}

        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
FYGE :
if(mem0) putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if (mem_menu) free(mem_menu);
if (mem_alert) free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return((int)kyk);
}


int mystrcmp (unsigned char *str1 , unsigned char *str2)
// Επιστρέφει 0 αν είναι ίσα !!
{
register int f =0 , i =0 ;

while (str1[f] != 255) f++;
while (str2[i] != 255) i++;

if (f != i) return 1;

for (f=0 ; f<i ; f++) {
    
    if (str1[f] != str2[f]) return 1;
}

return 0;
}

void what_mytime (time_t mytime, char *str)
{
char month [12][12];
char day [7][10];
char *str1;
unsigned short int f;
char ch;

diary=localtime(&mytime);

if (keyb_gr) {
strcpy (month[0],"Ιαν."); strcpy (month[1],"Φεβ."); strcpy (month[2],"Μαρ."); strcpy (month[3],"Απρ.");
strcpy (month[4],"Μάι."); strcpy (month[5],"Ιούν."); strcpy (month[6],"Ιούλ."); strcpy (month[7],"Αύγ.");
strcpy (month[8],"Σεπ."); strcpy (month[9],"Οκτ."); strcpy (month[10],"Νοε."); strcpy (month[11],"Δεκ.");

strcpy (day[1],"Δευ.");  strcpy (day[2],"Τρί."); strcpy (day[3],"Τετ."); strcpy (day[4],"Πέμ.");
strcpy (day[5],"Παρ."); strcpy (day[6],"Σαβ."); strcpy (day[0],"Κυρ.");


sprintf (str,"%s - %d %s %d - %02d:%02d" , day[diary->tm_wday] , diary->tm_mday , month[diary->tm_mon] , (diary->tm_year+1900) , diary->tm_hour , diary->tm_min);}
else
    {
    str1=asctime(diary);
    f=0;
    ch=str1[f];
    while (ch!='\0') {

        if (ch=='\n') break;
        str[f]=ch;
        f++;
        ch=str1[f];
            
        }
        str[f]='\0';
    }
}


unsigned char * convert_and_strstr  (short int arped, unsigned short int *how_many, unsigned short int *cur)

{

register int i,f ,w ;
int start_point , a ;
unsigned short int sefl , dem_len , sample_len , big_len ;
unsigned char deigma[22];
unsigned char *big_text , *mybigstr ;
unsigned char what ;
void *mem=0 ;

// Οι memk για το συγκεκριμένο πεδίο πρέπει να είναι ενημερωμένες .... πριν κληθεί τούτο εδώ !
// Δημιουργώ ένα αντίγραφο του string κειμένου του πεδίου arped στη μνήμη - εκεί θα περαστούν άτονα και μη κεφαλαία γράμματα για να γίνει το ψάξιμο του δείγματος μέσα σε αυτό. Το δείγμα φαίνεται στη δομή criterio ( multicr[arped]->txtcr->sample_t ).
//Μετά το ψάξιμο θα υπάρχουν μηδενικά και άσσοι στο αντίγραφο. Όπου είναι οι άσσοι θα έχουμε ισότητα με το δοθέν δείγμα !!!
// Επιστρέφει τη θέση μνήμης με τα μηδενικά και τους άσσους αν βρει ταυτίσεις με το δείγμα αλλιώς επιστρέφει 0 !!
// Στη μεταβλητή how_many επιστρέφει το πόσες ταυτίσεις βρέθηκαν !
// Στη μεταβλητή cur περνάει τη πρώτη θέση ταύτισης του δείγματος μέα στο bigstr (αν υπάρξει τάυτιση , ειδεμή περνάει 0 )!
// Στη δομή criterio ενημερώνεται η μεταβλητή mem_ghost του αντίστοιχου πεδίου δείχοντας τη θέση μνήμης που επιστρέφεται αν βρεθεί κάποια ταύτιση. (..και περιέχει άσσους και μηδενικά).
// PROSOXH : Αν ο επιστρεφόμενος unsigned char δείκτης ΔΕΝ είναι 0 , τότε θα πρέπει κάποτε να γίνει free(multicr[arped]->mem_ghost) !!!!!!

    if (multicr[arped]->mem_ghost) {free (multicr[arped]->mem_ghost); multicr[arped]->mem_ghost=0;}

    mybigstr=memk[arped];
    if (mybigstr[0]==255) {multicr[arped]->mem_ghost=0; *cur=0; return 0; }
    
    mystrcpy(deigma,multicr[arped]->sample_tcode);
    if (deigma[0]==255) {multicr[arped]->mem_ghost=0; *cur=0; return 0; }
    
    i=0;
    while (mybigstr[i]!=255) i++;
    big_len=i;
    mem=malloc(i+1);
    if (!mem) {information (2-keyb_gr,0,0); return 0;}
    big_text=mem;
    for (f=0;f<=i;f++) big_text[f]=mybigstr[f] ;
    
    // Δημιουργώ αντίγραφο του δείγματος για να γίνει άτονο και μη κεφαλαίο...
    
     i=0;
    while (deigma[i]!=255) i++;
    sample_len = i ;

   
    //Όλα μικρά και χωρίς τόνους !
    // To big_text είναι το μεγάλο κείμενο 

    
    for (f=0;f<big_len;f++) {
        if (keyb_gr) {
            switch (big_text[f]) {

                case 96:
                case 131:
                case 132:
                big_text[f]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                big_text[f]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                big_text[f]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                big_text[f]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                big_text[f]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                big_text[f]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                big_text[f]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                big_text[f]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                big_text[f]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                big_text[f]=128;
                break;

                case 130:
                big_text[f]=119;
            }
        }
        if ( (big_text[f]>68) && (big_text[f]<95) ) big_text[f]-=26;
    }


    sefl=0; // Πόσα βρέθηκαν .... 
    i=0;
    do {
        what=big_text[i];
        f=0; w=sample_len; dem_len=0; start_point=-1; a=i ; // sample_len : μήκος δείγματος , dem_len : demanded len
        while( (what!=255) && (w) ) {
            if (what==deigma[f++]) {
                if (start_point==-1) start_point=i; 
                dem_len++; 
                w--; 
                what=big_text[++i];
                continue;
            }
            else break;
        }
            
        if (dem_len==sample_len) { 
            sefl++;  
            if (sefl==1) {*cur = (unsigned short int) start_point ;}
            for(f=start_point;f<i;f++) big_text[f]=1;
            continue ;
        }
        else { big_text[a]=0; i=a+1; }
        
    }while (what!=255);
    
    *how_many=sefl;
    if (sefl) {
        multicr[arped]->mem_ghost=mem; return big_text;
    } 
    else {multicr[arped]->mem_ghost=0; *cur=0; free(mem); return 0; }
}


unsigned short int field_txt_scrollsearch (short int arped, unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *cochxr , int *cobkxr, int *coslxr)
{

// Θα έχει προηγηθεί η convert_and_strstr !!
// Κάνει scroll - show και search συνάμα .
// Πρέπει να είναι ενημερωμένη η memk του πεδίου !!
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,ar,a2=0,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_mod , ch_scan; 
int diaf1,diaf2 ;
short int wrap ,enbar ;
unsigned short int wherp ;
unsigned char what ;
unsigned char *str , *ghost ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue, neg ;
void *mem_bar=0;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;

str=memk[arped];
ghost=multicr[arped]->mem_ghost ;
elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
rectangle (xl,yt,xr,yb);
_bareacls (xr+2,yt-1,xr+11,yb,dbbkxr);refresh();

xl++ ; yt++ ; xr-- ; yb--;
if (xr+13>info.right)  bar=2;
if (!bar) {mem_bar=malloc((imagesize (xr+2,yt-1,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; return (0); }
getimage (xr+2,yt-1,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);

ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; goto stokalo ; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
        
        x1=xl; y1=yt;
        if (!ghost) {
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
        }
        else {
            
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            
            if (!co.lor)  {
                if (!ghost[a]) continue ; 
                else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
             
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            
            if (ghost[a]) {
                while (f<bh) {
                    setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                    for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
            }
        }
    }
        x=pos[cur][0] ; y=pos[cur][1];
        a2=a;
        
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+2,yt-1,xr+13,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
         if (mx<info.left || my<info.top) continue ;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;

        continue ;
        
        case SDL_MOUSEWHEEL :
            while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost){
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                    a2=a;
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
    
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }                    
                    refresh();
                     a2=a;               
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }
                my= sdlev.button.y ;
                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar-1][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if(!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }}
                    
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                     a2=a;               

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        
        if (ghost) {
                
                f=a2;
                if (f!=ar) {
                    while ( (!ghost[f]) && (f<ar) ) f++;
                }
                
                  if (f!=ar) cur=f; else continue ;
                
                        f=0;
                        while (pos[cur-f][0] !=xl)  f++;
                        diaf1=pos[cur-f][1]-yt;
                        for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
                        wherp=cur-f;
                        
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                        
                    for (a=wherp; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ;
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    
                    if (!co.lor)  {
                        if (!ghost[a]) continue ; 
                        else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                    
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    
                    if (ghost[a]) {
                        while (f<bh) {
                            setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                            for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                    }
                }
                
                    x=pos[cur][0] ; y=pos[cur][1];
                    a2=a;
                    goto barovios ;
                    
                }
            continue ;                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
        
            if (ghost) {
                
                if (cur) f=cur-1 ; else continue ;
                while ( (!ghost[f]) && (f) ) f--;
                if ( (!ghost[f]) && (!f) ) continue ; 
                if (f) {
                    while ( (ghost[f]) && (f) ) f--;
                    if (f) f++;
                }
            
                                
                cur=f;
                
                f=0;
                while (pos[cur-f][0] !=xl)  f++;
                diaf1=pos[cur-f][1]-yt;
                for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
                wherp=cur-f;
                
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            
            if (!co.lor)  {
                if (!ghost[a]) continue ; 
                else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
            
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            
            if (ghost[a]) {
                while (f<bh) {
                    setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                    for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
            }
        }
        
            x=pos[cur][0] ; y=pos[cur][1];
            a2=a;
            goto barovios ;
                
            }
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
            ch_mod=SDL_GetModState();
            
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            if(!ghost) {
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
            refresh();
            a2=a;
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) continue;

            if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            if(!ghost) {
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }}
            
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
            refresh();
             a2=a;               
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar-1][1]<ektos ) {cur=ar-1; x=pos[ar-1][0]; y=pos[ar-1][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if (!ghost) {
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    refresh();
                    a2=a;
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    if(!ghost){
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }}
                    else {
                        for (a=cur; a<ar; a++) {
                        what=str[a];
                            
                        if (what==200) continue ;
                        x1=pos[a][0]; y1=pos[a][1];
                        if (y1>=ektos) break ;
                        mem_int=gouv[what].where ;
                    
                        for(f=0; f<gouv[what].hei ; f++) {
                        for(i=0;i<gouv[what].wid;i++) {
                        co.lor = *mem_int++;
                        
                        if (!co.lor)  {
                            if (!ghost[a]) continue ; 
                            else {setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;  _putpixel(x1+i , y1+f); continue ; }}
                        
                        neg=255-co.rgb[0];
                        red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                        green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                        blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                        setcolor(COLOR (red,green,blue));
                        _putpixel(x1+i , y1+f);}}
                        
                        if (ghost[a]) {
                            while (f<bh) {
                                setcolor (COLOR(coslxr[0],coslxr[1],coslxr[2])) ;
                                for(i=0;i<gouv[what].wid;i++) { _putpixel(x1+i , y1+f);} f++ ;}
                        }
                    }
                }
                    a2=a;
                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+2,yt-1,xr+13,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar-1][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
        
        case SDL_QUIT :
            fyge=1 ; break ;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :
if (cur) {
    i=cur;
    while (pos[i][1]>yt) i--;
    if(i) {
        while (pos[i][0]>xl) i--;}

    cur=i;
}
if (bar==1) { putimage (xr+2,yt-1,mem_bar,0); refresh();}
if (mem_bar) free (mem_bar);

if (ar) {
        xr++;
        
        if (pos[0][1]<yt) {
            
        setrgbcolor(dbmag);
        line(xr+6,yt-1,xr+6,yt+10);
        line(xr+7,yt-1,xr+7,yt+10);
        line(xr+2,yt+3,xr+6,yt-1);
        line(xr+2,yt+4,xr+6,yt);
        line(xr+2,yt+5,xr+6,yt+1);
        line(xr+11,yt+5,xr+7,yt+1);
        line(xr+11,yt+4,xr+7,yt);
        line(xr+11,yt+3,xr+7,yt-1);
        
        }
        //else {_bareacls (xr+2,yt-1,xr+11,yt+10,dbbkxr);}

                
        if (pos[ar-1][1]>=ektos) {
        setrgbcolor(dbmag);
        line(xr+6,yb-10,xr+6,yb);
        line(xr+7,yb-10,xr+7,yb);
        line(xr+2,yb-6,xr+6,yb-2);
        line(xr+2,yb-5,xr+6,yb-1);
        line(xr+2,yb-4,xr+6,yb);
        line(xr+11,yb-6,xr+7,yb-2);
        line(xr+11,yb-5,xr+7,yb-1);
        line(xr+11,yb-4,xr+7,yb);
        }
refresh();
}
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 

return cur ;
}


void *proarial_12()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/Arial_12.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
sarial[i].who=elem[i].who;
sarial[i].wid=elem[i].wid;
sarial[i].hei=elem[i].hei;
sarial[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font Arial_12 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}


void show_help(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1)
// To text_help δείχνει ένα κανονικό στριγκ το οποίο η συνάρτηση  μετατρέπει σε δικό μου , στο str1024.
//Δείχνει με μικρά γράμματα κάποιο βοηθητικό κείμενο.
// Δίνουμε συντεταγμένες  xt , yt αλλά σβήνουμε το βοηθητικό κείμενο και αποκαθιστούμε οθόνη με τις συντεταγμένες xt1, yt1 !!! (Μπορεί να αλλάξουν οι αρχικές συν/νες!)
{
register int i=0,f=0 ;
unsigned char what ;
unsigned short int wid ;
int colxr[3] , colbk[3] ;

if (mem_small) {free(mem_small) ; mem_small=0;}
normtext_tomy (text_help , str1024);
what = str1024[f];
while (what != 255) {
    i += sarial[what].wid;
    what = str1024[++f];
    }
wid=i+4;
if ( xt+wid >= info.right ) {
    if (xt>wid) xt-=wid;
    else xt=info.left+1;
} 
if (yt+15>info.bottom) return;
*xt1=xt ; *yt1=yt ;
setrgbcolor(dbred);
mem_small=malloc(imagesize(xt,yt,xt+wid-1,yt+15));
if (!mem_small) return;
colxr[0]=colxr[1]=colxr[2]=0;
colbk[0]=colbk[1]=255 ; colbk[2]=0;
getimage (xt,yt,xt+wid-1,yt+15,mem_small);
rectangle (xt,yt,xt+wid-1,yt+15);
setrgbcolor(dbhelpcol); 
for (f=yt+1 ; f<=yt+14 ; f++) {
    for (i=xt+1; i<=xt+wid-2 ; i++) {
        _putpixel (i,f);
    }
}

//setalpha (getcolor (), 255); 
//_bareacls(xt+1,yt+1,xt+wid-2,yt+14,colbk);
_outmystr_center_col(2,str1024,xt+1,yt+1,xt+wid-2,yt+15,colxr,colbk);
refresh();
}

void hide_help(unsigned short int xt1, unsigned short int yt1)
{
    if (!mem_small) return;
    putimage (xt1,yt1,mem_small,0);
    refresh();
    free(mem_small);mem_small=0;
    return;
}


void show_help_2(char *text_help,unsigned short int xt, unsigned short int yt, unsigned short int *xt1 , unsigned short int *yt1)
// To text_help δείχνει ένα κανονικό στριγκ το οποίο η συνάρτηση  μετατρέπει σε δικό μου , στο δικό της strhlp.
//Δείχνει με μικρά γράμματα κάποιο βοηθητικό κείμενο.
// Δίνουμε συντεταγμένες  xt , yt αλλά σβήνουμε το βοηθητικό κείμενο και αποκαθιστούμε οθόνη με τις συντεταγμένες xt1, yt1 !!! (Μπορεί να αλλάξουν οι αρχικές συν/νες!)
{
register int i=0,f=0 ;
unsigned char what ;
unsigned short int wid ;
int colxr[3] , colbk[3] ;
unsigned char strhlp [786];

if (mem_small_2) {free(mem_small_2) ; mem_small_2=0;}
normtext_tomy (text_help , strhlp);
what = strhlp[f];
while (what != 255) {
    i += sarial[what].wid;
    what = strhlp[++f];
    }
wid=i+4;
if ( xt+wid >= info.right ) {
    if (xt>wid) xt-=wid;
    else xt=info.left+1;
} 
if (yt+15>info.bottom) return;
*xt1=xt ; *yt1=yt ;
setrgbcolor(dbred);
mem_small_2=malloc(imagesize(xt,yt,xt+wid-1,yt+15));
if (!mem_small_2) return;
colxr[0]=colxr[1]=colxr[2]=0;
colbk[0]=colbk[1]=255 ; colbk[2]=0;
getimage (xt,yt,xt+wid-1,yt+15,mem_small_2);
rectangle (xt,yt,xt+wid-1,yt+15);
setrgbcolor(dbhelpcol); 
for (f=yt+1 ; f<=yt+14 ; f++) {
    for (i=xt+1; i<=xt+wid-2 ; i++) {
        _putpixel (i,f);
    }
}

_outmystr_center_col(2,strhlp,xt+1,yt+1,xt+wid-2,yt+15,colxr,colbk);
refresh();
}

void hide_help_2(unsigned short int xt1, unsigned short int yt1)
{
    if (!mem_small_2) return;
    putimage (xt1,yt1,mem_small_2,0);
    refresh();
    free(mem_small_2);mem_small_2=0;
    return;
}


void *protimes_18()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/TIMES_18.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
times18[i].who=elem[i].who;
times18[i].wid=elem[i].wid;
times18[i].hei=elem[i].hei;
times18[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font Times_18 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}



int info_dbfnt()
// Ενημερώνει τη δομή για το button (dbfnt) με όλα τα ονόματα των fonts !
{
register int i,f ;
void *mem;
unsigned short int s;
unsigned int m;
unsigned char what ;
unsigned char name[20];

mem=malloc(size_fnts) ; 
synolo_fnts=mem;
if (!mem) return 0;

m=0;s=0;
dbfnt.fn_orio=0;


    for (f=0;f<ttf;f++) {
        
        if ( (m+21) > (size_fnts-40) ) {
            size_fnts+=128;
            mem=realloc(mem,size_fnts);
            if (!mem) return 0;
            synolo_fnts=mem;
        }
            normtext_tomy (myfont_name[f] , name);
            for (i=0;i<20;i++) {
                what=name[i];
                synolo_fnts[s] = what ;
                m++; s++;
                if (what==255) break;
            }
            if (dbfnt.fn_orio<i) dbfnt.fn_orio=i;
    }


if (s) {
    dbfnt.fn_ar = s ;
    synolo_fnts[s]=254;
}
else {
synolo_fnts[0]=255;
synolo_fnts[1]=254;
dbfnt.fn_ar=0;
}
dbfnt.mem_fn = (void*) synolo_fnts;
dbfnt.fn_data[0]=255;
dbfnt.fn_sorton=0;
return 1;
}


int fonts_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon, int *proxchxr, int *proxbkxr , int *proxslxr)
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3];
int chxrep[3] , bkxrep[3] , bkxryes[3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , pano, kato , telos ,sort ,bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned char *str ;
short int by , rby;
Uint8 klik;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;

    for (f=0;f<3;f++) {
        chxrep[f]=proxchxr[f];
        bkxrep[f]=proxbkxr[f];
        bkxryes[f]=proxslxr[f];
    }
kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
str=mem_str;
plbut=0;    


for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;

i=0; a=0;
for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       but[i++]=mem_str+a;
       a=f+1; 
        }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
f=0;
for (i=0; i<ttf; i++) {
    if (myfont_wid[i]>f) f=myfont_wid[i];
}
i=orio*f;
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,549);
mem0=malloc(size); //width x 550
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-550) / 2 ;
yt=yt1+19;  yb=yt1+549;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+15*30+1;
xok=xb-46 ; yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
_areacls (xtepl,ytepl,xtepr,ytepl+450,0,89,0);
_areacls(xtepl,ytepl+452,xtepr,ytepr,0,0,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
refresh();

chxr[0]=255 ; chxr[1]=255; chxr[2]=255;
bkxr[0]=30 ; bkxr[1]=30; bkxr[2]=30;
slxr[0]=0; slxr[1]=60; slxr[2]=0;
_bareacls (xtepl,ytepl,xtepr,ytepl+450,bkxr);
_areacls(xtepl,ytepl+452,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

a=0;k=0; a1=plbut; telos=0 ; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ
        _outmystr_center_col(ar_dom[a], but[ar_dom[a]] , xtepl+10 , ytepl+k*30 , xtepr, ytepl+k*30+29,chxr,bkxr);
        a++; a1--;k++;
    
}while (a1 && k<15);

setcolor(5);
line(xtepl,ytepl+k*30+1,xtepr,ytepl+k*30+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*15) / plbut ); y2+=y1;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;
protyx=tyx=15; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
       
     tyx=(my-ytepl)/30;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>14 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*30 , xtepr-1 , ytepl+tyx*30+29,bkxrep);
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*30 , xtepr-1, ytepl+tyx*30+29,chxrep,bkxrep);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1 , ytepl+tyx*30 , xtepr-1 , ytepl+tyx*30+29,bkxrep);
       _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+tyx*30 , xtepr-1, ytepl+tyx*30+29,chxrep,bkxrep);    
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=15 && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);      
        refresh();
        protyx=15;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); }
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ονομάτων γραμματοσειρών ή , όχι", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting Font names or , not", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        if (probar) probar=0;
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
                if (keyb_gr) information (0,"Διαγραφή γραμματοσειράς από τη Μνήμη !",0); else information (0,"Unload a Font from the Memory!",0);
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=15) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
            protyx=15;
            refresh();
            continue ;
        }
        //el= (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxryes);
         _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxrep,bkxryes);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
                elem=proelem=-1 ;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);refresh();
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η γραμματοσειρά από τη μνήμη ;" ,"Δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want this font to be unloaded?" , "The font remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου font - Μάλλον return με συγκεκριμένη τιμή
        }
        
        else if (profrba) {
            
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
                elem=proelem=-1 ;
            }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+549;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+15*30+1;
            xok=xb-46 ; yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ; 
            xfrba = (delon) ? xdel+55 : xdel+2 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*15) / plbut ); y2+=y1;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (probar) {
            
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
                 elem=proelem=-1 ;
            }

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*15); telos+=30;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*15) / plbut )+y1;    
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*15) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*15) / plbut );}
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+14)>plbut-1) {
            if ( (plbut-15)>=0)  { c=plbut-15 ; telos=15;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-14)<0 ) { 
            c=14; telos=15; 
            if (plbut<15) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           
        _bareacls(xtepl+1, ytepl+k*30,xtepr-1,ytepl+k*30+29,bkxr);
        _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+1 , ytepl+k*30 , xtepr-1, ytepl+k*30+29,chxr,bkxr);
        c+=bima ; telos--; k++;
        
    }while (telos && k<15);

    setcolor(5);
    line(xtepl,ytepl+k*30+1,xtepr,ytepl+k*30+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        //if ((!sort) && (pano==a1)) continue;
        //else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
                 elem=proelem=-1 ;
            }    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos+=18;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos+=12;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*30,xtepr-1,ytepl+protyx*30+29,bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                _outmystr_center_col(ar_dom[el], but[ar_dom[el]] , xtepl+1 , ytepl+protyx*30 , xtepr-1, ytepl+protyx*30+29,chxr,bkxr);
                refresh();
                protyx=15;
            }
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos+=14;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos+=16;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*15); telos+=30;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ytepl+450,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+14)>plbut-1) {
                    if ( (plbut-15)>=0)  { c=plbut-15 ; telos=15;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-14)<0 ) { 
                    c=14; telos=15; 
                    if (plbut<15) {c=plbut-1; telos=plbut; }}}
                    
            pano=c;
            do {                                           

                _outmystr_center_col(ar_dom[c], but[ar_dom[c]] , xtepl+10 , ytepl+k*30 , xtepr, ytepl+k*30+29,chxr,bkxr);
                c+=bima ; telos--; k++;
                
            }while (telos && k<15);

            setcolor(5);
            line(xtepl,ytepl+k*30+1,xtepr,ytepl+k*30+1);
            refresh();
            kato = (sort) ? c+1 : c-1;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*15) / plbut ); y2+=y1;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*15) / plbut ); y2+=y1;    
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; 
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
                case SDL_QUIT :
               fyge=1;
               kati=-2;
               continue;
                
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);

if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}

void *prosans_18()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/SnsSrf_18.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
sanser18[i].who=elem[i].who;
sanser18[i].wid=elem[i].wid;
sanser18[i].hei=elem[i].hei;
sanser18[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font SansSerif_18 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}



void *procaviar_22()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/Caviar_22.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
caviar22[i].who=elem[i].who;
caviar22[i].wid=elem[i].wid;
caviar22[i].hei=elem[i].hei;
caviar22[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font Caviar_22 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}

int bmptodisk_new (char *bmpname, unsigned int size_bytes,int width, int height)
{
union picols{
unsigned int ltimi;
unsigned char xro[4];
}col;
void *mem_start ;
int *mem_int, *mem_int0;
FILE *arxeio_fp;
long int good=width * height * 4 ;
int f ,i ,bad , transp_1;
char newname[150];
bad=size_bytes-good ;
mem_start = malloc (good+8);
if (mem_start==NULL) return 0;
arxeio_fp = fopen(bmpname,"rb");
if (!arxeio_fp) {free(mem_start); return 0;}
if ((fseek(arxeio_fp,bad,SEEK_SET))) {free(mem_start); fclose(arxeio_fp); return 0;}
//good=fread(mem_start,sizeof(short int),35,arxeio_fp);
//if(good != 35) {free(mem_start); fclose(arxeio_fp); return NULL;}
mem_int0=mem_start;
*mem_int0++ = width ; 
*mem_int0++ = height; 

for(f=height;f>0;f--) {
mem_int=mem_int0;
mem_int = mem_int + ((f-1)*width);
    for (i=0;i<width;i++) { 
        fread(&col.ltimi , sizeof(int) , 1, arxeio_fp);
         //transp_1=col.xro[0]; 
         //col.ltimi = col.ltimi >> 8;
        //col.xro[3]= transp_1; 
        *mem_int++ = col.ltimi;
    }}

fclose(arxeio_fp);
bad=strlen(bmpname);
strcpy(newname,bmpname);
newname[(bad-3)]='\0';
strcat(newname,"ico");
arxeio_fp = fopen(newname,"wb");
if (!arxeio_fp) {free(mem_start); return 0;}
i= (width*height*4) + 8 ;
fwrite (mem_start,1,i,arxeio_fp);
if(ferror(arxeio_fp)) {clearerr(arxeio_fp); printf("fwrite Problem !"); free(mem_start); fclose(arxeio_fp); return 0;}
fclose(arxeio_fp);
return 1;
}



void *proimpact_20()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/Impact_20.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
impact20[i].who=elem[i].who;
impact20[i].wid=elem[i].wid;
impact20[i].hei=elem[i].hei;
impact20[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font Impact 20 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}

int info_dbsec(short int arped , unsigned short int *ar_dom)
// Ενημερώνει τη δομή dbsec για το button που δείχνει φώτο . Δίνει τα στοιχεία του βοηθητικού πεδίου.
// Τα στοιχεία διαβάζονται από το δίσκο με τη σειρά που επιβάλλει η υφιστάμενη ταξινόμηση της βάσης δεδομένων !!! Για αυτό το λόγο διαβιβάζεται ο δείκτης της ar_dom !
// Όταν επιστρέφει 0 τότε κάτι δεν πήγε καλά , δηλαδή ακυρώθηκε και δεν επιτρέπεται να καλέσουμε την dbfield_show_button !!
{
register int i,f,a ;
unsigned int jump;
short int cur;
void *mem;
unsigned int s;
unsigned char deigma[48];
unsigned char what ;

if (ptr_pedio[arped]->fitype == 5) return 0;
if(dbsec.mem_fd) free(dbsec.mem_fd);
dbsec.mem_fd=0;
size_sec=2048;
mem=malloc(size_sec) ; synolo_sec=mem; 
if (!mem) return 0;

s=0;
cur =(ptr_pedio[arped]->fiorio > 45) ? 45 : ptr_pedio[arped]->fiorio;
jump = 0 ;

for (f=0 ; f<=dbfinum ; f++) {
    
    if (arped==f) break;
    jump+=xlimk[f];
}

for (f=0;f<dbplgr;f++) {
    i=fseek(fpcard , ((ar_dom[f] * dbcardsize) + jump) , 0);
    if (i) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; return 0 ;}
    fread(deigma,1,cur,fpcard);
    deigma[cur]=255;
    a=0; i=s; 
    what=deigma[a];
     while (what!=255) {
        synolo_sec[i]=what;
        i++; a++;
        what=deigma[a];
    }
    
    synolo_sec[i]=255;
    s = i+1;  
    
     if ( s > (size_sec-60) ) {
            size_sec+=1024;
            mem=realloc(mem,size_sec);
            if (!mem) return 0;
            synolo_sec=mem;
        }
    
}
dbsec.fd_sorton=0;
if (s) {
    dbsec.fd_ar = s ;
    synolo_sec[s]=254;
    dbsec.mem_fd= mem;
}
else {
synolo_sec[0]=255;
synolo_sec[1]=254;
dbsec.fd_ar=0;
dbsec.mem_fd=0;
}

return 1;
}


int photofield_show_button(void *mem_str, unsigned int ar, short int arped, short int arped2, short int *sorton , unsigned short int *disk_dom)
// O arped είναι ο αριθμός πεδίου των φώτο .
// Αν ο arped2 είναι -1 τότε δεν υπάρχει συνδιαχειριζόμενο πεδίο !!

// Η συνάρτηση info_dbsec ενημερώνει την καθολική δομή dbsec η οποία παρέχει το δείκτη mem_str και τον ar !
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) . Ξεκινάει με 0 και η τιμή γράφεται στην dbsec.
{
FILE *fp, *fpex ;
struct fansouv *whouv;
time_t cardwhen_1;
SDL_Cursor* cursor;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0 , *mem_deigma_text = 0 ;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0 ,*mem_ni=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbkxr[3] , cchxr[3] , cslxr[3], aspro[3] , mavro[3] ;
unsigned short int *ar_dom;
short int bima ,width , cur , cur_wid;
int xt1,xb1,yb1 ,kati ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort , sGidb, sG ;
unsigned short int  key , key_1, sort , sort_1, bar, proenter , xok , yok , protyx , plbut , pano , pano_1, kato , telos , telos1, metektos , metektos1 ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa , low ,karta ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ,  el , elem , proelem , c ;
unsigned char what ;
unsigned int size , size1 , photo_alma , ped_alma  ;
unsigned char *str  , redline ;
// unsigned char keyword[30] ;
short int by , rby , w , newsea=0  ;
Uint8 klik;
int  a1 , a , k , proyt , proyt1 , bary1, bary2, y1, y2 ,y3 ,pa=-1 ;  
short int sparky ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

static unsigned short int xt;
static int yt1;
unsigned char str1024a[1026];
unsigned char ektos=1;
short int sort_type;
unsigned char *but[dbplgr] ;
union button_item {
long unsigned int big;
unsigned char sma[8];
} bitem [3] ;

unsigned char nu[4];

unsigned int *Gitem , Gidb, Gi[3] ;
long int *Litem , Lidb, Li[3] ;
double *Fitem , Fidb, Fi[3] ;

unsigned char *deigma_text;
unsigned char deigma1_text[22] , neodeigma1_text[22] , deigma2_text[22] ;

unsigned char deigma [3][26] , neodeigma [3][26] ;

unsigned char krit[dbplgr] ;

int eikxt,eikyt,eikxb,eikyb ;
unsigned short int subxt , subyt , subxb , subyb ;
char apon[50] ;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
key_1=sort_1=65000;
deigma2_text[0]=255;
//printf("arped2=%d\n" , arped2);

if (keyb_gr) strcpy (apon,"Το αρχείο λείπει!");
else strcpy (apon,"Missing File!");
normtext_tomy(apon,0);

for (f=0;f<3;f++) {
    deigma[f][0]=255;
    neodeigma[f][0]=255;
}
deigma1_text[0]=255;
neodeigma1_text[0]=255;

whouv=gouv;
gouv = myfont[0];
str=mem_str;
plbut=dbplgr;
 

if (arped2>=0) { 
    
    sort_type=ptr_pedio[arped2]->fitype;
    
    for (f=0;f<3;f++) {
    deigma[f][0]=255;
    neodeigma[f][0]=255;
    }
    
    deigma1_text[0]=255;
    neodeigma1_text[0]=255;
    
    i=0; a=0;  
    for (f=0 ; f<ar && i<plbut ; f++) {
    if (str[f] == 255) {
        but[i++]=mem_str+a;
        a=f+1; 
            }
    }

    // Sorting Procedure !!
    ardom_mem=malloc(plbut*2);
    if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    ar_dom=ardom_mem;
    key=*sorton;
    for (f=0;f<plbut;f++) {ar_dom[f]=f; krit[f]=0;}
    
    ped_alma=size1=0;
    for (f=0;f<=dbfinum;f++) {
        if (arped2==f) ped_alma=size1; 
        size1 += xlimk[f];
        }
        //if (ptr_pedio[arped2]->fitype < 3) multicr[arped2]->cron_1=0;
        mem_deigma_text = malloc(xlimk[arped2]);
        if (!mem_deigma_text) {information (2-keyb_gr,0,0); goto FYGE; }
        deigma_text=mem_deigma_text;

    if (key) {
        switch (sort_type) {
        
            case 6 : // Ημερομηνία
                
                item_mem=malloc(plbut*4);
                if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                Gitem=item_mem;
                for (f=0;f<plbut;f++) {
                    cardiary.ldate=0;
                    if (but[f][0] !=255) {
                    mytext_tonorm(but[f],str1024,50);
                    w=strlen(str1024);
                    for (i=0;i<4;i++) {
                        nu[i]= str1024[w-i-1] - '0' ;
                    }
                    dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                    //dysena.wotim -= 1900;
                    cardiary.mydate[3]=dysena.dyomikra[1];
                    cardiary.mydate[2]=dysena.dyomikra[0];

                    nu[0]=  str1024[w-6] - '0' ;
                    nu[1]=  str1024[w-7] -  '0';
                    if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                    else cardiary.mydate[0]=nu[1]*10 + nu[0];

                    nu[0]=  str1024[w-9] - '0' ;
                    nu[1]=  str1024[w-10] - '0' ;
                    if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                    else cardiary.mydate[1]=nu[1]*10 + nu[0];
                            }
                    Gitem[f]=cardiary.ldate ;
                }
                pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
                break;
                
            case 3 :  // Ακέραιος αριθμός
                
                item_mem=malloc(plbut*8);
                if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                Litem=item_mem;
                for (f=0;f<plbut;f++) {
                    Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
                }
                pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
                break;
                
            case 4: // Φλοατ
                
                item_mem=malloc(plbut*8);
                if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                Fitem=item_mem;
                for (f=0;f<plbut;f++) {
                    Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
                }
                pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
                break;            
                
            case 0:
            case 1:
            case 2:
                
                item_mem=malloc(plbut*24);
                if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
                item=item_mem;
                for (f=0;f<plbut;f++) {
                    bitem[0].big=bitem[1].big=bitem[2].big=0;
                    i=0;by=23;
                    do {
                    what=but[f][i];
                    if (what>163) break;
                    if (keyb_gr){
                            switch (what) {

                                case 96:
                                case 101:
                                case 104:
                                case 107:
                                case 116:
                                case 122:
                                case 129:
                                case 132:
                                case 137:
                                case 140:
                                case 143:
                                case 151:
                                case 157:
                                case 163:
                                what--;
                                break;

                                case 108:
                                case 123:
                                case 144:
                                case 158:
                                what-=2;
                                break;


                                case 109:
                                case 124:
                                what-=3;
                                break;

                                case 130:
                                what=119;

                            }

                    }
                    rby=by%8; low=(2-(by/8));
                    //if (by>7) {low=0;rby=by-8;} else low=1;
                    bitem[low].sma[rby]=what;
                    by-- ; i++;
                    } while (by>=0);
                    item[f].fg=bitem[0].big;
                    item[f].sg=bitem[1].big;
                    item[f].tg=bitem[2].big;
                }

                pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                free (item_mem) ; item_mem=0;
            }
        }
}
else
{
    ardom_mem=malloc(plbut*2);
    if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    ar_dom=ardom_mem;
    key=0;
    for (f=0;f<plbut;f++) {ar_dom[f]=f;krit[f]=0;}
    sort_type=-1;
}

    // Το photo_alma είναι φυσικά υποχρεωτικό !!!
photo_alma=size1=0;
for (f=0;f<=dbfinum;f++) {
    if (arped==f) { photo_alma=size1; break ; } 
    size1+=xlimk[f];
    }

delon = (arped2>=0) ? 1 : 0 ;
cbkxr[0]=ptr_pedio[arped]->fibkxr[0] ; cbkxr[1]=ptr_pedio[arped]->fibkxr[1] ; cbkxr[2]=ptr_pedio[arped]->fibkxr[2] ; 
cchxr[0]=ptr_pedio[arped]->fichxr[0] ; cchxr[1]=ptr_pedio[arped]->fichxr[1] ; cchxr[2]=ptr_pedio[arped]->fichxr[2] ;
cslxr[0]=ptr_pedio[arped]->fislxr[0] ; cslxr[1]=ptr_pedio[arped]->fislxr[1] ; cslxr[2]=ptr_pedio[arped]->fislxr[2] ;

aspro[0]=aspro[1]=aspro[2]=255;
mavro[0]=mavro[1]=mavro[2]=0;

width=960 ;
size=imagesize(0,0,959,769);
mem0=malloc(size); //960χ770
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-770) / 2 ;
yt=yt1;  yb=yt1+769;
while (xt+width+11>info.right) xt--;
xb=xt+width-1;
getimage( xt , yt1 , xb , yb ,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
strcpy(file_1,path_name);
strcat(file_1,"ICD/Photo_fld.bmp");
if (!(fpex=fopen(file_1,"r"))) {information (6-keyb_gr,file_1,0); free(mem0); return 0;}
fclose(fpex);
readimagefile(file_1, (int) xt, yt1 , 0 ,0);
xtepl=xt+1; xtepr=xb-1 ; ytepl=yt1+20 ;
ytepr=yb-1; ybarb=yt1+721 ;
xok=xb-46 ; yok=ysort = ydel = yb-46;
xdel = xt+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-48 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
_bareacls(xtepl,ybarb,xtepr,ytepr,mavro);
bareacls(xtepl,yt1+1,xtepr,yt1+19,mavro); // Γέμισμα με χρώμα (κεφαλίδα)

// ΕΠΙΚΕΦΑΛΙΔΑ METAFORA
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

_outmystr_center_col(0, ptr_pedio[arped]->finame , xtepl, yt1+1, xtepr, yt1+20,aspro,mavro );
refresh();

if (arped2>=0) {
    cchxr[0]=ptr_pedio[arped2]->fichxr[0] ; cchxr[1]=ptr_pedio[arped2]->fichxr[1] ; cchxr[2]=ptr_pedio[arped2]->fichxr[2] ;
    cbkxr[0]=ptr_pedio[arped2]->fibkxr[0] ; cbkxr[1]=ptr_pedio[arped2]->fibkxr[1] ; cbkxr[2]=ptr_pedio[arped2]->fibkxr[2] ;
    cslxr[0]=ptr_pedio[arped2]->fislxr[0] ; cslxr[1]=ptr_pedio[arped2]->fislxr[1] ; cslxr[2]=ptr_pedio[arped2]->fislxr[2] ;
}


//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if (arped2>=0) {
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/sortascend.ico");
    mem_front = icontomem (file_1,255);
    if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/sortdescend.ico");
    mem_desc = icontomem (file_1,255);
    if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Search_30.ico");
    mem_del = icontomem (file_1,255);
    if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/ok_crit.ico");
mem_ni = icontomem (file_1,255);
if (mem_ni==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (delon && key) _puticon (xfrba,yfrba,mem_front,255) ;
else if (delon && !key) _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

a=0;k=0; a1=plbut; telos=0 ; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ 
        karta=ar_dom[a]; 
        eikyt=ytepl+(k/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(k%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        if (arped2 >= 0) {
            if (but[karta][0]!=255) _outmystr_center_col(2, but[karta] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
        }
        
        dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; goto FYGE ; }
        fread(str1024a,1,1024,fpcard);
        if (str1024a[0]!=255) {
            fpex=fopen(str1024a,"r"); 
            if (fpex!=NULL) {fclose(fpex) ; readimagefile (str1024a,eikxt+1,eikyt+1,eikxb-1,eikyb-1) ;}
            else {
                _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                _outmystr_center_col(2, apon , eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fichxr, ptr_pedio[arped]->fibkxr) ;
            }
        }
        else {
            _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
        }
        a++; a1--;k++;
    
}while (a1 && k<24);

if (k<24) {
    for (f=k; f<24 ; f++) {
        eikyt=ytepl+(f/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(f%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
    }
}



refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*24) / plbut ); y2+=y1;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;
protyx=tyx=24; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xt && mx<xb && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
       
    dy=(my-ytepl)/175 ; dx=(mx-xt)/160;
    tyx=dy*6+dx ;
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 24 δείγματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);  
          ektos=1;
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=24) {
                el = (sort) ? pano-protyx : pano+protyx;
                eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
                subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
                _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
                if (arped2 >= 0) {
                    if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
                }
                setrgbcolor(dbblack);
                rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb); 

                refresh();
                protyx=24;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>23 ) continue ;
          
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==24) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        eikyt=ytepl+(tyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(tyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,cbkxr);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, cchxr , cbkxr);
        }
        setrgbcolor(dbyel);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
        }
        setrgbcolor(dbblack);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);
        
        el = (sort) ? pano-tyx : pano+tyx;
        protyx=tyx ;
        eikyt=ytepl+(tyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(tyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,cbkxr);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, cchxr , cbkxr);
        }
        setrgbcolor(dbyel);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);
        refresh();
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=24 && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        el = (sort) ? pano-protyx : pano+protyx;
        eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
        }
        setrgbcolor(dbblack);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
        refresh();
        protyx=24;
    }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κριτηρίων αναζήτησης / Αριστερό κλικ : Αναζήτηση", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Criteria / Left Click : Search", xdel, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (arped2>=0) {
                                
        if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
        ektos=0;
        if (marrs) {
            marrs=0;
            puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
        else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (probar) probar=0;
            
        if (profrba) continue ;
        profrba=1;
        if (key) putNOTicon (xfrba,yfrba,mem_front) ;
            else putNOTicon (xfrba,yfrba,mem_back) ; 
        if (keyb_gr) show_help("Ταξινόμηση των στοιχείων ή, εμφάνιση σύμφωνα με την αύξουσα σειρά των καρτελών", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
            else show_help("Data sorting or , display according to the DB cards order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
            
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        
        continue ;
        }
        
        if (profrba) {
            profrba=0 ;
            hide_help(hdhlpxt , hdhlpyt);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ; }
    }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
      ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt && my<yt+18) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
        if (probar) probar=0;
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt1+1,mem_arrs);
         if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt+1, yt-16 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt+1, yt-16 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt1+1,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    if (ektos) continue ;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);}
   continue;
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (52-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) { // Ρύθμιση Αναζήτησης ανάλογα τον τύπο !
                // Right Click !!
                newsea=1;
                switch (sort_type) {

                    case 6 : // Ημερομηνία
                        user_ans=input_dbsearch_date(neodeigma[0],neodeigma[1],neodeigma[2],arped2);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                        
                    case 3 :  // Ακέραιος αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],3, arped2);

                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                    
                    case 4 :  // Δεκαδικός αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],4,arped2);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}

                        goto FROMNEWSEARCH;
                        
                    case 0 :
                    case 1 :
                    case 2 :
                        user_ans=input_dbsearch_text(neodeigma1_text , arped2);
                        if (user_ans!=1) continue ;
                        if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                        red=mystrcmp (deigma1_text,neodeigma1_text);
                        if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                        
                        goto FROMNEWSEARCH;
                }
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=24) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
           
        elem=proelem=-1 ; 
        eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
        }
        setrgbcolor(dbblack);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb); 
            protyx=24;
            refresh();
            continue ;
        }
        
        eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,cslxr);
        if (arped2 >= 0) {
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, cchxr , cslxr);
        }
        setrgbcolor(dbmag);
        rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);
        proelem=elem;
        refresh(); 

NOTHINGELSE:
        if (klik>1) goto DIPLO_KLIK ;
        continue ; 
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (arped2 >= 0) {
                if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
            }
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
  
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        
        if (delon && key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) { // Αναζήτηση με βάση προηγούμενο δεξί κλικ ...
FROMNEWSEARCH :
            a1=0;
            switch (sort_type) {

                case 3:
                case 4:
                case 6:
            
                    for (f=0;f<3;f++) {
                        if (deigma[f][0]!=255) {a1=1; break ;}}
                
                break ; 
            
                case 0:
                case 1:
                case 2:
                    
                    if (deigma1_text[0]!=255) a1=1;
                
                break ;
            }
            
            if (!a1) { // Δεν υπάρχει τίποτε για αναζήτηση !!

            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
                    
                    pa=pano;
                    telos1=(sort) ? pa+1 : plbut-pa ;
                    k=0;
                    //DIAGRAFEI PROHGOYMENES EYRESEIS
                    do {
                            karta=ar_dom[pa]; 
                            if (krit[karta]) {
                                eikyt=ytepl+(k/6)*175; eikyb = eikyt+159;
                                eikxt=xt+(k%6)*160; eikxb=eikxt+159 ;
                                                       
                                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
                                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; goto FYGE ; }
                                fread(str1024a,1,1024,fpcard);
                                if (str1024a[0]!=255) {
                                    fpex=fopen(str1024a,"r"); 
                                    if (fpex!=NULL) {fclose(fpex) ; readimagefile (str1024a,eikxt+1,eikyt+1,eikxb-1,eikyb-1) ;}
                                    else {
                                        _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                                        _outmystr_center_col(2, apon , eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fichxr, ptr_pedio[arped]->fibkxr) ;
                                    }
                                }
                                else {
                                    _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                                }
                            }
                            
                    pa+=bima ; telos1--; k++;
                    }while (telos1 && k<24);
                    
                    refresh();

                for (f=0;f<plbut;f++) krit[f]=0;
                redline=0; 
                if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
                newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) continue ;
                prodel=0; puticon (xdel,ydel,mem_del,255);
                continue ;}
                
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
            
            if (redline) {
                redline=1;
                if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη 24άδα....
                    c=pano+(bima*24) ;
                    if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                    if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                    telos=(sort) ? c+1 : plbut-c;
                    if (!sort) {
                        if (c<0) {c=0 ; telos=plbut;}
                        else if ((c+23)>plbut-1) {
                            if ( (plbut-24)>=0)  { c=plbut-24 ; telos=24;} else {c=0 ; telos=plbut;} } }
                
                    else if (sort) {
                        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                        else if ( (c-23)<0 ) { 
                            c=23; telos=24; 
                            if (plbut<24) {c=plbut-1; telos=plbut; }}}
                            pano=c; telos=(sort) ? c+1 : plbut-c;
                }
                //pano_1=pano ; sort_1=sort ; key_1=key;
                telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? pano+1 : plbut-pano ;
                }
                else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? pano+1 : plbut-pano ;
                }

                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            else {
                
                // Μετατροπή των αλφαριθμητικών στοιχείων που εισήχθηκαν για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                switch (sort_type) {
                    
                    case 6 : // Ημερομηνία
                        
                        for (f=0;f<3;f++) {
                            cardiary.ldate=0;
                            if (deigma[f][0] !=255) {
                            mytext_tonorm(deigma[f],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                            Gi[f]=cardiary.ldate ; // unsigned int Gi1
                            }
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            
                            for (f=0;f<3;f++){
                            Li[f]=(deigma[f][0]!=255) ? (long int) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            for (f=0;f<3;f++){
                                Fi[f]=(deigma[f][0]!=255) ? (double) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            mystrcpy (deigma2_text,deigma1_text) ;
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                    switch (sort_type) {
                        
                        case 6 : // Ημερομηνία
                            // Μετατρέπει στοιχεία λίστας  !
                            cardiary.ldate=0;
                            mytext_tonorm(but[pa],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                            
                            Gidb=cardiary.ldate ; // unsigned int Gi
                            
                        // ΣΥΓΚΡΙΣΗ !!
                           
                            if (deigma[0][0] !=255) {
                                sGidb=(unsigned short int) Gidb ; 
                                sG= (unsigned short int) Gi[0];
                                if (sGidb == sG ) { krit[pa]=1; pa++; continue ; }
                                //if ( Gidb==Gi[0] ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Gidb>Gi[1]) && (Gidb<Gi[2]) ) {krit[pa]=1; pa++; continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Gidb>Gi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Gidb<Gi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            // Συγκριση
                                                       
                            Lidb= (long int) convert_str( 15 , but[pa] ) ;
                            
                            if (deigma[0][0] !=255) {
                                    if ( Lidb==Li[0] ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Lidb>Li[1]) && (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Lidb>Li[1]) ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            Fidb= (double) convert_str(15 , but[pa]) ; 

                            if (deigma[0][0] !=255) {
                                if ( Fidb==Fi[0] ) {krit[pa]=1; pa++; continue;} 
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Fidb>Fi[1]) && (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Fidb>Fi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma_text μπορεί να διαβάζεται από το δίσκο ή όχι αναλόγως το μέγεθος - θα πάρει το μεγάλο στριγκ από το αντίστοιχο της λίστας

                            if (limk[arped2] < 46) mystrcpy (deigma_text,but[pa]);
                            else {
                                                     
                                fseek(fpcard , ((disk_dom[pa] * dbcardsize) + ped_alma) , 0);
                                fread(deigma_text,1,limk[arped2],fpcard);
                            }
                            i=0;
                            while (deigma_text[i]!=255) i++;

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma_text[f]=128;
                                        break;

                                        case 130:
                                        deigma_text[f]=119;
                                    }
                                }
                                if ( (deigma_text[f]>68) && (deigma_text[f]<95) ) deigma_text[f]-=26;
                            }
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=deigma_text[i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=deigma_text[i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    }
                }
            }
         
            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d καρτέλες!", i);
                else sprintf(str1024,"Identity occurred in %d DB cards!", i);
                if (ptr_pedio[arped2]->fitype < 3) {
                    mystrcpy ( multicr[arped2]->sample_tcode , deigma1_text );
                    mystrcpy (normdeigma[arped2] , deigma2_text) ;
                    multicr[arped2]->cron_1=1;
                }
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? pano+1 : plbut-pano ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;}  
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? pano+1 : plbut-pano ;
                }

                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;
            SDL_PollEvent(&sdlev);
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
            prodel=0; puticon (xdel,ydel,mem_del,255);
            goto emfan;
        }
        
        else if (profrba) {  // Από πάνω προς τα κάτω ή αντίστροφα !!
            
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (arped2 >= 0) {
                if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);}
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        
if (delon && key) {
    
    switch (sort_type) {
    
        case 6 : // Ημερομηνία
            
            item_mem=malloc(plbut*4);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Gitem=item_mem;
            for (f=0;f<plbut;f++) {
                cardiary.ldate=0;
                if (but[f][0] !=255) {
                mytext_tonorm(but[f],str1024,50);
                w=strlen(str1024);
                for (i=0;i<4;i++) {
                    nu[i]= str1024[w-i-1] - '0' ;
                }
                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                //dysena.wotim -= 1900;
                cardiary.mydate[3]=dysena.dyomikra[1];
                cardiary.mydate[2]=dysena.dyomikra[0];

                nu[0]=  str1024[w-6] - '0' ;
                nu[1]=  str1024[w-7] -  '0';
                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                nu[0]=  str1024[w-9] - '0' ;
                nu[1]=  str1024[w-10] - '0' ;
                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                        }
                Gitem[f]=cardiary.ldate ;
            }
            pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 3 :  // Ακέραιος αριθμός
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Litem=item_mem;
            for (f=0;f<plbut;f++) {
                Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 4: // Φλοατ
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Fitem=item_mem;
            for (f=0;f<plbut;f++) {
                Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;            
            
        case 0:
        case 1:
        case 2:
            
            item_mem=malloc(plbut*24);
            if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
            item=item_mem;
            for (f=0;f<plbut;f++) {
                bitem[0].big=bitem[1].big=bitem[2].big=0;
                i=0;by=23;
                do {
                what=but[f][i];
                if (what>163) break;
                if (keyb_gr){
                        switch (what) {

                            case 96:
                            case 101:
                            case 104:
                            case 107:
                            case 116:
                            case 122:
                            case 129:
                            case 132:
                            case 137:
                            case 140:
                            case 143:
                            case 151:
                            case 157:
                            case 163:
                            what--;
                            break;

                            case 108:
                            case 123:
                            case 144:
                            case 158:
                            what-=2;
                            break;


                            case 109:
                            case 124:
                            what-=3;
                            break;

                            case 130:
                            what=119;

                        }

                }
                rby=by%8; low=(2-(by/8));
                //if (by>7) {low=0;rby=by-8;} else low=1;
                bitem[low].sma[rby]=what;
                by-- ; i++;
                } while (by>=0);
                item[f].fg=bitem[0].big;
                item[f].sg=bitem[1].big;
                item[f].tg=bitem[2].big;
            }

            pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
        }
    *sorton=key;
    }

            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (delon && key) puticon (xfrba,yfrba,mem_front,255) ;
            else if (delon && !key) puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; 
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                 kati=ar_dom[elem];
                if (arped2>=0 && ptr_pedio[arped2]->fitype < 3) {
                    if ( (krit[kati]) && (deigma1_text[0] != 255) ) {
                        mystrcpy ( multicr[arped2]->sample_tcode , deigma1_text );
                        mystrcpy (normdeigma[arped2] , deigma2_text) ;
                        multicr[arped2]->cron_1=1;
                    }
                }
                   
                    continue ;
            }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;

            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt; continue ;}
            
            
            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }
            
            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt,xb,yb,mem_zer);
            putimage(xt,yt,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 

            xt=xt1; yt=yt1;
            xb=xt+width-1 ; yb=yt1+769;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

                xtepl=xt+1; xtepr=xb-1 ; ytepl=yt1+20 ;
                ytepr=yb-1; ybarb=yt1+721 ; 
                xok=xb-46 ; yok=ysort = ydel = yb-46;
                xdel = xt+2 ;  
                xfrba = (delon) ? xdel+55 : xdel +2 ; 
                yfrba = yb-48 ;
                xsort = xfrba+56;
                xvice=xsort+38; yversa=ysort+8;
                yicob = yb-9;
                
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*24) / plbut ); y2+=y1;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            
        
            continue ;
        }
        
        else if (probar) {
            
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (arped2 >= 0) {
                if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);}
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*24); telos+=48;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*24) / plbut )+y1;    
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*24) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*24) / plbut );}
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ

    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+23)>plbut-1) {
            if ( (plbut-24)>=0)  { c=plbut-24 ; telos=24;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-23)<0 ) { 
            c=23; telos=24; 
            if (plbut<24) c=plbut-1; telos=plbut; }}
            
    pano=c;
    do {
        karta=ar_dom[c];  
        eikyt=ytepl+(k/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(k%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        if (arped2 >= 0) {
            if (but[karta][0]!=255) _outmystr_center_col(2, but[karta] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
        }

        dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; goto FYGE ; }
        fread(str1024a,1,1024,fpcard);
        if (str1024a[0]!=255) {
            fpex=fopen(str1024a,"r"); 
            if (fpex!=NULL) {fclose(fpex) ; readimagefile (str1024a,eikxt+1,eikyt+1,eikxb-1,eikyb-1) ;}
            else {
                _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                _outmystr_center_col(2, apon , eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fichxr, ptr_pedio[arped]->fibkxr) ;
            }
        }
        else {
            _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
        }
        if (krit[karta]) puticon (eikxb-18,eikyb-18,mem_ni,255) ;
        c+=bima ; telos--; k++;
        
    }while (telos && k<24);

   if (k<24) {
    for (f=k; f<24 ; f++) {
        eikyt=ytepl+(f/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
        subxt=eikxt=xt+(f%6)*160; subxb=eikxb=eikxt+159 ;
        _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
        _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
    }
}
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        // if ((!sort) && (pano==a1)) continue;
        // else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (arped2 >= 0) {
                if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);}
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-6*bima; telos+=30;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+6*bima ; telos+=18;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=24) { 
            el= (sort) ? pano-protyx : pano+protyx;
            eikyt=ytepl+(protyx/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
            subxt=eikxt=xt+(protyx%6)*160; subxb=eikxb=eikxt+159 ;
            _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
            if (arped2 >= 0) {
                if (but[ar_dom[el]][0]!=255) _outmystr_center_col(2, but[ar_dom[el]] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);}
            setrgbcolor(dbblack);
            rectangle(eikxt,eikyt,eikxb,eikyb) ;  rectangle(subxt,subyt,subxb,subyb);       
            refresh();
            elem=proelem=-1 ; 
            protyx=24;
            }
      
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; 
               telos+=23;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima;
                telos+=25;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*24); telos+=48;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
           
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+23)>plbut-1) {
                    if ( (plbut-24)>=0)  { c=plbut-24 ; telos=24;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-23)<0 ) { 
                    c=23; telos=24; 
                    if (plbut<24) {c=plbut-1; telos=plbut; }}}
            
            sparky=0 ;        
            pano=c;
            do {        
                karta=ar_dom[c];  
                eikyt=ytepl+(k/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
                subxt=eikxt=xt+(k%6)*160; subxb=eikxb=eikxt+159 ;
                _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
                if (arped2 >= 0) {
                    if (but[karta][0]!=255) _outmystr_center_col(2, but[karta] ,  subxt+1 , subyt+1, subxb-1 , subyb, aspro , mavro);
                }
                
                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; goto FYGE ; }
                fread(str1024a,1,1024,fpcard);
                if (str1024a[0]!=255) {
                    fpex=fopen(str1024a,"r"); 
                    if (fpex!=NULL) {fclose(fpex) ; readimagefile (str1024a,eikxt+1,eikyt+1,eikxb-1,eikyb-1) ;}
                    else {
                        _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                        _outmystr_center_col(2, apon , eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fichxr, ptr_pedio[arped]->fibkxr) ;
                    }
                }
                else {
                    _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                }
                if (krit[karta]) { puticon (eikxb-18,eikyb-18,mem_ni,255) ; sparky=1;}
                c+=bima ; telos--; k++;
                
            }while (telos && k<24);
            
            if (k<24) {
                for (f=k; f<24 ; f++) {
                    eikyt=ytepl+(f/6)*175; subyt=eikyt+160 ; subyb = subyt+14; eikyb = eikyt+159;
                    subxt=eikxt=xt+(f%6)*160; subxb=eikxb=eikxt+159 ;
                    _bareacls(subxt+1,subyt+1,subxb-1,subyb-1,mavro);
                    _bareacls (eikxt+1,eikyt+1,eikxb-1,eikyb-1,ptr_pedio[arped]->fibkxr);
                }
            }
            refresh();

            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;
barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*24) / plbut ); y2+=y1;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*24) / plbut ); y2+=y1;    
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; 
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {

                 kati=ar_dom[elem];
                if (arped2>=0 && ptr_pedio[arped2]->fitype < 3) {
                    if ( (krit[kati]) && (deigma1_text[0] != 255) ) {
                        mystrcpy ( multicr[arped2]->sample_tcode , deigma1_text );
                        mystrcpy (normdeigma[arped2] , deigma2_text) ;
                        multicr[arped2]->cron_1=1;
                    }
                }
            }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
                case SDL_QUIT :
               fyge=1;
               kati=-2;
               continue;
    
     default :
         if(ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if (mem_ni) free (mem_ni) ;
if (item_mem) free (item_mem);
if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
if (mem_deigma_text) free (mem_deigma_text);
if(dbsec.mem_fd) { free(dbsec.mem_fd); dbsec.mem_fd=0;}
refresh();
gouv=whouv;
return kati ;
}


int spec_alert (int id,char *seleo,char *seleo1, char *img_file , int *spbkxr)
// π.χ. img_file = "art.ico" 90Χ90 - να είναι μέσα στο folder ICD . - spbkxr : special χρώμα spbkxr[0] , [1] και [2] ...
{
SDL_Cursor* cursor;
struct fansouv *whouv;
unsigned short int ch1, x ,xp, y ,y1, x2 , y2, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,ymy,xc,yc,xr,a;
unsigned int size ;
void *mem_menu , *mem0 , *mem_alert ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int;
unsigned short int neg;
short int kyk1, kyk, outmen ;
register int i,f ;
int mx,my,red,green,blue;
int chrxr[3];
char pros[30];
unsigned char what , enter_go=0;
char *str;
char ch;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_QUIT || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;

size=imagesize(0,0,399,299);
mem0=malloc(size);
if (!mem0)  {printf ("Spec Alert Function - Out of memory !! \n"); return 2;}
x=(info.right-info.left-399) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+399,y+299,mem0);
xp=x;
y1=y+219;
x+=92;
sprintf(file_1,"%s%s%s",path_name,"ICD/",img_file);
mem_alert=icontomem (file_1,255);
if (!mem_alert)  {free(mem0); printf ("Spec Alert Function - Out of memory !! \n"); return 2;}
strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu)  {free(mem0); free(mem_alert); printf ("Spec Alert Function - Out of memory !! \n"); return 2;}

setcolor(14);
rectangle(xp,y,xp+399,y+299);
rectangle(xp+5,y+5,xp+394,y+294);
_areacls (xp+1,y+1,xp+398,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+395,y+5,xp+398,y+298,255,165,0);
_areacls (xp+5,y+295,xp+394,y+298,255,165,0);

_bareacls (xp+6,y+6,xp+393,y+293,spbkxr);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chrxr[0]=chrxr[1]=chrxr[2]=0;

if (!keyb_gr) strcpy (pros,"A L E R T") ; 
else strcpy (pros,"Π Ρ Ο Σ Ο Χ Η") ;
normtext_tomy(pros,0);
_outmystr_center_col(7,pros,xp+6,y+10, xp+398 , y+35,chrxr,spbkxr);
setcolor (4);
line (xp+115,y+33,xp+290,y+33);
line (xp+120,y+35,xp+285,y+35);
refresh();

xr=xp+392;
x2=xp+100;
y2=y+38;
x4=xp+8;
y4=y2+64;
ymy=y4+64; // Στο x4,ymy γράφεται το seleo...αν δεν είναι NULL !!! Μπορώ μέχρι και y4+80 (seleo1) (2 γραμμές) .
i=0;f=0;
chrxr[0]=20;chrxr[1]=20;chrxr[2]=180;

do {
    what=sfalma[i];
    if (what==255) break ;
    if (what==10) {
        i++; what=sfalma[i]; 
        if (what==10) {
            i++; f++;
            if (f==id) {i+=2;break;}
        }}
       i++;
    } while (what !=255);
    
    
    if (f==id) {
        
        xc=x2;yc=y2;
        a=i;
        what=sfalma[a];
        
        do {
            if (what==200) { 
                 yc+=16;
                 if (yc>=ymy) break;
                 xc=(yc>=y4) ? x4 : x2 ;
                 a++; what=sfalma[a]; continue;}
                 
        if ((xc+souv[what].wid) > xr) {
            yc+=16;
            if (yc>=ymy) break;
            xc=(yc>=y4) ? x4 : x2 ;}
            
        mem_int1=souv[what].where ;
        for(f=0; f<souv[what].hei ; f++) {
        for(i=0;i<souv[what].wid;i++) {
        co.lor = *mem_int1++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (chrxr[0]*co.rgb[0]/255) - (spbkxr[0]*neg/255) );
        green =  abs( (chrxr[1]*co.rgb[0]/255) - (spbkxr[1]*neg/255) );
        blue =  abs( (chrxr[2]*co.rgb[0]/255) - (spbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(xc+i , yc+f);}}
        xc+=souv[what].wid;
        a++; what=sfalma[a];
        } while (what!=40);  // 41 αντιστοιχεί στον χαρακτήρα : '|'  
    }
    
    

    if (!id) ymy=y4 ;
    xc=x4; yc=ymy;
    
    if (seleo!=NULL) {
        size=strlen(seleo);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Spec Alert Function - Out of memory !! \n"); putimage(xp,y,mem0,0); refresh(); free(mem0); free(mem_alert); free(mem_menu); return 2;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==souv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo[f];}}
            
            str[a]=255;
            
           
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (spbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (spbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (spbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
                yc+=16;xc=x4;
    }
    
    if (yc<=y4+80) {
        if (seleo1!=NULL)  {
        size=strlen(seleo1);
        mem_efedr1=malloc(size+10);
        if (!mem_efedr1) {printf ("Spec Alert Function - Out of memory !! \n"); putimage(xp,y,mem0,0); refresh(); free(mem0); free(mem_alert); free(mem_menu); return 2;}
        str=mem_efedr1;
        f=0 ; a=0 ;
        ch=seleo1[f];
        while ( ch!='\0') {
            if (ch<0) {
                if (keyb_gr) {
                f++ ; ch1= ( (256*ch) + seleo1[f] ) ;
                    for (i=0 ; i<69 ; i++) {
                        if (ch1==unico[i][0]) {
                            str[a]=unico[i][1];  a++; break;}}
                if (i==69) {str[a]=0 ; a++ ; }
                f++; ch=seleo1[f];continue;}
                else {str[a]=0; a++;f++;ch=seleo1[f]; continue;}}
            else {
            if (ch=='\n') {str[a]=200; a++; f++; ch=seleo1[f]; continue;}
            for(i=0;i<95;i++) {
                if (ch==nouv[i].who) {
                str[a]=i ; a++ ; break;}}
            if (i==95) {str[a]=0 ; a++ ; }
            f++;ch=seleo1[f];}}
            
            str[a]=255;
                        
            a=0;    
            what=str[a]; 
            do {
                    if (what==200) { 
                        yc+=16;
                        if (yc>=y4+96) break;
                        xc=x4 ;
                        a++; what=str[a]; continue;}
                        
                if ((xc+souv[what].wid) > xr) {
                    yc+=16;
                    if (yc>=y4+96) break;
                    xc=x4 ;}
                    
                mem_int1=souv[what].where ;
                for(f=0; f<souv[what].hei ; f++) {
                for(i=0;i<souv[what].wid;i++) {
                co.lor = *mem_int1++;
                if (!co.lor) continue;
                neg=255-co.rgb[0];
                red =  abs( (chrxr[0]*co.rgb[0]/255) - (spbkxr[0]*neg/255) );
                green =  abs( (chrxr[1]*co.rgb[0]/255) - (spbkxr[1]*neg/255) );
                blue =  abs( (chrxr[2]*co.rgb[0]/255) - (spbkxr[2]*neg/255) );
                setcolor(COLOR (red,green,blue));
                _putpixel(xc+i , yc+f);}}
                xc+=souv[what].wid;
                a++; what=str[a];
                } while (what!=255);
                free(mem_efedr1);
    }}
    
refresh();
mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=2;start=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        if (sdlev.type==SDL_QUIT) { mx=x+170;my=y1+30;enter_go=1;break;  }
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά

        x0=(mx-x)/60;
        kyk=x0 ;
        if (outmen) {
        outmen=0;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);}
        
        if (!start) {
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
           wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        kyk1=kyk;
        x3=x0 ; 
        start=1;
       continue ;}
        
        if (kyk==kyk1) continue ;
        
        //EPANAFEREI XRVMA EPILOGHS
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        
              
        // XRVMATIZEI NEA EPILOGH
        kyk1=kyk ; x3=x0 ; 
        setcolor ( COLOR (255,255,0) );
        mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x0*wid_box+i,y1+f);}}
        refresh();
        continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();} 
        if (outmen==1) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=1;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen) ) && (!enter_go) ) ;
        
                 
        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
if(mem0) putimage(xp,y,mem0,0);
refresh();
free(mem0);
free(mem_menu);
free(mem_alert);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
return((int)kyk);
}



void *prosans_21()
{
/* Προυποθέτει καθολική μεταβλητή :
 struct fansouv {
 char who;
 short int wid;
 void *where;
} souv [165] ; // Σύνολο χαρακτήρων +1 */

FILE *fp;
int i;
unsigned int bytes , bytes1, metr ;
void *mem1;

struct fan {
    char who;
    short int wid;
    short int hei;
    unsigned int alma;
} elem [165] ;

strcpy(file_1,path_name);
strcat(file_1,"Fonts/SnSerif_21.dat");
fp=fopen(file_1,"rb");
if (fp==NULL) {printf("Disk I/O Problem \n"); return NULL;}
fread(&bytes,4,1,fp);
mem1=malloc(bytes);
if (mem1==NULL) {fclose(fp); return NULL;}
fread (&elem,sizeof(struct fan),164,fp);
for(i=0;i<164;i++) {
sanser21[i].who=elem[i].who;
sanser21[i].wid=elem[i].wid;
sanser21[i].hei=elem[i].hei;
sanser21[i].where=mem1+elem[i].alma;
}
fread(mem1,4,(bytes/4),fp);
   if(ferror(fp)) {free(mem1) ; clearerr(fp) ; printf("font SansSerif_21 load Problem ! \n"); fclose(fp); return NULL;}
fclose(fp);
return mem1;
}



unsigned short int hlp_txt_scroll (short int font, unsigned short int cur, unsigned char *str, unsigned short int ar, short int xl , short int yt , short int xr , short int yb , int *cochxr , int *cobkxr)
{
    
SDL_Cursor* cursor;
struct fansouv *whouv;
register int i,f ;
unsigned short int x,y,x1,y1,y2,a,elax,bh,ektos,user_ans,bar=0, maxline, ano_ar , fyge=0 , ch_scan; 
int diaf1,diaf2 ;
short int wrap ,enbar ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , mx1, my1, proyt , proyt1, olohei , metektos, metektos1 , x3 , y3 ,bary1, bary2, diafy ,red, green, blue, neg ;
void *mem_bar=0;
int *mem_int ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


int pos[ar+1][2] ;

whouv=gouv;
gouv=myfont[font];

elax=myfont_wid[font] ;
bh=myfont_hei[font] ;

setcolor(COLOR( 255-cobkxr[0], 255-cobkxr[1], 255-cobkxr[2]));
rectangle (xl,yt,xr,yb);
xl++ ; yt++ ; xr-- ; yb--;

if (!bar) {mem_bar=malloc((imagesize (xr+2,yt-1,xr+13,yb)));
if (mem_bar==NULL) {printf ("Memory Problem") ; gouv=whouv; return (0); }
getimage (xr+2,yt-1,xr+13,yb,mem_bar);}
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,cobkxr);
wherp=0;
refresh();

elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            
            pos[ar][0]=x1 ; pos[ar][1]=y1;

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
        
        x1=xl; y1=yt;
     
            for (a=wherp; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
        
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;

            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }
   

        x=pos[cur][0] ; y=pos[cur][1];
                
         // ELEGXOS GIA PLEYRIKH MPARA
        proyt=abs(pos[0][1]-yt) ;
        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
        if ( (!proyt) && (metektos<=0) ) goto Enarjh ;
        bar=1;
        setcolor (COLOR (0,255,0) );  
        rectangle (xr+2,yt-1,xr+13,yb);
        setcolor (COLOR (0,0,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=yt ; i < yb; i++) _putpixel (f,i); }
        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
        bary1=y1 ; bary2=y2;
        setcolor (COLOR (255,165,0) );  
        for (f=xr+3 ; f<xr+13 ; f++) {
            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
        
enbar= (bar) ? 17 : 0;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);       
Enarjh :
refresh();

    do {
    if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (mx<info.left || my<info.top) continue;
               
        if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;

        continue ;
        
        case SDL_MOUSEWHEEL :
            while (SDL_PollEvent(&sdlev)) continue ;
            if(sdlev.wheel.y > 0) { // scroll up
                    
                    if (!cur) continue;
                    
                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor (COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    goto barovios ;                
            }
            else if (sdlev.wheel.y < 0) { // scroll down
    
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    diaf2=(maxline>3) ? 3 : maxline ;
                    
                    f=cur;
                    while (pos[f][1] > yt) f--;
                    while (pos[f][0] !=xl) f--;
                    while ( pos[f][1]<(yt+diaf2*bh) ) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }
                 
                    refresh();        
                    goto barovios ;
            }
                
            continue ; 
    
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
            
            // KLIK STHN MPARA !!
            if (bar) {
            
            if (mx>xr+2 && mx<xr+14 && my>yt && my<yb) {

                if (my<bary1) goto PAGEUP ;
                if (my>bary2) goto PAGEDOWN ;
                //if(diak) {putimage(x,y,mem_cu,0); refresh() ; diak=0;}
                y3=bary1 + (bary2-bary1+1)/2 ;
                
                fyge=0;
                do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
                }
                my= sdlev.button.y ;
                if (my>yb) my=yb;
                if(my<yt) my=yt;
                if (y3==my) continue;
                diafy=my-y3;
                
                f=cur;
                if (f) {
                    while (pos[f][1]!=yt) f--;
                    while (pos[f][0]!=xl) f--;
                    ano_ar=f; } else ano_ar=cur;
                    y2=pos[ano_ar][1];
                    
                if (diafy<0) {
                    if (!cur) continue;
                    if (!ano_ar) {cur=0; continue;}
                    diafy=abs(diafy);
                    
                    diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                    if (!diaf2) continue;
                    
                    do {
                    if (pos[0][1] <= (yt - ( diaf2*bh)) ) {for (i=0;i<=ar;i++) pos[i][1]+=diaf2*bh; break ;}
                    else diaf2--;
                    } while (diaf2);
                    if (!diaf2) continue;
                    f=ano_ar;
                    while (pos[f][1]!=y2) f--;
                    while (pos[f][0]!=xl) f--;
                    cur=f;}
                    else {
                        if (cur==ar) continue;
                        if (pos[ar][1]<ektos) continue ;
                        diaf2=( diafy*(olohei/bh) ) / (yb-yt-1) ; // Σε πόσες γραμμές αντιστοιχούν τα pixels
                        if (!diaf2) continue;
                        do {
                            if (pos[ar][1] >= yt + ( diaf2*bh) ) {for (i=0;i<=ar;i++) pos[i][1] -= diaf2*bh; break ;}
                            else diaf2--;
                            } while (diaf2);
                            if (!diaf2) continue;
                            f=ano_ar;
                            while (pos[f][1]!=y2) f++;
                        cur=f;}
                
                x1=x=xl; y1=y=yt;
                
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    x1=pos[a][0];
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    _putpixel(x1+i , y1+f);}}
                    }
                    
                    refresh();
                              

                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                y3=bary1 + (bary2-bary1+1)/2 ;
                    refresh();
                } while (sdlev.type!=SDL_MOUSEBUTTONUP && (bar) && (!fyge) ) ; 
                //if (keyb_gr) {ton=0 ; dial=0 ;}
                fyge=0;
                x=pos[cur][0] ; y=pos[cur][1];
                continue ;
            }
        }   // END bar !!
        

            continue ;                      // END Case buttondown
        }
                                     // END Button Left
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
            mx = sdlev.button.x ; my= sdlev.button.y ;

            if (mx>xr+enbar || mx<xl || my<yt || my>yb) goto stokalo ;
        
            
        } // Τελος Button Right
        
        case SDL_KEYDOWN:
            ch_scan=sdlev.key.keysym.scancode;
                        
                    switch (ch_scan) { 
                        
        case SDL_SCANCODE_ESCAPE :  
                    fyge=1 ; break ;
                    
        case SDL_SCANCODE_UP :
                    
            if (!cur) continue;
            
            if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
            diaf2=1 ;
            f=cur;
            while (pos[f][1]>=yt) f--;
            while ( (pos[f][1] >=(yt-diaf2*bh)) && (f>=0) ) f--;
            f++; cur=f ;
            diaf1=yt-pos[f][1]; diaf1 /= bh;
            for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
            x1=x=xl ; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
           
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ;
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor (COLOR (red,green,blue));
            _putpixel(x1+i , y1+f);}}
            }

            refresh();
            
            goto barovios ;                
            
        case SDL_SCANCODE_DOWN :
    
            if (cur==ar) continue;

            if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
            diaf2=1 ;
            
            f=cur;
            while (pos[f][1] > yt) f--;
            while (pos[f][0] !=xl) f--;
            while ( pos[f][1]<(yt+diaf2*bh) ) f++;
            cur=f;
            for (i=0;i<=ar;i++) pos[i][1]-=(diaf2*bh);
            x1=x=xl; y1=y=yt;
            // ANADIATAJH 
            setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
            for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
            
            
            for (a=cur; a<ar; a++) {
            what=str[a];
                
            if (what==200) continue ;
            x1=pos[a][0]; y1=pos[a][1];
            if (y1>=ektos) break ; 
            mem_int=gouv[what].where ;
            for(f=0; f<gouv[what].hei ; f++) {
            for(i=0;i<gouv[what].wid;i++) {
            co.lor = *mem_int++;
            if (!co.lor) continue;
            neg=255-co.rgb[0];
            red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
            green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
            blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
            setcolor(COLOR (red,green,blue));
            
            _putpixel(x1+i , y1+f);}}
            }
            
            refresh();
                          
            goto barovios ;
        
        case SDL_SCANCODE_PAGEDOWN :
PAGEDOWN :
                
                    if (cur==ar) continue;

                    if (pos[ar][1]<ektos ) {cur=ar; x=pos[ar][0]; y=pos[ar][1]; continue ;}
                    
                    
                    f=cur;
                    while (pos[f][1]<ektos) f++;
                    cur=f;
                    for (i=0;i<=ar;i++) pos[i][1]-=(maxline*bh);
                    x1=x=xl; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                                        
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ; 
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                    goto barovios ;
                    
                        case SDL_SCANCODE_PAGEUP :
PAGEUP :

                    if (!cur) continue;

                    if (pos[0][1]==yt) {cur=0; x=xl ; y=yt; continue;}
                
                    f=cur;
                    while (pos[f][1]>=yt) f--;
                    while ( (pos[f][1] >=(yt-maxline*bh)) && (f>=0) ) f--;
                    f++; cur=f ;
                    diaf1=yt-pos[f][1]; diaf1 /= bh;
                    for (i=0;i<=ar;i++) pos[i][1] += (diaf1*bh);
                    x1=x=xl ; y1=y=yt;
                    // ANADIATAJH 
                    setcolor (COLOR(cobkxr[0],cobkxr[1],cobkxr[2]));  
                    for (i=xl;i<=xr;i++) {for (f=yt ; f<=yb; f++) _putpixel (i,f);}
                    
                    for (a=cur; a<ar; a++) {
                    what=str[a];
                        
                    if (what==200) continue ;
                    x1=pos[a][0]; y1=pos[a][1];
                    if (y1>=ektos) break ;
                    mem_int=gouv[what].where ;
                    for(f=0; f<gouv[what].hei ; f++) {
                    for(i=0;i<gouv[what].wid;i++) {
                    co.lor = *mem_int++;
                    if (!co.lor) continue;
                    neg=255-co.rgb[0];
                    red =  abs( (cochxr[0]*co.rgb[0]/255) - (cobkxr[0]*neg/255) );
                    green =  abs( (cochxr[1]*co.rgb[0]/255) - (cobkxr[1]*neg/255) );
                    blue =  abs( (cochxr[2]*co.rgb[0]/255) - (cobkxr[2]*neg/255) );
                    setcolor(COLOR (red,green,blue));
                    
                    _putpixel(x1+i , y1+f);}}
                    }

                    refresh();
                                    
    barovios :
    if ( (!bar) ) {
                        proyt=abs(pos[0][1]-yt) ;
                        metektos = pos[ar][1]- yt - ( (maxline-1)*bh );
                        
                        if ( (!proyt) && (metektos<=0) ) continue ;
                        bar=1;
                        setcolor (COLOR (0,255,0) );  
                        rectangle (xr+2,yt-1,xr+13,yb);
                        setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                        olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                        y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                        y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;
                        bary1=y1 ; bary2=y2;
                        setcolor (COLOR (255,165,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                        refresh();
                        continue ;
                                }
            else
                                {
                proyt1=abs(pos[0][1]-yt) ;
                metektos1 = pos[ar][1]- yt - ( (maxline-1)*bh );
                if ( (!proyt1) && (metektos1<=0) ) {
                putimage (xr+2,yt-1,mem_bar,0);
                bar=0;
                continue ;}
                if (proyt1==proyt && metektos1==metektos) continue;
                proyt=proyt1 ; metektos=metektos1;
                olohei = (metektos<=0) ? proyt+maxline*bh : proyt+maxline*bh+metektos ;
                setcolor (COLOR (0,0,0) );  
                        for (f=xr+3 ; f<xr+13 ; f++) {
                            for (i=yt ; i < yb; i++) _putpixel (f,i); }
                y1 = ( ( (yb-yt-1)*proyt) / olohei ); y1+= yt;
                y2=( ( (yb-yt-1)*maxline*bh) / olohei ); y2+=y1;     
                bary1=y1 ; bary2=y2;
                setcolor (COLOR (255,165,0) );  
                for (f=xr+3 ; f<xr+13 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                    continue;     
                    
                    }                         // END switch ch_scan and case SDL keydown
                    
        case SDL_WINDOWEVENT :
        refresh(); continue;
        
        case SDL_QUIT :
            fyge=1 ; break ;
            
        }                                    // END sdlev type 

        
    } while (!fyge);

stokalo :
if (bar==1) putimage (xr+2,yt-1,mem_bar,0);
if (mem_bar) free (mem_bar);
refresh();
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
setcolor(COLOR(cobkxr[0], cobkxr[1], cobkxr[2]));
rectangle (xl,yt,xr,yb);
refresh();
gouv=whouv;
return cur ;
}



int filehelp_show(short int font, char *filename, char *helpname, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr )
// Καλείται για να εμφανίσει βοήθεια. Διαβάζει αρχείο από το δίσκο...
// Καλεί την hlp_txt_scroll

{

SDL_Cursor* cursor;
struct fansouv *whouv;
FILE *fp;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 , *mem_drag=0;
void *mem_zer=0 ;
int *mem_int ;

int cbrown[3] , chrprnt[3];
short int width , height ;
int xt1,yt1, xb1,yb1 ;
unsigned short int xt, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int ar , proenter , xok , yok , drax, dray, cur=0 ;
unsigned short int fyge , marrs , drag, yicob ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned char ektos=1 , entos=0 ;
unsigned char str[60000];

sprintf(file_1,"%sHelp/%s",path_name,filename);
fp=fopen(file_1,"rb");
if (fp!=NULL) {
    i=0;
    fread (&what,1,1,fp);
    do {
        if (what<164 || what==200) {str[i++]=what ;}
        fread(&what,1,1,fp);
    }while (what!=255 && i<59999);
    str[i]=255;
    fclose(fp);
    fp=NULL;
}
else {
     information(6-keyb_gr,file_1,0);
     return 0;
}

whouv=gouv ;
ar=i;

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
width=500 ; height=300;
size=imagesize(0,0,width-1,height-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while (yt1+height > info.bottom) yt1--;
yt=yt1+19;  yb=yt1+height-1;
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
xok=xt+(width-35)/2 ; yok=yb-46;
yicob = yb-9;
drax=xb-40 ; dray=yok+8;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/All_directions.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 


_puticon(xt+1,yt1+1,mem_arrs,255);

normtext_tomy(helpname,str1024);
_outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);

_bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

refresh();
proenter=fyge=marrs=drag=0;
cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev) ) continue;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //PONTIKI MESA STO HELP_SHOW
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        ektos=1 ;
        if (entos) continue ;
        entos=1;
        cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
        if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
        continue;
    }
    
    entos=0;
    // PONTIKI EKTOS ΒΟΗΘΕΙΑΣ
                                 
    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
            
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
    
        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
    marrs=0;
    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}


        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
    ektos=0;
    
    if (!drag) {
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    drag=1;
    putNOTicon(drax,dray,mem_drag);
    if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    continue ;}
    else continue ;

    }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; 
        //klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
              
       
        if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; 
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            continue ;
                              
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+height-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            refresh();
            continue ;
        }
        
        else if (drag) {
            xt1=xt;
            xb1=xb; 
            yb1=yb ;
            change_dim(xt1, yt1 , &xb1 , &yb1);
            if (xb1-xt1<200) xb1= xt1+199 ;
            if( yb1-yt1<200) yb1=yt1+199 ;
            width=xb1-xt1+1 ; height=yb1-yt1+1;

            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            refresh();
            free(mem0); mem0=0;
            
            size=imagesize(0,0,width-1,height-1);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); goto FYGE ;}

            while (yt1+height > info.bottom) yt1--;
            yt=yt1+19;  yb=yt1+height-1;
            while (xt+width>info.right) xt--;
            xb=xt+width-1 ;

            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            _areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            _puticon(xt+1,yt1+1,mem_arrs,255);

             normtext_tomy(helpname,str1024);
            _outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);


            _bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

            _puticon (xok,yok,mem_ok,255);
            
            _puticon(drax,dray,mem_drag,255);
            
            refresh();
            cur=0;
            cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
            if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
          switch (sdlev.key.keysym.scancode) {
           
            
            case SDL_SCANCODE_RETURN :     
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                            
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
    case SDL_QUIT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                fyge=1;
        continue ;
        
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);
 if (mem_small) hide_help(hdhlpxt , hdhlpyt);
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return 1 ;
}



int change_hei(int xl, int yt ,int mxright , int *mybottom)
{
SDL_Cursor* cursor;
int myb , pryb ;
unsigned int size ;
void *mem1=NULL ;
register int i,f ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);

pryb=*mybottom;
size=imagesize (xl,yt,mxright,info.bottom);
mem1=malloc(size);
if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);return -1;}
getimage (xl,yt,mxright,pryb,mem1);
setcolor (COLOR(255,0,0)) ;  
rectangle (xl,yt,mxright,pryb);
setcolor (COLOR(255,255,0)) ;  
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<mxright; f+=3) _putpixel (f,i);}
refresh();

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       //SDL_GetRelativeMouseState (&mxr , &myb);
       myb = sdlev.motion.y ;
       if (myb<=yt) continue;
       if (myb>info.bottom) myb=info.bottom;
       if (myb==pryb) continue;
        putimage (xl,yt,mem1,0); 
        pryb=myb;
        getimage (xl,yt,mxright,myb,mem1);
        setcolor (COLOR(255,0,0)) ;  
        //rectangle (xl,yt,mxr,myb);
        for(f=xl;f<=mxright;f++) {_putpixel(f,yt); _putpixel(f,myb);}
        for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxright,i);}
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxright; f+=4) _putpixel (f,i);} refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
       
     do {SDL_PollEvent(&sdlev);} while (SDL_PollEvent(&sdlev));
     putimage (xl,yt,mem1,0); free(mem1);
    *mybottom=pryb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return 1;
}

void _outfanis_colxr(unsigned int font, char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *cchxr, int *cbkxr)
{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 , neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

    what=str[a];
    while (what!=255 && what!=200) {
    if ( x> (xr-gouv[what].wid) ) break;
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (cchxr[0]*co.rgb[0]/255) - (cbkxr[0]*neg/255) );
    green =  abs( (cchxr[1]*co.rgb[0]/255) - (cbkxr[1]*neg/255) );
    blue =  abs( (cchxr[2]*co.rgb[0]/255) - (cbkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
}



int dbfield_show_button(void *mem_str, unsigned char *data, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom)
// Η συνάρτηση info_dbfdata ενημερώνει την καθολική δομή dbfdata η οποία παρέχει το δείκτη mem_str (dbfdata.mem_fd) που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name (επικεφαλίδα του button). Εδώ παρέχεται και ο sort_type ανάλογα τον τύπο του πεδίου !
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα γίνεται search ή όχι !!
{
FILE * fp, *fpex ;
time_t cardwhen_1;
struct fansouv *whouv;
SDL_Cursor* cursor;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0 , *mem_extrael=0 , *mem_deigma_text = 0 ;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0 , *mem_drag=0;
void *mem_fonter=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3];
unsigned short int *ar_dom;
short int bima ,width , cur , cur_wid;
int xt1,xb1,yb1 ,kati ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int  key , key_1, sort , sort_1, bar, proenter , xok , yok , protyx , plbut , pano , pano_1, kato , telos , telos1, metektos , metektos1 ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa , low ,karta ,fonter ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ,  el , elem , proelem , c ;
unsigned char what ;
unsigned int size , size1 , photo_alma , ped_alma ,size2 ;
unsigned char *but[dbplgr] , *str  , keyword[30], redline , krit[dbplgr] , extra_data=0;
short int by , rby , w , newsea=0 , photo_ped ;
Uint8 klik;
int  a1 , a , k , proyt , proyt1 , bary1, bary2, y1, y2 ,y3 ,pa=-1 ;  
unsigned short int extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb ;
short int drax , dray , buthei , newhei , drag , xfo ;
short int sparky ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

unsigned char nu[4];

unsigned int *Gitem , Gidb, Gi[3] ;
long int *Litem , Lidb, Li[3] ;
double *Fitem , Fidb, Fi[3] ;

unsigned char *deigma_text;
unsigned char deigma1_text[22] , neodeigma1_text[22] , deigma2_text[22] ;

unsigned char deigma [3][26] , neodeigma [3][26] ;

static unsigned short int xt;
static int yt1;
static short int lines ;
char str1024a[1024];
unsigned char ektos=1;
char keno[10];
int xrcl[3] , slcl[3] , xrep[3] ;
unsigned short int fhe , sGidb, sG ;
static short int fo ;
static short int fnt ;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);
key_1=sort_1=65000;
deigma2_text[0]=255;

if (!fo && !fnt) fnt=4;

for (f=0;f<3;f++) {
    deigma[f][0]=255;
    neodeigma[f][0]=255;
}
deigma1_text[0]=255;
neodeigma1_text[0]=255;

whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=dbplgr;
i=0; a=0;   

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f] == 255) {
       but[i++]=mem_str+a;
       a=f+1; 
        }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) {ar_dom[f]=f; krit[f]=0;}

if (key) {
    switch (sort_type) {
    
        case 6 : // Ημερομηνία
            
            item_mem=malloc(plbut*4);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Gitem=item_mem;
            for (f=0;f<plbut;f++) {
                cardiary.ldate=0;
                if (but[f][0] !=255) {
                mytext_tonorm(but[f],str1024,50);
                w=strlen(str1024);
                for (i=0;i<4;i++) {
                    nu[i]= str1024[w-i-1] - '0' ;
                }
                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                //dysena.wotim -= 1900;
                cardiary.mydate[3]=dysena.dyomikra[1];
                cardiary.mydate[2]=dysena.dyomikra[0];

                nu[0]=  str1024[w-6] - '0' ;
                nu[1]=  str1024[w-7] -  '0';
                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                nu[0]=  str1024[w-9] - '0' ;
                nu[1]=  str1024[w-10] - '0' ;
                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                        }
                Gitem[f]=cardiary.ldate ;
            }
            pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 3 :  // Ακέραιος αριθμός
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Litem=item_mem;
            for (f=0;f<plbut;f++) {
                Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 4: // Φλοατ
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Fitem=item_mem;
            for (f=0;f<plbut;f++) {
                Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;            
            
        case 0:
        case 1:
        case 2:
            
            item_mem=malloc(plbut*24);
            if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
            item=item_mem;
            for (f=0;f<plbut;f++) {
                bitem[0].big=bitem[1].big=bitem[2].big=0;
                i=0;by=23;
                do {
                what=but[f][i];
                if (what>163) break;
                if (keyb_gr){
                        switch (what) {

                            case 96:
                            case 101:
                            case 104:
                            case 107:
                            case 116:
                            case 122:
                            case 129:
                            case 132:
                            case 137:
                            case 140:
                            case 143:
                            case 151:
                            case 157:
                            case 163:
                            what--;
                            break;

                            case 108:
                            case 123:
                            case 144:
                            case 158:
                            what-=2;
                            break;


                            case 109:
                            case 124:
                            what-=3;
                            break;

                            case 130:
                            what=119;

                        }

                }
                rby=by%8; low=(2-(by/8));
                //if (by>7) {low=0;rby=by-8;} else low=1;
                bitem[low].sma[rby]=what;
                by-- ; i++;
                } while (by>=0);
                item[f].fg=bitem[0].big;
                item[f].sg=bitem[1].big;
                item[f].tg=bitem[2].big;
            }

            pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
        }
    }

    // Το photo_alma αν είναι 0 τότε δεν υπάρχει φώτο !!!
photo_alma=size1=0;
for (f=0;f<=dbfinum;f++) {
    if (ptr_pedio[f]->fitype==5) {photo_alma=size1; photo_ped=f; break;}
    size1+=xlimk[f];
    }
    
ped_alma=size1=size2=0;
for (f=0;f<=dbfinum;f++) {
    if (dbfdata.fd_arped==f) ped_alma=size1; 
    size1 += xlimk[f];
    if (size2<xlimk[f]) size2=xlimk[f];
    // if (ptr_pedio[f]->fitype < 3) multicr[f]->cron_1=0;
    }
    
    mem_deigma_text = malloc(size2);
    if (!mem_deigma_text) {information (2-keyb_gr,0,0); goto FYGE; }
    deigma_text=mem_deigma_text;
    
cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; 
}
while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
xfo=xb-19;
_areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);


// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);

chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
slxr[0]=0; slxr[1]=0; slxr[2]=186;
xrep[0]=xrep[1]=255 ; xrep[2]=0;
slcl[0]=slcl[1]=255 ; slcl[2]=0;
xrcl[0]=xrcl[1]=xrcl[2]=0;
_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
refresh();

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 


if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ 
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;drag=0;fonter=0;
protyx=tyx=lines; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev)) continue ;    
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός (lines) επιλογών !!
        
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
       
     tyx=(my-ytepl)/fhe;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 25 δείγματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);  
          ektos=1;
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                 if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                if (extra_data) {
                    putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                    extra_data=0; free (mem_extrael); mem_extrael=0;
                }
                refresh();
                protyx=lines;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
          ektos=0;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1,ytepl+tyx*fhe,xtepr-1, ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1,ytepl+tyx*fhe,xtepr-1, ytepl+tyx*fhe+(fhe-2),slxr);
         if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS (lines) EPILOGVN
    
    if (protyx!=lines && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
         if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);        
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κριτηρίων αναζήτησης / Αριστερό κλικ : Αναζήτηση", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Criteria / Left Click : Search", xdel, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
    if (keyb_gr) show_help("Ταξινόμηση των στοιχείων ή, εμφάνιση σύμφωνα με την άυξουσα σειρά των καρτελών", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Data sorting or , display according to the DB cards order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
      ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
        if (probar) probar=0;
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
         if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt+1, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt+1, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
            ektos=0;
            if (probar) probar=0;
            else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
            
            if (!drag) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            drag=1;
            putNOTicon(drax,dray,mem_drag);
            if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
            else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
            continue ;}
            else continue ;

        }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}        
    
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
         
        
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    if (ektos) continue ;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);}
   continue;
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (52-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) { // Ρύθμιση Αναζήτησης ανάλογα τον τύπο !
                // Right Click !!
                newsea=1;
                switch (sort_type) {

                    case 6 : // Ημερομηνία
                        user_ans=input_dbsearch_date(neodeigma[0],neodeigma[1],neodeigma[2],dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                        
                    case 3 :  // Ακέραιος αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],3, dbfdata.fd_arped);

                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                    
                    case 4 :  // Δεκαδικός αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],4,dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}

                        goto FROMNEWSEARCH;
                        
                    case 0 :
                    case 1 :
                    case 2 :
                        user_ans=input_dbsearch_text(neodeigma1_text , dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                        
                        red=mystrcmp (deigma1_text,neodeigma1_text);
                        if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                        
                        goto FROMNEWSEARCH;
                }
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!fonter) ) { // Επιλογή κάποιου από τα κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
        elem=proelem=-1 ; 
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
         if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }
            protyx=lines;
            refresh();
            continue ;
        }

        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slcl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrcl, slcl );
        _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrcl, slcl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }
        proelem=elem;
        refresh(); 
        
        if (dbfdata.fd_arped != dbkey) { // Αν το πεδίο που ελέγχεται δεν είναι το κλειδί τότε θα εμφανίζεται και το κλειδί , ma αν δεν υπάρχει κλειδί τότε η πρώτη  φώτο ...αλλιώς τίποτε !!
            karta=ar_dom[elem];                        
            dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + alma_deigma) , 0);
            if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ; extra_data=0; goto NOTHINGELSE ;} // Να δω το break ...
            if (dbkey!=100) { // Αν έχουμε ένα πεδίο χρήστη ως κλειδί ...
                cur= (ptr_pedio[dbkey]->fiorio < 24) ? ptr_pedio[dbkey]->fiorio : 24 ; 
                fread (keyword , 1 , cur , fpcard);
                keyword[cur]=255;
                extra_data =1;
            }
            else if (photo_alma) { // το dbkey είναι η σειρά εγγραφής οπότε ψάχνω για φώτο !

                karta=ar_dom[elem];                        
                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
                fread(str1024a,1,1024,fpcard);
                what=str1024a[0];
                extra_data = (what!=255) ? 2 : 0 ;
            }
            
            else extra_data=0;
        }
        else { // To πεδίο που ελέγχεται είναι το κλειδί οπότε ψάχνω για φώτο...
            
            if (photo_alma) { 

                karta=ar_dom[elem];                        
                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + photo_alma) , 0);
                fread(str1024a,1,1024,fpcard);
                what=str1024a[0];
                extra_data = (what!=255) ? 2 : 0 ;
            }
            else extra_data=0;
        }

        if (extra_data == 1) { 
            cur_wid=0;f=0;
            what=keyword[0];
            if (what == 255) {
                if (keyb_gr) normtext_tomy ("Κενό Κλειδί !" , keyword ) ;
                else normtext_tomy ("Empty Key!" , keyword ) ;
            }
            if ( (ptr_pedio[dbkey]->fivar[2]) || (ptr_pedio[dbkey]->ficode) ){
                if (keyb_gr) normtext_tomy ("Κρυμμένο..ή με κωδικό !",keyword) ;
                else  normtext_tomy ("Hidden..or needs password!",keyword) ;
            }
            what = keyword[f];
            while (what != 255) {
                cur_wid += gouv[what].wid;
                what = keyword[++f];
            }
                extra_data=1;
                dx=info.right-xb-11; // Δεξιά μεριά
                dy=xt-info.left; // Αριστερή μεριά
                extra_elem_xt = (dx>dy) ? xb+11 : xt-cur_wid-3 ;
                extra_elem_yt = ytepl+protyx*fhe ;
                extra_elem_xr = extra_elem_xt + cur_wid +3 ;
                extra_elem_yb = extra_elem_yt + (fhe-1) ;
                
                mem_extrael = malloc ( imagesize ( extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb ) ) ; 
                if (!mem_extrael) {information(2-keyb_gr,NULL,NULL); extra_data=0; goto NOTHINGELSE ;}
                getimage(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb,mem_extrael);
                setrgbcolor(dbyel);
                rectangle(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb) ;
                _bareacls(extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1,ptr_pedio[dbkey]->fibkxr);
                _outmystr_center_col(fnt,keyword,extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1,ptr_pedio[dbkey]->fichxr, ptr_pedio[dbkey]->fibkxr);
                refresh();
        }

        else if (extra_data==2) {

            dx=info.right-xb-11; // Δεξιά μεριά
            dy=xt-info.left; // Αριστερή μεριά
            extra_elem_xt = (dx>dy) ? xb+11 : xt-162 ;
            extra_elem_yt = ytepl+protyx*fhe ;
            while (extra_elem_yt+162>info.bottom) extra_elem_yt--;
            extra_elem_xr = extra_elem_xt + 161 ;
            extra_elem_yb = extra_elem_yt + 161 ;
            mem_extrael = malloc ( imagesize ( extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb ) ) ;
            if (!mem_extrael) {information(2-keyb_gr,NULL,NULL); extra_data=0; goto NOTHINGELSE ;}
            getimage(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb,mem_extrael);
            setrgbcolor(dbyel);
            rectangle(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb) ;
            if ( (ptr_pedio[photo_ped]->fivar[2]) || (ptr_pedio[photo_ped]->ficode) ) _bareacls(extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1, ptr_pedio[photo_ped]->fibkxr);
            else {
                fpex=fopen(str1024a,"r");
                if (fpex!=NULL) {
                    fclose(fpex);
                    readimagefile(str1024a,extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1);
                }
            }
            refresh();
        }
NOTHINGELSE:
        if (klik>1) {
             if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
                refresh();
            }
            goto DIPLO_KLIK ;}
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
            refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) { // Αναζήτηση με βάση προηγούμενο δεξί κλικ ...
FROMNEWSEARCH :
            a1=0;
            switch (sort_type) {

                case 3:
                case 4:
                case 6:
            
                    for (f=0;f<3;f++) {
                        if (deigma[f][0]!=255) {a1=1; break ;}}
                
                break ; 
            
                case 0:
                case 1:
                case 2:
                    
                    if (deigma1_text[0]!=255) a1=1;
                
                break ;
            }
            
            if (!a1) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                    if (protyx!=lines) { 
                        el= (sort) ? pano-protyx : pano+protyx;
                        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                        if (extra_data) {
                            putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                            extra_data=0; free (mem_extrael); mem_extrael=0;
                        }
                        refresh();
                        elem=proelem=-1 ; 
                        protyx=lines;
                    }
                    
                    pa=pano;
                    telos1=(sort) ? pa+1 : plbut-pa ;
                    setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                    k=0;
                    do {
                            if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1));
                    pa+=bima ; telos1--; k++;
                    }while (telos1 && k<lines);
                    refresh();

                for (f=0;f<plbut;f++) krit[f]=0;
                redline=0; 
                if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
                newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) continue ;
                prodel=0; puticon (xdel,ydel,mem_del,255);
                continue ;}
                
                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    if (extra_data) {
                        putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                        extra_data=0; free (mem_extrael); mem_extrael=0;
                    }
                    refresh();
                    elem=proelem=-1 ; 
                    protyx=lines;
                }
            
            if (redline) {
                redline=1;
                if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                    c= pano + (bima*lines) ;
                    if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                    if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                    telos=(sort) ? c+1 : plbut-c;
                    if (!sort) {
                        if (c<0) {c=0 ; telos=plbut;}
                        else if ((c+lines)>plbut) {
                            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
                    else if (sort) {
                        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                        else if ( (c-lines+1)<0 ) { 
                            c=lines-1; telos=lines; 
                            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                            pano=c; telos=(sort) ? c+1 : plbut-c;
                }
                //pano_1=pano ; sort_1=sort ; key_1=key;
                telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;} 
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                }
                else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos= (sort) ? c+1 : plbut-c ;
                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            else {
                
                // Μετατροπή των αλφαριθμητικών στοιχείων που εισήχθηκαν για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                switch (sort_type) {
                    
                    case 6 : // Ημερομηνία
                        
                        for (f=0;f<3;f++) {
                            cardiary.ldate=0;
                            if (deigma[f][0] !=255) {
                            mytext_tonorm(deigma[f],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                            Gi[f]=cardiary.ldate ; // unsigned int Gi1
                            }
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            
                            for (f=0;f<3;f++){
                            Li[f]=(deigma[f][0]!=255) ? (long int) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            for (f=0;f<3;f++){
                                Fi[f]=(deigma[f][0]!=255) ? (double) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            mystrcpy (deigma2_text , deigma1_text);
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                    switch (sort_type) {
                        
                        case 6 : // Ημερομηνία
                            // Μετατρέπει στοιχεία λίστας  !
                            cardiary.ldate=0;
                            mytext_tonorm(but[pa],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                            
                            Gidb=cardiary.ldate ; // unsigned int Gi
                            
                        // ΣΥΓΚΡΙΣΗ !!
                           
                            if (deigma[0][0] !=255) {
                                sGidb=(unsigned short int) Gidb ; 
                                sG= (unsigned short int) Gi[0];
                                if (sGidb == sG ) { krit[pa]=1; pa++; continue ; }
                                //if ( Gidb==Gi[0] ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Gidb>Gi[1]) && (Gidb<Gi[2]) ) {krit[pa]=1; pa++; continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Gidb>Gi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Gidb<Gi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            // Συγκριση
                                                       
                            Lidb= (long int) convert_str( 15 , but[pa] ) ;
                            
                            if (deigma[0][0] !=255) {
                                    if ( Lidb==Li[0] ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Lidb>Li[1]) && (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Lidb>Li[1]) ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            Fidb= (double) convert_str(15 , but[pa]) ; 

                            if (deigma[0][0] !=255) {
                                if ( Fidb==Fi[0] ) {krit[pa]=1; pa++; continue;} 
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Fidb>Fi[1]) && (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Fidb>Fi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma_text μπορεί να διαβάζεται από το δίσκο ή όχι αναλόγως το μέγεθος - θα πάρει το μεγάλο στριγκ από το αντίστοιχο της λίστας

                            if (limk[dbfdata.fd_arped] < 46) mystrcpy (deigma_text,but[pa]);
                            else {
                                //karta=ar_dom[pa];                        
                                fseek(fpcard , ((disk_dom[pa] * dbcardsize) + ped_alma) , 0);
                                fread(deigma_text,1,limk[dbfdata.fd_arped],fpcard);
                            }
                            i=0;
                            while (deigma_text[i]!=255) i++;

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma_text[f]=128;
                                        break;

                                        case 130:
                                        deigma_text[f]=119;
                                    }
                                }
                                if ( (deigma_text[f]>68) && (deigma_text[f]<95) ) deigma_text[f]-=26;
                            }
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=deigma_text[i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=deigma_text[i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    }
                }
            }
         
            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d καρτέλες!", i);
                else sprintf(str1024,"Identity occurred in %d DB cards!", i);
                if (ptr_pedio[dbfdata.fd_arped]->fitype < 3) {
                    mystrcpy ( multicr[dbfdata.fd_arped]->sample_tcode , deigma1_text );
                    mystrcpy (normdeigma[dbfdata.fd_arped] , deigma2_text) ;
                    multicr[dbfdata.fd_arped]->cron_1=1;
                }
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+bima*f;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;} 
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+bima*f;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;
                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;
            SDL_PollEvent(&sdlev);
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
            prodel=0; puticon (xdel,ydel,mem_del,255);
            goto emfan;
        }
        
        else if (profrba) {  // Από πάνω προς τα κάτω ή αντίστροφα !!
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            elem=proelem=-1 ; 
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        
if (key) {
    
    switch (sort_type) {
    
        case 6 : // Ημερομηνία
            
            item_mem=malloc(plbut*4);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Gitem=item_mem;
            for (f=0;f<plbut;f++) {
                cardiary.ldate=0;
                if (but[f][0] !=255) {
                mytext_tonorm(but[f],str1024,50);
                w=strlen(str1024);
                for (i=0;i<4;i++) {
                    nu[i]= str1024[w-i-1] - '0' ;
                }
                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                //dysena.wotim -= 1900;
                cardiary.mydate[3]=dysena.dyomikra[1];
                cardiary.mydate[2]=dysena.dyomikra[0];

                nu[0]=  str1024[w-6] - '0' ;
                nu[1]=  str1024[w-7] -  '0';
                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                nu[0]=  str1024[w-9] - '0' ;
                nu[1]=  str1024[w-10] - '0' ;
                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                        }
                Gitem[f]=cardiary.ldate ;
            }
            pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 3 :  // Ακέραιος αριθμός
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Litem=item_mem;
            for (f=0;f<plbut;f++) {
                Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 4: // Φλοατ
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Fitem=item_mem;
            for (f=0;f<plbut;f++) {
                Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;            
            
        case 0:
        case 1:
        case 2:
            
            item_mem=malloc(plbut*24);
            if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
            item=item_mem;
            for (f=0;f<plbut;f++) {
                bitem[0].big=bitem[1].big=bitem[2].big=0;
                i=0;by=23;
                do {
                what=but[f][i];
                if (what>163) break;
                if (keyb_gr){
                        switch (what) {

                            case 96:
                            case 101:
                            case 104:
                            case 107:
                            case 116:
                            case 122:
                            case 129:
                            case 132:
                            case 137:
                            case 140:
                            case 143:
                            case 151:
                            case 157:
                            case 163:
                            what--;
                            break;

                            case 108:
                            case 123:
                            case 144:
                            case 158:
                            what-=2;
                            break;


                            case 109:
                            case 124:
                            what-=3;
                            break;

                            case 130:
                            what=119;

                        }

                }
                rby=by%8; low=(2-(by/8));
                //if (by>7) {low=0;rby=by-8;} else low=1;
                bitem[low].sma[rby]=what;
                by-- ; i++;
                } while (by>=0);
                item[f].fg=bitem[0].big;
                item[f].sg=bitem[1].big;
                item[f].tg=bitem[2].big;
            }

            pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
        }
    }

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
                refresh();
            }
            
            if (elem!=-1) {
                 kati=ar_dom[elem];
                if (ptr_pedio[dbfdata.fd_arped]->fitype < 3) {
                    if ( (krit[kati]) && (deigma1_text[0] != 255) ) {
                        mystrcpy ( multicr[dbfdata.fd_arped]->sample_tcode , deigma1_text );
                        mystrcpy (normdeigma[dbfdata.fd_arped] , deigma2_text) ;
                        multicr[dbfdata.fd_arped]->cron_1=1;
                    }
                }
                   
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            if (extra_data) {
            putimage (extra_elem_xt , extra_elem_yt , mem_extrael , 0);
            free (mem_extrael); mem_extrael=0;
            refresh();
            }
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ; 
            xfrba = (delon) ? xdel+55 : xdel+2 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            
                if (extra_data == 1) { 

                        dx=info.right-xb-11; // Δεξιά μεριά
                        dy=xt-info.left; // Αριστερή μεριά
                        extra_elem_xt = (dx>dy) ? xb+11 : xt-cur_wid-3 ;
                        extra_elem_yt = ytepl+protyx*fhe ;
                        extra_elem_xr = extra_elem_xt + cur_wid ;
                        extra_elem_yb = extra_elem_yt + (fhe-1) ;
                        
                        mem_extrael = malloc ( imagesize ( extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb ) ) ; 
                        if (!mem_extrael) {information(2-keyb_gr,NULL,NULL); extra_data=0; continue ;}
                        getimage(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb,mem_extrael);
                        setrgbcolor(dbyel);
                        rectangle(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb) ;
                        _bareacls(extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1,ptr_pedio[dbkey]->fibkxr);
                        _outmystr_center_col(fnt,keyword,extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1,ptr_pedio[dbkey]->fichxr, ptr_pedio[dbkey]->fibkxr);
                        refresh();
                }

                else if (extra_data==2) {

                    dx=info.right-xb-11; // Δεξιά μεριά
                    dy=xt-info.left; // Αριστερή μεριά
                    extra_elem_xt = (dx>dy) ? xb+11 : xt-162 ;
                    extra_elem_yt = ytepl+protyx*fhe ;
                    while (extra_elem_yt+162>info.bottom) extra_elem_yt--;
                    extra_elem_xr = extra_elem_xt + 161 ;
                    extra_elem_yb = extra_elem_yt + 161 ;
                    mem_extrael = malloc ( imagesize ( extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb ) ) ;
                    if (!mem_extrael) {information(2-keyb_gr,NULL,NULL); extra_data=0; continue ;}
                    getimage(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb,mem_extrael);
                    setrgbcolor(dbyel);
                    rectangle(extra_elem_xt , extra_elem_yt , extra_elem_xr , extra_elem_yb) ;
                    if (ptr_pedio[photo_ped]->fivar[2]) _bareacls(extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1, ptr_pedio[photo_ped]->fibkxr);
                    else {
                    fpex=fopen(str1024a,"r");
                        if (fpex!=NULL) {
                            fclose(fpex);
                            readimagefile(str1024a,extra_elem_xt+1 , extra_elem_yt+1 , extra_elem_xr-1 , extra_elem_yb-1);
                        }
                    }
                    refresh();
                }
            
            continue ;
        }
        
        else if (drag) {
            drag=0;
            if (extra_data) {
            putimage (extra_elem_xt , extra_elem_yt , mem_extrael , 0);
            free (mem_extrael); mem_extrael=0;
            extra_data=0;
            refresh();
            }
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;

            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);

            _puticon(xfo,yt-18,mem_fonter,255);
            
            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        

        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            if (user_ans<0) continue;
            fo=1;
            if (extra_data) {
            putimage (extra_elem_xt , extra_elem_yt , mem_extrael , 0);
            free (mem_extrael); mem_extrael=0;
            extra_data=0;
            refresh();
            }
            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) c=plbut-1; telos=plbut; }}
            
    pano=c;
    do {                                           
        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
         if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        // if ((!sort) && (pano==a1)) continue;
        // else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            if (extra_data) {
                putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                extra_data=0; free (mem_extrael); mem_extrael=0;
            }
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; 
               telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima;
               telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            sparky=0;        
            pano=c;
            do {                                           
                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                if (krit[ar_dom[c]]) {sparky=1;setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);
            refresh();
            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;
            
barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                if (extra_data) {
                    putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                    extra_data=0; free (mem_extrael); mem_extrael=0;
                    refresh();
                }
                
                if (elem!=-1) {

                 kati=ar_dom[elem];
                if (ptr_pedio[dbfdata.fd_arped]->fitype < 3) {
                    if ( (krit[kati]) && (deigma1_text[0] != 255) ) {
                        mystrcpy ( multicr[dbfdata.fd_arped]->sample_tcode , deigma1_text );
                        mystrcpy (normdeigma[dbfdata.fd_arped] , deigma2_text) ;
                        multicr[dbfdata.fd_arped]->cron_1=1;
                    }
                }
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
                if (extra_data) {
                    putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
                    extra_data=0; free (mem_extrael); mem_extrael=0;
                    refresh();
                }
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
    case SDL_QUIT :
            fyge=1;
        if (extra_data) {
            putimage(extra_elem_xt , extra_elem_yt , mem_extrael , 0);
            extra_data=0; free (mem_extrael); mem_extrael=0;
            refresh();
        }
        kati=-2;
        continue;
                
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if (item_mem) free (item_mem);
if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_drag) free(mem_drag);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_fonter) free(mem_fonter);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
if (mem_extrael) free (mem_extrael) ;
if (mem_deigma_text) free (mem_deigma_text);
if(dbfdata.mem_fd) { free(dbfdata.mem_fd); dbfdata.mem_fd=0;}
refresh();
gouv=whouv;
return kati ;
}



int mystr_show(short int font, unsigned char *mystr, char *headername, unsigned short int moux, unsigned short int mouy, int *cochxr , int *cobkxr )
// Καλείται για να εμφανίσει όμορφα ένα κείμενο δικό μου (char *mystr). 
// Καλεί την hlp_txt_scroll

{

SDL_Cursor* cursor;
struct fansouv *whouv;
FILE *fp;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 , *mem_drag=0;
void *mem_zer=0 ;
int *mem_int ;

int cbrown[3] , chrprnt[3];
short int width , height ;
int xt1,yt1, xb1,yb1 ;
unsigned short int xt, yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int ar , proenter , xok , yok , drax, dray, cur=0 ;
unsigned short int fyge , marrs , drag, yicob ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned char ektos=1 , entos=0 ;
unsigned char *str ;
str=mystr;
f=0;
while (str[f]!=255) f++;
whouv=gouv ;
ar=f;

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
width=800 ; height=600;
size=imagesize(0,0,width-1,height-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while (yt1+height > info.bottom) yt1--;
yt=yt1+19;  yb=yt1+height-1;
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
xok=xt+(width-35)/2 ; yok=yb-46;
yicob = yb-9;
drax=xb-40 ; dray=yok+8;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/All_directions.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 


_puticon(xt+1,yt1+1,mem_arrs,255);

normtext_tomy(headername,str1024);
_outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);

_bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

refresh();
proenter=fyge=marrs=drag=0;
cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //PONTIKI MESA STO HELP_SHOW
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
        ektos=1;
        if (entos) continue ;
        entos=1;
        cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
        if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
        continue;
    }
    
     entos=0;
    // PONTIKI EKTOS ΒΟΗΘΕΙΑΣ
                                 
    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
            
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
    
        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
    marrs=0;
    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}


        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
    ektos=0;
    
    if (!drag) {
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);
    drag=1;
    putNOTicon(drax,dray,mem_drag);
    if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
    continue ;}
    else continue ;

    }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; 
        //klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
              
       
        if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            continue ;
                              
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+height-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            refresh();
            continue ;
        }
        
        else if (drag) {
            xt1=xt;
            xb1=xb; 
            yb1=yb ;
            change_dim(xt1, yt1 , &xb1 , &yb1);
            if (xb1-xt1<200) xb1= xt1+199 ;
            if( yb1-yt1<200) yb1=yt1+199 ;
            width=xb1-xt1+1 ; height=yb1-yt1+1;

            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            refresh();
            free(mem0); mem0=0;
            
            size=imagesize(0,0,width-1,height-1);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); goto FYGE ;}

            while (yt1+height > info.bottom) yt1--;
            yt=yt1+19;  yb=yt1+height-1;
            while (xt+width>info.right) xt--;
            xb=xt+width-1 ;

            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            _areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=yb-59;
            xok=xt+(width-35)/2 ; yok=yb-46;
            yicob = yb-9;
            drax=xb-40 ; dray=yok+8;
            _puticon(xt+1,yt1+1,mem_arrs,255);

             normtext_tomy(headername,str1024);
            _outmystr_center_col(0, str1024 , xtepl, yt1+2, xtepr, yt1+20, chrprnt, cbrown);


            _bareacls (xtepl,ytepl,xtepr,ybarb,cobkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,30,30,30);

            _puticon (xok,yok,mem_ok,255);
            
            _puticon(drax,dray,mem_drag,255);
            
            refresh();
            cur=0;
            cur=hlp_txt_scroll (font, cur, str, ar , xtepl , ytepl , xtepr-13 , ybarb , cochxr , cobkxr);
            if (sdlev.key.keysym.scancode==SDL_SCANCODE_ESCAPE) goto FYGE ;
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
          switch (sdlev.key.keysym.scancode) {
           
            
            case SDL_SCANCODE_RETURN :     
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                            
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
    case SDL_QUIT :
        fyge=1;
               
               continue;
    
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 if (mem_small) hide_help(hdhlpxt , hdhlpyt);
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return 1 ;
}


int criterio_show (int *cochxr , int *cobkxr)
{
    register int f,i ;
    int f1 ;
    void *mem0=0 ;
    unsigned char *str ;
    unsigned int metr;
    unsigned int size ;
    short int iso , meg , a ;
    unsigned short int moux, mouy;
    
    if (dbfinum<0) return 0;
    
    char pedname[64] , strbig[120], strless[120];
    char critstr[52];
    unsigned char fldk[1024];
    

    
    // Έλεγχος για ύπαρξη ή όχι κριτηρίων !
    i=0;
    for (a=0;a<=dbfinum;a++) {
        switch (ptr_pedio[a]->fitype) {
            case 5:
                continue ;
            case 0:
            case 1:
            case 2:
                 if (multicr[a]->sample_t[0]!=255) {i=1; break;}
                 break ;
            case 3:
            case 4:
            case 6:
                for (f=0 ; f<3 ; f++) {
                    if (multicr[a]->sample[f][0]!=255) {i=1; break;}
                }
        }
        
        if (i) break ;
    }
    if (!i) {
        if (keyb_gr) information (0,"Δεν έχετε ορίσει κριτήρια εύρεσης!" , 0) ;
        else information (0,"You have not defined searching criteria!" , 0) ;
        return 0;
    }
    
    size=1024 ;
    mem0=malloc (size) ;
    if (!mem0) {information (2-keyb_gr,0,0); return 0; }
    str=mem0;
    
    metr=0; //Μετρητής χώρου για το στριγκ και την αναγκαία μνήμη
    i=0; // Μετρητής του str
    
    for (a=0;a<=dbfinum;a++) {
        
        if (ptr_pedio[a]->fitype == 5) continue ;
        mytext_tonorm (ptr_pedio[a]->finame , pedname , 61 );
        
 
        switch (ptr_pedio[a]->fitype) {
            
            case 0:
            case 1:
            case 2:

                if (multicr[a]->sample_t[0]==255) continue ;
                mytext_tonorm(multicr[a]->sample_t , critstr, 44) ;
                if (keyb_gr) {sprintf(str1024,"Το πεδίο κειμένου [%s] να περιέχει το αλφαριθμητικό : \"%s\".",pedname,critstr);}
                else {sprintf(str1024,"The text field [%s] has to contain the string : \"%s\".",pedname,critstr);}
                
                break;
                
            case 3: // Αριθμοί
            case 4:
                
                f1=0; 
                
                for (f=0;f<3;f++) {
                    if (multicr[a]->sample[f][0]!=255) {f1++ ; break ;}
                }
                if (!f1) continue ;
                
                iso=meg=0;
                if (multicr[a]->sample[0][0]!=255) {
                    iso=1;
                    mytext_tonorm(multicr[a]->sample[0] , critstr, 22) ;
                    if (keyb_gr) {sprintf(str1024,"Το αριθμητικό πεδίο [%s] να είναι ίσο με : *%s*",pedname,critstr);}
                    else {sprintf(str1024,"The numeric field [%s] has to be equal to : *%s*",pedname,critstr);}
                }
                
                 if (multicr[a]->sample[1][0]!=255) {
                     meg=1;
                     mytext_tonorm(multicr[a]->sample[1] , critstr, 22) ;
                     
                     if (iso) { 
                         if (keyb_gr) strcat(str1024," είτε, να είναι " ) ;
                         else strcat(str1024," or , to be " ) ;
                         
                         if (keyb_gr) {sprintf(strbig,"μεγαλύτερο από : *%s*",critstr);}
                        else {sprintf(strbig,"bigger than : *%s*",critstr);}
                        
                        strcat (str1024,strbig);
                    }
                    
                    else {
                        if (keyb_gr) {sprintf(str1024,"To αριθμητικό πεδίο [%s] να είναι μεγαλύτερο από : *%s*",pedname,critstr);}
                        else {sprintf(str1024,"The numeric field [%s] has to be bigger than : *%s*",pedname,critstr);}
                    }
                 }
                
                if (multicr[a]->sample[2][0]!=255) {
                    
                    mytext_tonorm(multicr[a]->sample[2] , critstr, 22) ;
                    
                    if (!iso && !meg) {
                         if (keyb_gr) {sprintf(str1024,"To αριθμητικό πεδίο [%s] να είναι μικρότερο από : *%s*",pedname,critstr);}
                        else {sprintf(str1024,"The numeric field [%s] has to be less than : *%s*",pedname,critstr);}
                    }
                    
                    else if (iso && !meg) {
                        
                         if (keyb_gr) strcat(str1024," είτε, να είναι " ) ;
                         else strcat(str1024," or , to be " ) ;
                         
                         if (keyb_gr) {sprintf(strless,"μικρότερο από : *%s*",critstr);}
                        else {sprintf(strless,"less than : *%s*",critstr);}
                        
                        strcat (str1024,strless);
                    }
                    
                    else {
                        
                        if (keyb_gr) strcat(str1024," και " ) ;
                        else strcat(str1024," and " ) ;
                        
                        if (keyb_gr) {sprintf(strless,"μικρότερο από : *%s*",critstr);}
                        else {sprintf(strless,"less than : *%s*",critstr);}
                        
                        strcat (str1024,strless);
                    }
                    
                }

                strcat(str1024,".");
                               
                break ;       

            case 6 : // Ημερομηνία
                
                f1=0; 
                
                for (f=0;f<3;f++) {
                    if (multicr[a]->sample[f][0]!=255) {f1++ ; break ;}
                }
                if (!f1) continue ;
                
                iso=meg=0;
                if (multicr[a]->sample[0][0]!=255) {
                    iso=1;
                    mytext_tonorm(multicr[a]->sample[0] , critstr, 50) ;
                    if (keyb_gr) {sprintf(str1024,"Η ημερομηνία [%s] να είναι σαν σήμερα : *%s*",pedname,critstr);}
                    else {sprintf(str1024,"The date [%s] has to be like today : *%s*",pedname,critstr);}
                }
                
                 if (multicr[a]->sample[1][0]!=255) {
                     meg=1;
                     mytext_tonorm(multicr[a]->sample[1] , critstr, 50) ;
                     
                     if (iso) { 
                         if (keyb_gr) strcat(str1024," είτε, να είναι " ) ;
                         else strcat(str1024," or , to be " ) ;
                         
                         if (keyb_gr) {sprintf(strbig,"μετά από την : *%s*",critstr);}
                        else {sprintf(strbig,"after the : *%s*",critstr);}
                        
                        strcat (str1024,strbig);
                    }
                    else {
                        if (keyb_gr) {sprintf(str1024,"Η ημερομηνία [%s] να είναι μετά την : *%s*",pedname,critstr);}
                        else {sprintf(str1024,"The date [%s] has to be after the : *%s*",pedname,critstr);}
                    }
                 }
                
                if (multicr[a]->sample[2][0]!=255) {
                    
                    mytext_tonorm(multicr[a]->sample[2] , critstr, 50) ;
                    
                    if (!iso && !meg) {
                         if (keyb_gr) {sprintf(str1024,"Η ημερομηνία [%s] να είναι πριν από : *%s*",pedname,critstr);}
                        else {sprintf(str1024,"The date [%s] has to be before : *%s*",pedname,critstr);}
                    }
                    
                    else if (iso && !meg) {
                        
                         if (keyb_gr) strcat(str1024," είτε, να είναι " ) ;
                         else strcat(str1024," or , to be " ) ;
                         
                         if (keyb_gr) {sprintf(strless,"πριν από : *%s*",critstr);}
                        else {sprintf(strless,"before : *%s*",critstr);}
                        
                        strcat (str1024,strless);
                    }
                    
                    else {
                        
                        if (keyb_gr) strcat(str1024," και " ) ;
                        else strcat(str1024," and " ) ;
                        
                        if (keyb_gr) {sprintf(strless,"πριν από : *%s*",critstr);}
                        else {sprintf(strless,"before : *%s*",critstr);}
                        
                        strcat (str1024,strless);
                    }
                    
                }

                strcat(str1024,".");
                
                break ;
        }
        
        normtext_tomy(str1024 , fldk ) ;
        f=0;
        while(fldk[f]!=255) f++;
        metr=metr+f+1;
        f1=f ;

        if ( (size - metr) < (f1+10) ) {
            size+=1024;
            mem0=realloc(mem0,size);
            if (!mem0) {information (2-keyb_gr,0,0); return 0; }
            str=mem0;
        }

        for (f=0;f<f1;f++) {
            str[i++] = fldk[f];
        }

        if (a!=dbfinum) {str[i++] = 200;}
        
    }
    
    str[i]=255;
    moux=(info.right-info.left-800) / 2 ; mouy=(info.bottom-info.top-600) / 2 ;
    if (keyb_gr) mystr_show(4, str,"Κριτήρια Εύρεσης",moux, mouy, cochxr , cobkxr ) ;
    else mystr_show(4, str,"Searching Criteria",moux, mouy, cochxr , cobkxr ) ;

FYGE :
if (mem0) free(mem0);
return 1;
}


int input_compl_search ()
// Επιστρέφει 1 εάν τελικά συμφωνήσει ο χρήστης !
// Ενημερώνει πλήρως τη δομή criterio και το seflag.
{
SDL_Cursor* cursor;
FILE *fp ;
struct fansouv *whouv;
unsigned short int x ,xp, y ,y1, x0,  x3 ,start ,wtimi ,wid , hei , wid_box, hei_box ,x4,y4,xr;
unsigned short int ryt[4] , rxt , delxt , field_yt ,epil_ped = 0 ;
unsigned short int infox,savex,loadx,comy ;
unsigned int size ;
void *mem_menu=0 , *mem0=0 , *mem_alert=0 , *mem_delete=0 ,*mem_info=0 , *mem_save=0 , *mem_load=0 ;
void *mem_efedr1;
int *mem_int1;
short int *mem_int , c , a , p ;
unsigned short int neg , trik ,del[4] ;
short int kyk1, kyk=0, outmen , w ;
register int i,f ;
int mx,my,red,green,blue,dx,fide_crit;
int chrxr[3];
int cbkxr[3];
int fchxr[3];
int fbkxr[3];
unsigned char what , enter_go=0 , *pio_str[4] , now_save=0;
short int save=0 , load=0, info1=0 ;
char ch;
unsigned char nu[4];

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

int chxra[3] , bkxra[3] , slxra[3] ;
static short int arped ;
char t2[2];

struct criterio_cp *multicr_cp[dbfinum+1];

if (dbfinum<0) return 0;
whouv=gouv;
    for (f=0;f<3;f++) {
        bkxra[f]=bkxr[f] ; chxra[f]=chxr[f] ; slxra[f]=slxr[f];
    }
 
i=0; 

for (f=0 ; f<=dbfinum ; f++) multicr_cp[f]=0;

for (f=0 ; f<=dbfinum ; f++) {
    if (ptr_pedio[f]->fitype!=5) {  
    multicr_cp[f] = mem0 = malloc ( sizeof (struct criterio_cp) ) ;
    if (!multicr_cp[f]) {information (2-keyb_gr,0,0) ; i=1; break ;}
    mystrcpy (multicr_cp[f]->sample_cp[0] , multicr[f]->sample[0]);
    mystrcpy (multicr_cp[f]->sample_cp[1] , multicr[f]->sample[1]);
    mystrcpy (multicr_cp[f]->sample_cp[2] , multicr[f]->sample[2]);
    mystrcpy (multicr_cp[f]->sample_t_cp , multicr[f]->sample_t);
    }
}

mem0=0;
if (i) goto EJODOS ;

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
wid_box=60; 
hei_box=60;

size=imagesize(0,0,499,299);
mem0=malloc(size);
if (!mem0) {
    information (2-keyb_gr,0,0) ;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
    return 0;}
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
x=(info.right-info.left-499) / 2 ; y=(info.bottom-info.top-299) / 2 ;
getimage(x,y,x+499,y+299,mem0);
xp=x;
y1=y+219;
x+=142;
strcpy (file_1,path_name);
strcat (file_1,"ICD/File_cab_90.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Alert_sub_1.icw");
mem_menu= icWtomem (file_1);
if (!mem_menu) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Delete_18.ico");
mem_delete=icontomem (file_1,255);
if (!mem_delete) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Info_25.ico");
mem_info=icontomem (file_1,255);
if (!mem_info) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Load_25.ico");
mem_load=icontomem (file_1,255);
if (!mem_load) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/Save_25.ico");
mem_save=icontomem (file_1,255);
if (!mem_save) {information (2-keyb_gr,0,0) ; goto EJODOS ;}

del[0]=del[1]=del[2]=0;
setcolor(14);
rectangle(xp,y,xp+499,y+299);
rectangle(xp+5,y+5,xp+494,y+294);
_areacls (xp+1,y+1,xp+498,y+4,255,165,0);
_areacls (xp+1,y+5,xp+4,y+298,255,165,0);
_areacls (xp+495,y+5,xp+498,y+298,255,165,0);
_areacls (xp+5,y+295,xp+494,y+298,255,165,0);
bkxr[0]=bkxr[1]=cbkxr[0]=cbkxr[1]=20; bkxr[2]=cbkxr[2]=60;
_areacls (xp+6,y+6,xp+493,y+293,20,20,60);

_areacls (x+18,y1+7,x+198,y1+67,128,128,128); // φόντο πίσω από μενού
_puticon(xp+7,y+7,mem_alert,255);
puticW(x,y1,mem_menu);
x+=18;y1+=7;
chxr[0]=chrxr[0]=255;chxr[1]=chrxr[1]=10;chxr[2]=chrxr[2]=20;
fchxr[0]=fchxr[1]=fchxr[2]=0;
fbkxr[0]=fbkxr[1]=255; fbkxr[2]=0;
slxr[0]=slxr[2]=0; slxr[1]=120;
xr=xp+492;

if (!keyb_gr) {

normtext_tomy("Complex  Search",str1024);
_outmystr_center_col(1,str1024,xp+90,y+6,xr,y+32,chrxr, cbkxr);
outsouv_col(xp+105,y+40,"Field:",0,chrxr,cbkxr); 
}
else {
normtext_tomy("Σύνθετη Αναζήτηση",str1024);
_outmystr_center_col(1,str1024,xp+90,y+6,xr,y+32,chrxr, cbkxr);
outsouv_col(xp+105,y+40,"Pedi'o:",1,chrxr,cbkxr);  
}

x4=xp+2;
rxt=x4+160;
ryt[3]=y+100; 
ryt[0]=ryt[3]+25;
ryt[1]=ryt[0]+25;
ryt[2]=ryt[1]+25;
field_yt=y+40;
delxt=xr-20;
savex=rxt; infox=savex+150; loadx=xr-47; comy=field_yt+30;
i=0;f=0;

setcolor (4);
line (rxt,y+32,xr-22,y+32);
line (rxt+5,y+34,xr-27,y+34);

if (ics_arped==-1) arped=0;
if (arped>dbfinum) arped=0;
if ( ptr_pedio[arped]->fitype==5 ) {
    ics_arped=-1;
    for (f=0;f<=dbfinum;f++) {
        if (ptr_pedio[f]->fitype!=5) {arped=f; ics_arped=arped; break;}
    }
}
else ics_arped=arped ;

if (ics_arped==-1) goto EJODOS ;

setcolor(5);
rectangle (rxt,field_yt,xr-22,field_yt+20);
_bareacls (rxt+1,field_yt+1,xr-23,field_yt+19,fbkxr);
_outmystr_center_col(0,ptr_pedio[arped]->finame,rxt+1,field_yt+1,xr-23,field_yt+19,fchxr,fbkxr);


gouv=myfont[0];

_puticon(infox,comy,mem_info,255);
_puticon(savex,comy,mem_save,255);
_puticon(loadx,comy,mem_load,255);
refresh();

switch (ptr_pedio[arped]->fitype) {
    
    case 0:
    case 1:
    case 2:

        if (keyb_gr) sprintf (str1024," Κείμενο:");
        else sprintf (str1024," Text :");
    
        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[3], xr,chrxr,cbkxr);
        setcolor(5);
        rectangle (rxt,ryt[3],xr-22,ryt[3]+20);
        _puticon(delxt,ryt[3],mem_delete,255);
        pio_str[3] = multicr[arped]->sample_t ;
        
        for (f=0;f<3;f++) {
            pio_str[f] = multicr[arped]->sample[f] ;
        }
        if (keyb_gr) sprintf (str1024," Ίσο (=)");
        else sprintf (str1024," Equal (=)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[0],xr-22,ryt[0]+20);
        _areacls(rxt+1,ryt[0]+1,xr-23,ryt[0]+19,0,0,0);
        _puticon(delxt,ryt[0],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Μεγαλ. από (>)");
        else sprintf (str1024," Bigger than (>)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[1],xr-22,ryt[1]+20);
        _areacls(rxt+1,ryt[1]+1,xr-23,ryt[1]+19,0,0,0);
        _puticon(delxt,ryt[1],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Μικρότ. από (<)");
        else sprintf (str1024," Less than (<)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);
        
        setcolor(5);
        rectangle (rxt,ryt[2],xr-22,ryt[2]+20);
        _areacls(rxt+1,ryt[2]+1,xr-23,ryt[2]+19,0,0,0);
        _puticon(delxt,ryt[2],mem_delete,255);
        break ;
        
    case 3:
    case 4:
        
        if (keyb_gr) sprintf (str1024," Κείμενο:");
        else sprintf (str1024," Text :");
        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[3], xr,chrxr,cbkxr);
        setcolor(5);
        rectangle (rxt,ryt[3],xr-22,ryt[3]+20);
        _areacls(rxt+1,ryt[3]+1,xr-23,ryt[3]+19,0,0,0);
        _puticon(delxt,ryt[3],mem_delete,255);
        pio_str[3] = multicr[arped]->sample_t ;
        for (f=0;f<3;f++) {
            pio_str[f] = multicr[arped]->sample[f] ;
        }
        if (keyb_gr) sprintf (str1024," Ίσο (=)");
        else sprintf (str1024," Equal (=)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[0],xr-22,ryt[0]+20);
        _puticon(delxt,ryt[0],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Μεγαλ. από (>)");
        else sprintf (str1024," Bigger than (>)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[1],xr-22,ryt[1]+20);
        _puticon(delxt,ryt[1],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Μικρότ. από (<)");
        else sprintf (str1024," Less than (<)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);
        
        setcolor(5);
        rectangle (rxt,ryt[2],xr-22,ryt[2]+20);
        _puticon(delxt,ryt[2],mem_delete,255);
        break ;
        
        
    case 6:

        if (keyb_gr) sprintf (str1024," Κείμενο:");
        else sprintf (str1024," Text :");
        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[3], xr,chrxr,cbkxr);
        setcolor(5);
        rectangle (rxt,ryt[3],xr-22,ryt[3]+20);
        _areacls(rxt+1,ryt[3]+1,xr-23,ryt[3]+19,0,0,0);
        _puticon(delxt,ryt[3],mem_delete,255);
        pio_str[3] = multicr[arped]->sample_t ;
        
        for (f=0;f<3;f++) {
            pio_str[f] = multicr[arped]->sample[f] ;
        }
        
        if (keyb_gr) sprintf (str1024," Σαν σήμερα");
        else sprintf (str1024," Anniversary");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[0],xr-22,ryt[0]+20);
        _puticon(delxt,ryt[0],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Μετά την (>)");
        else sprintf (str1024," After .. (>)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);

        setcolor(5);
        rectangle (rxt,ryt[1],xr-22,ryt[1]+20);
        _puticon(delxt,ryt[1],mem_delete,255);

        if (keyb_gr) sprintf (str1024," Πριν από (<)");
        else sprintf (str1024," Before.. (<)");

        normtext_tomy(str1024,0);
        _outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);
        
        setcolor(5);
        rectangle (rxt,ryt[2],xr-22,ryt[2]+20);
        _puticon(delxt,ryt[2],mem_delete,255);
}

switch (ptr_pedio[arped]->fitype) {
    
    case 3 : // Ακέραιος
    case 4 :
    case 6 :
        
        if(pio_str[0][0]!=255) _outmystr_col(0, pio_str[0] , rxt+1, ryt[0]+1, xr-23 ,chrxr,cbkxr);
        if(pio_str[1][0]!=255) _outmystr_col(0, pio_str[1] , rxt+1, ryt[1]+1, xr-23 ,chrxr,cbkxr);
        if(pio_str[2][0]!=255)  _outmystr_col(0, pio_str[2] , rxt+1, ryt[2]+1, xr-23 ,chrxr,cbkxr);
        break ;
        
    case 0 : // KEIMENA
    case 1 :
    case 2 :
      
         if(pio_str[3][0]!=255) _outmystr_col(0, pio_str[3] , rxt+1, ryt[3]+1, xr-23 ,chrxr,cbkxr);
}
          
refresh();
mem_int=mem_menu;
wid=*mem_int++;
hei=*mem_int; 

kyk=-2; kyk1=-1; outmen=0; start=0;trik=0;
      
              
        do {
        SDL_PollEvent(&sdlev);
        mx=sdlev.motion.x ; my=sdlev.motion.y; 
        
        if (sdlev.type==SDL_WINDOWEVENT) {refresh(); continue;}
        else if (sdlev.type==SDL_QUIT) { mx=x+170;my=y1+30;enter_go=1;break;  }
        else if (sdlev.type==SDL_KEYDOWN ) {
            switch (sdlev.key.keysym.scancode) {
                case SDL_SCANCODE_RETURN:
                mx=x+80;my=y1+30;enter_go=1;break;
                case SDL_SCANCODE_ESCAPE :
                mx=x+170;my=y1+30;enter_go=1;break;
                default : continue;
            }}
            
        else if (sdlev.type == SDL_MOUSEBUTTONDOWN) {trik=1; mx = sdlev.button.x ; my = sdlev.button.y ;}
   
        if (mx>x && mx<x+180 && my>y1 && my < y1+60 ) { // όσο είναι μέσα στα επιλέξιμα κουτιά
            
            if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            else if (del[0]) {del[0]=0 ; puticon(delxt,ryt[0],mem_delete,255);}
            else if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
            else if(epil_ped) {epil_ped=0 ; setcolor(5) ; rectangle (rxt,field_yt,xr-22,field_yt+20);setcolor(COLOR(cbkxr[0],cbkxr[1],cbkxr[2])); rectangle (rxt-1,field_yt-1,xr-21,field_yt+21);refresh();}
            else if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
            trik=0;
            x0=(mx-x)/60;
            kyk=x0 ;
            if (!outmen) {
            outmen=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);}
            
            if (!start) {
            setcolor ( COLOR (255,255,0) );
            mem_efedr1 = mem_menu+4 + 3060 + (x0*wid_box*2);
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x0*wid_box+i,y1+f);}}
            refresh();
            kyk1=kyk;
            x3=x0 ; 
            start=1;
        continue ;}
            
            if (kyk==kyk1) continue ;
            
            //EPANAFEREI XRVMA EPILOGHS
            setcolor ( COLOR (128,128,128) ) ; 
            mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x3*wid_box+i,y1+f);}}
            
                
            // XRVMATIZEI NEA EPILOGH
            kyk1=kyk ; x3=x0 ; 
            setcolor ( COLOR (255,255,0) );
            mem_efedr1 = mem_menu+4+ (x0*wid_box*2)+ 3060;
            for (f=0;f<hei_box-1;f++) {
            mem_int=(mem_efedr1+(f*wid*2));
            for (i=0;i<wid_box-1;i++) {
                wtimi=*mem_int++ ;
            if (wtimi/32768) continue;
            _putpixel (x+x0*wid_box+i,y1+f);}}
            refresh();
            continue ;    
        }
        else {
        if (start) {
        setcolor ( COLOR (128,128,128) ) ; 
        mem_efedr1 = mem_menu+4+(x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
         wtimi=*mem_int++ ;   
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        start=0; kyk1=-1;refresh();}
        
        
            if (mx>rxt && mx<xr-23 && my>field_yt && my<field_yt+19) { // Epilogh pediou
        
            if (del[0]) {del[0]=0 ; puticon(delxt,ryt[0],mem_delete,255);}
            else if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            else if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
            else if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (epil_ped) goto TRIKY ;
            epil_ped=1;
            setrgbcolor(dbmag);
            rectangle (rxt,field_yt,xr-22,field_yt+20); rectangle (rxt-1,field_yt-1,xr-21,field_yt+21); refresh();
            continue;
            
        }
        
        if(epil_ped) {epil_ped=0 ; setcolor(5) ; rectangle (rxt,field_yt,xr-22,field_yt+20);setcolor(COLOR(cbkxr[0],cbkxr[1],cbkxr[2])); rectangle (rxt-1,field_yt-1,xr-21,field_yt+21);refresh();}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[0] && my<ryt[0]+19) { // Del 0
        
            if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            else if (del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            else if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
            else if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
            //else if(epil_ped) {epil_ped=0 ; setcolor(5) ; rectangle (rxt,field_yt,xr-22,field_yt+20);setcolor(COLOR(cbkxr[0],cbkxr[1],cbkxr[2])); rectangle (rxt-1,field_yt-1,xr-21,field_yt+21);refresh();}
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del[0]) goto TRIKY ;
            del[0]=1;
            putNOTicon(delxt,ryt[0],mem_delete);
            continue;
            
        }
        
        if(del[0]) {del[0]=0 ; puticon(delxt,ryt[0],mem_delete,255);}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[1] && my<ryt[1]+19) { // Del 1

            if(del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
            else if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
            else if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
            //else if(epil_ped) {epil_ped=0 ; setcolor(5) ; rectangle (rxt,field_yt,xr-22,field_yt+20);setcolor(COLOR(cbkxr[0],cbkxr[1],cbkxr[2])); rectangle (rxt-1,field_yt-1,xr-21,field_yt+21);refresh();}
                
            if (outmen==2) {
                outmen=1;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (del[1]) goto TRIKY ;
            del[1]=1;
            putNOTicon(delxt,ryt[1],mem_delete);
            continue;            
            
        }
        
        if(del[1]) {del[1]=0 ; puticon(delxt,ryt[1],mem_delete,255);}
            
        if (mx>delxt && mx<delxt+19 && my>ryt[2] && my<ryt[2]+19) { // Del 2
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                
            if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
            else if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
                     
            if (del[2]) goto TRIKY ;
            del[2]=1;
            putNOTicon(delxt,ryt[2],mem_delete);
            continue;              
            
        }
        
        if(del[2]) {del[2]=0 ; puticon(delxt,ryt[2],mem_delete,255);}
        
        if (mx>delxt && mx<delxt+19 && my>ryt[3] && my<ryt[3]+19) { // Στο del3
            
            if(info1) {info1=0;_puticon(infox,comy,mem_info,255);}
            else if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
                     
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (del[3]) goto TRIKY ;
            del[3]=1;
            putNOTicon(delxt,ryt[3],mem_delete);
            continue;              
            
        }
        
        if (del[3]) {del[3]=0 ; puticon(delxt,ryt[3],mem_delete,255);}
        
        if (mx>infox && mx<infox+25 && my>comy && my<comy+25) { // Στο info
            
            if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            else if(save) {save=0;puticon(savex,comy,mem_save,255);}
            
                      
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (info1) goto TRIKY ;
            info1=1;
            putNOTicon(infox,comy,mem_info);
            continue;              
        }
        
        if(info1) {info1=0;puticon(infox,comy,mem_info,255);}
        
        if (mx>savex && mx<savex+25 && my>comy && my<comy+25) { // Στο save
            
            if(load) {load=0;puticon(loadx,comy,mem_load,255);}
            
            
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (save) goto TRIKY ;
            save=1;
            putNOTicon(savex,comy,mem_save);
            continue;              
        }
        
        if(save) {save=0;puticon(savex,comy,mem_save,255);}
        
        if (mx>loadx && mx<loadx+25 && my>comy && my<comy+25) { // Στο load
            
            if (!outmen) {
                outmen=2;
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);}
                    
            if (load) goto TRIKY ;
            load=1;
            putNOTicon(loadx,comy,mem_load);
            continue;              
        }
        
        if(load) {load=0;puticon(loadx,comy,mem_load,255);}
        
        what=255;
        for (f=0 ; f<4 ; f++) {
            if  (mx>=rxt && mx<xr-22 && my>=ryt[f] && my < ryt[f]+19 ) {
                
                switch (ptr_pedio[arped]->fitype) {
                    case 0:
                    case 1:
                    case 2:
                        if (f!=3) break ;
                        if (!outmen) {
                            outmen=2;
                            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);}
                            what=0;
                    break ;
                    
                    case 3:
                    case 4:
                    case 6:
                        if (f==3) break ;
                        if (!outmen) {
                            outmen=2;
                            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);}
                            what=0;
                }
                break ;
            }
        }
        
        if (!what && !trik) continue;

TRIKY :      
        if (trik) {
            trik=0;
            a=-1;
            do {
            SDL_PollEvent(&sdlev);
            } while (sdlev.type != SDL_MOUSEBUTTONUP) ;
            
            
            if (info1) {
                info1=0;puticon(infox,comy,mem_info,255);
                criterio_show (chrxr,cbkxr);
                continue;
            }
            
            
            else if(save) {
              
                // Έλεγχος για ύπαρξη ή όχι κριτηρίων !
                i=0;
                for (p=0;p<=dbfinum;p++) {
                    switch (ptr_pedio[p]->fitype) {
                        case 5:
                            continue ;
                        case 0:
                        case 1:
                        case 2:
                            if (multicr[p]->sample_t[0]!=255) {i=1; break;}
                            break ;
                        case 3:
                        case 4:
                        case 6:
                            for (f=0 ; f<3 ; f++) {
                                if (multicr[p]->sample[f][0]!=255) {i=1; break;}
                            }
                    }
                    
                    if (i) break ;
                }
                if (!i) {
                    if (keyb_gr) information (0,"Δεν έχετε ορίσει κριτήρια εύρεσης!" , 0) ;
                    else information (0,"You have not defined searching criteria!" , 0) ;
                    kyk=0;
                    goto TRABA ;
                }
    
                now_save=1;
                kyk=1;
                goto KYKISON1;
            }
            
            
            else if(load) {
                
                if ( (wasopdb) && (fpdb!=NULL) ) {
                    fsync (fide_fpdb);
                    fclose (fpdb);
                    fpdb=NULL;
                }

                if ( (wasopca) && (fpcard!=NULL) ) {
                    fsync (fide_fpcard);
                    fclose (fpcard);
                    fpcard=NULL;
                }

                if ( (wasopdo) && (fpdom!=NULL) ) {
                    fsync (fide_fpdom);
                    fclose (fpdom);
                    fpdom=NULL;
                } 
                
                kyk=0;
                   
                c=0;
                if (keyb_gr) strcpy (file_1,"\"Φορτώστε Κριτήρια Εύρεσης\"");
                else strcpy (file_1,"\"Load Search Criteria\"");

                sprintf(str1024,"zenity --file-selection --title=%s --filename=%s --file-filter='*.cri' > %s%s",file_1, savedbpath,path_name,"zenity.txt");
                system(str1024);
                refresh();
                sprintf (str1024,"%s%s",path_name,"zenity.txt");
                fp = fopen(str1024,"r");
                if (fp==NULL) {information (6-keyb_gr,str1024,0); goto TRABA;}
                f=0;
                    do {
                    str1024[f]= (char) getc(fp);
                    f++;
                    }while ( (!feof(fp)) && (f<1000) );
                fclose(fp);
                if (f<3) goto TRABA;
                f-=2; str1024[f]='\0';
                c=strlen(str1024);
                if ( !c || c>1023) goto TRABA;
                
                fp = fopen(str1024,"rb");
                if (fp==NULL) {information (6-keyb_gr,str1024,0); goto TRABA;}

                fread(&c,2,1,fp);
                if (c!=dbfinum) {information (54-keyb_gr,str1024,0); fclose(fp); fp=NULL; goto TRABA;}

                i=0;
                for (f=0;f<=dbfinum;f++){
                fread (t2,2,1,fp);
                if (ptr_pedio[f]->fitype!=t2[0]) {i=1;break;}
                }
                if (i) {information (54-keyb_gr,str1024,0); fclose(fp); fp=NULL; goto TRABA;}
                
                               
                kyk=1;x3=1;seflag=9;
                size=sizeof(struct criterio);
                for (f=0;f<=dbfinum;f++) {
                    if(ptr_pedio[f]->fitype!=5) { 
                        if (multicr[f]->mem_ghost) { free(multicr[f]->mem_ghost) ; multicr[f]->mem_ghost=0; }
                        fread(multicr[f],size,1,fp); 
                        multicr[f]->cron_1=0;
                        multicr[f]->mem_ghost=0;
                    }
                }
    
                
                if(ferror(fp)) {clearerr(fp);  information(6-keyb_gr,str1024,0); fclose(fp); fp=NULL; goto TRABA;}
                
                fclose(fp);fp=NULL;
                
                gocards=0; firstcrit=0;
                seflag=10;            
                for (f=0;f<=dbfinum;f++) {
                
                    if (ptr_pedio[f]->fitype==5) continue ;
                
                    if (multicr[f]->cron) { seflag=1; break;}
                }
                
                //if (keyb_gr) information(0,"Τα κριτήρια φορτώθηκαν !",str1024);
                //else information(0,"Criteria Loaded !",str1024);
                
                goto TRABA ;
                
            }
            
            
            else if (epil_ped) {
                
                dx = button_show(dbfds.mem_fd, dbfds.fd_data, dbfds.fd_ar, dbfds.fd_orio, dbfds.fd_name, &dbfds.fd_sorton,0 );
                
                 do {
                SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);
                
                for (f=0;f<3;f++) {chxr[f]=chrxr[f] ; bkxr[f]=cbkxr[f];} 
                slxr[0]=slxr[2]=0; slxr[1]=120;
                if (dx<0) continue;
                if (ptr_pedio[dx]->fitype==5) continue ;
                arped=dx;
                _bareacls (rxt+1,field_yt+1,xr-23,field_yt+19,fbkxr);
                _outmystr_center_col(0,ptr_pedio[arped]->finame,rxt+1,field_yt+1,xr-23,field_yt+19,fchxr,fbkxr);
                pio_str[3] = multicr[arped]->sample_t ;
                for (f=0;f<3;f++) {
                    pio_str[f] = multicr[arped]->sample[f] ;
                }
                switch (ptr_pedio[arped]->fitype) {
                    
                    case 3 : // Ακέραιος - Dekadikos - Date
                    case 4 :

                        _bareacls(rxt+1, ryt[0]+1, xr-23 , ryt[0]+19, cbkxr);
                        _bareacls(rxt+1, ryt[1]+1, xr-23 , ryt[1]+19, cbkxr);
                        _bareacls(rxt+1, ryt[2]+1, xr-23 , ryt[2]+19, cbkxr);
                        _areacls (rxt+1, ryt[3]+1, xr-23 , ryt[3]+19, 0,0,0);
                        _bareacls (x4+4, ryt[0], rxt-1, ryt[0]+19,cbkxr);
                        _bareacls (x4+4, ryt[1], rxt-1, ryt[1]+19,cbkxr);
                        _bareacls (x4+4, ryt[2], rxt-1, ryt[2]+19,cbkxr);
                        if(pio_str[0][0]!=255) _outmystr_col(0, pio_str[0] , rxt+1, ryt[0]+1, xr-23 ,chrxr,cbkxr);
                        if(pio_str[1][0]!=255) _outmystr_col(0, pio_str[1] , rxt+1, ryt[1]+1, xr-23 ,chrxr,cbkxr);
                        if(pio_str[2][0]!=255)  _outmystr_col(0, pio_str[2] , rxt+1, ryt[2]+1, xr-23 ,chrxr,cbkxr);
                        pio_str[3][0]=255;
                        if (keyb_gr) sprintf (str1024," Ίσο (=)");
                        else sprintf (str1024," Equal (=)");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);
                        if (keyb_gr) sprintf (str1024," Μεγαλ. από (>)");
                        else sprintf (str1024," Bigger than (>)");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);
                        if (keyb_gr) sprintf (str1024," Μικρότ. από (<)");
                        else sprintf (str1024," Less than (<)");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);
                        break ;
                        
                    case 6 :
                        
                        _bareacls(rxt+1, ryt[0]+1, xr-23 , ryt[0]+19, cbkxr);
                        _bareacls(rxt+1, ryt[1]+1, xr-23 , ryt[1]+19, cbkxr);
                        _bareacls(rxt+1, ryt[2]+1, xr-23 , ryt[2]+19, cbkxr);
                        _areacls (rxt+1, ryt[3]+1, xr-23 , ryt[3]+19, 0,0,0);
                        _bareacls (x4+4, ryt[0], rxt-1, ryt[0]+19,cbkxr);
                        _bareacls (x4+4, ryt[1], rxt-1, ryt[1]+19,cbkxr);
                        _bareacls (x4+4, ryt[2], rxt-1, ryt[2]+19,cbkxr);
                        if(pio_str[0][0]!=255) _outmystr_col(0, pio_str[0] , rxt+1, ryt[0]+1, xr-23 ,chrxr,cbkxr);
                        if(pio_str[1][0]!=255) _outmystr_col(0, pio_str[1] , rxt+1, ryt[1]+1, xr-23 ,chrxr,cbkxr);
                        if(pio_str[2][0]!=255)  _outmystr_col(0, pio_str[2] , rxt+1, ryt[2]+1, xr-23 ,chrxr,cbkxr);
                        pio_str[3][0]=255;
                        if (keyb_gr) sprintf (str1024," Σαν σήμερα");
                        else sprintf (str1024," Anniversary");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[0], xr,chrxr,cbkxr);
                        if (keyb_gr) sprintf (str1024," Μετά την (>)");
                        else sprintf (str1024," After .. (>)");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[1], xr ,chrxr,cbkxr);
                        if (keyb_gr) sprintf (str1024," Πριν από (<)");
                        else sprintf (str1024," Before (<)");
                        normtext_tomy(str1024,0);
                        _outmystr_col(0, str1024 , x4, ryt[2], xr ,chrxr,cbkxr);
                        break ;
                        
                    case 0 : // Keimeno
                    case 1 :
                    case 2 :
                        _areacls(rxt+1, ryt[0]+1, xr-23 , ryt[0]+19, 0 ,0 ,0 );
                        _areacls(rxt+1, ryt[1]+1, xr-23 , ryt[1]+19,  0 ,0 ,0);
                        _areacls(rxt+1, ryt[2]+1, xr-23 , ryt[2]+19,  0 ,0 ,0);
                        _bareacls (rxt+1, ryt[3]+1, xr-23 , ryt[3]+19, cbkxr);
                        if(pio_str[3][0]!=255) _outmystr_col(0, pio_str[3] , rxt+1, ryt[3]+1, xr-23 ,chrxr,cbkxr);
                        pio_str[0][0] = pio_str[1][0] = pio_str[2][0] = 255; 
                }
                        
                refresh();
                continue;
                
            }
            else if  (mx>=rxt && mx<xr-22 && my>=ryt[0] && my < ryt[0]+19 ) a=0 ;
            else if (mx>=rxt && mx<xr-22 && my>=ryt[1] && my < ryt[1]+19) a=1;
            else if (mx>=rxt && mx<xr-22 && my>=ryt[2] && my < ryt[2]+19) a=2 ;
            else if (mx>=rxt && mx<xr-22 && my>=ryt[3] && my < ryt[3]+19) a=3 ;
            else if (del[0]) {
                if (ptr_pedio[arped]->fitype<3) continue ;
                pio_str[0][0]=255 ; bareacls (rxt+1,ryt[0]+1, xr-23, ryt[0]+19,cbkxr); continue;}
            else if (del[1]) {
                if (ptr_pedio[arped]->fitype<3) continue ;
                pio_str[1][0]=255 ; bareacls (rxt+1,ryt[1]+1, xr-23, ryt[1]+19,cbkxr); continue;}
            else if (del[2]) {
                if (ptr_pedio[arped]->fitype<3) continue ;
                pio_str[2][0]=255 ; bareacls (rxt+1,ryt[2]+1, xr-23, ryt[2]+19,cbkxr); continue;}
            else if (del[3]) {
                if (ptr_pedio[arped]->fitype>2) continue ;
                pio_str[3][0]=255 ; bareacls (rxt+1,ryt[3]+1, xr-23, ryt[3]+19,cbkxr); continue;}
           
           if (a!=-1) {
           
                if (!outmen) {
                    outmen=3;
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                }
           
           switch (ptr_pedio[arped]->fitype) {
        
               case 6 :
                if (a==3) continue ;
                
                ptr_char=pedaba_calendar( -1 );
                if(!ptr_char) continue;
                ptr_char[24]=255;
                mystrcpy (pio_str[a],ptr_char);
                free ( (void *) ptr_char ) ;
                //normtext_tomy(str1024,pio_str[a]);
                _bareacls(rxt+1,ryt[a]+1,xr-23,ryt[a]+19,cbkxr);
                _outmystr_col(0,pio_str[a],rxt+1, ryt[a]+1, xr-23 , chrxr ,cbkxr );
                refresh();
                continue;
           
               case 3 : // Ακέραιος
                        
                        if (a==3) continue ;
                        do{
                        i=qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 2);
                        if (i==-9) {a= (a+1<3) ? a+1 : 0 ;  i = qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 2);}
                        else break;
                        if (i==-9) {a= (a+1<3) ? a+1 : 0 ;  i = qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 2);}
                        else break;
                        a= (a+1<3) ? a+1 : 0 ;
                        } while (i==-9);
                        break;
                        
                case 4 : // Δεκαδικός
                    
                        if (a==3) continue ;
                        do{
                        i=qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 3);
                        if (i==-9) {a= (a+1<3) ? a+1 : 0 ; i = qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 3); }
                        else break;
                        if (i==-9) {a= (a+1<3) ? a+1 : 0 ; i = qnum_input(pio_str[a], rxt+1, ryt[a]+1, xr-23, ryt[a]+19, 14 , 3); }
                        else break;
                        a= (a+1<3) ? a+1 : 0 ;
                        } while (i==-9);
                        break;
                        
                case 0:
                case 1:
                case 2:
                    
                    if (a!=3) continue ;
                    qtext_input (pio_str[3],rxt+1, ryt[3]+1, xr-23, ryt[3]+19, 20);
                    break ;
                }
                
                do {
                SDL_PollEvent(&sdlev);} while  (sdlev.type==SDL_KEYDOWN);
                continue ;
                
                 }
        }
    
        if ( del[0] || del[1] || del[2] || del[3] || epil_ped || info1 || save || load ) continue ;

        if (!outmen) continue;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        outmen=0;
        continue ;   
        }
        continue ;
        
        } while ( (sdlev.type !=SDL_MOUSEBUTTONDOWN || (outmen!=1) ) && (!enter_go) ) ;
        
        KYKISON1:
        
        if (kyk==1) {
            
            for (p=0;p<=dbfinum;p++) {
                
                switch (ptr_pedio[p]->fitype) {
                    
                    case 5: 
                        continue ;
                    
                    case 0:
                    case 1:
                    case 2:
                        
                        if (multicr[p]->sample_t[0]==255) {multicr[p]->cron=0; continue ;}
                        else if (multicr[p]->sample_t[1]==255) {multicr[p]->sample_t[0]=255; multicr[p]->cron=0; continue ;}
                        else {
                            multicr[p]->cron=1; multicr[p]->cron_1=1;
                            mystrcpy (multicr[p]->sample_tcode , multicr[p]->sample_t) ;
                            i=0;
                            while (multicr[p]->sample_tcode[i]!=255) i++;
                           
                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (multicr[p]->sample_tcode[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        multicr[p]->sample_tcode[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        multicr[p]->sample_tcode[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        multicr[p]->sample_tcode[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        multicr[p]->sample_tcode[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        multicr[p]->sample_tcode[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        multicr[p]->sample_tcode[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        multicr[p]->sample_tcode[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        multicr[p]->sample_tcode[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        multicr[p]->sample_tcode[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        multicr[p]->sample_tcode[f]=128;
                                        break;

                                        case 130:
                                        multicr[p]->sample_tcode[f]=119;
                                    }
                                }
                                if ( (multicr[p]->sample_tcode[f]>68) && (multicr[p]->sample_tcode[f]<95) ) multicr[p]->sample_tcode[f]-=26;
                            }
                        }
                        continue ;
                        
                    case 3 :  // Ακέραιος αριθμός
                        
                        i=0;   
                        for (f=0;f<3;f++){
                        if (multicr[p]->sample[f][0]==255) { i++; multicr[p]->numcr.litem[f] = 0 ;}
                        else multicr[p]->numcr.litem[f] = (long int) convert_str(15 , multicr[p]->sample[f] ) ;   
                        }
                        multicr[p]->cron = (i==3) ? 0 : 1 ;
                        continue ;

                    case 4 :  // Δεκαδικός αριθμός
                         
                        i=0;
                        for (f=0;f<3;f++){
                        if (multicr[p]->sample[f][0]==255) { i++; multicr[p]->numcr.fitem[f] = 0 ;}
                        else multicr[p]->numcr.fitem[f] = (double) convert_str(15 , multicr[p]->sample[f] ) ;   
                        }
                        multicr[p]->cron = (i==3) ? 0 : 1 ;
                        continue ;
                        
                    case 6 : // Ημερομηνία 
                        
                        c=0;
                        for (f=0;f<3;f++) {
                            cardiary.ldate=0;
                            if (multicr[p]->sample[f][0] !=255) {
                            c++;
                            mytext_tonorm(multicr[p]->sample[f],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                            multicr[p]->numcr.gitem[f]=cardiary.ldate ; // unsigned int Gi1
                        }
                        multicr[p]->cron = (c) ? 1 : 0 ;
                        continue ;
                }
            }
            seflag=10;
            
            for (f=0;f<=dbfinum;f++) {
                
                if (ptr_pedio[f]->fitype==5) continue ;
                
                if (multicr[f]->cron) { seflag=1; break;}
            }
        }
        
        if (now_save) {
            
            if ( (wasopdb) && (fpdb!=NULL) ) {
                fsync (fide_fpdb);
                fclose (fpdb);
                fpdb=NULL;
            }

            if ( (wasopca) && (fpcard!=NULL) ) {
                fsync (fide_fpcard);
                fclose (fpcard);
                fpcard=NULL;
            }

            if ( (wasopdo) && (fpdom!=NULL) ) {
                fsync (fide_fpdom);
                fclose (fpdom);
                fpdom=NULL;
            } 
            
            x3=1;
               
            c=0;
            if (keyb_gr) strcpy (file_1,"\"Σώστε Κριτήρια Εύρεσης\"");
            else strcpy (file_1,"\"Save Search Criteria\"");

            sprintf(str1024,"zenity --file-selection --save --title=%s --filename=%s --file-filter='*.cri' > %s%s",file_1, savedbpath,path_name,"zenity.txt");
            system(str1024);
            refresh();
            sprintf (str1024,"%s%s",path_name,"zenity.txt");
            fp = fopen(str1024,"r");
            if (fp==NULL) {information (6-keyb_gr,str1024,0); goto TRABA;}
            f=0;
                do {
                str1024[f]= (char) getc(fp);
                f++;
                }while ( (!feof(fp)) && (f<1000) );
            fclose(fp);
            if (f<3) goto TRABA;
            f-=2; str1024[f]='\0';
            c=strlen(str1024);
            if ( !c || c>1000) goto TRABA;
            ptr_char=strstr(str1024,".cri");
            if (!ptr_char) {strcat(str1024,".cri");}

            fp = fopen(str1024,"wb");
            if (fp==NULL) {information (6-keyb_gr,str1024,0); goto TRABA;}
            fide_crit = fileno (fp) ;
            fwrite(&dbfinum,2,1,fp);
            fdatasync (fide_crit);
            for (f=0;f<=dbfinum;f++){
            t2[0]=ptr_pedio[f]->fitype;
            t2[1]=ptr_pedio[f]->mathtype;
            fwrite (t2,2,1,fp);
            }
            fdatasync (fide_crit);
            size=sizeof(struct criterio);
            for (f=0;f<=dbfinum;f++){
            if(ptr_pedio[f]->fitype!=5) fwrite(multicr[f],size,1,fp);
            }
            fsync (fide_crit);
            if(ferror(fp)) {clearerr(fp);  information(6-keyb_gr,str1024,NULL); fclose(fp); fp=NULL; }
            else {
            fclose(fp);fp=NULL;
            if (keyb_gr) information(0,"Τα κριτήρια σώθηκαν στο δίσκο!",str1024);
            else information(0,"Criteria Saved !",str1024);}
            
        }
        
TRABA:

        if ( (wasopdb) && (fpdb==NULL) ) {
            fpdb=fopen(LDdbfile,"r+b");
            if (fpdb==NULL) {information (6-keyb_gr,LDdbfile,"Please .. Quit Now !!");}
            else { fide_fpdb = fileno (fpdb); }
        }
        
        if ( (wasopca) && (fpcard==NULL) ) {
            fpcard=fopen(Strcardfp,"r+b");
            if (fpcard==NULL) {information (6-keyb_gr,Strcardfp,"Please .. Quit Now !!");}
            else { fide_fpcard = fileno (fpcard); }
        }
        
        if ( (wasopdo) && (fpdom==NULL) ) {
            fpdom=fopen(Strdomfp,"r+b");
            if (fpdom==NULL) {information (6-keyb_gr,Strdomfp,"Please .. Quit Now !!");}
            else { fide_fpdom = fileno (fpdom); } 
        } 

        if (kyk>0){
         // ΒΑΦΩ MPLE
        setcolor ( COLOR (0,0,255) ) ; 
        mem_efedr1 = mem_menu+4+ (x3*wid_box*2)+ 3060;
        for (f=0;f<hei_box-1;f++) {
        mem_int=(mem_efedr1+(f*wid*2));
        for (i=0;i<wid_box-1;i++) {
            wtimi=*mem_int++ ;
        if (wtimi/32768) continue;
        _putpixel (x+x3*wid_box+i,y1+f);}}
        refresh(); }
        
    //} while ( && sdlev.key.keysym.scancode != SDL_SCANCODE_ESCAPE) ;

if(mem0) fidicls(xp, y,xp+399,y+299, 65,80,225);  
EJODOS:
if(mem0) putimage(xp,y,mem0,0);
refresh();
if(mem0) free(mem0);
if(mem_menu) free(mem_menu);
if(mem_alert) free(mem_alert);
if (mem_delete) free (mem_delete); 
if (mem_info) free(mem_info);
if (mem_load) free(mem_load);
if (mem_save) free(mem_save);
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
    for (f=0;f<3;f++) {
        bkxr[f]=bkxra[f] ; chxr[f]=chxra[f] ; slxr[f]=slxra[f];
    }
gouv=whouv;

if (kyk!=1 && seflag>=2) {
    for (f=0 ; f<=dbfinum ; f++) {
        if (ptr_pedio[f]->fitype!=5) {
            if (multicr_cp[f]) {
                mystrcpy (multicr[f]->sample[0],multicr_cp[f]->sample_cp[0]);
                mystrcpy (multicr[f]->sample[1],multicr_cp[f]->sample_cp[1]);
                mystrcpy (multicr[f]->sample[2],multicr_cp[f]->sample_cp[2]);
                mystrcpy (multicr[f]->sample_t, multicr_cp[f]->sample_t_cp);
            }
            else break ;
        }
    }
}

dx=0;
if ( (kyk!=1) && (seflag==1) ) {
    for (f=0 ; f<=dbfinum ; f++) {
        switch (ptr_pedio[f]->fitype) {
            
            case 0:
            case 1:
            case 2:
            
                if (multicr[f]->sample_t[0]==255) {
                    if (multicr[f]->mem_ghost) free(multicr[f]->mem_ghost) ;
                    multicr[f]->mem_ghost=0;
                    multicr[f]->sample_tcode[0]=255; 
                    multicr[f]->cron=0;
                    multicr[f]->cron_1=0;
                }
                else dx++;
                break ;
            
            case 3:
            case 4:
                
                a=0;
                for (i=0 ; i<3 ; i++) {
                    if (multicr[f]->sample[i][0]!=255) { a=1; break ; }
                }
                if (!a) { multicr[f]->cron=0; multicr[f]->mem_ghost=0; }
                else dx++;
                break;
        } // τέλος switch
    }
    if (!dx) {
        seflag=0;mmed[10]=1;
        for (f=0;f<dbplgr;f++) crits[f]=0;
        gocards=0; firstcrit=0;
    }
}


for (f=0 ; f<=dbfinum ; f++) {
    if (ptr_pedio[f]->fitype!=5) {
        mem0=multicr_cp[f];
        if (mem0) free (mem0);
        else break ;
    }
}
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return((int)kyk);
}


void * mulbutton_show(void *mem_str, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_ghost =0 , *mem_fonter=0 ,*mem_epl=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , c ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;
unsigned char *epl;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
static short int fo ;
static short int fnt ;

if (!fo && !fnt) fnt=4;
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
kati=0; // Όλα καλά ....
whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=0;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;
unsigned char *gbut[plbut];
unsigned char krit[plbut];
mem_epl=malloc(plbut);
if (!mem_epl)  {information (2-keyb_gr,0,0); goto FYGE; }
epl=mem_epl;

mem_ghost=malloc(ar+1);
if (!mem_ghost)  {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
ghost_str=mem_ghost;
for (f=0; f<ar; f++) ghost_str[f]=str[f] ;

i=0; a=0; 

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       gbut[i]=ghost_str+a;
       but[i]=mem_str+a;
       i++;
       a=f+1; 
        }
}

for (f=0;f<plbut;f++) {krit[f]=0; epl[f]=0;}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);
refresh();

chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
xrep[0]=xrep[1]=xrep[2] = 0;
xrkl[0]=216 ; xrkl[1] = xrkl[2] = 0;
slkl[1]=162 ; slkl[0] = slkl[2] = 0;

_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; 
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev)) continue ;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
               
                el = (sort) ? pano-protyx : pano+protyx;
                if (!epl[ar_dom[el]]) {
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
                    refresh();}
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);refresh();}
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);refresh();}
        el = (sort) ? pano-tyx : pano+tyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
            refresh();}
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el = (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
            refresh();}
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ή , εμφάνιση στοιχείων με την αρχική τους σειρά", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting or , show data by their initial order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κειμένου αναζήτησης / Αριστερό κλικ : Αναζήτηση", searx, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Text / Left Click : Search", searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            
           if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Πολλαπλή Επιλογή
                
                f=protyx; k=f+1 ; el=pano+bima*f;
                a=(sort) ? plbut-el : el ; a++;
                pa = ar_dom[el];
                if (!epl[pa]) { // Δεξί κλικ σε μη επιλεγμένο
                    protyx=lines;
                    do {
                        epl[pa]=1;
                        if (k) { // Χρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά )
                                k--;
                                _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                                if (but[pa][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                                else  {_outfanis_colxr(fnt, but[pa] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                                    if (krit[pa]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                        }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (epl[pa]) break ;
                    }while (a) ;
                }
                else {  // Δεξί κλικ σε επιλεγμένο
                    do {
                        epl[pa]=0;
                        if (k) { // Αποχρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά)
                                k--;
                                _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                                if (but[pa][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                                else {_outfanis_col(fnt, but[pa] , xtepl+10 , ytepl+k*fhe , xtepr);
                                    if (krit[pa]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                            }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (!epl[pa]) break ;
                    }while (a) ;
                }
                refresh();
                
            }
            else if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
               
            }
            else if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -1);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Αριστερό Κλικ πάνω σε επιλογή - απλά αντιστρέφει !!
        
            
        //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        //SDL_SetCursor(cursor);   
        el= (sort) ? pano-protyx : pano+protyx;
        if (epl[ar_dom[el]])  { // Ακυρώνεται η επιλογή !
          epl[ar_dom[el]]=0;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else {_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
            protyx=lines;
            refresh();
            continue ;
        }
        else {
        epl[ar_dom[el]]=1;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
        refresh(); 
        continue ;}
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
          
        protyx=lines;
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
  
        }
        
        else if (profrba) {
        
        protyx=lines;
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            protyx=lines;
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!
                _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                
                k=0;
                do {
                    if (!epl[ar_dom[pa]]) {
                        _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                        if (but[ar_dom[pa]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                        else _outfanis_col(fnt, but[ar_dom[pa]] , xtepl+10 , ytepl+k*fhe , xtepr);
                    }
                    else {
                        _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                        if (but[ar_dom[pa]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                        else  _outfanis_colxr(fnt, but[ar_dom[pa]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                        }
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }
                    SDL_PollEvent(&sdlev);
                    mx=sdlev.motion.x ; my=sdlev.motion.y;
                    if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                    search=0; puticon (searx,seary,mem_search,255);
                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                search=0; puticon (searx,seary,mem_search,255);
                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;
            SDL_PollEvent(&sdlev);
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
            search=0; puticon (searx,seary,mem_search,255);
            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            i=0;
            for (f=0;f<plbut;f++) {
                if(epl[f]) {i=1;break;}
            }
            if (!i) {free(mem_epl); mem_epl=0;}
         }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            refresh();

            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, xrep, xrkl, slkl );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            if (user_ans<0) continue;
            fo=1;
            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            protyx=lines;

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (!epl[ar_dom[c]]) {
            _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
            if (but[ar_dom[c]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
        }
        else {
            _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
            if (but[ar_dom[c]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
            else  _outfanis_colxr(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
            }
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
             
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;
                protyx=lines;
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
              
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
                protyx=lines ;
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;
                protyx=lines ;
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (!epl[ar_dom[c]]) {
                    _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[c]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                }
                else {
                    _bareacls(xtepl+1, ytepl+k*fhe,xtepr,ytepl+k*fhe+(fhe-2),slkl);
                    if (but[ar_dom[c]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl );
                    else  _outfanis_colxr(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr , xrkl, slkl);
                    }
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
                protyx=lines ;
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                i=0;
                for (f=0;f<plbut;f++) {
                    if(epl[f]) {i=1;break;}
                }
                if (!i) {free(mem_epl); mem_epl=0;}
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               free(mem_epl); mem_epl=0;
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
                case SDL_QUIT :
               fyge=1;
               free(mem_epl); mem_epl=0;
               continue;
                
     default :
         if (ektos==1) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);
if(kati) {
    if (mem_epl) {free(mem_epl);} 
    mem_epl=0;
}
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_ghost) free(mem_ghost );
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return mem_epl ;
}


void * muldbfield_show_button(void *mem_str, unsigned char *pedia, unsigned int ar, unsigned short int orio, unsigned char *but_name, short int *sorton , short int sort_type , short int delon , unsigned short int *disk_dom, unsigned short int *flag_mulsel)
// Η συνάρτηση info_dbfdata ενημερώνει την καθολική δομή dbfdata η οποία παρέχει το δείκτη mem_str (dbfdata.mem_fd) που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name (επικεφαλίδα του button). Εδώ παρέχεται και ο sort_type ανάλογα τον τύπο του πεδίου !
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα γίνεται search ή όχι !!
// Στην flag_mulsel γράφεται το synepil !
{
FILE * fp ;
time_t cardwhen_1;
struct fansouv *whouv;
SDL_Cursor* cursor;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0 , *mem_deigma_text = 0 ;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0 , *mem_drag=0;
void *mem_fonter=0 , *mem_epl=0 , *mem_right=0 , *mem_left=0 , *mem_cancel=0 ,*mem_group=0 ,*mem_found=0 ;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , cblack[3] , conom[3] ;
unsigned short int *ar_dom;
short int bima ,width , cur , cur_wid;
int xt1,xb1,yb1 ,kati ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ,ynames ;
unsigned short int  key , key_1, sort , sort_1, bar, proenter , xok , yok , protyx , plbut , pano , pano_1, kato , telos , telos1, metektos , metektos1 , xcancel , ycancel , xgroup , xfound ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa , low ,karta ,fonter ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue ,  el , c ;
unsigned char what ;
unsigned int size , size1 , size2 ;
unsigned char *but[dbplgr] , *str , redline , krit[dbplgr] ;
// unsigned char keyword[30] ;
short int by , rby , w , newsea=0 , smaller , smaller1, bigger ;
int  a1 , a , k , k1, proyt , proyt1 , bary1, bary2, y1, y2 ,y3 ,pa=-1 ;  
short int drax , dray , buthei , newhei , drag , xfo , xright , xleft , tori, tole , prokef, kefali ,akiro , krit_insert , add_found ;
short int sparky ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] , orange[3] ;
unsigned short int synepil=0 , chepil , finds=0 , finds_1=0 ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

unsigned char nu[4];

unsigned int *Gitem , Gidb, Gi[3] ;
long int *Litem , Lidb, Li[3] ;
double *Fitem , Fidb, Fi[3] ;
float mespl , plape ;

unsigned char *deigma_text;
unsigned char deigma1_text[22] , neodeigma1_text[22] , deigma2_text[22] ;

unsigned char deigma [3][26] , neodeigma [3][26] ;
short int pedtosh;


unsigned char str50[51];
unsigned char ektos=1;
char keno[10];
int xrcl[3] , slcl[3] , xrep[3] ;
unsigned short int fhe , sGidb, sG ;
unsigned char *epl , *mesa_ptr;
unsigned char str1024a[50];
unsigned int ptr1;

static short int fo ;
static short int fnt ;
static unsigned short int xt;
static int yt1;
static short int lines ;

kati=0; 
SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
cblack[0]=cblack[1]=cblack[2]=0;
conom[0]=conom[2]=0; conom[1]=200;
orange[0]=220 ; orange[1]=114; orange[2]=0 ;
deigma2_text[0]=255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);
key_1=sort_1=65000;

if (!fo && !fnt) fnt=4;

// Πόσα πεδία (μη εικόνας) έχουν επιλεγεί !
// Ποια πεδία έχουν τον μικρότερο και μεγαλύτερο αύξοντα αριθμό αντίστοιχα (εξαιρείται το πεδίο βάσης) !
i=0; smaller=-1; bigger=-1;
for(f=0;f<=dbfinum;f++) {
     if (f==dbfdata.fd_arped) {i++; continue;}
    if (pedia[f] && ptr_pedio[f]->fitype!=5) {
        i++;
        if (smaller==-1) smaller=f;
        if (bigger<f) bigger=f;
        
    }
}
smaller1=smaller;
k1=i; // k1 δεν αλλάζει !!!! Είναι ο μέγιστος αριθμός των πεδίων που ζητήθηκε να παρουσιαστούν !

short int svou ; // Στήλη πεδίου από την οποία και μετά θα γίνεται μετακίνηση προς τα δεξιά !
short int showp[i];
unsigned int almap[i];
unsigned short int xpl[i] , xpr[i];
unsigned short int bread[i];
void *mem_ped[i];
short int desm[i];

for (f=0;f<i;f++) { mem_ped[f]=0; desm[f]=-1;}

showp[0]=desm[0]=dbfdata.fd_arped;

//Αρχική απόδοση τιμών στην showp[]
i=1;
for(f=0; f<=dbfinum; f++) {
    if (f==dbfdata.fd_arped) continue ;
    if (pedia[f] && ptr_pedio[f]->fitype!=5) { showp[i]=f; i++; }
}

// Αρχικός υπολογισμός των συντεταγμένων (xpl-xpr) κάθε πεδίου - υπολογισμός του max width στα 4/5 της οθόνης
// Υπολογισμός μέγιστου αριθμού πεδίων προς εμφάνιση και μέγιστου αριθμού χαρακτ. κατά πεδίο.

mespl=myfont_wid[fnt]*75/100; i = (4 * (info.right-info.left+1) ) / 5 ;
dx=36; dy=26;

    width=18;
    xpl[0]=0;
    for (f=0; f<k1 ; f++) {
        a=ptr_pedio[showp[f]]->fiorio;
        if (showp[f]==dbkey) { a=(a<dx) ? a : dx-1 ; }
        else { a=(a<dy) ? a : dy-1 ; }
        bread[f]= a ; // How many bytes to read from disk per field ! 
        plape=a*mespl;
        a = (int) (plape);
        if (!f) { xpr[0]=xpl[0]+a-1 ; }
        else { xpl[f]=xpr[f-1]+myfont_wid[fnt]; xpr[f]=xpl[f]+a-1;}
        
        width=width+a+myfont_wid[fnt];
        if (width>i) break ;
    }

if (width>i) { width=width-a-myfont_wid[fnt]; width+=2; } 
if (width<470) width=470 ;

pedtosh=f ; // Αριθμός πεδίων (+1) για εμφάνιση ! Τυχόν loop να είναι μικρότερο του pedtosh
//for (i=f;i<k1;i++) showp[i]=-1;

for(f=pedtosh ; f<k1 ; f++) { showp[f]=-1; }
            
    
for (f=0;f<3;f++) {
    deigma[f][0]=255;
    neodeigma[f][0]=255;
}
deigma1_text[0]=255;
neodeigma1_text[0]=255;

whouv=gouv;
gouv = myfont[fnt];
str=mem_str;

plbut=dbplgr;
mem_epl=malloc(plbut);
if (!mem_epl)  {information (2-keyb_gr,0,0); goto FYGE; }
epl=mem_epl;

i=0; a=0;   

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f] == 255) {
       but[i++]=mem_str+a;
       a=f+1; 
        }
}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) {ar_dom[f]=f; krit[f]=0; epl[f]=0;}

if (epil_pos) {
    for (f=0 ; f<tot_opts ; f++) {
        for (i=0 ; i<plbut ;i++) {
            if (disk_dom[i] == epil_pos[f]) {epl[i]=1; synepil++; break;}
        }
    }
}

if (key) {
    switch (sort_type) {
    
        case 6 : // Ημερομηνία
            
            item_mem=malloc(plbut*4);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Gitem=item_mem;
            for (f=0;f<plbut;f++) {
                cardiary.ldate=0;
                if (but[f][0] !=255) {
                mytext_tonorm(but[f],str1024,50);
                w=strlen(str1024);
                for (i=0;i<4;i++) {
                    nu[i]= str1024[w-i-1] - '0' ;
                }
                dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                //dysena.wotim -= 1900;
                cardiary.mydate[3]=dysena.dyomikra[1];
                cardiary.mydate[2]=dysena.dyomikra[0];

                nu[0]=  str1024[w-6] - '0' ;
                nu[1]=  str1024[w-7] -  '0';
                if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                else cardiary.mydate[0]=nu[1]*10 + nu[0];

                nu[0]=  str1024[w-9] - '0' ;
                nu[1]=  str1024[w-10] - '0' ;
                if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                else cardiary.mydate[1]=nu[1]*10 + nu[0];
                        }
                Gitem[f]=cardiary.ldate ;
            }
            pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 3 :  // Ακέραιος αριθμός
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Litem=item_mem;
            for (f=0;f<plbut;f++) {
                Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;
            
        case 4: // Φλοατ
            
            item_mem=malloc(plbut*8);
            if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
            Fitem=item_mem;
            for (f=0;f<plbut;f++) {
                Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
            }
            pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
            break;            
            
        case 0:
        case 1:
        case 2:
            
            item_mem=malloc(plbut*24);
            if (!item_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
            item=item_mem;
            for (f=0;f<plbut;f++) {
                bitem[0].big=bitem[1].big=bitem[2].big=0;
                i=0;by=23;
                do {
                what=but[f][i];
                if (what>163) break;
                if (keyb_gr){
                        switch (what) {

                            case 96:
                            case 101:
                            case 104:
                            case 107:
                            case 116:
                            case 122:
                            case 129:
                            case 132:
                            case 137:
                            case 140:
                            case 143:
                            case 151:
                            case 157:
                            case 163:
                            what--;
                            break;

                            case 108:
                            case 123:
                            case 144:
                            case 158:
                            what-=2;
                            break;


                            case 109:
                            case 124:
                            what-=3;
                            break;

                            case 130:
                            what=119;

                        }

                }
                rby=by%8; low=(2-(by/8));
                //if (by>7) {low=0;rby=by-8;} else low=1;
                bitem[low].sma[rby]=what;
                by-- ; i++;
                } while (by>=0);
                item[f].fg=bitem[0].big;
                item[f].sg=bitem[1].big;
                item[f].tg=bitem[2].big;
            }

            pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
            free (item_mem) ; item_mem=0;
        }
    }

for (i=0;i<pedtosh;i++) {    
    size1=0;
    for (f=0;f<=dbfinum;f++) {
        if (showp[i]==f) {almap[i]=size1; break;} 
        size1 += xlimk[f];
    }
}

/*
for (f=0;f<=dbfinum;f++) {
    if (ptr_pedio[f]->fitype < 3) multicr[f]->cron_1=0;
}
*/
    size2=xlimk[dbfdata.fd_arped];
    mem_deigma_text = malloc(size2);
    if (!mem_deigma_text) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
    deigma_text=mem_deigma_text;
    
cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 

fhe=myfont_hei[fnt]+2;

if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; 
}
while ( ((lines*fhe + 110 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 110 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+110;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;
ynames=yt1+28;
yb=yt1+buthei-1;

while (xt+width+11>info.right) xt--;
xb=xt+width-1;

i=(lines<plbut) ? lines : plbut ; 
for(f=1;f<pedtosh;f++) {
    mem_ped[f]=malloc( (bread[f]+1) * i );
    if (!mem_ped[f]) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
}

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)

refresh();
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);

line (xt+9,ynames+19,xb-9,ynames+19) ; // Γραμμή κάτω από ονόματα

rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=ynames+20 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
xfrba = (delon) ? xdel+55 : xdel +2 ; 
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
xfo=xb-19; xright=xfo-45 ; xleft=xt+23;
xcancel = xvice + 30 ; ycancel=ysort-5;
xgroup=xcancel+50; xfound=xgroup+50 ;
_areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);


// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); kati=1; goto FYGE ; } 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl+60, yt1+2, xtepr-60);

// Εμφάνιση Ονομάτων Πεδίων !
if (k1>1) _bareacls(xt+9,ynames,xb-9,ynames+18,conom); // Γέμισμα για τα ονόματα των πεδίων
else _bareacls(xt+9,ynames,xb-9,ynames+18,orange);

svou=0;

for (f=0;f<pedtosh;f++) {
    xpl[f]+=xtepl ; xpr[f]+=xtepl; // Προσοχή εδώ....
    if (f>svou) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
    else { 
        _bareacls(xpl[f],ynames,xpr[f],ynames+18,orange);
        if (k1>1) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
        else  _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xtepr,ynames+18,cblack, orange);
    }
    if (k1>1) {setrgbcolor(dbred) ; line (xpl[f],ynames,xpl[f],ynames+18); line  (xpr[f],ynames,xpr[f],ynames+18); }
}

chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
slxr[0]=0; slxr[1]=0; slxr[2]=186;
xrep[0]=xrep[1]=255 ; xrep[2]=0;
slcl[0]=slcl[1]=255 ; slcl[2]=0;
xrcl[0]=xrcl[1]=xrcl[2]=0;
_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
refresh();

// TELOS EPIKEFALIDAS


//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Right_17.ico");
mem_right=icontomem(file_1,255);
if (mem_right==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Left_17.ico");
mem_left=icontomem(file_1,255);
if (mem_left==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Cancel_40.ico");
mem_cancel=icontomem(file_1,255);
if (mem_cancel==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/Add_group.ico");
mem_group=icontomem(file_1,255);
if (mem_group==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

strcpy(file_1,path_name);
strcat(file_1,"ICD/add_found.ico");
mem_found=icontomem(file_1,255);
if (mem_found==NULL) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ;} 

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(xfo,yt-18,mem_fonter,255);

if (synepil) _puticon(xcancel,ycancel,mem_cancel,255);

if (showp[pedtosh-1]<bigger) _puticon(xright,yt-18,mem_right,255);

if (k1>1 && showp[1]>smaller) _puticon(xleft,yt-18,mem_left,255);

if (seflag==2)  _puticon(xgroup,ycancel,mem_group,255);

_puticon(xfound,ycancel,mem_found,255);

a=0;k=0; a1=plbut; sort=0;bar=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL);  kati=1; goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ 
    karta=ar_dom[a];
    if (!epl[karta]) {
        _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),bkxr);
        if (but[karta][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0]);
        else _outfanis_col(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0]);

        for (f=1;f<pedtosh;f++) {
            dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
            if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
            fread(str1024a,1,bread[f],fpcard);
            str1024a[bread[f]]=255;
            ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
            mystrcpy(mesa_ptr,str1024a);
            _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
            if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
            else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
        }
    }
    else {
        _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),slcl);
        if (but[karta][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl );
        else  _outfanis_colxr(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl);
        
        for (f=1;f<pedtosh;f++) {
            dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
            if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
            fread(str1024a,1,bread[f],fpcard);
            str1024a[bread[f]]=255;
            ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
            mystrcpy(mesa_ptr,str1024a);
            _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),slcl);
            if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , xrcl, slcl);
            else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , xrcl , slcl);
        }
    }
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=0;drag=0;fonter=0; tori=tole=0;
protyx=tyx=lines; prokef=kefali=akiro=krit_insert=add_found=0 ; 
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev)) continue ;    
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    i=0;
    for (f=1;f<pedtosh;f++) {
        if (mx>xpl[f] && mx<xpr[f] && my>ynames && my<ynames+18) {
            kefali=f ; i=1; break ;
        }
    }
    
    if (i) { // Κίνηση στα ονόματα πεδίων
        
        if (ektos) {ektos=0;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        }
        if (marrs) {
            marrs=0;
            puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
        else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (profrba) {
            profrba=0 ;
            hide_help(hdhlpxt , hdhlpyt);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ; }
        else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (probar) probar=0;
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (prokef==kefali) continue ;
        
        if (kefali>svou) {
            for (f=svou+1;f<=kefali;f++) {
            _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,orange);
            _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
            }
            prokef=kefali;
            refresh();
            continue;
        }
        
        else if (kefali<svou) {
            
            for(f=svou;f>=kefali;f--) {
                _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,conom);
                _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
            }
            prokef=kefali;
            refresh();
            continue;
        }
        
        else {
            f=kefali;
            _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,conom);
            _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
            prokef=kefali;
            refresh();
            continue;
        }       
    }
    
    if (prokef) {
        for (f=1; f<=svou ; f++) {
            _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,orange);
            _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
        }
        
        for (f=svou+1 ; f<pedtosh ; f++) {
            _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,conom);
            _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
        }
        refresh(); prokef=0;
    }
    
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός (lines) επιλογών !!
        
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
               
                el = (sort) ? pano-protyx : pano+protyx;
                if (!epl[ar_dom[el]]) {
                    _bareacls(xtepl, ytepl+protyx*fhe,xpr[0],ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+protyx*fhe , xpr[0]);  
                    for (f=1;f<pedtosh;f++) {
                        _bareacls(xpl[f], ytepl+protyx*fhe,xpr[f],ytepl+protyx*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                        ptr1=protyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                        if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+protyx*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr) ;
                        else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+protyx*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                    }
                    refresh();}
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
        ektos=0;  
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         if (!epl[ar_dom[el]]) {
            _bareacls(xtepl, ytepl+tyx*fhe,xpr[0],ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+tyx*fhe , xpr[0] , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+tyx*fhe , xpr[0], xrep, slxr);
            for (f=1;f<pedtosh;f++) {
                _bareacls(xpl[f], ytepl+tyx*fhe,xpr[f],ytepl+tyx*fhe+(fhe-2),slxr);
                ptr1=tyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+tyx*fhe , xpr[f] , xrep, slxr );
                else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+tyx*fhe , xpr[f], xrep, slxr);
            }
            refresh();}
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl, ytepl+protyx*fhe,xpr[0],ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
            for (f=1;f<pedtosh;f++) {
                _bareacls(xpl[f], ytepl+protyx*fhe,xpr[f],ytepl+protyx*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                ptr1=protyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+protyx*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr) ;
                else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+protyx*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
            }
            refresh();}
        el = (sort) ? pano-tyx : pano+tyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl, ytepl+tyx*fhe,xpr[0],ytepl+tyx*fhe+(fhe-2),slxr);
            if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+tyx*fhe , xpr[0] , xrep, slxr );
            else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+tyx*fhe , xpr[0] , xrep, slxr);
            for (f=1;f<pedtosh;f++) {
                _bareacls(xpl[f], ytepl+tyx*fhe,xpr[f],ytepl+tyx*fhe+(fhe-2),slxr);
                ptr1=tyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+tyx*fhe , xpr[f] , xrep, slxr );
                else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+tyx*fhe , xpr[f], xrep, slxr);
            }
            refresh();}
        protyx=tyx;
        continue;
        }
    }
    
    
    // PONTIKI EKTOS (lines) EPILOGVN
    
    if (protyx!=lines) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        el = (sort) ? pano-protyx : pano+protyx;
        if (!epl[ar_dom[el]]) {
            _bareacls(xtepl, ytepl+protyx*fhe,xpr[0],ytepl+protyx*fhe+(fhe-2),bkxr);
            el = (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+protyx*fhe , xpr[0]);  
            for (f=1;f<pedtosh;f++) {
                _bareacls(xpl[f], ytepl+protyx*fhe,xpr[f],ytepl+protyx*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                ptr1=protyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+protyx*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr );
                else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+protyx*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
            }
            refresh();}
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κριτηρίων αναζήτησης / Αριστερό κλικ : Αναζήτηση", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Criteria / Left Click : Search", xdel, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
    if (keyb_gr) show_help("Ταξινόμηση των στοιχείων ή, εμφάνιση σύμφωνα με την άυξουσα σειρά των καρτελών", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Data sorting or , display according to the DB cards order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
      ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
        ektos=0;
        if (probar) probar=0;
        else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
         if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt+1, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt+1, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
            ektos=0;
            if (probar) probar=0;
            else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
            
            if (!drag) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            drag=1;
            putNOTicon(drax,dray,mem_drag);
            if (keyb_gr) show_help("Αλλαγή Διαστάσεων Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
            else show_help("Change Window Dimensions", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
            continue ;}
            else continue ;

        }

    if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}        
    
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        else if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
        else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}  
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (k1>1) {

        if (showp[pedtosh-1]<bigger) {

            if (mx>xright && mx<xright+40 && my>yt-18 && my<yt) { // PONTIKI STO right_arrow
            
                ektos=0;
                if (probar) probar=0;
                else if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
                
                if (!tori) {
                    
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                tori=1;
                putNOTicon(xright,yt-18,mem_right);
                if (keyb_gr) show_help(" Μετακίνηση πεδίων δεξιά ", xright , yt , &hdhlpxt , &hdhlpyt) ;
                else show_help(" Fields movement to the right ", xright , yt, &hdhlpxt , &hdhlpyt) ;
                continue; }
                else continue;
                }
            
            if (tori) {tori=0 ; puticon(xright,yt-18,mem_right,255); hide_help(hdhlpxt , hdhlpyt);}        

        }
        
        f=0;
        while (desm[f]>=0) f++;
        if (showp[f]>smaller) {
            
            if (mx>xleft && mx<xleft+40 && my>yt-18 && my<yt) { // PONTIKI STO Left_arrow
            
                ektos=0;
                if (probar) probar=0;
                else if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
                
                if (!tole) {
                    
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                tole=1;
                putNOTicon(xleft,yt-18,mem_left);
                if (keyb_gr) show_help(" Μετακίνηση πεδίων αριστερά ", xleft , yt , &hdhlpxt , &hdhlpyt) ;
                else show_help(" Fields movement to the left ", xleft , yt, &hdhlpxt , &hdhlpyt) ;
                continue; }
                else continue;
                }
            
            if (tole) {tole=0 ; puticon(xleft,yt-18,mem_left,255); hide_help(hdhlpxt , hdhlpyt);} 
        }
    }
    
    if (synepil) {
        
            if (mx>xcancel && mx<xcancel+42 && my>ycancel && my<yicob ) { // PONTIKI STO CANCEL
            
                ektos=0;
                if (probar) probar=0;
                else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
                
                if (!akiro) {
                    
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                akiro=1;
                putNOTicon(xcancel,ycancel,mem_cancel);
                if (keyb_gr) sprintf (str1024 , " Ακύρωση Επιλογών ( %u στοιχεία ) " , synepil );
                else sprintf (str1024 , " Cancel Selections ( %u elements ) " , synepil );
                show_help(str1024, xcancel , yb, &hdhlpxt , &hdhlpyt) ;
                continue; }
                else continue;
                }
            
            if (akiro) {akiro=0 ; puticon(xcancel,ycancel,mem_cancel,255); hide_help(hdhlpxt , hdhlpyt);} 
    }

    
        if (mx>xfound && mx<xfound+41 && my>ycancel && my<yicob ) { // PONTIKI STO add_found (προσθέτει ευρήματα)
        
            ektos=0;
            if (probar) probar=0;
            else if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);}
            
            if (!add_found) {
                
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            add_found=1;
            putNOTicon(xfound,ycancel,mem_found);
            
            if (finds) {
                if (keyb_gr) sprintf (str1024 , " Συμπερίληψη ευρημάτων στις επιλογές σας (μέχρι %u στοιχεία ) " , finds );
                else sprintf (str1024 , " Include findings in your selections (up to %u elements ) " , finds_1 );}
            else {
                if (keyb_gr) sprintf (str1024 , " Δεν υπάρχουν ευρήματα για συμπερίληψη στις επιλογές σας " );
                else sprintf (str1024 , " There are no findings to include in your selections ");
            }
                
            show_help(str1024, xfound , yb, &hdhlpxt , &hdhlpyt) ;
            continue; }
            else continue;
            }
            
            if (add_found) {add_found=0;puticon(xfound,ycancel,mem_found,255);hide_help(hdhlpxt , hdhlpyt);}
    
    if (seflag==2) {
        
            if (mx>xgroup && mx<xgroup+40 && my>ycancel && my<yicob ) { // PONTIKI STO Get from criteria
            
                ektos=0;
                if (probar) probar=0;
                
                if (!krit_insert) {
                    
                cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                krit_insert=1;
                putNOTicon(xgroup,ycancel,mem_group);
                if (keyb_gr) sprintf (str1024 , " Πρόσθεση ευρημάτων σύνθετης αναζήτησης (μέχρι %u στοιχεία ) " , gocards );
                else sprintf (str1024 , " Add foundings from complex search (up to %u elements ) " , gocards );
                show_help(str1024, xgroup , yb, &hdhlpxt , &hdhlpyt) ;
                continue; }
                else continue;
                }
            
            if (krit_insert) {krit_insert=0 ; puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);} 
    }
        

    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
    }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    if (ektos) continue ;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);}
   continue;
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
           
           if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!fonter) ) { // Πολλαπλή Επιλογή
                
                f=protyx; k=f+1 ; el=pano+bima*f;
                a=(sort) ? plbut-el : el ; a++;
                pa = ar_dom[el];
                chepil=synepil;
                if (!epl[pa]) { // Δεξί κλικ σε μη επιλεγμένο
                    protyx=lines;
                    do {
                        epl[pa]=1; synepil++;
                        if (k) { // Χρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά )
                                k--;
                                _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),slcl);
                                if (but[pa][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl );
                                else  _outfanis_colxr(fnt, but[pa] , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl);

                                for (f=1;f<pedtosh;f++) {
                                    _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),slcl);
                                    ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                                    if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , xrcl, slcl );
                                    else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+k*fhe , xpr[f], xrcl, slcl);
                                }
                                
                                if (krit[pa]) {setrgbcolor (dbred) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                        }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (epl[pa]) break ;
                    }while (a) ;
                }
                else {  // Δεξί κλικ σε επιλεγμένο
                    do {
                        epl[pa]=0; synepil--;
                        if (k) { // Αποχρωματίζει επιλογή (το πολύ μέχρι το pano φαίνεται , μετά συμβαίνει εσωτερικά)
                                k--;
                                _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),bkxr);
                                if (but[pa][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0]);
                                else _outfanis_col(fnt, but[pa] , xtepl+1 , ytepl+k*fhe , xpr[0]);
                                for (f=1;f<pedtosh;f++) {
                                    _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                                    ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                                    if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr );
                                    else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+k*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                                }
                                    if (krit[pa]) {setrgbcolor (dbyel) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                            }
                        el-=bima; pa = ar_dom[el]; a-- ;
                        if (!epl[pa]) break ;
                    }while (a) ;
                }
                if (chepil && !synepil) _areacls(xcancel,ycancel,xcancel+41,ycancel+39,0,0,0);
                else if (!chepil && synepil) _puticon(xcancel,ycancel,mem_cancel,255); 
                refresh();
                
            }
            else if (profrba) information (52-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) { // Ρύθμιση Αναζήτησης ανάλογα τον τύπο !
                // Right Click !!
                newsea=1;
                switch (sort_type) {

                    case 6 : // Ημερομηνία
                        user_ans=input_dbsearch_date(neodeigma[0],neodeigma[1],neodeigma[2],dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                        
                    case 3 :  // Ακέραιος αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],3, dbfdata.fd_arped);

                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}
                        
                        goto FROMNEWSEARCH;
                    
                    case 4 :  // Δεκαδικός αριθμός   
                        user_ans=input_dbsearch_num(neodeigma[0],neodeigma[1],neodeigma[2],4,dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        
                        red=mystrcmp (deigma[0],neodeigma[0]);
                        if (red) {mystrcpy(deigma[0],neodeigma[0]); redline=0;}
                        green=mystrcmp (deigma[1],neodeigma[1]);
                        if (green) {mystrcpy(deigma[1],neodeigma[1]); redline=0;}
                        blue=mystrcmp (deigma[2],neodeigma[2]);
                        if (blue) {mystrcpy(deigma[2],neodeigma[2]); redline=0;}

                        goto FROMNEWSEARCH;
                        
                    case 0 :
                    case 1 :
                    case 2 :
                        user_ans=input_dbsearch_text(neodeigma1_text , dbfdata.fd_arped);
                        if (user_ans!=1) continue ;
                        if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                        red=mystrcmp (deigma1_text,neodeigma1_text);
                        if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                        
                        goto FROMNEWSEARCH;
                }
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!fonter) && (!add_found) && (!prokef) && (!tori) && (!tole) && (!akiro) && (!krit_insert) ) { // Επιλογή κάποιου από τα κουτιά αντιστρέφει την κατάστασή του.
        
        el= (sort) ? pano-protyx : pano+protyx;
        if (epl[ar_dom[el]])  { // Ακυρώνεται η επιλογή !
          epl[ar_dom[el]]=0; synepil--;
          if (!synepil) _areacls(xcancel,ycancel,xcancel+41,ycancel+39,0,0,0);
        _bareacls(xtepl, ytepl+protyx*fhe,xpr[0],ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+protyx*fhe , xpr[0]);
        for (f=1;f<pedtosh;f++) {
            _bareacls(xpl[f], ytepl+protyx*fhe,xpr[f],ytepl+protyx*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
            ptr1=protyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
            if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+protyx*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr );
            else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+protyx*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
        }
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+1,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }
            protyx=lines;
            refresh();
            continue ;
        }
        else {
        epl[ar_dom[el]]=1; synepil++;
        if (synepil==1) _puticon(xcancel,ycancel,mem_cancel,255);
        _bareacls(xtepl, ytepl+protyx*fhe,xpr[0],ytepl+protyx*fhe+(fhe-2),slcl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+protyx*fhe , xpr[0] , xrcl, slcl );
        else  _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+1 , ytepl+protyx*fhe , xpr[0] , xrcl, slcl);
        for (f=1;f<pedtosh;f++) {
            _bareacls(xpl[f], ytepl+protyx*fhe,xpr[f],ytepl+protyx*fhe+(fhe-2),slcl);
            ptr1=protyx*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
            if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+protyx*fhe , xpr[f] , xrcl, slcl );
            else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+protyx*fhe , xpr[f], xrcl, slcl);
        }
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+1,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }
        refresh(); 
        continue ;}
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            protyx=lines ;
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) { // Αναζήτηση με βάση προηγούμενο δεξί κλικ ...
FROMNEWSEARCH :
            a1=0;
            switch (sort_type) {

                case 3:
                case 4:
                case 6:
            
                    for (f=0;f<3;f++) {
                        if (deigma[f][0]!=255) {a1=1; break ;}}
                
                break ; 
            
                case 0:
                case 1:
                case 2:
                    
                    if (deigma1_text[0]!=255) a1=1;
                
                break ;
            }
            
            if (!a1) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                    protyx=lines; 
                    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
                    pa=pano;
                    telos1=(sort) ? pa+1 : plbut-pa ;
                    
                    k=0;
                    do {
                    karta=ar_dom[pa];
                    if (!epl[karta]) {
                        _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),bkxr);
                        if (but[karta][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0]);
                        else _outfanis_col(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0]);

                        for (f=1;f<pedtosh;f++) {
                            _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                            ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                            if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr );
                            else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+k*fhe , xpr[f],ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                        }
                    }
                    
                    else {
                        _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),slcl);
                        if (but[karta][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl );
                        else  _outfanis_colxr(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl);
                        
                        for (f=1;f<pedtosh;f++) {
                            _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),slcl);
                            ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                            if (mesa_ptr[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , xrcl, slcl );
                            else _outfanis_colxr(fnt, mesa_ptr , xpl[f]+1 , ytepl+k*fhe , xpr[f], xrcl, slcl);
                        }
                    }
                                           
                    pa+=bima ; telos1--; k++;
                    }while (telos1 && k<lines);
                    refresh();

                for (f=0;f<plbut;f++) krit[f]=0;
                redline=0; finds=0;
                if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
                newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) continue ;
                prodel=0; puticon (xdel,ydel,mem_del,255);
                continue ;}
                
                protyx=lines ; 
            
            if (redline) {
                redline=1;
                if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                    c= pano + (bima*lines) ;
                    if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                    if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                    telos=(sort) ? c+1 : plbut-c;
                    if (!sort) {
                        if (c<0) {c=0 ; telos=plbut;}
                        else if ((c+lines)>plbut) {
                            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
                    else if (sort) {
                        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                        else if ( (c-lines+1)<0 ) { 
                            c=lines-1; telos=lines; 
                            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                            pano=c; telos=(sort) ? c+1 : plbut-c;
                }
                //pano_1=pano ; sort_1=sort ; key_1=key;
                telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;} 
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                }
                else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos= (sort) ? c+1 : plbut-c ;
                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            else {
                
                // Μετατροπή των αλφαριθμητικών στοιχείων που εισήχθηκαν για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                switch (sort_type) {
                    
                    case 6 : // Ημερομηνία
                        
                        for (f=0;f<3;f++) {
                            cardiary.ldate=0;
                            if (deigma[f][0] !=255) {
                            mytext_tonorm(deigma[f],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                            Gi[f]=cardiary.ldate ; // unsigned int Gi1
                            }
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            
                            for (f=0;f<3;f++){
                            Li[f]=(deigma[f][0]!=255) ? (long int) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            for (f=0;f<3;f++){
                                Fi[f]=(deigma[f][0]!=255) ? (double) convert_str(15 , deigma[f] ) : 0 ;   
                            }
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            mystrcpy (deigma2_text , deigma1_text) ;
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                    switch (sort_type) {
                        
                        case 6 : // Ημερομηνία
                            // Μετατρέπει στοιχεία λίστας  !
                            cardiary.ldate=0;
                            mytext_tonorm(but[pa],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                            
                            Gidb=cardiary.ldate ; // unsigned int Gi
                            
                        // ΣΥΓΚΡΙΣΗ !!
                           
                            if (deigma[0][0] !=255) {
                                sGidb=(unsigned short int) Gidb ; 
                                sG= (unsigned short int) Gi[0];
                                if (sGidb == sG ) { krit[pa]=1; pa++; continue ; }
                                //if ( Gidb==Gi[0] ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Gidb>Gi[1]) && (Gidb<Gi[2]) ) {krit[pa]=1; pa++; continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Gidb>Gi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Gidb<Gi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 3 :  // Ακέραιος αριθμός
                            // Συγκριση
                                                       
                            Lidb= (long int) convert_str( 15 , but[pa] ) ;
                            
                            if (deigma[0][0] !=255) {
                                    if ( Lidb==Li[0] ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Lidb>Li[1]) && (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Lidb>Li[1]) ) {krit[pa]=1; pa++; continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Lidb<Li[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 4: // Φλοατ
                            
                            Fidb= (double) convert_str(15 , but[pa]) ; 

                            if (deigma[0][0] !=255) {
                                if ( Fidb==Fi[0] ) {krit[pa]=1; pa++; continue;} 
                            }
                            
                            if ( (deigma[1][0] !=255) && (deigma[2][0]!=255) ) {
                                if ( (Fidb>Fi[1]) && (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                                krit[pa]=0; pa++;  continue;
                            }
                            
                            if (deigma[1][0] !=255) {
                                if ( (Fidb>Fi[1]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            if (deigma[2][0] !=255) {
                                if ( (Fidb<Fi[2]) ) {krit[pa]=1; pa++;  continue;}
                            }
                            
                            krit[pa]=0; pa++;  continue;
                            
                            break ;
                            
                        case 0:
                        case 1:
                        case 2:
                            
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma_text μπορεί να διαβάζεται από το δίσκο ή όχι αναλόγως το μέγεθος - θα πάρει το μεγάλο στριγκ από το αντίστοιχο της λίστας

                            if (limk[dbfdata.fd_arped] < 46) mystrcpy (deigma_text,but[pa]);
                            else {
                                //karta=ar_dom[pa];                        
                                fseek(fpcard , ((disk_dom[pa] * dbcardsize) + almap[0]) , 0);
                                fread(deigma_text,1,limk[dbfdata.fd_arped],fpcard);
                            }
                            i=0;
                            while (deigma_text[i]!=255) i++;

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma_text[f]=128;
                                        break;

                                        case 130:
                                        deigma_text[f]=119;
                                    }
                                }
                                if ( (deigma_text[f]>68) && (deigma_text[f]<95) ) deigma_text[f]-=26;
                            }
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=deigma_text[i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=deigma_text[i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    }
                }
            }
         
            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1; 
            finds=i ;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d καρτέλες!", i);
                else sprintf(str1024,"Identity occurred in %d DB cards!", i);
                if (ptr_pedio[dbfdata.fd_arped]->fitype < 3) {
                    mystrcpy ( multicr[dbfdata.fd_arped]->sample_tcode , deigma1_text );
                    mystrcpy (normdeigma[dbfdata.fd_arped] , deigma2_text) ;
                    multicr[dbfdata.fd_arped]->cron_1=1;
                }
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+bima*f;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;} 
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+bima*f;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;
                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                prodel=0; puticon (xdel,ydel,mem_del,255);
                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;
            SDL_PollEvent(&sdlev);
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>xdel && mx<xdel+30 && my>ydel && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
            prodel=0; puticon (xdel,ydel,mem_del,255);
            goto emfan;
        }
        
        else if (profrba) {  // Ταξινόμηση !!
            
            protyx=lines ; 
            key=(1-key);
            for (f=0;f<plbut;f++) ar_dom[f]=f;
        
            if (key) {
    
                switch (sort_type) {
    
                    case 6 : // Ημερομηνία
                        
                        item_mem=malloc(plbut*4);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                        Gitem=item_mem;
                        for (f=0;f<plbut;f++) {
                            cardiary.ldate=0;
                            if (but[f][0] !=255) {
                            mytext_tonorm(but[f],str1024,50);
                            w=strlen(str1024);
                            for (i=0;i<4;i++) {
                                nu[i]= str1024[w-i-1] - '0' ;
                            }
                            dysena.wotim=nu[3]*1000 + nu[2]*100 + nu[1]*10 + nu[0];
                            //dysena.wotim -= 1900;
                            cardiary.mydate[3]=dysena.dyomikra[1];
                            cardiary.mydate[2]=dysena.dyomikra[0];

                            nu[0]=  str1024[w-6] - '0' ;
                            nu[1]=  str1024[w-7] -  '0';
                            if (keyb_gr) cardiary.mydate[1]=nu[1]*10 + nu[0];
                            else cardiary.mydate[0]=nu[1]*10 + nu[0];

                            nu[0]=  str1024[w-9] - '0' ;
                            nu[1]=  str1024[w-10] - '0' ;
                            if (keyb_gr) cardiary.mydate[0]=nu[1]*10 + nu[0];
                            else cardiary.mydate[1]=nu[1]*10 + nu[0];
                                    }
                            Gitem[f]=cardiary.ldate ;
                        }
                        pro_sort_uint(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                        free (item_mem) ; item_mem=0;
                        break;
                        
                    case 3 :  // Ακέραιος αριθμός
                        
                        item_mem=malloc(plbut*8);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                        Litem=item_mem;
                        for (f=0;f<plbut;f++) {
                            Litem[f]= (but[f][0]!=255) ? (long int) convert_str(15 , but[f]) : 0 ;
                        }
                        pro_sort_signedlong(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                        free (item_mem) ; item_mem=0;
                        break;
                        
                    case 4: // Φλοατ
                        
                        item_mem=malloc(plbut*8);
                        if (!item_mem) {information (2-keyb_gr,0,0) ; break ;}
                        Fitem=item_mem;
                        for (f=0;f<plbut;f++) {
                            Fitem[f]= (but[f][0]!=255) ? (double) convert_str(15 , but[f]) : 0 ;
                        }
                        pro_sort_double(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                        free (item_mem) ; item_mem=0;
                        break;            
                        
                    case 0:
                    case 1:
                    case 2:
                        
                        item_mem=malloc(plbut*24);
                        if (!item_mem) {information (2-keyb_gr,0,0); kati=1; goto FYGE; }
                        item=item_mem;
                        for (f=0;f<plbut;f++) {
                            bitem[0].big=bitem[1].big=bitem[2].big=0;
                            i=0;by=23;
                            do {
                            what=but[f][i];
                            if (what>163) break;
                            if (keyb_gr){
                                    switch (what) {

                                        case 96:
                                        case 101:
                                        case 104:
                                        case 107:
                                        case 116:
                                        case 122:
                                        case 129:
                                        case 132:
                                        case 137:
                                        case 140:
                                        case 143:
                                        case 151:
                                        case 157:
                                        case 163:
                                        what--;
                                        break;

                                        case 108:
                                        case 123:
                                        case 144:
                                        case 158:
                                        what-=2;
                                        break;


                                        case 109:
                                        case 124:
                                        what-=3;
                                        break;

                                        case 130:
                                        what=119;

                                    }

                            }
                            rby=by%8; low=(2-(by/8));
                            //if (by>7) {low=0;rby=by-8;} else low=1;
                            bitem[low].sma[rby]=what;
                            by-- ; i++;
                            } while (by>=0);
                            item[f].fg=bitem[0].big;
                            item[f].sg=bitem[1].big;
                            item[f].tg=bitem[2].big;
                        }

                        pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
                        free (item_mem) ; item_mem=0;
                    }
                }

                *sorton=key;
                _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
                if (key) puticon (xfrba,yfrba,mem_front,255) ;
                else puticon (xfrba,yfrba,mem_back,255) ;
                
                c = (sort) ? plbut-1 : 0 ;
                telos=plbut;
                goto emfan ;
            
        }  // TELOS profrba
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255; 
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            i=0;
            for (f=0;f<plbut;f++) {
                if(epl[f]) {i=1;break;}
            }
            if (!i) {free(mem_epl); mem_epl=0;}
            continue ;
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;

            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            for (f=0;f<pedtosh;f++) {
                xpl[f]-=xtepl ; xpr[f]-=xtepl;
            }
            
            xt=xt1; yt=yt1+19;
            ynames=yt1+28;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=ynames+20 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ; 
            xfrba = (delon) ? xdel+55 : xdel+2 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ;
            xfo=xb-19; xright=xfo-45 ; xleft=xt+23;
            xcancel = xvice + 30 ; ycancel = ysort-5 ;
            xgroup=xcancel+50; xfound=xgroup+50 ;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;}
            

            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();

            for (f=0;f<pedtosh;f++) {
                xpl[f]+=xtepl ; xpr[f]+=xtepl;
            }

            
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<110+fhe*5) newhei=110+fhe*5;
            newhei=(newhei-110)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+110;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            protyx=lines;
            for(f=1;f<k1;f++) {
                if (mem_ped[f]) { free(mem_ped[f]); mem_ped[f]=0; }
            }
            
            i = (lines<plbut) ? lines : plbut ;
            for(f=1;f<pedtosh;f++) {
                mem_ped[f]=malloc( (bread[f]+1) * i );
                if (!mem_ped[f]) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
            }
            
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            
            refresh();
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            line (xt+9,ynames+19,xb-9,ynames+19) ; // Γραμμή κάτω από ονόματα
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            ycancel = ysort-5 ;

            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl+60, yt1+2, xtepr-60);
            // Εμφάνιση Ονομάτων Πεδίων !
            if (k1>1) _bareacls(xt+9,ynames,xb-9,ynames+18,conom); // Γέμισμα για τα ονόματα των πεδίων
            else _bareacls(xt+9,ynames,xb-9,ynames+18,orange);
            
            for (f=0;f<pedtosh;f++) {
                
                if (f>svou) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                else { 
                    _bareacls(xpl[f],ynames,xpr[f],ynames+18,orange);
                    if (k1>1) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
                    else  _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xtepr,ynames+18,cblack, orange);
                    
                }
                if (k1>1) {setrgbcolor(dbred) ; line (xpl[f],ynames,xpl[f],ynames+18); line  (xpr[f],ynames,xpr[f],ynames+18); }
            }
            
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);

            _puticon(xfo,yt-18,mem_fonter,255);
            
            if (synepil) _puticon(xcancel,ycancel,mem_cancel,255);
            
            if (seflag==2)  _puticon(xgroup,ycancel,mem_group,255);
           
            
            if (k1>1) {
                 if (showp[pedtosh-1]<bigger) _puticon(xright,yt-18,mem_right,255);
                f=0; while (desm[f]>=0) f++;
                if (showp[f]>smaller)  _puticon(xleft,yt-18,mem_left,255);
            }
            
            _puticon(xfound,ycancel,mem_found,255);
            
            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        

        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, chxr, bkxr, slxr );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            if (user_ans<0) continue;
            fo=1;

            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            fhe=myfont_hei[fnt]+2;
            while  ( ((lines*fhe + 110 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 110 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            
            // Αρχικός υπολογισμός των συντεταγμένων (xpl-xpr) κάθε πεδίου - υπολογισμός του max width στα 4/5 της οθόνης
            // Υπολογισμός μέγιστου αριθμού πεδίων προς εμφάνιση και μέγιστου αριθμού χαρακτ. κατά πεδίο.
            
            mespl=myfont_wid[fnt]*75/100; cur = (4 * (info.right-info.left+1) ) / 5 ;
            dx=36; dy=26;
            
                width=18;
                xpl[0]=0;
                k=-1;
                for (f=0; f<k1 ; f++) {
                    if ( (showp[f]<0) && (k<0) ) {
                        k=f;
                        if (k==1) {
                             for (i=0 ; i<=dbfinum ; i++) {
                                if (i==showp[0]) continue ;
                                if (pedia[i] && ptr_pedio[i]->fitype!=5) {
                                    showp[k]=i; k++ ;
                                }
                            }
                        }
                        else {
                            for (i=showp[f-1]+1 ; i<=dbfinum ; i++) {
                                if (i==showp[0]) continue ;
                                if (pedia[i] && ptr_pedio[i]->fitype!=5) {
                                    showp[k]=i; k++ ;
                                }
                            }
                        }
                    }
                    if (showp[f]<0) break ;
                    a=ptr_pedio[showp[f]]->fiorio;
                    if (showp[f]==dbkey) { a=(a<dx) ? a : dx-1 ; }
                    else { a=(a<dy) ? a : dy-1 ; }
                    bread[f]= a ; // How many bytes to read from disk per field ! 
                    plape=a*mespl;
                    a = (int) (plape);
                    if (!f) { xpr[0]=xpl[0]+a-1 ; }
                    else { xpl[f]=xpr[f-1]+myfont_wid[fnt]; xpr[f]=xpl[f]+a-1;}
                    width=width+a+myfont_wid[fnt];
                    if (width>cur) break ;
                }

            if (width>cur) { width=width-a-myfont_wid[fnt]; width+=2; } 
            
            while (xt+width+11>info.right) xt--;
            if (width<470) width=470 ;
            pedtosh=f ; // Αριθμός πεδίων (+1) για εμφάνιση ! Τυχόν loop να είναι μικρότερο του pedtosh
            for(f=pedtosh ; f<k1 ; f++) { desm[f]=-1 ; showp[f]=-1; }
            if (svou>pedtosh-1) svou=pedtosh-1;
            
            for(f=0;f<pedtosh;f++) {
                if (showp[f]==dbfdata.fd_arped) continue ;
                if (showp[f]>bigger) bigger=showp[f];
            }
            
            for (i=0;i<pedtosh;i++) {    
            size1=0;
                for (f=0;f<=dbfinum;f++) {
                    if (showp[i]==f) {almap[i]=size1; break;} 
                    size1 += xlimk[f];
                }
            }
            
              for(f=1;f<k1;f++) {
                if (mem_ped[f]) { free(mem_ped[f]); mem_ped[f]=0; }
            }
            
            i = (lines<plbut) ? lines : plbut ;
            for(f=1;f<pedtosh;f++) {
                mem_ped[f]=malloc( (bread[f]+1) * i );
                if (!mem_ped[f]) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
            }
            
            xb=xt+width-1;
            buthei=lines*fhe+110;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            
            protyx=lines;
            ynames=yt1+28;
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            
            refresh();
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            line (xt+9,ynames+19,xb-9,ynames+19) ; // Γραμμή κάτω από ονόματα
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=ynames+20 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19; xright=xfo-45 ; xleft=xt+23;
             xcancel = xvice + 30 ; ycancel = ysort-5 ;
             xgroup=xcancel+50; xfound=xgroup+50 ;
             
            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl+60, yt1+2, xtepr-60);
            // Εμφάνιση Ονομάτων Πεδίων !
            if (k1>1) _bareacls(xt+9,ynames,xb-9,ynames+18,conom); // Γέμισμα για τα ονόματα των πεδίων
            else _bareacls(xt+9,ynames,xb-9,ynames+18,orange);
            
            for (f=0;f<pedtosh;f++) {
                xpl[f]+=xtepl ; xpr[f]+=xtepl; // Προσοχή εδώ....
                if (f>svou) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                else { 
                    _bareacls(xpl[f],ynames,xpr[f],ynames+18,orange);
                    if (k1>1) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
                    else  _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xtepr,ynames+18,cblack, orange);
                    
                }
                if (k1>1) {setrgbcolor(dbred) ; line (xpl[f],ynames,xpl[f],ynames+18); line  (xpr[f],ynames,xpr[f],ynames+18); }
            }
                
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            if (synepil) _puticon(xcancel,ycancel,mem_cancel,255);
            
            if (seflag==2)  _puticon(xgroup,ycancel,mem_group,255);
            
            _puticon(xfound,ycancel,mem_found,255);
            
            if (k1>1) {
                if (showp[pedtosh-1]<bigger) _puticon(xright,yt-18,mem_right,255);

                f=0; while (desm[f]>=0) f++;
                if (showp[f]>smaller)  _puticon(xleft,yt-18,mem_left,255);
            }
            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            refresh();
            goto emfan ;
        }

        else if (tori) {
PANERIGHTRE:
            if (k1==1) continue ;
            if (showp[pedtosh-1]==bigger) continue ;
            if (desm[pedtosh-1]>=0) continue ;
            tori=0; puticon(xright,yt-18,mem_right,255);
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            
            for(f=1;f<k1;f++) {
                if (mem_ped[f]) { free(mem_ped[f]); mem_ped[f]=0; }
            }
            
            showp[0]=desm[0] = dbfdata.fd_arped;

            //Απόδοση τιμών στην showp[] με κίνηση πεδίων προς τα δεξιά από την αδέσμευτη στήλη και μετά.
            i=1;
            for(f=0; f<=dbfinum; f++) {
                if (f==dbfdata.fd_arped) continue ;
                if (pedia[f] && ptr_pedio[f]->fitype!=5) {
                    if (desm[i]>=0) {
                        showp[i]=desm[i]; f=desm[i];
                        i++;
                        continue ;
                    }
                    else break;
                }
            }
            if (showp[i] < 0) { cur = (i==1) ? -1 : showp[i-1] ; }
            else cur=showp[i];
            for (f=cur+1 ; f<=dbfinum ; f++ ) {
                if (f==dbfdata.fd_arped) continue ;
                if (pedia[f] && ptr_pedio[f]->fitype!=5) {showp[i]=f ; i ++ ;}
            }
            // Αρχικός υπολογισμός των συντεταγμένων (xpl-xpr) κάθε πεδίου - υπολογισμός του max width στα 4/5 της οθόνης
            // Υπολογισμός μέγιστου αριθμού πεδίων προς εμφάνιση και μέγιστου αριθμού χαρακτ. κατά πεδίο.
            
            mespl=myfont_wid[fnt]*75/100; cur = (4 * (info.right-info.left+1) ) / 5 ;
            dx=36; dy=26;
            
                width=18;
                xpl[0]=0;
                for (f=0; f<k1 ; f++) {
                    if (showp[f]<0) break ;
                    a=ptr_pedio[showp[f]]->fiorio;
                    if (showp[f]==dbkey) { a=(a<dx) ? a : dx-1 ; }
                    else { a=(a<dy) ? a : dy-1 ; }
                    bread[f]= a ; // How many bytes to read from disk per field ! 
                    plape=a*mespl;
                    a = (int) (plape);
                    if (!f) { xpr[0]=xpl[0]+a-1 ; }
                    else { xpl[f]=xpr[f-1]+myfont_wid[fnt]; xpr[f]=xpl[f]+a-1;}
                    width=width+a+myfont_wid[fnt];
                    if (width>cur) break ;
                }

            if (width>cur) { width=width-a-myfont_wid[fnt]; width+=2; } 
            
            while (xt+width+11>info.right) xt--;
            if (width<470) width=470 ;
            pedtosh=f ; // Αριθμός πεδίων (+1) για εμφάνιση ! Τυχόν loop να είναι μικρότερο του pedtosh
            
            for(f=pedtosh ; f<k1 ; f++) { desm[f]=-1 ; showp[f]=-1; }
            if (svou>pedtosh-1) svou=pedtosh-1;
            
            for(f=0;f<pedtosh;f++) {
                if (showp[f]==dbfdata.fd_arped) continue ;
                if (showp[f]>bigger) bigger=showp[f];
            }
            
            for (i=0;i<pedtosh;i++) {    
            size1=0;
                for (f=0;f<=dbfinum;f++) {
                    if (showp[i]==f) {almap[i]=size1; break;} 
                    size1 += xlimk[f];
                }
            }

            i = (lines<plbut) ? lines : plbut ;
            for(f=1;f<pedtosh;f++) {
                mem_ped[f]=malloc( (bread[f]+1) * i );
                if (!mem_ped[f]) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
            }
            
            xb=xt+width-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            
            protyx=lines;
            
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            
            refresh();
            // Rectangles
            
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            line (xt+9,ynames+19,xb-9,ynames+19) ; // Γραμμή κάτω από ονόματα
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; 
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            xsort = xfrba+56;
            xvice=xsort+38;
            drax=xb-38 ; 
            xok=drax-80 ; 
            xfo=xb-19; xright=xfo-45 ; xleft=xt+23;
            xcancel = xvice + 30 ;
            xgroup=xcancel+50; xfound=xgroup+50 ;
            
            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl+60, yt1+2, xtepr-60);
            // Εμφάνιση Ονομάτων Πεδίων !
            if (k1>1) _bareacls(xt+9,ynames,xb-9,ynames+18,conom); // Γέμισμα για τα ονόματα των πεδίων
            else _bareacls(xt+9,ynames,xb-9,ynames+18,orange);
            
            for (f=0;f<pedtosh;f++) {
                xpl[f]+=xtepl ; xpr[f]+=xtepl; // Προσοχή εδώ....
                if (f>svou) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                else { 
                    _bareacls(xpl[f],ynames,xpr[f],ynames+18,orange);
                    if (k1>1) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
                    else  _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xtepr,ynames+18,cblack, orange);
                    
                }
                if (k1>1) {setrgbcolor(dbred) ; line (xpl[f],ynames,xpl[f],ynames+18); line  (xpr[f],ynames,xpr[f],ynames+18); }
            }
                
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            if (synepil) _puticon(xcancel,ycancel,mem_cancel,255);
            
            if (seflag==2)  _puticon(xgroup,ycancel,mem_group,255);
            
            _puticon(xfound,ycancel,mem_found,255);
            
            if (k1>1) {
                if (showp[pedtosh-1]<bigger) _puticon(xright,yt-18,mem_right,255);
                f=0; while (desm[f]>=0) f++;
                if (showp[f]>smaller)  _puticon(xleft,yt-18,mem_left,255);
            }

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            refresh();
            goto emfan ;
        }
       
       
        else if (tole) {
PANELEFTRE:
            if (k1==1) continue ;
            f=0; while (desm[f]>=0) f++;
            if (showp[f]==smaller) continue ;
            tole=0; puticon(xleft,yt-18,mem_left,255);
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            
            for(f=1;f<k1;f++) {
                if (mem_ped[f]) { free(mem_ped[f]); mem_ped[f]=0; }
            }
            
            showp[0]=desm[0] = dbfdata.fd_arped;

            //Απόδοση τιμών στην showp[] με κίνηση πεδίων προς τα αριστερ'α από την αδέσμευτη στήλη και μετά.
            i=1;k=0;
            for(f=0; f<=dbfinum; f++) {
                if (f==dbfdata.fd_arped) continue ;
                if (pedia[f] && ptr_pedio[f]->fitype!=5) {
                    if (desm[i]>=0) {
                        showp[i]=desm[i];  f=desm[i];
                        i++;
                        continue ;
                    }
                    else {
                        
                        k=1; a=showp[i] ;
                        if (showp[i]<0) { a = (i==1) ? -1 : showp[i-1] ; break ; }
                        
                        if (i==1) {
                            for (a=showp[i]-1 ; a>=0 ; a--) {
                                if (a==dbfdata.fd_arped) continue ;
                                if (pedia[a] && ptr_pedio[a]->fitype!=5) { showp[i]=a; i++; break ; }
                            }
                        }
                        else {
                            for (a=showp[i]-1 ; a>showp[i-1] ; a--) {
                                if (a==dbfdata.fd_arped) continue ;
                                if (pedia[a] && ptr_pedio[a]->fitype!=5) { showp[i]=a; i++; break ; }
                            }
                        }
                    }
                    break ;
                }
            }
            
            if (k) {
                for (f=a+1 ; f<=dbfinum ; f++) {
                    if (f==dbfdata.fd_arped) continue ;
                    if (pedia[f] && ptr_pedio[f]->fitype!=5) {showp[i]=f; i++;}
                }
            }
            
            for (f=i ; f<k1 ; f++) { showp[f]=-1 ; }
            // Αρχικός υπολογισμός των συντεταγμένων (xpl-xpr) κάθε πεδίου - υπολογισμός του max width στα 4/5 της οθόνης
            // Υπολογισμός μέγιστου αριθμού πεδίων προς εμφάνιση και μέγιστου αριθμού χαρακτ. κατά πεδίο.
            
            mespl=myfont_wid[fnt]*75/100; cur = (4 * (info.right-info.left+1) ) / 5 ;
            dx=36; dy=26;
            
                width=18;
                xpl[0]=0;
                for (f=0; f<k1 ; f++) {
                    if (showp[f]<0) break ;
                    a=ptr_pedio[showp[f]]->fiorio;
                    if (showp[f]==dbkey) { a=(a<dx) ? a : dx-1 ; }
                    else { a=(a<dy) ? a : dy-1 ; }
                    bread[f]= a ; // How many bytes to read from disk per field ! 
                    plape=a*mespl;
                    a = (int) (plape);
                    if (!f) { xpr[0]=xpl[0]+a-1 ; }
                    else { xpl[f]=xpr[f-1]+myfont_wid[fnt]; xpr[f]=xpl[f]+a-1;}
                    width=width+a+myfont_wid[fnt];
                    if (width>cur) break ;
                }

            if (width>cur) { width=width-a-myfont_wid[fnt]; width+=2; } 
            
            while (xt+width+11>info.right) xt--;
            if (width<470) width=470 ;
            pedtosh=f ; // Αριθμός πεδίων (+1) για εμφάνιση ! Τυχόν loop να είναι μικρότερο του pedtosh
            
            for(f=pedtosh ; f<k1 ; f++) { desm[f]=-1 ; showp[f]=-1; }
            if (svou>pedtosh-1) svou=pedtosh-1;
            
            for(f=0;f<pedtosh;f++) {
                if (showp[f]==dbfdata.fd_arped) continue ;
                if (showp[f]>bigger) bigger=showp[f];
            }
            
            for (i=0;i<pedtosh;i++) {    
            size1=0;
                for (f=0;f<=dbfinum;f++) {
                    if (showp[i]==f) {almap[i]=size1; break;} 
                    size1 += xlimk[f];
                }
            }

            i = (lines<plbut) ? lines : plbut ;
            for(f=1;f<pedtosh;f++) {
                mem_ped[f]=malloc( (bread[f]+1) * i );
                if (!mem_ped[f]) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE; }
            }
            
            xb=xt+width-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);kati=1; goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            
            protyx=lines;
            
            _bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            
            refresh();
            // Rectangles
            
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            line (xt+9,ynames+19,xb-9,ynames+19) ; // Γραμμή κάτω από ονόματα
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; 
            xdel = xtepl+2 ;  
            xfrba = (delon) ? xdel+55 : xdel +2 ; 
            xsort = xfrba+56;
            xvice=xsort+38;
            drax=xb-38 ; 
            xok=drax-80 ; 
            xfo=xb-19; xright=xfo-45 ; xleft=xt+23;
            xcancel = xvice + 30 ;
            xgroup=xcancel+50; xfound=xgroup+50 ;
            
            _areacls (xtepl,ytepl,xtepr,ybarb-1,26,255,255);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl+60, yt1+2, xtepr-60);
            // Εμφάνιση Ονομάτων Πεδίων !
            if (k1>1) _bareacls(xt+9,ynames,xb-9,ynames+18,conom); // Γέμισμα για τα ονόματα των πεδίων
            else _bareacls(xt+9,ynames,xb-9,ynames+18,orange);
            
            for (f=0;f<pedtosh;f++) {
                xpl[f]+=xtepl ; xpr[f]+=xtepl; // Προσοχή εδώ....
                if (f>svou) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                else { 
                    _bareacls(xpl[f],ynames,xpr[f],ynames+18,orange);
                    if (k1>1) _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
                    else  _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xtepr,ynames+18,cblack, orange);
                    
                }
                if (k1>1) {setrgbcolor(dbred) ; line (xpl[f],ynames,xpl[f],ynames+18); line  (xpr[f],ynames,xpr[f],ynames+18); }
            }
                
            chxr[0]=239 ; chxr[1]=138; chxr[2]=87;
            bkxr[0]=0 ; bkxr[1]=34; bkxr[2]=24;
            slxr[0]=0; slxr[1]=0; slxr[2]=186;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            if (synepil) _puticon(xcancel,ycancel,mem_cancel,255);
            
            if (seflag==2)  _puticon(xgroup,ycancel,mem_group,255);
            
            if (showp[pedtosh-1]<bigger) _puticon(xright,yt-18,mem_right,255);
            
            _puticon(xfound,ycancel,mem_found,255);

            f=0; while (desm[f]>=0) f++;
            if (showp[f]>smaller)  _puticon(xleft,yt-18,mem_left,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); kati=1; goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            refresh();
            goto emfan ;
        }
        
        else if (prokef) {
            
            if (prokef>svou) {
                for (f=svou+1;f<=prokef;f++) {
                _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,orange);
                _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, orange);
                desm[f]=showp[f];
                }
                f--;
                i=showp[f]+1 ;
                svou=prokef;
                for(f=i; f<=dbfinum;f++) {
                    if (f==showp[0]) continue ;
                    if (pedia[f] && ptr_pedio[f]->fitype!=5) {smaller=f; break ;}
                }
                
            }
            
            else if (prokef<svou) {
                
                for(f=svou;f>=prokef;f--) {
                    _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,conom);
                    _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                    desm[f]=-1;
                }
                f++;
                if (f==1) {
                    smaller=smaller1;
                }
                else {
                    i=showp[f-1];
                    for (f=i+1 ; f<=dbfinum ; f++) {
                        if (f==showp[0]) continue ;
                        if (pedia[f] && ptr_pedio[f]->fitype!=5) {smaller=f; break ;}
                    } 
                }
                svou=prokef-1;
            }
            
            else {
                f=prokef;
                _bareacls(xpl[f]+1,ynames,xpr[f]-1,ynames+18,conom);
                _outmystr_center_col(3,ptr_pedio[showp[f]]->finame,xpl[f]+2,ynames,xpr[f]-2,ynames+18,cblack, conom);
                desm[f]=-1;
                if (f==1) {
                    smaller=smaller1;
                }
                else {
                    i=showp[f-1];
                    for (f=i+1 ; f<=dbfinum ; f++) {
                        if (f==showp[0]) continue ;
                        if (pedia[f] && ptr_pedio[f]->fitype!=5) {smaller=f; break ;}
                    } 
                }
                svou=prokef-1;
                
            }
            f=0; while (desm[f]>=0) f++;
            if (showp[f]>smaller)  _puticon(xleft,yt-18,mem_left,255);
            else _bareacls(xleft,yt-18,xleft+39,yt-2,cbrown);
            
            refresh();
            prokef=0;
            continue;
        }
        
        else if (akiro) {
            for (f=0 ; f<plbut ; f++) epl[f]=0;
            synepil=0; akiro=0;
            areacls(xcancel,ycancel,xcancel+41,ycancel+39,0,0,0);
            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (krit_insert) {
            krit_insert=0;
            puticon(xgroup,ycancel,mem_group,255); hide_help(hdhlpxt , hdhlpyt);
            i=0;finds_1=0;
            for (f=firstcrit ; f<plbut && i<gocards ; f++) {
                if (crits[f]) {
                    i++;
                    if (!epl[f]) { 
                        finds_1++;
                        epl[f]=1; 
                        synepil++; 
                        if (synepil==1) {puticon(xcancel,ycancel,mem_cancel,255);}
                    }
                }
            }
            if (finds_1) {
                if (keyb_gr) sprintf(str1024 , "Έχουν προστεθεί %u νέα στοιχεία!",finds_1);
                else sprintf(str1024 , "%u new elements have been added !",finds_1);
                information(0,str1024,0);
            }
            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
         else if (add_found) {
            if (!finds) continue ;
            add_found=0;
            i=0;finds_1=0;
            puticon(xfound,ycancel,mem_found,255); hide_help(hdhlpxt , hdhlpyt);
            for (f=0 ; (f<plbut && i<finds) ; f++ ) {
                if (krit[f]) {
                    i++;
                    if (!epl[f]) {
                        finds_1++;
                        epl[f]=1; 
                        synepil++; 
                        if (synepil==1) {puticon(xcancel,ycancel,mem_cancel,255);}
                    }
                }
            }
            if (finds_1) {
                if (keyb_gr) sprintf(str1024 , "Έχουν προστεθεί %u νέα στοιχεία!",finds_1);
                else sprintf(str1024 , "%u new elements have been added !",finds_1);
                information(0,str1024,0);
            }
            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            protyx=lines; 

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) c=plbut-1; telos=plbut; }}
            
    pano=c;
    do {                                           
        karta=ar_dom[c];
        if (!epl[karta]) {
            _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),bkxr);
            if (but[karta][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0]);
            else _outfanis_col(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0]);
            
            for (f=1;f<pedtosh;f++) {
                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
                fread(str1024a,1,bread[f],fpcard);
                str1024a[bread[f]]=255;
                _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
            }
            
            if (krit[karta]) {setrgbcolor (dbyel) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
        }
        else {
            _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),slcl);
            if (but[karta][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl );
            else  _outfanis_colxr(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl);
            
            for (f=1;f<pedtosh;f++) {
                dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
                if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
                fread(str1024a,1,bread[f],fpcard);
                str1024a[bread[f]]=255;
                _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),slcl);
                if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , xrcl, slcl);
                else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , xrcl , slcl);
            }
            
            if (krit[karta]) {setrgbcolor (dbred) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
        }

        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        // if ((!sort) && (pano==a1)) continue;
        // else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                protyx=lines;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
                protyx=lines;
                c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          protyx=lines;        
            
          switch (sdlev.key.keysym.scancode) {
              
              
            case SDL_SCANCODE_RIGHT :
                if (k1==1) continue ;
                if (showp[pedtosh-1]==bigger) continue ;
                if (desm[pedtosh-1]>=0) continue ;
                if (!tori) {tori=1; putNOTicon(xright,yt-18,mem_right);}
                goto PANERIGHTRE ;
                break;
                
                case SDL_SCANCODE_LEFT :
                    if (k1==1) continue ;
                    f=0; while (desm[f]>=0) f++;
                    if (showp[f]==smaller) continue ;
                    if (!tole) {tole=1; putNOTicon(xleft,yt-18,mem_left);}
                    goto PANELEFTRE ;
                    break;
           
              
            case SDL_SCANCODE_DOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; 
               telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima;
               telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            sparky=0;        
            pano=c;
            do {                                           
                karta=ar_dom[c];
                if (!epl[karta]) {
                    _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),bkxr);
                    if (but[karta][0]==255) _outfanis_col(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0]);
                    else _outfanis_col(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0]);

                    for (f=1;f<pedtosh;f++) {
                        dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
                        fread(str1024a,1,bread[f],fpcard);
                        str1024a[bread[f]]=255;
                        ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                        mystrcpy(mesa_ptr,str1024a);
                        _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),ptr_pedio[showp[f]]->fibkxr);
                        if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                        else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , ptr_pedio[showp[f]]->fichxr, ptr_pedio[showp[f]]->fibkxr);
                    }
                    
                    if (krit[karta]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                }
                else {
                    _bareacls(xtepl, ytepl+k*fhe,xpr[0],ytepl+k*fhe+(fhe-2),slcl);
                    if (but[karta][0]==255) _outfanis_colxr(fnt, keno , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl );
                    else  _outfanis_colxr(fnt, but[karta] , xtepl+1 , ytepl+k*fhe , xpr[0] , xrcl, slcl);
                    
                    for (f=1;f<pedtosh;f++) {
                        dx=fseek(fpcard , ((disk_dom[karta] * dbcardsize) + almap[f]) , 0);
                        if (dx) { sprintf(str1024,"%s%s",savedbpath,"Data1.aba"); information (6-keyb_gr,str1024,0) ;}
                        fread(str1024a,1,bread[f],fpcard);
                        str1024a[bread[f]]=255;
                        ptr1=k*(bread[f]+1); mesa_ptr=mem_ped[f]+ptr1;
                        mystrcpy(mesa_ptr,str1024a);
                        _bareacls(xpl[f], ytepl+k*fhe,xpr[f],ytepl+k*fhe+(fhe-2),slcl);
                        if (str1024a[0]==255) _outfanis_colxr(fnt, keno , xpl[f]+1 , ytepl+k*fhe , xpr[f] , xrcl, slcl);
                        else _outfanis_colxr(fnt, str1024a , xpl[f]+1 , ytepl+k*fhe , xpr[f]  , xrcl , slcl);
                    }
                    
                    if (krit[karta]) {sparky=1; setrgbcolor (dbred) ; line(xtepl+1,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }
                }
                    
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);
            refresh();
            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;
            
barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; 
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                i=0;
                for (f=0;f<plbut;f++) {
                    if(epl[f]) {i=1;break;}
                }
                if (!i) {free(mem_epl); mem_epl=0;}
                 *flag_mulsel=1;
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               free(mem_epl); mem_epl=0;
               *flag_mulsel=0;
               continue;
               
            }
        
    break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
                case SDL_QUIT :
               fyge=1;
               free(mem_epl); mem_epl=0;
               *flag_mulsel=0;
               continue;
                
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
if(kati) {
    if (mem_epl) {free(mem_epl);} 
    mem_epl=0;
}
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if (item_mem) free (item_mem);
if (mem_front) free(mem_front);
if (mem_back) free(mem_back);
if (mem_drag) free(mem_drag);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_fonter) free(mem_fonter);
if (mem_desc) free(mem_desc);
if(mem_right) free(mem_right);
if(mem_left) free(mem_left);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
if (mem_deigma_text) free (mem_deigma_text);
if (mem_cancel) free (mem_cancel);
if (mem_group) free (mem_group) ;
if (mem_found) free (mem_found);
if(dbfdata.mem_fd) { free(dbfdata.mem_fd); dbfdata.mem_fd=0;}
for(f=1;f<k1;f++) {
    if (mem_ped[f]) free(mem_ped[f]);
}
refresh();
gouv=whouv;
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
return mem_epl ;
}


int choise_alert (char *str1,char *str2, short int akyro)
// akyro=0 : χωρίς δυνατότητα να μην επιλέξω κάτι από τα δυο
// Επιστρέφει -1 αν προέκυψε πρόβλημα !
// Τα str1 και str2 είναι κανονικά strings που τελειώνουν σε 0 ! Να μην υπερβαίνουν τους 1000 χαρακτήρες ! Να μην χρησιμοποιήσω τη γενική μεταβλητή char file_1 !!!!!!
// Επιστρέφτει 1 για 1η περίπτωση , 2 για 2η και 0 για άκυρο !
{

register int f,i ;
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_ni=0 , *mem_go=0 , *mem_yes=0, *mem_alert=0;
short int xt,yt,xb,yb,r1xt,r1yt,r1xb,r1yb,r2xt,r2yt,r2xb,r2yb,bo1xt,bo1yt,bo1xb,bo1yb,bo2xt,bo2yt,bo2xb,bo2yb ;
short int yesxt,yesyt,yesxb,yesyb,goxt,goyt,goxb,goyb,alext,aleyt ;
int mx,my,mx1, my1, fyge=-1;
unsigned int size ;
unsigned short int ch_scan ;
int choxr_r[3] , choxr_b[3], chobkxr[3] , boxbkxr[3] ;
unsigned char mystr[1024];
short int loop=1 , ejo=1 , yes=0, cancel=0 , bo1 , bo2 , re1, re2 , nep;

SDL_EventState(SDL_DROPFILE, SDL_DISABLE);

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

size=imagesize(0,0,599,499);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}
xt=(info.right-info.left-599) / 2 ; yt=(info.bottom-info.top-499) / 2 ;
xb=xt+599;
yb=yt+499;
getimage(xt,yt,xb,yb,mem0);

// Yes : 54 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/Yel_ok_39.ico");
mem_yes= icontomem (file_1,255);
if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_40.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


// Ένδειξη "νι-οκ" μέσα σε κουτί 35 Χ 35
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ni= icontomem (file_1,255);
if (mem_ni==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/notif_1.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
choxr_r[0]=0; choxr_r[1]=0;  choxr_r[2]=0;
choxr_b[0]=255; choxr_b[1]=255;  choxr_b[2]=255;
boxbkxr[0]=253 ; boxbkxr[1]=106 ; boxbkxr[2]=2 ; 
whouv=gouv;
gouv=myfont[7];

alext=xt+(600-90)/2;
aleyt=yt+10;
r1xt=xt+12; r1yt=aleyt+100; r1xb=r1xt+500; r1yb=r1yt+160;
r2xt=r1xt; r2yt=r1yb+20; r2xb=r1xb; r2yb=r2yt+160;
bo1xt=r1xb+25; bo1yt=r1yt; bo1xb=bo1xt+40; bo1yb=bo1yt+40;
bo2xt=bo1xt; bo2yt=r2yt; bo2xb=bo2xt+40; bo2yb=bo2yt+40;
yesxt=xb-65; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
goxt=r1xt+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;


_bareacls(xt,yt,xb,yb,chobkxr);
setrgbcolor (dbred) ;
rectangle (xt,yt,xb,yb);
rectangle (xt+1,yt+1,xb-1,yb-1);
setrgbcolor (dbaspro) ;
rectangle (xt+2,yt+2,xb-2,yb-2);
rectangle (xt+3,yt+3,xb-3,yb-3);
setrgbcolor (dbblack) ;
rectangle (xt+4,yt+4,xb-4,yb-4);
rectangle (xt+5,yt+5,xb-5,yb-5);
setrgbcolor (dbyel) ;
rectangle (xt+6,yt+6,xb-6,yb-6);
refresh();

normtext_tomy (str1 , mystr);
_nofield_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_r, chobkxr);
refresh();
normtext_tomy (str2 , mystr);
_nofield_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_b, chobkxr);
refresh();

setrgbcolor (dbblack) ;
rectangle (bo1xt,bo1yt,bo1xb,bo1yb);
rectangle (bo2xt,bo2yt,bo2xb,bo2yb);
rectangle (bo1xt+1,bo1yt+1,bo1xb-1,bo1yb-1);
rectangle (bo2xt+1,bo2yt+1,bo2xb-1,bo2yb-1);
_bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);

setrgbcolor (dbmag) ;
rectangle (r1xt , r1yt, r1xb , r1yb) ;

_puticon(alext,aleyt,mem_alert,255);
_puticon(yesxt,yesyt,mem_yes,255);
if (akyro) _puticon(goxt,goyt,mem_go,255);
_puticon(bo1xt+3,bo1yt+3,mem_ni,255);

refresh();
fyge=1 ;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
bo1=re1=nep=1; bo2=re2=0 ;

do {

if (!SDL_PollEvent(&sdlev)) continue;
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (mx<xt || mx>xb || my<yt || my>yb) {
            if (ejo) continue ;
            ejo=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor); 
            if (!bo1 && re1) {re1=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();}
            if (!bo2 && re2) {re2=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();}
            continue ;
        }
        
        if (ejo) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ejo=0;
        }
        
        if (mx>bo1xt && mx<bo1xb && my>bo1yt && my<bo1yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo1) {
                if (!re2) continue ;
                re2=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();
                continue ;
            }
            if (re1) continue ;
            re1=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (mx>r1xt && mx<r1xb && my>r1yt && my<r1yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo1) {
                if (!re2) continue ;
                re2=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r2xt , r2yt, r2xb , r2yb) ;
                refresh();
                continue ;
            }
            if (re1) continue ;
            re1=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        
        if (mx>bo2xt && mx<bo2xb && my>bo2yt && my<bo2yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo2) {
                if (!re1) continue ;
                re1=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();
                continue ;
            }
            if (re2) continue ;
            re2=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (mx>r2xt && mx<r2xb && my>r2yt && my<r2yb) {
            
            if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
            else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (bo2) {
                if (!re1) continue ;
                re1=0;
                setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (r1xt , r1yt, r1xb , r1yb) ;
                refresh();
                continue ;
            }
            
            if (re2) continue ;
            re2=1 ; 
            //_bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
            
            setrgbcolor (dbaspro);
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            //_puticon(bo1xt+3,bo1yt+3,mem_ni,255);
            refresh();
            continue ;
        }
        
        if (!bo1 && re1) {re1=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
            rectangle (r1xt , r1yt, r1xb , r1yb) ;
            refresh();}
        if (!bo2 && re2) {re2=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
            rectangle (r2xt , r2yt, r2xb , r2yb) ;
            refresh();}
        
        if (mx>yesxt && mx<yesxb && my>yesyt && my<yesyb) {
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (yes) continue ;
            yes=1;
            putNOTicon(yesxt,yesyt,mem_yes);
            continue ;
        }
        
        if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
        
        if (akyro) {
        
            if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
                
                if (cancel) continue ;
                cancel=1;
                putNOTicon(goxt,goyt,mem_go);
                continue ;
            }
        }
        
        if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        break ; // break of SDL_MOUSEMOTION
        
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx1 = sdlev.button.x ; my1= sdlev.button.y ;
            if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONDOWN);
                continue ;
            }
        
            if (mx1>bo1xt && mx1<bo1xb && my1>bo1yt && my1<bo1yb) nep=1 ;
            else if (mx1>r1xt && mx1<r1xb && my1>r1yt && my1<r1yb) nep=1 ;
            else if (mx1>bo2xt && mx1<bo2xb && my1>bo2yt && my1<bo2yb) nep=2 ;
            else if (mx1>r2xt && mx1<r2xb && my1>r2yt && my1<r2yb) nep=2 ;
            else nep=0;
            
            
            switch (nep) {
                
                case 1 :
                    if (bo1) {
                        if (!re2) continue ;
                        re2=0;
                        setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                        rectangle (r2xt , r2yt, r2xb , r2yb) ;
                        refresh();
                        continue ;
                    }
                    bo2=0; bo1=1; re2=0;re1=1;
                    _bareacls (bo2xt+2,bo2yt+2,bo2xb-2,bo2yb-2,boxbkxr);
                    _puticon(bo1xt+3,bo1yt+3,mem_ni,255);
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (r2xt , r2yt, r2xb , r2yb) ;
                    setrgbcolor (dbmag);
                    rectangle (r1xt , r1yt, r1xb , r1yb) ;
                    normtext_tomy (str1 , mystr);
                    _nofield_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_r, chobkxr);
                    normtext_tomy (str2 , mystr);
                    _nofield_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_b, chobkxr); 
                    refresh();
                    continue ;
                    
                case 2 :
                    
                    if (bo2) {
                        if (!re1) continue ;
                        re1=0;
                        setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                        rectangle (r1xt , r1yt, r1xb , r1yb) ;
                        refresh();
                        continue ;
                    }
                    bo1=0; bo2=1;re2=1;re1=0;
                    _bareacls (bo1xt+2,bo1yt+2,bo1xb-2,bo1yb-2,boxbkxr);
                    _puticon(bo2xt+3,bo2yt+3,mem_ni,255);
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (r1xt , r1yt, r1xb , r1yb) ;
                    setrgbcolor (dbmag);
                    rectangle (r2xt , r2yt, r2xb , r2yb) ;
                    normtext_tomy (str1 , mystr);
                    _nofield_txt_show (mystr , 0, r1xt+2 , r1yt+1 , r1xb-1 , r1yb-1 , 1000 , choxr_b, chobkxr);
                    normtext_tomy (str2 , mystr);
                    _nofield_txt_show (mystr , 0, r2xt+2 , r2yt+1 , r2xb-1 , r2yb-1 , 1000 , choxr_r, chobkxr); 
                    refresh();
                    continue ;
                    
                case 0:
                    
                    nep = (bo1) ? 1 : 2 ;
                    break ;
                    
            }
            
            if (yes) {
                fyge = (bo1) ? 1 : 2 ;
                loop=0;
                break ;
            }
            
            if (akyro && cancel) {
                fyge=0;
                loop=0;
                break ;
            }
            
        }
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            continue ;
        }
        break ;
        
        case SDL_KEYDOWN:
            
            ch_scan=sdlev.key.keysym.scancode;
                        
            switch (ch_scan) { 
                        
                case SDL_SCANCODE_ESCAPE :  
                    if (!akyro) break;
                    fyge=0;
                    loop=0;
                    break ;
                    
                case SDL_SCANCODE_RETURN :
                
                    fyge = (bo1) ? 1 : 2 ;
                    loop=0;
                    break ;
                
            }
            
        break ;

        case SDL_WINDOWEVENT :
        refresh(); 
        continue;
    }
        
} while (loop);

FYGE:
if (mem0) {
    fidicls(xt,yt,xb,yb,55,84,112); 
    putimage (xt,yt,mem0,0);
    refresh();
    free (mem0) ;
}
if (mem_ni) free (mem_ni);
if (mem_go) free (mem_go);
if (mem_yes) free(mem_yes);
if (mem_alert) free(mem_alert);

gouv=whouv;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
return fyge;
}


void *convertinp_strstr  (short int left_right, char  *str, short int arped, unsigned short int *how_many, unsigned short int *cur)

// left_right =0 για αριστερό κλικ αλλιώς 1 για δεξιό κλικ
// Λέγοντας αριστερό κλικ εννοούμε ότι θέλουμε να ψάξει με κριτήρια που προυπάρχουν.
// Λεγοντας δεξιό κλικ εννοούμε ότι θέλουμε οπωσδήποτε να δούμε παράθυρο εισαγωγής στοιχείων...
// Ως  *str είναι το κείμενο που θέλουμε να γίνει ... ghost....
// Αριθμός πεδίου μπορεί και να μην υπάρχει (-1). Αν υπάρχει όμως τότε λαμβάνει τιμές ή εξετάζει τέλος πάντων τα κριτήρια.
// how_many ... περνάει το πόσα ταύτισε/
// cur..η πρώτη ταύτιση - θέση δρομέα.
// ΕΠΙΣΤΡΕΦΕΙ void * για τo ghost string (αυτό με 0 και 1) ή 0 !! Βασικά ενημερώνεται η καθολική μεταβλητή inp_mem_ghost !! 
//Πριν κληθεί εκ νέου η συνάρτηση πρέπει να γίνει free στην inp_mem_ghost αν έχει τιμή !!!!
{

register int i,f ,w ;
int start_point , a ;
unsigned short int sefl , dem_len , sample_len , big_len ;

unsigned char *big_text , *mybigstr ;
unsigned char what ;
void *mem=0 ;
int user_ans;

unsigned char deigma[22];
short int pe ;

inp_mem_ghost=0;
*cur=0; *how_many=0;


mybigstr=str;
if (mybigstr[0]==255) return 0;

pe = ( (arped>=0) && (dbplgr) ) ? arped : 100 ;

if (left_right) // δεξιό κλικ - θέλω να ορίσω νέο στοιχείο για εύρεση
{
    if (normdeigma[pe][0]==255) {
        if (pe<100) {
            if (multicr[arped]->sample_t[0]!=255) { mystrcpy(normdeigma[pe],multicr[arped]->sample_t); }
        }
    }
    if (pe==100) user_ans=input_dbsearch_text(normdeigma[pe] , -1);
    else user_ans=input_dbsearch_text(normdeigma[pe] , arped);
    if (user_ans!=1) return 0;
}
else
{
    if (normdeigma[pe][0]==255) {
        
        if (pe<100) {
            if (multicr[arped]->sample_t[0]!=255) { mystrcpy(normdeigma[pe],multicr[arped]->sample_t); }
        }
    }
}
// Αριστερό κλικ ή προχωράμε με ότι υπήρχε στα κριτήρια ή εισάχθηκε πριν - άρα εντολή εύρεσης με ότι στοιχεία υπάρχουν...αν υπάρχουν...
    
if (normdeigma[pe][0]==255) return 0;

mystrcpy(deigma,normdeigma[pe]);

//Όλα μικρά και χωρίς τόνους !! 
// To deigma είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
    
i=0;
while (deigma[i]!=255) i++;
sample_len=i; //strlen (deigma1) (χωρίς το 255)

for (f=0;f<i;f++) {
    if (keyb_gr) {
        switch (deigma[f]) {

            case 96:
            case 131:
            case 132:
            deigma[f]=95;
            break;
            
            case 133:
            case 134:
            case 135:
            case 138:
            case 141:
            deigma[f]-=36;
            break;
            
            case 101:
            case 136:
            case 137:
            deigma[f]=100;
            break;
            
            case 104:
            case 139:
            case 140:
            deigma[f]=103;
            break;
            
            case 107:
            case 108:
            case 109:
            case 142:
            case 143:
            case 144:
            deigma[f]=106;
            break;
            
            case 145 :
            case 146 :
            case 147 :
            case 148 :
            case 149 :
            case 152 :
            case 153 :
            case 154 :
            case 155 :
            deigma[f]-=35;
            break ;
            
            case 116 :
            case 150 :
            case 151 :
            deigma[f]=115;
            break;
            
            case 122 :
            case 123 :
            case 124 :
            case 156 :
            case 157 :
            case 158 :
            deigma[f]=121;
            break;
            
            case 159 :
            case 160 :
            case 161 :
            deigma[f]-=34;
            break;
            
            case 129 :
            case 162 :
            case 163 :
            deigma[f]=128;
            break;

            case 130:
            deigma[f]=119;
        }
    }
    if ( (deigma[f]>68) && (deigma[f]<95) ) deigma[f]-=26;
}


i=0;
while (mybigstr[i]!=255) i++;
big_len=i;
mem=malloc(i+1);
if (!mem) {information (2-keyb_gr,0,0); return 0;}
big_text=mem;
for (f=0;f<=i;f++) big_text[f]=mybigstr[f] ;
    
   
    //Όλα μικρά και χωρίς τόνους !
    // To big_text είναι το μεγάλο κείμενο 

    
    for (f=0;f<big_len;f++) {
        if (keyb_gr) {
            switch (big_text[f]) {

                case 96:
                case 131:
                case 132:
                big_text[f]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                big_text[f]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                big_text[f]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                big_text[f]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                big_text[f]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                big_text[f]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                big_text[f]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                big_text[f]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                big_text[f]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                big_text[f]=128;
                break;

                case 130:
                big_text[f]=119;
            }
        }
        if ( (big_text[f]>68) && (big_text[f]<95) ) big_text[f]-=26;
    }


    sefl=0; // Πόσα βρέθηκαν .... 
    i=0;
    do {
        what=big_text[i];
        f=0; w=sample_len; dem_len=0; start_point=-1; a=i ; // sample_len : μήκος δείγματος , dem_len : demanded len
        while( (what!=255) && (w) ) {
            if (what==deigma[f++]) {
                if (start_point==-1) start_point=i; 
                dem_len++; 
                w--; 
                what=big_text[++i];
                continue;
            }
            else break;
        }
            
        if (dem_len==sample_len) { 
            sefl++;  
            if (sefl==1) {*cur = (unsigned short int) start_point ;}
            for(f=start_point;f<i;f++) big_text[f]=1;
            continue ;
        }
        else { big_text[a]=0; i=a+1; }
        
    }while (what!=255);
    
    if (pe<100) {
        //mystrcpy(multicr[arped]->sample_t,normdeigma[pe]);
        mystrcpy(multicr[arped]->sample_tcode,deigma);
        multicr[arped]->cron_1=1;
    }
    
    *how_many=sefl;
    if (sefl) {
        inp_mem_ghost=mem;
        return mem;}
    else {
        *cur=0; free(mem); inp_mem_ghost=0; 
        return 0; 
    }
}



int mystrcpy_lim (unsigned char *str1 , unsigned char * str2 , int orio)
// Αποκλειστικά για δικά μου αλφαριθμητικά που τελειώνουν σε 255 - αντιγραφή από str2 sto str1 με όριο χαρακτήρων για το str 1 (Να έχω προβλέψει ένα byte παραπάνω χωρητικότητα στο str1 !!
{
    register int i;
    
    i=0;
    while ( (str2[i]!=255) && (orio) ) {str1[i]=str2[i]; i++; orio--;}
    str1[i]=255;
    return i;
}



int recent_files_inform (char *ndbpath , char *ndbname)
{
    
    FILE * fp;
    register int f;
    int a , b, i, fide_fp ;
    unsigned int size ;

    struct recent {
    short int hm;
    int pass;
    char dbpath[10][702];
    char dbname[10][62];
    } hard ;

    
    size = sizeof ( (struct recent) hard ) ;
    sprintf (str1024,"%s%s",path_name,"opened.dat");
    fp=fopen(str1024,"rb");
    if (fp==NULL) {
        // Το αρχείο δεν υπάρχει οπότε το δημιουργώ ...
        fp=fopen(str1024,"w+b");
        if (fp==NULL) {information (6-keyb_gr,str1024,0);return 0; }
        fide_fp = fileno (fp) ;
        if (keyb_gr) strcpy (hard.dbpath[0],"Επέλεξε και Φόρτωσε .. κάποιο άλλο αρχείο");
        else strcpy (hard.dbpath[0],"Select and Load .. another file");
        strcpy (hard.dbname[0],"-");
        hard.pass = 22111963;
        hard.hm=1;
        strcpy (hard.dbpath[1],ndbpath);
        f=strlen(hard.dbpath[1]);
        f-=2;
        while ( (hard.dbpath[1][f] != '/') && (f) ) f--;
        f++;
        hard.dbpath[1][f] = '\0';
        strcpy (hard.dbname[1],ndbname);
        for (f=2 ; f<10 ; f++) {
            hard.dbpath[f][0]='\0';
            hard.dbname[f][0]='\0';
        }
        fwrite ( &hard , 1 , size , fp );
        fsync (fide_fp);
        fclose (fp);
        return 1;
    }
    else { // To αρχείο υπάρχει...
        fclose (fp);
        fp=fopen(str1024,"r+b");
        if (fp==NULL) { information (6-keyb_gr,str1024,0);return 0; }
        fread ( &hard , 1 , size , fp );
        if (hard.pass!=22111963) {
            fclose (fp) ; 
            remove (str1024);
            information (6-keyb_gr,str1024,"Removal for auto-recreation");return 0;
        }
        fide_fp = fileno (fp) ;
        
        strcpy (hard.dbpath[0],ndbpath);
        f=strlen(hard.dbpath[0]);
        f-=2;
        while ( (hard.dbpath[0][f] != '/') && (f) ) f--;
        f++;
        hard.dbpath[0][f] = '\0';
        
        i=0;
        for (f=1; f<=hard.hm; f++) {
            a=strcmp(hard.dbpath[f] , hard.dbpath[0]);
            b=strcmp(hard.dbname[f] , ndbname);
            if ( (!a) && (!b) ) { i=f ; break; }
        }
        
        if (i==1) {
            fclose (fp) ;
            return 1 ;
        }
        
        if (i>1) {
            
            for (f=i ; f<hard.hm; f++) {
                strcpy (hard.dbpath[f] , hard.dbpath[f+1]) ;
                strcpy (hard.dbname[f] , hard.dbname[f+1]) ;
            }
            
            hard.dbpath[hard.hm][0] = '\0';
            hard.dbname[hard.hm][0] = '\0';
            //hard.hm--;
        }
        
        if ( (!i) && (hard.hm<9) ) hard.hm++;
        
        for (f=hard.hm; f>1; f--) {
            strcpy (hard.dbpath[f] , hard.dbpath[f-1]) ;
            strcpy (hard.dbname[f] , hard.dbname[f-1]) ;
        }
        
        strcpy (hard.dbpath[1],hard.dbpath[0]);
        strcpy (hard.dbname[1],ndbname);

        if (keyb_gr) strcpy (hard.dbpath[0],"Επέλεξε και Φόρτωσε .. κάποιο άλλο αρχείο");
        else strcpy (hard.dbpath[0],"Select and Load .. another file");
        
        
        rewind (fp);
        fwrite ( &hard , 1 , size , fp );
        fsync (fide_fp);
        fclose (fp);
        return 2;
    }
}



int menu_dbfiles(char *loaddbfile)

{

SDL_Cursor* cursor;
FILE *fp ;
struct fansouv *whouv;
void  *mem_ok=0 ;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] ;
short int bima ,width ;
int kati ,a1 ,a , k  ;
unsigned short int xt, yt, yt1, xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , proenter , xok , yok , protyx ;
unsigned short int tyx ,fyge , yicob ,el , xtepla , xtepra ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, proelem ,c ;
unsigned char what ;
unsigned int size;
Uint8 klik;
short int hf , plbut;
int bkxrm[3] , chxrm[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

unsigned char ektos=1;

struct recent {
short int hm;
int pass;
char dbpath[10][702];
char dbname[10][62];
} hard ;


kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο ! 

size = sizeof ( (struct recent) hard ) ;
sprintf (str1024,"%s%s",path_name,"opened.dat");
fp=fopen(str1024,"rb");
if (fp==NULL) return -1; 
fread ( &hard , 1 , size , fp );
if (ferror(fp)) {information (6-keyb_gr,str1024,0);clearerr(fp); fclose(fp); return -1;}
rewind(fp);
fclose (fp);

if (!hard.hm) return -1;

plbut = hard.hm + 1 ;

unsigned char *but[plbut];
unsigned char *but1[plbut];

whouv=gouv;
gouv = myfont[5];
hf = myfont_hei[5]+2;

for (f=0 ; f<plbut ; f++) {
    normtext_tomy(hard.dbpath[f],0);
    normtext_tomy(hard.dbname[f],0);
    but[f]=hard.dbname[f];
    but1[f]=hard.dbpath[f];
}

// Sorting Procedure !!

sort=0;

// Colorsssssssss

bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ; 

chxrm[0]=chxrm[1]=chxrm[2]=0;
bkxrm[0]=bkxrm[1]=bkxrm[2]=100;

chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;

width=1200;
xt=(info.right-info.left-1199) / 2 ; yt1=(info.bottom-info.top-400) / 2 ;
yt=yt1+62;  yb=yt+(plbut*hf+70);
xb=xt+width-1 ;

bareacls(xt+1,yt1+1,xb-1,yt1+27,bkxrkef); // Γέμισμα καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
setcolor(2);
rectangle (xt-1,yt1-1,xb+1,yb+1) ;
setcolor(5);
rectangle (xt-2,yt1-2,xb+2,yb+2) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+27,xb-1,yt1+27);
line (xt+1,yt1+28,xb-1,yt1+28);

rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*hf+1;
xok=xb-46 ; yok=yb-45;
yicob = yb-9;
xtepra=xtepl+400; xtepla=xtepra+5;

// ΕΠΙΚΕΦΑΛΙΔΑ


if (keyb_gr) strcpy (str1024 , "Κατάλογος Αρχείων που Ανοίχτηκαν Πρόσφατα"); 
else strcpy (str1024 , "List of Recently Opened Files");
normtext_tomy(str1024,0);
_outmystr_center_col(7, str1024 , xtepl, yt1+1, xtepr, yt1+hf+1, chxrkef , bkxrkef);

refresh();


_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*hf),bkxrm);
_areacls(xtepl,ytepl+(plbut*hf)+2,xtepr,ytepr,30,30,30);

setcolor(5);
line (xtepra+2 , yt1+27 , xtepra+2 , ybarb);
setcolor(2);
line (xtepra+3 , yt1+27 , xtepra+3 , ybarb);
setcolor(5);
line (xtepra+4 , yt1+27 , xtepra+4 , ybarb);

if (keyb_gr) {
    strcpy (str1024 , "Φάκελος Βάσης Δεδομένων");
    normtext_tomy(str1024,0);
    _outmystr_center_col(5, str1024 , xtepl, yt1+hf+3, xtepra-1, yt+1, chxrkef , bkxrkef);
    
    strcpy (str1024 , "Διαδρομή στο δίσκο");
    normtext_tomy(str1024,0);
    _outmystr_center_col(5, str1024 , xtepla+1, yt1+hf+3, xtepr-1, yt+1, chxrkef , bkxrkef);
}
else {
    strcpy (str1024 , "Data Base Folder");
    normtext_tomy(str1024,0);
    _outmystr_center_col(5, str1024 , xtepl, yt1+hf+3, xtepra-1, yt+1, chxrkef , bkxrkef);
    
    strcpy (str1024 , "Pathname");
    normtext_tomy(str1024,0);
    _outmystr_center_col(5, str1024 , xtepla+1, yt1+hf+3, xtepr-1, yt+1, chxrkef , bkxrkef);
}
refresh ();
// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        //_outfanis_col(0, but[a] , xtepl+10 , ytepl+k*hf , xtepr);
        _outmystr_center_col(5, but[a] , xtepl+1, ytepl+k*hf, xtepra, ytepl+k*hf+hf, chxrm , bkxrm);
        _outmystr_center_col(5, but1[a] , xtepla+1, ytepl+k*hf, xtepr, ytepl+k*hf+hf, chxrm , bkxrm);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

setcolor(5);
line(xtepl,ytepl+k*hf+1,xtepr,ytepl+k*hf+1);
_puticon (xok,yok,mem_ok,255);
refresh();
c=a;
kato=--a;
telos=a1;
 
proenter=fyge=0;
protyx=tyx=15; elem=proelem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;

    if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
       
     tyx=(my-ytepl)/hf;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 15 koytia !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=15) {
                //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
                _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
                _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
                el = (sort) ? pano-protyx : pano+protyx;
                //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);        
                _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
                _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
                refresh();
                protyx=15;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
        _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
        _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
        _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
        _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
        _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
        _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
        //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
         //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
        _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
        _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
        _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=15 && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
        _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
        _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
        el = (sort) ? pano-protyx : pano+protyx;
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);  
        _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
        _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
        refresh();
        protyx=15;
                }
                                 

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
       //if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=15)  && (!proenter) ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
            //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
            //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
            _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
            _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
            _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
            _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
            protyx=15;
            refresh();
            continue ;
        }
        //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
        //el= (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
        _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrsel);
        _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrsel);
        _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrsel , bkxrsel);
        _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrsel , bkxrsel);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        continue ; 
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
        
       
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=elem;
                    if (kati>0) {
                    mytext_tonorm (but[elem],hard.dbname[0],60);
                    mytext_tonorm (but1[elem],hard.dbpath[0],700);
                    sprintf(loaddbfile,"%s%s%s",hard.dbpath[0],hard.dbname[0],"/Mainped.aba");
                    }
                    continue ;
                }
        }
                    
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            //if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            /*
          if (protyx!=15) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
            _outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
            protyx=15;
            refresh();}
            */
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (tyx>=plbut-1) tyx=0; else tyx=tyx+1;
                    
                    
                    
        if (tyx==protyx) {      
            if (elem!=-1) { // Ακυρώνεται η επιλογή !
                elem=proelem=-1 ; 
            //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
            //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
                _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
                _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
                _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
                _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
                protyx=15;
                refresh();
          }
          else continue ;
        }
        
       
                    
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
                    _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
                    _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
                    _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                

                if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (!tyx) tyx=plbut-1; else tyx-=1;
                    
                if (tyx==protyx) {      
                    if (elem!=-1) { // Ακυρώνεται η επιλογή !
                        elem=proelem=-1 ; 
                    //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
                    _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    protyx=15;
                    refresh();
                }
                else continue ;
                }
                        
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
                    _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrm);
                    _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrm);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrm , bkxrm);
                    
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*hf , xtepr);     
                    _bareacls(xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf-1,bkxrepi);
                    _bareacls(xtepla+1, ytepl+tyx*hf, xtepr-1, ytepl+tyx*hf+hf-1,bkxrepi);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+tyx*hf, xtepra, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+tyx*hf, xtepr, ytepl+tyx*hf+hf, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1 || ( protyx==15 && el_pl==-1) ) {
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                kati = elem ;
                if (kati>0) {
                    mytext_tonorm (but[elem],hard.dbname[0],60);
                    mytext_tonorm (but1[elem],hard.dbpath[0],700);
                    sprintf(loaddbfile,"%s%s%s",hard.dbpath[0],hard.dbname[0],"/Mainped.aba");
                    }
                }
                else {
                    if (protyx!=15) el_pl=protyx;
                    if (el_pl!=-1) {    
                    //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
                    elem= el= el_pl; protyx=el_pl;
                    //_bareacls(xtepl+10, ytepl+protyx*hf,xtepr,ytepl+protyx*hf+18,bkxr);
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*hf , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf-1,bkxrsel);
                    _bareacls(xtepla+1, ytepl+protyx*hf, xtepr-1, ytepl+protyx*hf+hf-1,bkxrsel);
                    _outmystr_center_col(5, but[el] , xtepl+1, ytepl+protyx*hf, xtepra, ytepl+protyx*hf+hf, chxrsel , bkxrsel);
                    _outmystr_center_col(5, but1[el] , xtepla+1, ytepl+protyx*hf, xtepr, ytepl+protyx*hf+hf, chxrsel , bkxrsel);
                    proelem=elem;
                    refresh(); 
                    //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
                }}
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        //if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
                case SDL_QUIT :
               fyge=1;
               kati=-2;
               continue;
                
     default :
         if (ektos) continue;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

if (mem_ok) free (mem_ok);
cls();
gouv=whouv;
return kati ;
}



int smmenu_show(short int plbut, char menu[][80], char *but_name, unsigned short int moux, unsigned short int mouy )
// Βλέπε array submenu...

{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *mem_arrs =0, *mem_ok=0 ;
void *mem_zer=0 ;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] , bkxrm[3] , chxrm[3] ;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k  ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , proenter , xok , yok , protyx ;
unsigned short int tyx ,fyge , marrs , yicob ,el ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned short int orio;
Uint8 klik;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned short int xt;
int yt1;
unsigned char ektos=1;
unsigned char but[plbut][100];

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
orio=0;

for (f=0 ; f<plbut ; f++) {
    normtext_tomy(menu[f],but[f]);
    i=0;
    while (but[f][i]!=255) i++;
    if (orio<i) orio=i;
}

// Sorting Procedure !!

sort=0;

bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ; 

chxrm[0]=chxrm[1]=chxrm[2]=0;
bkxrm[0]=bkxrm[1]=bkxrm[2]=100;

chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;

i=orio*myfont_wid[0];
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,(plbut*20+69));
mem0=malloc(size); //250 x ... ( όσο βγει το ύψος...προσοχή λίγο όμως...)
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
xt=moux ; yt1=mouy ;
while ( (yt1+(plbut*20+69)>info.bottom-50) && (yt1>info.top) ) yt1--;
yt=yt1+19;  yb=yt1+(plbut*20+69);
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,bkxrkef); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20+1;
xok=xb-46 ; yok=yb-42;
yicob = yb-9;

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);


//_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
_outmystr_center_col(0, but_name , xtepl, yt1+2, xtepr, yt1+20, chxrkef , bkxrkef);
refresh();

_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*20),bkxrm);
_areacls(xtepl,ytepl+(plbut*20)+2,xtepr,ytepr,30,30,30);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        //_outfanis_col(0, but[a] , xtepl+10 , ytepl+k*20 , xtepr);
        _outmystr_center_col(0, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm , bkxrm);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

setcolor(5);
line(xtepl,ytepl+k*20+1,xtepr,ytepl+k*20+1);
_puticon (xok,yok,mem_ok,255);
refresh();
c=a;
kato=--a;
telos=a1;
 
proenter=fyge=marrs=0;
protyx=tyx=15; elem=proelem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
       
     tyx=(my-ytepl)/20;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 15 koytia !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=15) {
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                el = (sort) ? pano-protyx : pano+protyx;
                //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                refresh();
                protyx=15;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=15 && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        el = (sort) ? pano-protyx : pano+protyx;
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);  
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        refresh();
        protyx=15;
                }
                                 

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;

        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help(" Μετακίνηση παραθύρου ", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help(" Move the window ", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
            if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=15)  && (!proenter) && (!marrs)  ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
            _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
            _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
            protyx=15;
            refresh();
            continue ;
        }
        //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        continue ; 
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
        
       
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=elem;
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}


            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+(plbut*20+69);
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20+1;
            xok=xb-46 ; yok=yb-42;
            yicob = yb-9;
            refresh();
            continue ;
        }
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            /*
          if (protyx!=15) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
            _outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
            protyx=15;
            refresh();}
            */
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                if (marrs) {
                    marrs=0;
                    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

                else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (tyx>=plbut-1) tyx=0; else tyx=tyx+1;
                    
                    
                    
        if (tyx==protyx) {      
            if (elem!=-1) { // Ακυρώνεται η επιλογή !
                elem=proelem=-1 ; 
            //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
            //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                protyx=15;
                refresh();
          }
          else continue ;
        }
        
       
                    
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                
                if (marrs) {
                    marrs=0;
                    puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

                else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
                    
                if (!tyx) tyx=plbut-1; else tyx-=1;
                    
                if (tyx==protyx) {      
                    if (elem!=-1) { // Ακυρώνεται η επιλογή !
                        elem=proelem=-1 ; 
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                        protyx=15;
                        refresh();
                }
                else continue ;
                }
                        
                if (protyx==15) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    proelem=elem=-1;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr); 
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1 || ( protyx==15 && el_pl==-1) ) {
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255; 
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                kati = elem ;
                }
                else {
                    if (protyx!=15) el_pl=protyx;
                    if (el_pl!=-1) {    
                    //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
                    elem= el= el_pl; protyx=el_pl;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
                    proelem=elem;
                    refresh(); 
                    //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
                }}
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
                case SDL_QUIT :
                    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
               fyge=1;
               kati=-2;
               continue;
                
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ

if (mem_ok) free (mem_ok);

if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}


short int find_dayname (unsigned short int uyear,unsigned short int umonth,unsigned short int uday)
{
    register int i,f ;
    unsigned short int staday , stayear , mon11 ;
    unsigned int metr=0 , tel_all , arx_all , arx_1582, uolo ;
    short int mo[13];
    int fimoday ;
    short int greg ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2500 || !uday || !umonth) return 0;
    
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;

       
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_all=story.olo ;
    
    
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=10;
    story.mewo[1]=1582;
    tel_all=story.olo ;
    
    // Και ο χρήστης έδωσε ... : 
    
    story.olo=0;
    story.meros[0]= uday;
    story.meros[1]= umonth;
    story.mewo[1]=uyear;
    uolo=story.olo ;
    
    // (Επιστρέφει με κωδικό τρόπο για τον περίεργο μήνα Οκτ 1582 - αντί για επιστροφή 2 = Δευτέρα)
    if (uolo>=arx_all && uolo<=tel_all) return 20;
    //printf ("uyear=%u, uolo=%u , arx_all=%u , tel_all=%u \n" , uyear, uolo, arx_all, tel_all);
    
    // 1-11-1582 : Δευτέρα
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=11;
    story.mewo[1]=1582;
    arx_1582=story.olo ;
       
    if (uyear>=2400) {stayear=2400; staday=7; greg=1 ; }
    else if (uyear>=2200) {stayear=2200; staday=4; greg=1 ; }
    else if (uyear>=2000) {stayear=2000; staday=7; greg=1 ;  }
    else if (uyear>=1800) {stayear=1800; staday=4; greg=1 ; }
    else if (uyear>=1600) {stayear=1600; staday=7; greg=1 ;  }
    else if (uolo>=arx_1582) {greg=1 ;stayear=1599; staday=7;}
    else if (uyear>=1200) {stayear=1200; staday=7; greg=0 ; }
    else if (uyear>=800) {stayear=800; staday=4; greg=0 ; }
    else if (uyear>=400) {stayear=400; staday=1; greg=0 ; }
    else if (uyear>=1) {stayear=1; staday=7; greg=0 ; }
   
        
    if (greg) {
        
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
        
        if (uday>mo[umonth]) uday=mo[umonth] ;
        
        metr=staday-1;
        mon11 = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;
        if (stayear!=1599) {
            
            while(uyear>stayear) {
                if (stayear%4) mo[2]=28;
                else {
                    if (stayear%100) mo[2]=29;
                    else {mo[2]=(stayear%400) ? 28 : 29 ;}
                    }
                    
                metr=metr+mon11+mo[2];
                
                stayear++;
            }
            
            if (uyear%4) mo[2]=28;
            else {
                if (uyear%100) mo[2]=29;
                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                }
                
            for (f=1 ; f<umonth ; f++) {
                metr += mo[f] ;
            }
            
            metr++; 
            fimoday = metr%7;
            if (!fimoday) fimoday=7; // Πρώτη ημέρα του μήνα / έτους ενδιαφέροντος μας. Κυρ=1...Σαβ=7.
    
        }
        else {  // stayear = 1599
            
            while (uyear < stayear) {
                
                if (stayear%4) mo[2]=28;
                else {
                    if (stayear%100) mo[2]=29;
                    else {mo[2]=(stayear%400) ? 28 : 29 ;}
                    }
                
                for (f=12 ; f>0 ; f--) {
                    for (i=mo[f] ; i>0 ; i--) {
                        staday = (staday-1) ? staday-1 : 7 ;
                    }
                }
                                
                stayear--;
            }
            
            if (uyear%4) mo[2]=28;
            else {
                if (uyear%100) mo[2]=29;
                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                }
                
            f=12;
            while (umonth<f) {
                for (i=mo[f] ; i>0 ; i--) {
                    staday = (staday-1) ? staday-1 : 7 ;
                }
                f--;
            }
            
            for (i=mo[f] ; i>0 ; i--){
                staday = (staday-1) ? staday-1 : 7 ;
            }
            
            fimoday=staday;
        }
    }
    
    else { // IOYLIANO
        
        mo[2] = (uyear%4) ? 28 : 29 ;
       
        if (uday>mo[umonth]) uday=mo[umonth] ;
        
        metr=staday-1;
        mon11 = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;
        
        while(uyear>stayear) {
            
            mo[2] = (stayear%4) ? 28 : 29 ;
            
            metr=metr+mon11+mo[2];
            stayear++;
        }
        
        mo[2] = (uyear%4) ? 28 : 29 ;
            
        for (f=1 ; f<umonth ; f++) {
                metr += mo[f] ;
            }
        
        metr++; 
        
    fimoday = metr%7;
    if (!fimoday) fimoday=7; // Πρώτη ημέρα του μήνα / έτους ενδιαφέροντος μας. Κυρ=1...Σαβ=7.
    
    }
    
    return (short int) fimoday ;
}



short int _show_month (unsigned short int xt, unsigned short int yt, unsigned short int uyear,unsigned short int umonth,unsigned short int uday,unsigned short int stamonth)
{
    register int i,f ;
    unsigned short int xb,yb ;
    unsigned short int a , b ;
    int bluedy,reddy ;
    unsigned int metr=0 , tel_all , arx_all , arx_1582, uolo ;
    short int mo[13];
    short int greg , metab=0 , specmonth=0;
    unsigned short int cx[8] , cy[6] ;
    
    union {
        unsigned int olo;
        unsigned char meros[4];
        unsigned short int mewo[2];
    } story ;
    
    char mera [8][8] , monda [32][3] ;
    
    int bluechxr[3] , redchxr[3] , genchxr[3] ;
    int *piobkxr ;
    int genbkxr[3] , bkxrepi[3] ; 
    
    // 4 Okt 1582 τελευταία ημέρα Ιουλιανού - Πέμπτη !
    // 15 Okt 1582 πρώτη ημέρα Γρηγοριανού - Παρασκευή !
    
    if (!uyear || uyear>2800) return -1;
    
    bluechxr[0] = 0; bluechxr[1] = 0; bluechxr[2] = 255;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    redchxr[0]=255;redchxr[1]=0; redchxr[2]=0;
    genchxr[0]=genchxr[1]=genchxr[2]=0;
    genbkxr[0]=genbkxr[1]=genbkxr[2]=100;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_all=story.olo ;
    
    
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=10;
    story.mewo[1]=1582;
    tel_all=story.olo ;
    
    // Και ο χρήστης έδωσε ... : 
    
    story.olo=0;
    story.meros[0]= uday;
    story.meros[1]= umonth;
    story.mewo[1]=uyear;
    uolo=story.olo ;
    
    // (Για  τον περίεργο μήνα Οκτ 1582 ...)
    if (uolo>=arx_all && uolo<=tel_all) { metab=1 ; specmonth=1;}
    
    // 1-11-1582 : Δευτέρα
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=11;
    story.mewo[1]=1582;
    arx_1582=story.olo ;
       
    greg = (uolo>=arx_1582) ? 1 : 0 ; 
        
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
        
    if (greg) {
        
        if (uyear%4) mo[2]=28;
        else {
            if (uyear%100) mo[2]=29;
            else {mo[2]=(uyear%400) ? 28 : 29 ;}
            }
    }
    
    else { mo[2] = (uyear%4) ? 28 : 29 ; }
    
    if (keyb_gr) {

        strcpy (mera[1],"Κυρ");  strcpy (mera[2],"Δευ"); strcpy (mera[3],"Τρι"); strcpy (mera[4],"Τετ");
        strcpy (mera[5],"Πεμ"); strcpy (mera[6],"Παρ"); strcpy (mera[7],"Σαβ"); }
    else {

        strcpy (mera[1],"Sun");  strcpy (mera[2],"Mon"); strcpy (mera[3],"Tue"); strcpy (mera[4],"Wed");
        strcpy (mera[5],"Thu"); strcpy (mera[6],"Fri"); strcpy (mera[7],"Sat"); }
        
       // Στήλες Σαββατοκύριακου έγχρωμες 
    a=stamonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
        normtext_tomy (mera[f],0);
    }
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=xt+(i-1)*60; }
    xb=xt+(i-1)*60;
    for (f=0 ; f<6;f++) { cy[f]=yt+f*25; }
    yb=yt+f*25;
    
    bareacls (xt,yt,xb,yb,genbkxr);
    
    // ΒΑΣΙΚΗ ΣΧΕΔΙΑΣΗ 
    setrgbcolor(dbaspro);
    rectangle (xt,yt,xb,yb) ;
    
    if (!metab) {
        a=0;b=stamonth;
        
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if (bluedy==i) _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1],bluechxr,genbkxr);
                    else if (reddy==i) _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1],redchxr,genbkxr);
                    else _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1],genchxr,genbkxr);
            
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if (a>mo[umonth]) break ;
                if (a==uday) {
                    piobkxr = bkxrepi ;
                    _bareacls (cx[i]+1, cy[f]+1, cx[i]+59, cy[f]+24, piobkxr) ; 
                }
                else {piobkxr=genbkxr;}
                
                if (i==bluedy) _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,redchxr,piobkxr);
                else _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,genchxr,piobkxr);
                
            }
        }
    }
    else { // KOYFH EBDOMADA
        a=0;b=2;metab=0;
        
        for (f=0 ; f<6;f++) {
            setrgbcolor(dbaspro);
            line (cx[1],cy[f],xb,cy[f]);
            for (i=1 ; i<8 ; i++ ) {
                if (!f) {
                    setrgbcolor(dbaspro);
                    line (cx[i],cy[0],cx[i],yb);
                    
                    if(i==bluedy) _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1],bluechxr,genbkxr);
                    else if (i==reddy) _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1], redchxr, genbkxr);
                    else _outmystr_center_col (6,mera[b],cx[i],cy[0],cx[i]+59,cy[1],genchxr,genbkxr);
                    
                    b++; if (b==8) b=1 ;
                    continue ;
                    
                }
                
                a++;
                if ( (!metab) && (a>4 && a<19) ) continue ;
                if ( (!metab) && (a==19) ) {metab=1; a=15;}
                if (a>mo[umonth]) break ;
                if (a==uday) {
                    piobkxr = bkxrepi ;
                    _bareacls (cx[i]+1, cy[f]+1, cx[i]+59, cy[f]+24, piobkxr) ; 
                }
                else {piobkxr=genbkxr;}
                
                if (i==bluedy) _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,bluechxr,piobkxr);
                else if (i==reddy) _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,redchxr,piobkxr);
                else _outmystr_center_col (6,monda[a],cx[i],cy[f],cx[i]+59,cy[f]+25,genchxr,piobkxr);
                
            }
        }

    }
    setrgbcolor(dbaspro);
    line (cx[1], yb, xb,yb);
    return (specmonth) ;
}



char * pedaba_calendar(short int arped)
//Με απλά λόγια, μετά τις 15 Φεβρουαρίου 1923 «εξαφανίστηκαν» 13 ημέρες και ακολούθησε η 1η Μαρτίου 1923.
{

struct tm *diar;
time_t loctim;
SDL_Cursor* cursor;
struct fansouv *trampa;
register int i,f ;
void *mem0=0 , *mem_arrs=0 , *mem_ri=0 , *mem_le=0, *mem_ok=0 , *mem_yes=0, *mem_akyro=0 , *mem_sync=0 ,*mem_flgr=0, *mem_move;
char month [13][12] , mera [8][20]  , monda [32][4] ;
unsigned short int caxt , cayt , caxb, cayb , mhnxt, mhnxb ;
short int mhnyt[13] , mhnyb[13] ;
int xb, yb , xt1, yt1 ,mx, my, dx, dy ;
unsigned short int unameday , uday, umonth , uyear , a , b, d, startmonth, nowday, nowyear, nownameday, nowmonth;
int bluedy , reddy ;
unsigned short int cx[8] , cy[6] ;
short int mo[13];
int bluechxr[3] , redchxr[3] , genchxr[3] , bkxrkef[3] , chxrkef[3] , olobkxr[3] ,olochxr [3] ,chxrsel[3], bkxrsel[3] , gkrichxr[3], black[3];
int *piobkxr ;
int genbkxr[3] , bkxrepi[3] ; 
unsigned short int movext , moveyt , leyearxt, leyearyt, riyearxt, riyearyt, ledayxt, ledayyt, ridayxt, ridayyt ;
unsigned short int recyearxt, recyearyt , recyearxb, recyearyb ,syncxt, syncyt ;
unsigned short int recshmxt,recshmyt,recshmxb, recshmyb , recfullxt, recfullyt, recfullxb, recfullyb ;
unsigned short int inpyearxt, inpyearyt , inpyearxb, inpyearyb , inpmonthxt, inpmonthyt, inpmonthxb, inpmonthyb ;
unsigned short int inpdayxt, inpdayyt, inpdayxb, inpdayyb , adddaysxt, adddaysyt, adddaysxb, adddaysyb ;
unsigned short int yesxt, yesyt , akyroxt, akyroyt , addokxt, addokyt, putokxt, putokyt , flaggrxt, flaggryt;
unsigned short int marrs=0 , putok=0 , addok=0, finyes=0, akyro=0, inpyear=0, inpmonth=0, inpday=0 ;
unsigned short int panel=0 , leyear=0, leday=0, riyear=0, riday=0 ,adddays=0 , sync=0 , flaggr=0 ,kext, keyt ;
unsigned int size , arx_grh, uolo , first_xam, last_xam, arx_diary, tel_diary ;
short int ektos=1 , fyge=0 , profyge=0 , box=-1, probox=-1 , monbox=-1, promonbox=-1 , syncyes=0, flaggryes=1;
short int nowon=1 , pronow=0 , specmonth=0 , greg=1 , c , keepfld=0 ;

unsigned char year_t[10] , month_t[6], day_t[6] , addday_t[12];
unsigned short int prosyear, prosmonth=1, prosday ,greday=40, grenameday, gremonth,greyear;
int prosadd=0;
unsigned char *flddate=0;
void *memfld=0;
unsigned char syncyear_t[10] , syncmonth_t[6], syncday_t[6] ;
unsigned int gre_xam_1 , gre_xam_t;

union {
    unsigned int olo;
    unsigned char meros[4];
    unsigned short int mewo[2];
} story ;

static int xt,yt ;

    size=imagesize(0,0,539,499);
    mem0=malloc(size);
    if (!mem0) {information (2-keyb_gr,0,0);return 0;}
    trampa=gouv;
    for(f=0 ; f<3 ; f++) {
        bkxr1[f]=bkxr[f] ; chxr1[f]=chxr[f] ; slxr1[f]=slxr[f];
    }
    
    year_t[0]=255; month_t[0]=255; day_t[0]=255;addday_t[0]=255;
    
    story.olo=0;
    story.meros[0]=15;
    story.meros[1]=10;
    story.mewo[1]=1582;
    arx_grh=story.olo ;
    
    
    story.olo=0;
    story.meros[0]=5;
    story.meros[1]=10;
    story.mewo[1]=1582;
    first_xam=story.olo ;
        
    story.olo=0;
    story.meros[0]=14;
    story.meros[1]=10;
    story.mewo[1]=1582;
    last_xam=story.olo ;
    
    story.olo=0;
    story.meros[0]=1;
    story.meros[1]=1;
    story.mewo[1]=1;
    arx_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=31;
    story.meros[1]=12;
    story.mewo[1]=2500;
    tel_diary=story.olo ;
    
    story.olo=0;
    story.meros[0]=16;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_1=story.olo ;
    
    story.olo=0;
    story.meros[0]=28;
    story.meros[1]=2;
    story.mewo[1]=1923;
    gre_xam_t=story.olo ;
    
    //xt=(unsigned short int) info.left+3 ; yt= (unsigned short int) info.top+3 ;
    if (!xt && !yt) {
    xt=(info.right-info.left-539) / 2 ; yt=(info.bottom-info.top-499) / 2 ;}
    xb=xt+539; yb=yt+499;
    getimage(xt,yt,xt+539,yt+499,mem0);

    bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
    chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ;
    bluechxr[0] = 0; bluechxr[1] = 0; bluechxr[2] = 255;
    bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;
    redchxr[0]=255;redchxr[1]=0; redchxr[2]=0;
    genchxr[0]=genchxr[1]=genchxr[2]=0;
    genbkxr[0]=genbkxr[1]=genbkxr[2]=100;
    olobkxr[0]=4 ; olobkxr[1]=41 ; olobkxr[2]=67 ;
    olochxr[0]=olochxr[1]=olochxr[2]=255;
    chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
    bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;
    gkrichxr[0]=25; gkrichxr[1]=90; gkrichxr[2]=15;
    black[0]=black[1]=black[2]=0;
    
    if (keyb_gr) {
        strcpy (month[1],"Ιαν."); strcpy (month[2],"Φεβ."); strcpy (month[3],"Μαρ."); strcpy (month[4],"Απρ.");
        strcpy (month[5],"Μάι."); strcpy (month[6],"Ιούν."); strcpy (month[7],"Ιούλ."); strcpy (month[8],"Αύγ.");
        strcpy (month[9],"Σεπ."); strcpy (month[10],"Οκτ."); strcpy (month[11],"Νοε."); strcpy (month[12],"Δεκ.");

        strcpy (mera[1],"Κυριακή");  strcpy (mera[2],"Δευτέρα"); strcpy (mera[3],"Τρίτη"); strcpy (mera[4],"Τετάρτη");
        strcpy (mera[5],"Πέμπτη"); strcpy (mera[6],"Παρασκευή"); strcpy (mera[7],"Σάββατο"); }
    else {
        strcpy (month[1],"Jan."); strcpy (month[2],"Feb."); strcpy (month[3],"Mar."); strcpy (month[4],"Apr.");
        strcpy (month[5],"Mai"); strcpy (month[6],"Jun"); strcpy (month[7],"July"); strcpy (month[8],"Aug.");
        strcpy (month[9],"Sep."); strcpy (month[10],"Oct."); strcpy (month[11],"Nov."); strcpy (month[12],"Dec.");

        strcpy (mera[1],"Sunday");  strcpy (mera[2],"Monday"); strcpy (mera[3],"Tuesday"); strcpy (mera[4],"Wednesday");
        strcpy (mera[5],"Thursday"); strcpy (mera[6],"Friday"); strcpy (mera[7],"Saturday"); }
        
    mo[1]=mo[3]=mo[5]=mo[7]=mo[8]=mo[10]=mo[12]=31;
    mo[4]=mo[6]=mo[9]=mo[11]=30;
    
    for (f=1; f<32; f++) {
        sprintf(monda[f],"%d",f);
        normtext_tomy (monda[f],0);
    }
    
    
    // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
    recfullxt = xt+15 ;
    leyearxt=xt+30;
    ledayxt=xt+50;
    movext=caxt=xt+6 ;
    inpyearxt=xt+93;
    moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
    recfullyt=yt+33;
    recfullyb=recfullyt+28;
    leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
    mhnyb[0]-=4;
    recyearxt=leyearxt+30;
    recshmxt=ledayxt+30;
    recfullxb=xb-15;
    recyearyb=recyearyt+25;
    ledayyt=ridayyt=recshmyt=recyearyb+4;
    recshmyb=recshmyt+25;
    cayt=recshmyb+9;
    
    // Υπολογισμός cx - cy
    for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*60; }
    caxb=caxt+(i-1)*60;
    for (f=0 ; f<6;f++) { cy[f]=cayt+f*25; }
    cayb=cayt+f*25;

    ridayxt=caxb-76;
    riyearxt=caxb-56;
    recyearxb=riyearxt-4 ;
    recshmxb=ridayxt-4 ;
    inpyearxb=inpyearxt+80;
    inpmonthxt=inpyearxb+31; inpmonthxb=inpmonthxt+40;
    inpdayxt=inpmonthxb+29; inpdayxb=inpdayxt+40;
    inpyearyt = inpmonthyt = inpdayyt = cayb+66;
    // ENDIAMESA NA GRAFEI KATI....
    inpyearyb=inpmonthyb=inpdayyb=inpdayyt+25;
    putokxt=inpdayxb+7; putokyt = inpdayyt-4;
    // ENDIAMESA NA GRAFEI KATI....
    adddaysxt=xt+155; adddaysyt=inpyearyb+40;
    adddaysxb=adddaysxt+120;
    adddaysyb=adddaysyt+25;
    addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
    yesxt = xb-90 ; yesyt = adddaysyb+17;
    akyroxt = xt+15; akyroyt = adddaysyb+17;
    syncxt = xt+250 ; syncyt = akyroyt;
    flaggrxt=yesxt-50; flaggryt=yesyt+8;
    
    
    // RECTANGLES
    setcolor(5);
    rectangle (xt,yt,xb,yb);
    setcolor(2);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setcolor(5);
    rectangle (xt+2,yt+2,xb-2,yb-2);
    setcolor(5);
    line (xt+3,yt+29,xb-3,yt+29) ; // Γραμμή Επικεφαλίδας
    _bareacls (xt+4 , yt+3 , xb-4 , yt+28, bkxrkef);
    if (keyb_gr) strcpy (str1024,"Η Μ Ε Ρ Ο Λ Ο Γ Ι Ο") ;
    else strcpy (str1024,"C A L E N D A R");
    normtext_tomy (str1024,0);
    _outmystr_center_col (6,str1024,xt+4,yt+4,xb-4,yt+29,chxrkef, bkxrkef);
    
    // ΓΕΜΙΣΜΑ ΚΑΤΩ ΑΠΟ ΕΠΙΚΕΦΑΛΙΔΑ ΟΛΟ ΤΟ ΧΩΡΟ
    _bareacls(xt+3,yt+29,xb-3,yb-3,olobkxr);
    // ΠΛΗΡΗΣ ΗΜΕΡΟΜΗΝΙΑ
    setcolor(3);
    rectangle (recfullxt , recfullyt , recfullxb , recfullyb);
    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1 , bkxrsel);
    
    kext=recyearxt+((recyearxb-recyearxt)/2);
    keyt=recfullyb+2;
    setcolor(COLOR(100,100,100));
    while(keyt<recyearyt){
        line(recyearxt,recyearyt,kext,keyt);
        line(kext,keyt,recyearxb,recyearyt);
        keyt++;
    }
    refresh();
    
    // ΗΜΕΡΟΜΗΝΙΑ ΣΥΣΤΗΜΑΤΟΣ
    loctim=time(NULL);
    diar=localtime(&loctim);
    unameday=diar->tm_wday+1;
    uday= diar->tm_mday;
    umonth = diar->tm_mon+1;
    uyear = diar->tm_year+1900;
    strcpy (mera[0],mera[unameday]);
    
    
   
    if (uyear%4) mo[2]=28;
    else {
        if (uyear%100) mo[2]=29;
        else {mo[2]=(uyear%400) ? 28 : 29 ;}
    }
    
   
    startmonth=unameday+1;
    if (startmonth==8) startmonth=1;
    for (f=uday ; f>0 ; f--){
        startmonth--;
        if (!startmonth) startmonth=7;
    }

    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
    
    // ΕΤΟΣ - ΣΗΜΕΡΑ
    setrgbcolor(dbred);
    rectangle (recyearxt-1,recyearyt-1,recyearxb+1,recyearyb+1);
    setrgbcolor(dbaspro);
    rectangle (recyearxt,recyearyt,recyearxb,recyearyb);
    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
    sprintf (str1024,"%04u",uyear);
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
    
    setrgbcolor(dbaspro);
    rectangle (recshmxt,recshmyt,recshmxb,recshmyb);
    _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
    if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
    else strcpy(str1024,"TODAY");
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
    
    refresh() ;
    
    // ΠΑΝΕΛ
    _show_month (caxt, cayt, uyear,umonth,uday,startmonth);
    
        a=startmonth;
    for (f=1; f<8; f++) {
        if (a==1) reddy=f;
        else if (a==7) bluedy=f;
        a++;
        if (a==8) a=1;
    }
    
    // ΜΕΤΑΒΑΣΗ
    setrgbcolor(dbaspro);
    rectangle (caxt+20,cayb+5,caxb-20,inpyearyb+5);
    if (keyb_gr) strcpy(str1024,"Α Ν Α Ζ Η Τ Η Σ Η");
    else strcpy(str1024,"GO TO");
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,caxt+20,cayb+7,caxb-20,cayb+32,redchxr,olobkxr);
    if (keyb_gr) strcpy(str1024,"ΕΤΟΣ      ΜΗΝΑΣ  ΗΜΕΡΑ");
    else strcpy(str1024,"YEAR      MONTH  DAY");
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,caxt+6,cayb+33,caxb-6,cayb+58,olochxr,olobkxr);
    line (inpyearxt+10,inpyearyt-12,inpdayxb+13,inpyearyt-12);
    line (inpyearxt+10,inpyearyt-11,inpdayxb+13,inpyearyt-11);
    setrgbcolor(dbaspro);
    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
    
    
    // ΠΡΟΣΘΑΦΑΙΡΕΣΗ
    setrgbcolor(dbaspro);
    rectangle (caxt+20,inpyearyb+8,caxb-20,adddaysyb+5);
    if (keyb_gr) strcpy(str1024,"ΠΡΟΣΘΑΦΑΙΡΕΣΗ ΗΜΕΡΩΝ");
    else strcpy(str1024,"ADD-SUBTRACT DAYS");
    normtext_tomy(str1024,0);
    _outmystr_center_col(6,str1024,caxt+6,inpyearyb+10,caxb-6,inpyearyb+35,redchxr,olobkxr);
    setrgbcolor(dbaspro);
    rectangle (adddaysxt,adddaysyt,adddaysxb,adddaysyb);
    
    // ΜΗΝΕΣ
    mhnxt=caxb+10;
    mhnxb=mhnxt+100;
    for (f=1; f<13 ; f++) {
        normtext_tomy (month[f],0);
        mhnyt[f]=mhnyb[f-1]+4;
        mhnyb[f] = mhnyt[f]+26;
        setrgbcolor(dbaspro);
        rectangle (mhnxt,mhnyt[f],mhnxb,mhnyb[f]);
        if (f!=umonth) _outmystr_center_col(6,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],olochxr,olobkxr);
        else {
            _bareacls(mhnxt+1,mhnyt[f]+1,mhnxb-1,mhnyb[f]-1,bkxrepi);
            _outmystr_center_col(6,month[f],mhnxt,mhnyt[f]+1,mhnxb,mhnyb[f],bluechxr,bkxrepi);
        }
    }
    
    refresh();
    memfld = malloc(26);
    if(!memfld) goto FYGE;
    flddate=memfld;
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/hand_17.ico");
    mem_arrs=icontomem(file_1,255);
    if (mem_arrs==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_right.ico");
    mem_ri = icontomem (file_1,255);
    if (!mem_ri) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_left.ico");
    mem_le = icontomem (file_1,255);
    if (!mem_le) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // Ένα "ν" δίπλα στην δοθείσα ημερομηνία !
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Search_30.ico");
    mem_ok= icontomem (file_1,255);
    if (mem_ok==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // YES !!! Περνάει την ημερομηνία
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Yel_ok_39.ico");
    mem_yes= icontomem (file_1,255);
    if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_36.ico");
    mem_akyro = icontomem (file_1,255);
    if (!mem_akyro) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/sync_35.ico");
    mem_sync = icontomem (file_1,255);
    if (!mem_sync) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/Info_25.ico");
    mem_flgr=icontomem(file_1,255);
    if (!mem_flgr) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // ΕΙΚΟΝΙΔΙΑ
    _puticon(movext,moveyt,mem_arrs,255);
    _puticon(leyearxt,leyearyt,mem_le,255);
    _puticon(ledayxt,ledayyt,mem_le,255);
    _puticon(riyearxt,riyearyt,mem_ri,255);
    _puticon(ridayxt,ridayyt,mem_ri,255);
    _puticon(putokxt,putokyt,mem_ok,255);
    _puticon(addokxt,addokyt,mem_ok,255);
    _puticon(yesxt,yesyt,mem_yes,255);
    _puticon(akyroxt,akyroyt,mem_akyro,255);
    if (arped<0) i=0;
    else {
        keimk=memk[arped];
        i = (keimk[0]!=255) ? 1 : 0 ;
    }
    if (i) {syncyes=1; _puticon(syncxt,syncyt,mem_sync,255);}
    
    _puticon(flaggrxt,flaggryt,mem_flgr,255);
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_DISABLE);
    d=0;

    do {

        if (!SDL_PollEvent(&sdlev)) continue;

        switch (sdlev.type) {
            
            case SDL_MOUSEMOTION:
                
                while ( (SDL_PollEvent(&sdlev)) && (sdlev.type==SDL_MOUSEMOTION) ) continue ;    
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx<info.left || my<info.top) continue ;
        
                if (mx>caxt && mx<caxb && my>cayt && my<cayb) { // into Panel
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                        refresh();
                        promonbox=monbox=-1;
                    }
                    else if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
    
                    if (!panel) {
                        panel=1;
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);
                        refresh();
                    }
                    if (my<cy[1]) box=-1;
                    else {
                    dx=(mx-caxt)/60; dy=(my-cy[1])/25;
                    box=(dy*7)+dx+1;}
                    
                    if (box==probox) continue ;
                    if (!specmonth){
                        if (probox!=-1) {
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            if (probox!=uday) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            refresh();
                        }
                        if (box>mo[umonth] || box==-1) {box=probox=-1;continue;}
                        if (box!=uday) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+59,cy[dy+1]+24);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+58,cy[dy+1]+23);
                        refresh();
                        probox=box;
                        continue;
                    }
                    else { // specmonth=1 - Okt 1582

                        if (probox!=-1) {
                            
                            a=(probox/7)+1 ; b=probox%7 ;
                            if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                            c=(probox<5) ? 0 : 4 ;
                            
                            if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);    
                            }
                            
                            refresh();
                        }
                        if (box>4 && box<19) {box=probox=-1;continue;}
                        if (box==-1) {box=probox=-1;continue;}
                        c=(box<5) ? 0 : 4 ;
                        if (box!=uday+c) setrgbcolor(dbyel); else setrgbcolor(dbblack);
                        rectangle (cx[dx+1]+1,cy[dy+1]+1,cx[dx+1]+59,cy[dy+1]+24);
                        rectangle (cx[dx+1]+2,cy[dy+1]+2,cx[dx+1]+58,cy[dy+1]+23);
                        refresh();
                        probox=box;
                        
                    }
                    continue ;
                }
                
                if (panel) {
                    panel=0;
                    setrgbcolor(dbaspro);
                    rectangle (caxt,cayt,caxb,cayb);
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=-1) {
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        if (probox!=uday+c) {
                            setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        }
                        else {
                            setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                            rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                            rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        }
                        box=probox=-1;
                    }
                    refresh();
                }
                
                if (mx>mhnxt && mx<mhnxb && my>mhnyt[1] && my<mhnyb[12]) { // into 12 months
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpyear) {
                        inpyear=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                        refresh();
                    }
                    else if (inpmonth) {
                        inpmonth=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                        refresh();
                    }
                    else if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    monbox=((my-mhnyt[1])/30) + 1;
                    if (monbox>12) monbox=12;
                    if (promonbox==monbox) continue ;
                    if (promonbox!=-1) {
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                        line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    }
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[monbox],mhnxb,mhnyb[monbox]);
                    line(mhnxt-1,mhnyt[monbox]+1,mhnxt-1,mhnyb[monbox]+1);
                    line(mhnxt-1,mhnyb[monbox]+1,mhnxb,mhnyb[monbox]+1);
                    promonbox=monbox;
                    refresh();
                    continue;
                }
                
                if (promonbox!=-1) {
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                    line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                    refresh();
                    promonbox=monbox=-1;
                }                
                

                if (mx>inpyearxt && mx<inpyearxb && my>inpyearyt && my<inpyearyb) { // into inpyear
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                else if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                else if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (inpyear) continue;
                    inpyear=1;
                    setrgbcolor(dbmag);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpyear) {
                    inpyear=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpmonthxt && mx<inpmonthxb && my>inpmonthyt && my<inpmonthyb) { // into inmonth
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (inpday) {
                        inpday=0;
                        setrgbcolor(dbaspro);
                        rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                        refresh();
                    }
                    else if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (inpmonth) continue;
                    inpmonth=1;
                    setrgbcolor(dbmag);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpmonth) {
                    inpmonth=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                    refresh();
                }
                
                
                if (mx>inpdayxt && mx<inpdayxb && my>inpdayyt && my<inpdayyb) { // into inpday
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (adddays) {
                        adddays=0;
                        setrgbcolor(dbaspro);
                        rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                        refresh();
                    }
                    else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (inpday) continue;
                    inpday=1;
                    setrgbcolor(dbmag);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (inpday) {
                    inpday=0;
                    setrgbcolor(dbaspro);
                    rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                    refresh();
                }
                
                
                if (mx>adddaysxt && mx<adddaysxb && my>adddaysyt && my<adddaysyb) { // into adddays
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (adddays) continue;
                    adddays=1;
                    setrgbcolor(dbmag);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                    continue ;
                }
                
                if (adddays) {
                    adddays=0;
                    setrgbcolor(dbaspro);
                    rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                    refresh();
                }
                

                if (mx>movext && mx<movext+17 && my>moveyt && my<moveyt+17) { // move window
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                    else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (marrs) continue ;
                    marrs=1;
                    putNOTicon(movext,moveyt,mem_arrs);
                    if (keyb_gr) show_help (" Αλλαγή Θέσης Παραθύρου ",movext,moveyt+18,&hdhlpxt , &hdhlpyt);
                    else show_help (" Change Window Position ",movext,moveyt+20,&hdhlpxt , &hdhlpyt);
                    continue ;
                }
        
                if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt); }


                if (mx>leyearxt && mx<leyearxt+26 && my>leyearyt && my<leyearyt+26) { // Left Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                    else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (leyear) continue ;
                    leyear=1;
                    putNOTicon(leyearxt,leyearyt,mem_le);
                    continue ;
                }
        
                if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
                
                
                if (mx>riyearxt && mx<riyearxt+26 && my>riyearyt && my<riyearyt+26) { // Right Year
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                    else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                    
                    if (riyear) continue ;
                    riyear=1;
                    putNOTicon(riyearxt,riyearyt,mem_ri);
                    continue ;
                }
        
                if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
                
                
                if (mx>ledayxt && mx<ledayxt+26 && my>ledayyt && my<ledayyt+26) { // Left day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                    else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (leday) continue ;
                    leday=1;
                    putNOTicon(ledayxt,ledayyt,mem_le);
                    continue ;
                }
        
                if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
                
                
                if (mx>ridayxt && mx<ridayxt+26 && my>ridayyt && my<ridayyt+26) { // Right day
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                    else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (riday) continue ;
                    riday=1;
                    putNOTicon(ridayxt,ridayyt,mem_ri);
                    continue ;
                }
        
                if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
                
                
                if (mx>putokxt && mx<putokxt+30 && my>putokyt && my<putokyt+30) { // Put OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                    else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (putok) continue ;
                    putok=1;
                    putNOTicon(putokxt,putokyt,mem_ok);
                    continue ;
                }
        
                if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
                
                
                if (mx>addokxt && mx<addokxt+30 && my>addokyt && my<addokyt+30) { // Add OK !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                    else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (addok) continue ;
                    addok=1;
                    putNOTicon(addokxt,addokyt,mem_ok);
                    continue ;
                }
        
                if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
                
                
                if (mx>yesxt && mx<yesxt+54 && my>yesyt && my<yesyt+36) { // YESSSSSSS !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                    else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (finyes) continue ;
                    if (arped>=0) {
                        mytext_tonorm (ptr_pedio[arped]->finame,file_2,60);
                        if (keyb_gr) sprintf(str1024," Καταχώρηση ημερομηνίας στο πεδίο [%s] ! " ,file_2);
                        else sprintf(str1024," Record Date to the data field [%s] ! " ,file_2);
                        show_help (str1024,yesxt,yesyt+37, &hdhlpxt , &hdhlpyt) ;
                    }
                        
                    finyes=1;
                    putNOTicon(yesxt,yesyt,mem_yes);
                    continue ;
                }
        
                if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
                
                
                if (mx>akyroxt && mx<akyroxt+36 && my>akyroyt && my<akyroyt+36) { // akyroooo !
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                        SDL_SetCursor(cursor);
                        ektos=0;
                    }
                    
                    if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                    else if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                            line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                            line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                            line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                            line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                            line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                    else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                        
                    if (akyro) continue ;
                    akyro=1;
                    putNOTicon(akyroxt,akyroyt,mem_akyro);
                    continue ;
                }
        
                if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
                
                
                if (syncyes) {
                    if (mx>syncxt && mx<syncxt+35 && my>syncyt && my<syncyt+35) { // Sync !
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if (pronow) {
                            pronow=0; 
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                            line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                            line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                            line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                            line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                            line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                            refresh(); 
                        }
                        else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                            
                        if (sync) continue ;
                        sync=1;
                        putNOTicon(syncxt,syncyt,mem_sync);
                        if (keyb_gr) show_help(" Λήψη Ημερομηνίας από το Πεδίο της Βάσης δεδομένων ", syncxt,syncyt+35, &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Get Date from the DB Field ", syncxt,syncyt+35, &hdhlpxt , &hdhlpyt) ;
                        continue ;
                    }
            
                    if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
                }
                
                
                if (!nowon) {
                    if (mx>recshmxt && mx<recshmxb && my>recshmyt && my<recshmyb) { // SHMERA !
                        
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
                                            
                        if (pronow) continue ;
                        pronow=1;
                        setrgbcolor(dbred);
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh();
                        continue ;
                    }
            
                    if (pronow) {
                        pronow=0; 
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                    }
                }
                
                if (flaggryes) {
                    if (mx>flaggrxt && mx<flaggrxt+25 && my>flaggryt && my<flaggryt+26) {
                        if (ektos) {
                            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                            SDL_SetCursor(cursor);
                            ektos=0;
                        }
                        
                        if (flaggr) continue;
                        flaggr=1;
                        putNOTicon (flaggrxt,flaggryt,mem_flgr);
                        if (keyb_gr) show_help(" Επέκταση Ιουλιανού Ημερολογίου από Οκτ 1582 μέχρι το 1923.. ", flaggrxt,flaggryt+28, &hdhlpxt , &hdhlpyt) ;
                        else show_help(" Extension of the Julian calendar from Oct 1582 to year 1923... ", flaggrxt,flaggryt+28, &hdhlpxt , &hdhlpyt) ;
                        continue;
                    }
                    
                    if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255); hide_help(hdhlpxt , hdhlpyt);}
                }
                
                
            // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
                if (!ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                ektos=1;
                }
                
            break ; // Πέρας mousemotion
            
            case SDL_MOUSEBUTTONDOWN:
                
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                if (ektos) continue ;
                
                if (probox!=-1) {
LIKE_PROBOX:
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    if (specmonth) {c=(uday<5) ? 0 : 4 ;}
                    else c=0;
                    if (probox!=uday+c) {
                        a=((uday+c)/7)+1 ; b=(uday+c)%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24,genbkxr);
                        if (b==bluedy) _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,bluechxr,genbkxr);
                        else if (b==reddy) _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,redchxr,genbkxr);
                        else _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,genchxr,genbkxr);
                        
                        if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                        else c=0;
                        uday=probox-c;
                        //specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        a=(probox/7)+1 ; b=probox%7 ;
                        if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                        _bareacls (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24,bkxrepi);
                        if (b==bluedy) _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,bluechxr,bkxrepi);
                        else if (b==reddy) _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,redchxr,bkxrepi);
                        else _outmystr_center_col (6,monda[uday],cx[b],cy[a],cx[b]+59,cy[a]+25,genchxr,bkxrepi);
                       
                        setrgbcolor(dbblack);
                        rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                        rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                        
                        // Τι μέρα έχουμε στις τάδε του μήνα ;
                        unameday=startmonth;
                        for (f=2; f<=uday ; f++) {
                            unameday++;
                            if (unameday==8) unameday=1;
                        }
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        
                        if (!d) {
                        // Ξαναχρωμάτισε το panel
                        setrgbcolor(dbmag);
                        rectangle (caxt,cayt,caxb,cayb);}
                        else { probox=-1; d=0;}
                        refresh();
                        
                    }
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    continue ;
                }
                                
                if(riday){
                    

                    size=500000000;
                    
                    do{
                    if (uyear==2500) {
                        if (umonth==12 && uday==31) break ;
                    }
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==mo[umonth]) { 
                        uday=1; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        startmonth=unameday;
                        
                        // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                        _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                        setrgbcolor(dbaspro);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                        umonth++;
                        if (umonth==13) { 
                            umonth=1; 
                            uyear++;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                            
                            story.olo=0;
                            story.meros[0]= uday;
                            story.meros[1]= umonth;
                            story.mewo[1]=uyear;
                                                        
                            uolo=story.olo ;
                            
                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                            
                            if (greg) {
    
                                if (uyear%4) mo[2]=28;
                                else {
                                    if (uyear%100) mo[2]=29;
                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                    }
                            }

                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                        }
                        
                        // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                        _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                        _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                        setrgbcolor(dbmag);
                        rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                        line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                        line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        
                    }
                    else { 
                        uday++; 
                        unameday++;
                        if (unameday==8) unameday=1;
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        
                        //printf("uday = %u , umonth = %u , uyear/mewo = %u/%u \n", uday, umonth, uyear,story.mewo);
                        uolo=story.olo ;
                        if (uolo==first_xam) {
                            greg=1;
                            uday=15;
                        }
                    }
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        refresh ();
                        
                        f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        } while (!SDL_PollEvent(&sdlev) && sdlev.type!=SDL_MOUSEBUTTONUP) ;
                        continue ;
                    }
                    
                    if (pronow) {
SHMERIS :
                        pronow=0; nowon=1;d=0;
                        setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                        line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                        line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                        line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                        line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                        line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                        line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                        refresh(); 
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        unameday=diar->tm_wday+1;
                        uday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        strcpy (mera[0],mera[unameday]);
                        greg=1;
                        
                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            umonth=nowmonth;
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        if (nowyear != uyear) {
                        // ΕΤΟΣ - ΣΗΜΕΡΑ
                        
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                            sprintf (str1024,"%04u",nowyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                            if (nowyear%4) mo[2]=28;
                            else {
                                if (nowyear%100) mo[2]=29;
                                else {mo[2]=(nowyear%400) ? 28 : 29 ;}
                            }
                            uyear = nowyear ;
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        for (f=uday ; f>0 ; f--){
                            startmonth--;
                            if (!startmonth) startmonth=7;
                        }
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        
                       
                        // ΑΝΑΨΕ ΤΟ ΚΟΥΜΠΙ ΣΗΜΕΡΑ
                        
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        
                        // ΠΑΝΕΛ
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;
                        }
                        
                        refresh();
                        continue ;
                    }
                    
                if(leday){
                    size=500000000;
                    do {
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                                        
                    if (uday==1) {
                        if (umonth==1){
                            if (uyear==1) break;
                            else {
                                uyear--;
                                // ΑΛΛΑΓΗ ΕΤΟΥΣ
                                _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                                sprintf (str1024,"%04u",uyear);
                                normtext_tomy(str1024,0);
                                _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                                
                                uday=31; umonth=12;
                                
                                startmonth=unameday;
                                for (f=31 ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                                }
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                
                                uolo=story.olo ;
                                
                                greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                
                                if (greg) {

                                    if (uyear%4) mo[2]=28;
                                    else {
                                        if (uyear%100) mo[2]=29;
                                        else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                        }
                                }

                                else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[1]+1,mhnxb-1,mhnyb[1]-1,olobkxr);
                            _outmystr_center_col(6,month[1],mhnxt,mhnyt[1]+1, mhnxb, mhnyb[1],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[1],mhnxb,mhnyb[1]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[1]+1,mhnxt-1,mhnyb[1]+1);
                            line(mhnxt-1,mhnyb[1]+1,mhnxb,mhnyb[1]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗNA
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            }
                        }
                        else {
                            
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            umonth--;
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                            
                            uday=mo[umonth];
                            startmonth=unameday;
                            for (f=uday ; f>0 ; f--) {
                                startmonth--;
                                if (!startmonth) startmonth=7;
                            }
                        }
                    }
                    else { uday--; }
                    
                    unameday--;
                    if (!unameday) unameday=7;
                        
                    story.olo=0;
                    story.meros[0]= uday;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                        
                    if (uolo==last_xam) uday=4;
                                
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                    refresh ();
                    
                    f=0; while (f<size) f++;
                   if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    } while (!SDL_PollEvent(&sdlev) && sdlev.type!=SDL_MOUSEBUTTONUP) ;
                    continue ;
                }
                    
                if (promonbox!=-1) {
                    if (umonth==promonbox) continue ;
                    //nowday=uday; nowmonth=umonth; nownameday=unameday;

                    // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                    _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                    setrgbcolor(dbaspro);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    umonth = promonbox;
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                    
                    _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                    _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                    setrgbcolor(dbmag);
                    rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                    line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                    line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                }
                
                
                if (leyear) {
                    if (uyear==1) continue ;
                    size=500000000;
                    do{
                    uyear--;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    }while (uyear!=1 && !SDL_PollEvent(&sdlev) && sdlev.type!=SDL_MOUSEBUTTONUP) ;
                    continue ;
                }
                
                
                if (riyear) {
                    if (uyear==2500) continue ;
                    size=500000000;
                    do {
                    uyear++;

                    // ΑΛΛΑΓΗ ΕΤΟΥΣ
                    _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                    sprintf (str1024,"%04u",uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);

                    a = (uday>28) ? 28 : uday ;
                    story.olo=0;
                    story.meros[0]= a;
                    story.meros[1]= umonth;
                    story.mewo[1]=uyear;
                    
                    uolo=story.olo ;
                    
                    greg = (uolo>=arx_grh) ? 1 : 0 ; 
                    
                    if (greg) {

                        if (uyear%4) mo[2]=28;
                        else {
                            if (uyear%100) mo[2]=29;
                            else {mo[2]=(uyear%400) ? 28 : 29 ;}
                            }
                    }

                    else { mo[2] = (uyear%4) ? 28 : 29 ; }
                    
                    startmonth=find_dayname(uyear , umonth , 1);
                    
                    if (startmonth!=20) {
                        if (uday>mo[umonth]) uday=mo[umonth];
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    else {
                        startmonth=2;
                        if (uday>mo[umonth]) uday=mo[umonth];
                        else if (uday>4 && uday<15) uday=15;
                        unameday=startmonth;
                        for (f=2 ; f<=uday; f++) {
                        if (f>4 && f<15) continue;
                        unameday = (unameday==7) ? 1 : unameday+1 ;}
                    }
                    
                    
                    specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                    
                    // Στήλες Σαββατοκύριακου έγχρωμες 
                    a=startmonth;
                    for (f=1; f<8; f++) {
                        if (a==1) reddy=f;
                        else if (a==7) bluedy=f;
                        a++;
                        if (a==8) a=1;}
                    
                    strcpy (mera[0],mera[unameday]);
                    
                    // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                    _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                    if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                    else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                    normtext_tomy(str1024,0);
                    _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                    refresh ();
                    
                    loctim=time(NULL);
                    diar=localtime(&loctim);
                    nownameday=diar->tm_wday+1;
                    nowday= diar->tm_mday;
                    nowmonth = diar->tm_mon+1;
                    nowyear = diar->tm_year+1900;
                    
                    f=0; while (f<size) f++;
                    if (size>450000000) size-=5000000 ;
                    else if (size>350000000) size-=10000000;
                    else if (size>10000000) size-=20000000;
                    
                    if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                        if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                        // Αναβω το button "Σήμερα"
                        nowon=1;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                        refresh() ;
                        continue ;
                    }
                    else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                        if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                        // Το σβήνω....
                        nowon=0;
                        _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                        if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                        else strcpy(str1024,"TODAY");
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                        refresh() ;
                        continue ;
                    }
                    
                    } while (uyear!=2500 && !SDL_PollEvent(&sdlev) && sdlev.type!=SDL_MOUSEBUTTONUP) ;
                    continue;
                }
                
                if (inpyear) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    i=num_input(year_t,inpyearxt+20,inpyearyt+1,inpyearxb-1,inpyearyb-1,4,0);
                    
                    prosyear=(unsigned short int) convert_str (4,year_t);
                    if (!prosyear) prosyear=1;
                    else if (prosyear>2500) prosyear=2500; 
                    
                    sprintf (str1024,"%04u",prosyear);
                    sprintf (year_t,"%u",prosyear);
                    normtext_tomy(str1024,0); normtext_tomy(year_t,0);
                    _bareacls(inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpyearxt+1,inpyearyt+1,inpyearxb-1,inpyearyb,olochxr,olobkxr);
                    refresh();
                    

                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpyearxt,inpyearyt,inpyearxb,inpyearyb);
                        setrgbcolor (dbmag);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        inpmonth=1; inpyear=0;
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        refresh();
                        i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                        
                        prosmonth=(unsigned short int) convert_str (2,month_t);
                        if (!prosmonth) prosmonth=1;
                        else if (prosmonth>12) prosmonth=12; 
                        
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                        refresh();
                        
                    }
                    else continue ;
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, 
                                             olochxr,olobkxr);
                        refresh();
                        
                    }
                    
                    continue;
                }
                
                
                if (inpmonth) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    i=num_input(month_t,inpmonthxt+10,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,2,0);
                    
                    prosmonth=(unsigned short int) convert_str (2,month_t);
                    if (!prosmonth) prosmonth=1;
                    else if (prosmonth>12) prosmonth=12; 
                    sprintf (month_t,"%u",prosmonth);    
                    sprintf (str1024,"%02u",prosmonth);
                    normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                    _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    refresh();
                
                    
                    if (i==-9) {
                        setrgbcolor (dbaspro);
                        rectangle (inpmonthxt,inpmonthyt,inpmonthxb,inpmonthyb);
                        setrgbcolor (dbmag);
                        rectangle (inpdayxt,inpdayyt,inpdayxb,inpdayyb);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        refresh();
                        inpmonth=0; inpday=1;
                        if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                        
                        i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                        
                        prosday=(unsigned short int) convert_str (2,day_t);
                        if (!prosday) prosday=1; 
                        else if (prosday>b) prosday=b; 
                        sprintf (day_t,"%u",prosday);
                        sprintf (str1024,"%02u",prosday);
                        normtext_tomy(str1024,0);
                        normtext_tomy(day_t,0);
                        _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                        refresh();
                    }
                    
                    continue;
                }
                
                
                if (inpday) {
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = olochxr[f];
                        bkxr[f] = olobkxr[f];
                        slxr[f] = bkxrepi[f];
                    }
                    gouv=myfont[6];
                    if (!prosmonth) {
                        prosmonth=1;
                        sprintf (str1024,"%02u",prosmonth);
                        sprintf (month_t,"%u",prosmonth);
                        normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                        _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                    }
                    if (prosmonth==2) b=29; else b=mo[prosmonth] ;
                    bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    i=num_input(day_t,inpdayxt+10,inpdayyt+1,inpdayxb-1,inpdayyb-1,2,0);
                    
                    prosday=(unsigned short int) convert_str (2,day_t);
                    if (!prosday) prosday=1; 
                    else if (prosday>b) prosday=b; 
                        
                    sprintf (str1024,"%02u",prosday);
                    sprintf (day_t,"%u",prosday);
                    normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                    _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                    _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                    refresh();
                    continue ;
                }
                    
                    if (putok) {
                        
                        if (year_t[0]==255) continue;
                        if (prosyear==uyear && prosmonth==umonth && prosday==uday) continue ;
                        if (month_t[0]==255) {
                            prosmonth=1;
                            sprintf (str1024,"%02u",prosmonth);
                            sprintf (month_t,"%u",prosmonth);
                            normtext_tomy(str1024,0); normtext_tomy(month_t,0);
                            _bareacls(inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpmonthxt+1,inpmonthyt+1,inpmonthxb-1,inpmonthyb,olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (day_t[0]==255) {
                            prosday=1;
                            sprintf (str1024,"%02u",prosday); sprintf (day_t,"%u",prosday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        a = (prosday>28) ? 28 : prosday ;
                        story.olo=0;
                        story.meros[0]= a;
                        story.meros[1]= prosmonth;
                        story.mewo[1]=prosyear;
                        uolo=story.olo ;

                        greg = (uolo>=arx_grh) ? 1 : 0 ;
                        
                        uday=greday=prosday;
                        
                        if (greg) {

                            if (prosyear%4) b=28;
                            else {
                                if (prosyear%100) b=29;
                                else {b=(prosyear%400) ? 28 : 29 ;}
                                }
                        }

                        else { b = (prosyear%4) ? 28 : 29 ; }
                        
                        
                        if (prosmonth==2) {
                            if (prosday>b) {uday=b ;}
                        }
                        else if (prosday>mo[prosmonth]) uday=mo[prosmonth] ;
                        
                        story.olo=0;
                        story.meros[0]=greday;
                        story.meros[1]=prosmonth;
                        story.mewo[1]=prosyear;
                         if (story.olo<first_xam || story.olo>gre_xam_t) {greday=40;}
                        
                        
                        mo[2]=b;
                        
                        if (uday!=prosday) {
                            prosday=uday;
                            sprintf (str1024,"%02u",uday);
                            sprintf (day_t,"%u",uday);
                            normtext_tomy(str1024,0); normtext_tomy(day_t,0);
                            _bareacls(inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  inpdayxt+1,inpdayyt+1,inpdayxb-1,inpdayyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                                                                        
                        if (prosyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=prosyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                        }

                        if (umonth!=prosmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=prosmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=find_dayname(uyear , umonth , 1);
                        
                        if (startmonth!=20) {
                            if (uday>mo[umonth]) uday=mo[umonth];
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        else {
                            startmonth=2;
                            if (uday>mo[umonth]) uday=mo[umonth];
                            else if (uday>4 && uday<15) {
                                uday=15;
                            }
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            if (f>4 && f<15) continue;
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                        continue ;
                        
                    }
                    
                    if (adddays) {
                        
                        for (f=0 ; f<3 ; f++) {
                            chxr[f] = olochxr[f];
                            bkxr[f] = olobkxr[f];
                            slxr[f] = bkxrepi[f];
                        }
                        
                        gouv=myfont[6];
                        bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        num_input(addday_t,adddaysxt+10,adddaysyt+1,adddaysxb-1,adddaysyb-1,7,2);
                        prosadd=(int) convert_str (7,addday_t);
                        if (prosadd<0) {
                            if (prosadd<-913107) prosadd=-913107;
                            sprintf (str1024,"%07d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        } 
                        else { 
                            if (prosadd>913107) prosadd=913107;
                            sprintf (str1024,"%06d",prosadd);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                        }
                        
                        normtext_tomy(str1024,0);
                        _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                        _outmystr_center_col(6, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                        refresh();
                        continue ;
                    }
                    
                    if (addok) {
                        
                        if (!prosadd) continue ;
                            
                        story.olo=0;
                        story.meros[0]= uday;
                        story.meros[1]= umonth;
                        story.mewo[1]=uyear;
                        uolo=story.olo ;
                        
                        nowmonth = umonth;
                        nowyear = uyear;
                        
                        if (prosadd>0) { // ΠΡΟΣΘΕΣΗ
                            if (uolo == tel_diary) continue ;
                            i=prosadd;
                            while(i) {
                                unameday = (unameday==7) ? 1 : unameday+1;
                                uday = (uday == mo[umonth]) ? 1 : uday+1;
                                if (uday==1) {
                                    umonth=(umonth==12) ? 1 : umonth+1;
                                    if (umonth==1) {
                                        uyear++;
                                        
                                        story.olo=0;
                                        story.meros[0]= uday;
                                        story.meros[1]= umonth;
                                        story.mewo[1]=uyear;
                                        uolo=story.olo ;
                                        
                                        greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                        
                                        if (greg) {

                                            if (uyear%4) mo[2]=28;
                                            else {
                                                if (uyear%100) mo[2]=29;
                                                else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                }
                                        }

                                        else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                        i--;
                                        continue;
                                    }
                                }
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==first_xam) uday=15;
                                else if (uolo==tel_diary) {i--;break;}
                                i--;
                            }
                        }
                        else { // ΑΦΑΙΡΕΣΗ
                            if (uolo == arx_diary) continue ;
                            i=abs(prosadd);
                            while (i) {
                                unameday = (unameday==1) ? 7 : unameday-1 ;
                                if (uday==1){
                                    if (umonth==1) {
                                        if (uyear==1) {unameday = (unameday==7) ? 1 : unameday+1; break;}
                                        else {
                                            uyear--; uday=31; umonth=12;
                                            story.olo=0;
                                            story.meros[0]= uday;
                                            story.meros[1]= umonth;
                                            story.mewo[1]=uyear;
                                            uolo=story.olo ;
                                            
                                            greg = (uolo>=arx_grh) ? 1 : 0 ; 
                                            
                                            if (greg) {

                                                if (uyear%4) mo[2]=28;
                                                else {
                                                    if (uyear%100) mo[2]=29;
                                                    else {mo[2]=(uyear%400) ? 28 : 29 ;}
                                                    }
                                            }

                                            else { mo[2] = (uyear%4) ? 28 : 29 ; }
                                            i--;
                                            continue ;
                                        }
                                    } else { umonth--; uday=mo[umonth]; i--; continue ;}
                                }
                                else { uday--;}
                                
                                story.olo=0;
                                story.meros[0]= uday;
                                story.meros[1]= umonth;
                                story.mewo[1]=uyear;
                                uolo=story.olo ;
                                
                                if (uolo==last_xam) uday=4;
                                i--;
                                
                            }
                        }
                        
                        if (i) {
                            if (prosadd<0) {
                                prosadd=-i+1;
                                sprintf (str1024,"%07d",prosadd);
                            }
                            else {
                            prosadd=i-1;
                            sprintf (str1024,"%06d",prosadd);}
                            normtext_tomy(str1024,0);
                            sprintf (addday_t,"%d",prosadd);
                            normtext_tomy(addday_t,0);
                            _bareacls(adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb-1,olobkxr);
                            _outmystr_center_col(6, str1024,  adddaysxt+1,adddaysyt+1,adddaysxb-1,adddaysyb, olochxr,olobkxr);
                            refresh();
                        }
                        
                        if (nowyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                        }

                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[nowmonth]+1,mhnxb-1,mhnyb[nowmonth]-1,olobkxr);
                            _outmystr_center_col(6,month[nowmonth],mhnxt,mhnyt[nowmonth]+1, mhnxb, mhnyb[nowmonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[nowmonth],mhnxb,mhnyb[nowmonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[nowmonth]+1,mhnxt-1,mhnyb[nowmonth]+1);
                            line(mhnxt-1,mhnyb[nowmonth]+1,mhnxb,mhnyb[nowmonth]+1);

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        startmonth=unameday+1;
                        if (startmonth==8) startmonth=1;
                        
                        for (f=uday ; f>0 ; f--) {
                            startmonth=(startmonth==1) ? 7 : startmonth-1 ;
                        }
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                            refresh() ;
                            continue ;
                        }
                            
                        continue ;    
                    }
                    
                    if (sync){
                        
                        keimk=memk[arped];
                        i=0;
                        while (keimk[i]!=255) i++;
                        
                        syncyear_t[0]=keimk[i-4];
                        syncyear_t[1]=keimk[i-3];
                        syncyear_t[2]=keimk[i-2];
                        syncyear_t[3]=keimk[i-1];
                        syncyear_t[4]=255;
                        nowyear=(unsigned short int) convert_str (4,syncyear_t);
                        
                        syncmonth_t[0]=keimk[i-7];
                        syncmonth_t[1]=keimk[i-6];
                        syncmonth_t[2]=255;
                        nowmonth=(unsigned short int) convert_str (2,syncmonth_t);
                        
                        syncday_t[0]=keimk[i-10];
                        syncday_t[1]=keimk[i-9];
                        syncday_t[2]=255;
                        nowday=(unsigned short int) convert_str (2,syncday_t);
                        
                        if (!keyb_gr) {a=nowday; nowday=nowmonth; nowmonth=a;}
                        
                        mytext_tonorm (keimk,str1024,50);
                        str1024[50]='\0';
                        //printf("%s\n",str1024);
                        
                        nownameday=0;
                        for (f=1;f<8;f++) {
                            ptr_char=strstr(str1024,mera[f]);
                            if (ptr_char!=NULL) { nownameday=f; break; }
                        }
                        if (!nownameday) { // Ασυμβατότητα γλωσσών !!!!!!!!!!!!!!!!
                            if (keyb_gr) {
                            dx=alert (0,"Διαφορετική Γλώσσα Εισαγωγής!\nΝα γίνει αντιμετάθεση Ημέρας-Ημερομηνίας ;",0);}
                            else {dx=alert (0,"Different Input Language!\nDo you agree for Day-Date transposition?",0);}
                            if (!dx || dx==2) continue;
                            a=nowday; nowday=nowmonth; nowmonth=a;
                        }
                        
                        if (nowyear==uyear && nowmonth==umonth && nowday==uday) continue ;
                        if (nowyear<1 || nowyear>2500 || nowmonth<1 || nowmonth>12 || nowday<1 || nowday>31) {
                            if (keyb_gr) information (0,"Η καταχώρηση είναι λανθασμένη!",0);
                            else information (0,"Bad Date Entry!",0);
                            continue;
                        }
                        
                        a = (nowday>28) ? 28 : nowday ;
                        story.olo=0;
                        story.meros[0]= a;
                        story.meros[1]= nowmonth;
                        story.mewo[1]=nowyear;
                        uolo=story.olo ;

                        a=0;
                        
                        greg = (uolo>=arx_grh) ? 1 : 0 ;
                        
                        
                        if (greg) {

                            if (nowyear%4) b=28;
                            else {
                                if (nowyear%100) b=29;
                                else {b=(nowyear%400) ? 28 : 29 ;}
                                }
                        }

                        else { b = (nowyear%4) ? 28 : 29 ; }
                        
                        if (nowmonth==2 && nowday>b) a=1;
                        else if (nowday>mo[nowmonth]) a=1;
                        if (a) {
                            if (keyb_gr) information (0,"Η καταχώρηση είναι λανθασμένη!",0);
                            else information (0,"Bad Date Entry!",0);
                            continue;
                        }
                        
                        mo[2]=b;
                        
                        if (nowyear!=uyear) {
                            // ΑΛΛΑΓΗ ΕΤΟΥΣ
                            uyear=nowyear;
                            _bareacls (recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, genbkxr);
                            sprintf (str1024,"%04u",uyear);
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recyearxt+1,recyearyt+1,recyearxb-1,recyearyb-1, black , genbkxr);
                        }

                        if (umonth!=nowmonth) {
                            // ΚΑΘΑΡΙΣΜΑ ΠΡΟΗΓΟΥΜΕΝΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,olobkxr);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1, mhnxb, mhnyb[umonth],olochxr,olobkxr);
                            setrgbcolor(dbaspro);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);

                            umonth=nowmonth;

                            // ΕΜΦΑΝΙΣΗ ΝΕΟΥ ΜΗΝΑ
                            _bareacls(mhnxt+1,mhnyt[umonth]+1,mhnxb-1,mhnyb[umonth]-1,bkxrepi);
                            _outmystr_center_col(6,month[umonth],mhnxt,mhnyt[umonth]+1,mhnxb,mhnyb[umonth], bluechxr, bkxrepi);
                            setrgbcolor(dbmag);
                            rectangle (mhnxt,mhnyt[umonth],mhnxb,mhnyb[umonth]);
                            line(mhnxt-1,mhnyt[umonth]+1,mhnxt-1,mhnyb[umonth]+1);
                            line(mhnxt-1,mhnyb[umonth]+1,mhnxb,mhnyb[umonth]+1);
                        }
                        
                        uday=nowday ;
                        
                        startmonth=find_dayname(uyear , umonth , 1);
                        
                        if (startmonth!=20) {
                            if (uday>mo[umonth]) uday=mo[umonth];
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        else {
                            startmonth=2;
                            if (uday>mo[umonth]) uday=mo[umonth];
                            else if (uday>4 && uday<15) {
                                uday=15;
                            }
                            unameday=startmonth;
                            for (f=2 ; f<=uday; f++) {
                            if (f>4 && f<15) continue;
                            unameday = (unameday==7) ? 1 : unameday+1 ;}
                        }
                        
                        
                        specmonth=_show_month (caxt, cayt, uyear,umonth,uday,startmonth);
                        
                        if ( (nownameday) && (unameday != nownameday) ) {
                            if (keyb_gr) information (0,"Προέκυψε διαφορετική ημέρα..\nαπό την αρχικά καταχωρημένη",0);
                            else information (0,"The dayname is different..\nfrom the initial entered one!",0);
                        }
                        // Στήλες Σαββατοκύριακου έγχρωμες 
                        a=startmonth;
                        for (f=1; f<8; f++) {
                            if (a==1) reddy=f;
                            else if (a==7) bluedy=f;
                            a++;
                            if (a==8) a=1;}
                        
                        strcpy (mera[0],mera[unameday]);
                        
                        // ΓΡΑΨΕ ΠΛΗΡΗ ΗΜΕΡΟΜΗΝΙΑ
                        _bareacls (recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb-1, bkxrsel);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,0);
                        _outmystr_center_col(7,str1024,recfullxt+1 , recfullyt+1 , recfullxb-1 , recfullyb, chxrsel , bkxrsel);
                        refresh ();
                        
                        loctim=time(NULL);
                        diar=localtime(&loctim);
                        nownameday=diar->tm_wday+1;
                        nowday= diar->tm_mday;
                        nowmonth = diar->tm_mon+1;
                        nowyear = diar->tm_year+1900;
                        
                        if (uday==nowday && uyear==nowyear && umonth==nowmonth) { // είναι η σημερινή ;
                            if (nowon) continue; // Αν το "σήμερα" είναι αναμμένο φύγε.
                            // Αναβω το button "Σήμερα"
                            nowon=1;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,bkxrepi);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, redchxr , bkxrepi);
                            refresh() ;
                            continue ;
                        }
                        else { // Η επιλεγμένη δεν είναι η σημερινή ημέρα !!
                            if (!nowon) continue; // Αν το "σήμερα" είναι σβηστό φύγε !
                            // Το σβήνω....
                            nowon=0;
                            _bareacls(recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1,olobkxr);
                            if (keyb_gr) strcpy (str1024,"ΣΗΜΕΡΑ");
                            else strcpy(str1024,"TODAY");
                            normtext_tomy(str1024,0);
                            _outmystr_center_col(6,str1024,recshmxt+1,recshmyt+1,recshmxb-1,recshmyb-1, gkrichxr , olobkxr);
                            refresh() ;
                            continue ;
                        }

                        continue;
                    }
                    
                    if (flaggr) {
                        
                        story.olo=0;
                        story.meros[0]=uday;
                        story.meros[1]=umonth;
                        story.mewo[1]=uyear;
                        if (story.olo<first_xam || story.olo>gre_xam_t) {greday=40; continue ;}
                        if (keyb_gr && story.olo>=gre_xam_1 && story.olo<=gre_xam_t) { information (0,"Η ημερομηνία αυτή δεν υπήρξε,\nλόγω εφαρμογής του Γρηγοριανού ημερολογίου!",0); greday=40;continue;}
                        if (greday==40) greday=uday; 
                        gremonth=umonth; 
                        greyear=uyear;
                        
                        b = (greyear%4) ? 28 : 29 ;
                        if (gremonth==2 && greday>b) greday=b;
                        else if (greday>mo[gremonth]) greday=mo[gremonth];
                        
                        nowyear=1582 ; 
                        // 1/1/1582 ήταν Δευτέρα !
                        //staday=2; 
                                
                        dx=1;
                        a = mo[1]+mo[3]+mo[4]+mo[5]+mo[6]+mo[7]+mo[8]+mo[9]+mo[10]+mo[11]+mo[12] ;

                        while(greyear>nowyear) {
                            
                            b = (nowyear%4) ? 28 : 29 ;
                            
                            dx=dx+a+b;
                            nowyear++;
                        }

                        b = (nowyear%4) ? 28 : 29 ;
                            
                        for (f=1 ; f<gremonth ; f++) {
                                dx = (f==2) ? dx+b : dx+mo[f] ;
                            }

                        for(f=1; f<=greday ; f++) dx++; 

                        grenameday = dx%7;
                        if (!grenameday) grenameday=7;
                        
                        if (keyb_gr) sprintf (str1024,"Ελλάδα, %02u-%02u-%04u ημέρα %s" , greday,gremonth,greyear,mera[grenameday]);
                        else sprintf(str1024,"(Julian) %02u-%02u-%04u : %s" , gremonth,greday,greyear,mera[grenameday]);
                        normtext_tomy(str1024,0);
                        mytext_toclipboard (str1024);
                        
                        if (keyb_gr) {
                        sprintf (str1024,"ΆΤΥΠΗ ΑΝΑΦΟΡΑ !!\nΕλλάδα, %02u-%02u-%04u ..",greday,gremonth,greyear);
                        sprintf (file_2,"..ήταν ημέρα %s !\nΤυπικά..δεν χρησιμοιείται!\nΔεν καταχωρείται! Γράφτηκε στο clipboard.",mera[grenameday]);}
                        else {
                            sprintf (str1024,"ATYPICAL REPORT !!\n%02u-%02u-%04u ..",gremonth,greday,greyear);
                            sprintf (file_2,"..was %s !\nTypically..it is not usable!\nCan't save! Just copied to  clipboard.",mera[grenameday]);
                        }
                        information (0,str1024,file_2);
                        
                        greday=40;
                        continue ;
                    }
                    
                    if (marrs) {
                        size=imagesize(0,0,539,499);
                        mem_move=malloc(size);
                        if (!mem_move) {information (2-keyb_gr,0,0);continue;}
                        getimage(xt,yt,xt+539,yt+499,mem_move);
                        xt1=xt ; yt1=yt ;
                        dx=change_pos(&xt1, &yt1, &xb , &yb);
                        if (dx<0) { free(mem_move); xb=xt+539; yb=yt+499; continue ; }
                        putimage(xt,yt,mem0,0);
                        while (((yt1+499)>=info.bottom-50)) yt1--;
                        xt=xt1; yt=yt1;
                        xb=xt+539; yb=yt+499;
                        getimage(xt,yt,xb,yb,mem0);
                        putimage(xt,yt,mem_move,0);
                        free(mem_move);

                            // ΣΥΝΤΕΤΑΓΜΕΝΕΣ
                            recfullxt = xt+15 ;
                            leyearxt=xt+30;
                            ledayxt=xt+50;
                            movext=caxt=xt+6 ;
                            inpyearxt=xt+93;
                            moveyt=yt+4; // Επικεφαλίδα στο yt+4 επίσης!
                            recfullyt=yt+33;
                            recfullyb=recfullyt+28;
                            leyearyt=riyearyt=recyearyt=mhnyb[0]=recfullyb+8;
                            mhnyb[0]-=4;
                            recyearxt=leyearxt+30;
                            recshmxt=ledayxt+30;
                            recfullxb=xb-15;
                            recyearyb=recyearyt+25;
                            ledayyt=ridayyt=recshmyt=recyearyb+4;
                            recshmyb=recshmyt+25;
                            cayt=recshmyb+9;
                            
                            // Υπολογισμός cx - cy
                            for (i=1 ; i<8 ; i++ ) { cx[i]=caxt+(i-1)*60; }
                            caxb=caxt+(i-1)*60;
                            for (f=0 ; f<6;f++) { cy[f]=cayt+f*25; }
                            cayb=cayt+f*25;

                            ridayxt=caxb-76;
                            riyearxt=caxb-56;
                            recyearxb=riyearxt-4 ;
                            recshmxb=ridayxt-4 ;
                            inpyearxb=inpyearxt+80;
                            inpmonthxt=inpyearxb+31; inpmonthxb=inpmonthxt+40;
                            inpdayxt=inpmonthxb+29; inpdayxb=inpdayxt+40;
                            inpyearyt = inpmonthyt = inpdayyt = cayb+66;
                            // ENDIAMESA NA GRAFEI KATI....
                            inpyearyb=inpmonthyb=inpdayyb=inpdayyt+25;
                            putokxt=inpdayxb+7; putokyt = inpdayyt-4;
                            // ENDIAMESA NA GRAFEI KATI....
                            adddaysxt=xt+155; adddaysyt=inpyearyb+40;
                            adddaysxb=adddaysxt+120;
                            adddaysyb=adddaysyt+25;
                            addokxt=adddaysxb+7; addokyt=adddaysyt-4 ;
                            yesxt = xb-90 ; yesyt = adddaysyb+17;
                            akyroxt = xt+15; akyroyt = adddaysyb+17;
                            syncxt = xt+250 ; syncyt = akyroyt;
                            flaggrxt=yesxt-50; flaggryt=yesyt+8;
                            
                            // ΜΗΝΕΣ
                            mhnxt=caxb+10;
                            mhnxb=mhnxt+100;
                            for (f=1; f<13 ; f++) {       
                                mhnyt[f]=mhnyb[f-1]+4;
                                mhnyb[f] = mhnyt[f]+26;
                            }
                            
                            refresh();
                            continue;
                    }
                    
                    
                    if (akyro) {
                        fyge=1;
                        keepfld=0; 
                        flddate=0;
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        continue;
                    }
                    
                    if (finyes) {
                        
                        if (arped>=0) {
                            keimk=memk[arped];
                            if (keimk[0]!=255) {
                                mytext_tonorm(keimk,file_1,50);
                                file_1[49]='\0';
                                //printf ("%s\n",file_1);
                                if (keyb_gr) {
                                    sprintf (file_2,"Προηγούμενη καταχώρηση :\n[%s]",file_1);
                                    dx=alert(0,file_2,"Θέλετε να αντικατασταθεί;");}
                                else {
                                    sprintf (file_2,"Previous Entry :\n[%s]",file_1);
                                    dx=alert(0,file_2,"Do you agree to change it?");}
                                if (!dx || dx==2) continue;
                            }
                        }
                        keepfld=1;
                        strcpy (mera[0],mera[unameday]);
                        if (keyb_gr) sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],uday,umonth,uyear);
                        else sprintf (str1024,"%s , %02u-%02u-%04u",mera[0],umonth,uday,uyear);
                        normtext_tomy(str1024,flddate);
                        //mytext_toclipboard (flddate);
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        fyge=1;
                        continue ;
                    }
                    
                    continue;
                
            break ; // Πέρας mousebuttondown
            
        case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        refresh(); 
        break;
        
        case SDL_QUIT :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                fyge=1;
                keepfld=0;
                flddate=0;
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                break ;
        
        case SDL_KEYDOWN:

        //ch_scan=sdlev.key.keysym.scancode;
        do { SDL_PollEvent(&sdlev) ; } while ( (SDL_PollEvent(&sdlev)) && (sdlev.type == SDL_KEYDOWN) ) ;

        a=0;
        d=0;
        switch (sdlev.key.keysym.scancode) {
            
            case SDL_SCANCODE_LEFT :
                if (uday==1) continue ;
                a=1;
                break;

            case SDL_SCANCODE_RIGHT :
                
                if (uday==mo[umonth]) continue ;
                a=2;
                break;

            case SDL_SCANCODE_UP :
                
                dx=uday-7;
                if(dx<1) continue ;
                a=3;
                break ;
               
            case SDL_SCANCODE_DOWN :

                if ((uday+7) > mo[umonth]) continue ;
                a=4;
                break ;
                
            case SDL_SCANCODE_HOME :
                
                a=5;
                break ;

            case SDL_SCANCODE_ESCAPE :
                fyge=1;
                keepfld=0;
                flddate=0;
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                continue ;
        }
        
        if (!a) continue ;
        d=a;
        
                
        if (panel) {
            panel=0;
            setrgbcolor(dbaspro);
            rectangle (caxt,cayt,caxb,cayb);
            if (specmonth) {c=(probox<5) ? 0 : 4 ;}
            else c=0;
            if (probox!=-1) {
                a=(probox/7)+1 ; b=probox%7 ;
                if(!b) { a--; b=7; } // Γραμμή=α , Στήλη = β !
                if (probox!=uday+c) {
                    setcolor (COLOR(genbkxr[0],genbkxr[1],genbkxr[2]));
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                }
                else {
                    setcolor (COLOR(bkxrepi[0],bkxrepi[1],bkxrepi[2]));    
                    rectangle (cx[b]+1,cy[a]+1,cx[b]+59,cy[a]+24);
                    rectangle (cx[b]+2,cy[a]+2,cx[b]+58,cy[a]+23);
                }
                box=probox=-1;
            }
            refresh();
        }
        else if (promonbox!=-1) {
                setrgbcolor(dbaspro);
                rectangle (mhnxt,mhnyt[promonbox],mhnxb,mhnyb[promonbox]);
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                line(mhnxt-1,mhnyt[promonbox]+1,mhnxt-1,mhnyb[promonbox]+1);
                line(mhnxt-1,mhnyb[promonbox]+1,mhnxb,mhnyb[promonbox]+1);
                refresh();
                promonbox=monbox=-1;
            }
            else if (inpyear) {
                inpyear=0;
                setrgbcolor(dbaspro);
                rectangle (inpyearxt , inpyearyt, inpyearxb, inpyearyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpyearxt-1 , inpyearyt-1, inpyearxb+1, inpyearyb+1) ;
                refresh();
            }
            else if (inpmonth) {
                inpmonth=0;
                setrgbcolor(dbaspro);
                rectangle (inpmonthxt , inpmonthyt, inpmonthxb, inpmonthyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpmonthxt-1 , inpmonthyt-1, inpmonthxb+1, inpmonthyb+1) ;
                refresh();
            }
            else if (inpday) {
                inpday=0;
                setrgbcolor(dbaspro);
                rectangle (inpdayxt , inpdayyt, inpdayxb, inpdayyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (inpdayxt-1 , inpdayyt-1, inpdayxb+1, inpdayyb+1) ;
                refresh();
            }
            else if (adddays) {
                adddays=0;
                setrgbcolor(dbaspro);
                rectangle (adddaysxt , adddaysyt, adddaysxb, adddaysyb) ;
                setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                rectangle (adddaysxt-1 , adddaysyt-1, adddaysxb+1, adddaysyb+1) ;
                refresh();
            }
            else if (marrs) {marrs=0; puticon(movext,moveyt,mem_arrs,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (leyear) {leyear=0; puticon(leyearxt,leyearyt,mem_le,255); }
            else if (riyear) {riyear=0; puticon(riyearxt,riyearyt,mem_ri,255); }
            else if (leday) {leday=0; puticon(ledayxt,ledayyt,mem_le,255); }
            else if (riday) {riday=0; puticon(ridayxt,ridayyt,mem_ri,255); }
            else if (putok) {putok=0; puticon(putokxt,putokyt,mem_ok,255); }
            else if (addok) {addok=0; puticon(addokxt,addokyt,mem_ok,255); }
            else if (finyes) {finyes=0; puticon(yesxt,yesyt,mem_yes,255); if (mem_small) hide_help(hdhlpxt , hdhlpyt);}
            else if (akyro) {akyro=0; puticon(akyroxt,akyroyt,mem_akyro,255); }
            else if (sync) {sync=0; puticon(syncxt,syncyt,mem_sync,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (pronow) {
                    pronow=0; 
                    setcolor(COLOR(olobkxr[0],olobkxr[1],olobkxr[2]));
                    line(recshmxt+3,recshmyb+1,recshmxb-3,recshmyb+1);
                line(recshmxt+15,recshmyb+2,recshmxb-15,recshmyb+2);
                line(recshmxt+30,recshmyb+3,recshmxb-30,recshmyb+3);
                line(recshmxt+40,recshmyb+4,recshmxb-40,recshmyb+4);
                line(recshmxt+50,recshmyb+5,recshmxb-50,recshmyb+5);
                line(recshmxt+60,recshmyb+6,recshmxb-60,recshmyb+6);
                    refresh(); 
                }
            else if(flaggr) {flaggr=0;puticon(flaggrxt,flaggryt,mem_flgr,255);hide_help(hdhlpxt , hdhlpyt);}
            
            if (!ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            ektos=1;
            }
            
            a=d;
            switch (a) {

                case 1 :
                                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-1;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-1;
                    
                    goto LIKE_PROBOX ;

                case 2 :
                    
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+1;
                        if (probox>4 && probox<19) probox=19;
                        
                    }
                    else probox=uday+1;
                    
                    goto LIKE_PROBOX ;

                case 3 :
                            
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c-7;
                        if (probox>4 && probox<19) probox=4;
                        
                    }
                    else probox=uday-7;
                    
                    goto LIKE_PROBOX ;

                case 4: 

                    if ((uday+7) > mo[umonth]) continue ;
                    if (specmonth) {c=(probox<5) ? 0 : 4 ;}
                    else c=0;
                
                    if (specmonth) {
                        c=(uday<5) ? 0 : 4 ;
                        probox=uday+c+7;
                        if (probox>4 && probox<19) probox=19;
                    }
                    else probox=uday+7;
                    
                    goto LIKE_PROBOX ;
                    
                case 5 :
                            
                    goto SHMERIS ;   
            }
            
        
        } // Πέρας switch sdlev.type
        
    } while (!fyge);


FYGE:
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    if(mem0) {putimage(xt,yt,mem0,0); refresh();free(mem0);}
    if(mem_arrs) free(mem_arrs);
    if(mem_ri) free(mem_ri);
    if(mem_le) free(mem_le);
    if(mem_ok) free(mem_ok);
    if(mem_yes) free(mem_yes);
    if(mem_akyro) free(mem_akyro);
    if (mem_sync) free (mem_sync);
    if(mem_flgr) free(mem_flgr); 
    if( (!keepfld) && (memfld)) free(memfld);
    gouv=trampa;
    for (f=0;f<3;f++) {
        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
    }
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
    return flddate;
}


int button_show(void *mem_str, char *data, unsigned short int ar, unsigned short int orio, char *but_name, short int *sorton,short int delon )
// Η button_load παρέχει το δείκτη mem που δείχνει το αλφαριθμητικό , τον ar (μέγεθος του str) , το orio και το button name.
// Με τον sorton καθορίζουμε αν θέλουμε ή όχι να γίνει sorting (0 σημαίνει όχι) ενώ με τον delon καθορίζουμε αν θα υπάρχει σκουπιδοτενεκές ή όχι !!
{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0 , *ardom_mem=0, *mem_arrs =0, *mem_bar=0 , *mem_ok=0 , *mem_S0=0, *mem_S1=0;
void *mem_front=0 , *mem_back=0 , *mem_del=0 ,*mem_sort=0 , *item_mem=0 ,*mem_bar1 , *mem_zer=0 , *mem_desc=0;
void *mem_drag=0 , *mem_search=0 ,*mem_ghost =0 , *mem_fonter=0;
int *mem_int ;
struct XX4_byte {
unsigned long int fg;
unsigned long int sg;
unsigned long int tg;
};
struct XX4_byte *item;
int user_ans ;
int cbrown[3] , chrprnt[3] , xrep[3] , xrkl[3] , slkl [3] ;
unsigned short int *ar_dom;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k , bary1, bary2, y1, y2 , y3 ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb,  xfrba, yfrba , xsort , ysort ;
unsigned short int plbut , key , key_1, pano, pa, pano_1, kato , telos , telos1, sort , sort_1, bar, proyt , metektos , proyt1 , metektos1 , proenter , xok , yok , protyx ;
unsigned short int prodel ,xdel , ydel , prosort ,profrba , tyx ,fyge , marrs , probar , yicob ,xvice, yversa ,el , low ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , proelem ,c ;
unsigned char what ;
unsigned int size;
unsigned char *str , *ghost_str ;
short int by , rby , w, drax , dray , buthei , newhei , drag ,search , searx, seary ;
Uint8 klik;
unsigned char deigma1_text[22] , neodeigma1_text[22] ; 
short int redline=0 , newsea=0 , xfo ;
char keno[10];
short int sparky , fonter ;
int proxchxr[3] , proxbkxr[3] , proxslxr[3] ;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union button_item {
    long unsigned int big;
    unsigned char sma[8];
} bitem [3] ;

static unsigned short int xt;
static int yt1;
unsigned char ektos=1;
static short int lines ;
unsigned short int fhe;
static short int fo ;
static short int fnt ;

if (!fo && !fnt) fnt=4;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[fnt];
str=mem_str;
plbut=0;    
key_1=sort_1=65000;

deigma1_text[0] = 255; neodeigma1_text[0] = 255;
if (keyb_gr) strcpy (keno,"KENO");
else strcpy (keno,"EMPTY");
normtext_tomy(keno,0);

for (f=0 ; f<ar && plbut<65533 ; f++) {
    if (str[f]==255) plbut++;
        }

unsigned char *but[plbut] ;
unsigned char *gbut[plbut];
unsigned char krit[plbut];

mem_ghost=malloc(ar+1);
if (!mem_ghost)  {information (2-keyb_gr,0,0); goto FYGE; }
ghost_str=mem_ghost;
for (f=0; f<ar; f++) ghost_str[f]=str[f] ;

i=0; a=0; 

for (f=0 ; f<ar && i<plbut ; f++) {
   if (str[f]==255) {
       gbut[i]=ghost_str+a;
       but[i]=mem_str+a;
       i++;
       a=f+1; 
        }
}

for (f=0;f<plbut;f++) {krit[f]=0;}

// Sorting Procedure !!
ardom_mem=malloc(plbut*2);
if (!ardom_mem) {information (2-keyb_gr,0,0); goto FYGE; }
ar_dom=ardom_mem;
key=*sorton;
for (f=0;f<plbut;f++) ar_dom[f]=f;
if (key) {
    item_mem=malloc(plbut*24);
    if (!item_mem) {information (2-keyb_gr,0,0); goto FYGE; }
    item=item_mem;
    for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

// Μετατροπή των gbut σε άτονα και μικρά !!

for (f=0;f<plbut;f++) {
    i=0;
    while (gbut[f][i]!=255) i++;
    by=i; //strlen (gbut[f])

    for (i=0;i<by;i++) {
        if (keyb_gr) {
            switch (gbut[f][i]) {

                case 96:
                case 131:
                case 132:
                gbut[f][i]=95;
                break;
                
                case 133:
                case 134:
                case 135:
                case 138:
                case 141:
                gbut[f][i]-=36;
                break;
                
                case 101:
                case 136:
                case 137:
                gbut[f][i]=100;
                break;
                
                case 104:
                case 139:
                case 140:
                gbut[f][i]=103;
                break;
                
                case 107:
                case 108:
                case 109:
                case 142:
                case 143:
                case 144:
                gbut[f][i]=106;
                break;
                
                case 145 :
                case 146 :
                case 147 :
                case 148 :
                case 149 :
                case 152 :
                case 153 :
                case 154 :
                case 155 :
                gbut[f][i]-=35;
                break ;
                
                case 116 :
                case 150 :
                case 151 :
                gbut[f][i]=115;
                break;
                
                case 122 :
                case 123 :
                case 124 :
                case 156 :
                case 157 :
                case 158 :
                gbut[f][i]=121;
                break;
                
                case 159 :
                case 160 :
                case 161 :
                gbut[f][i]-=34;
                break;
                
                case 129 :
                case 162 :
                case 163 :
                gbut[f][i]=128;
                break;

                case 130:
                gbut[f][i]=119;
            }
        }
        if ( (gbut[f][i]>68) && (gbut[f][i]<95) ) gbut[f][i]-=26;
    }
}


cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrprnt[0]=150 ; chrprnt[1]=255 ; chrprnt[2]=177 ; 
i=orio*myfont_wid[fnt];
fhe=myfont_hei[fnt]+2;
if (i <320) width = 320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
if (!lines) lines = 15 ;
if (lines>plbut) lines=plbut;
else {
    while ( (lines<plbut) && (lines<31) ) lines++; }
while ( ((lines*fhe + 100+ yt1) >= info.bottom-35) && (lines>5) ) lines--;
while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
buthei=lines*fhe+100;
size=imagesize(0,0,width-1,buthei-1);
mem0=malloc(size); 
if (!mem0) {information(2-keyb_gr,NULL,NULL);return 0;}
if (!xt) xt=(info.right-info.left-width) / 2 ; if (!yt1) yt1=(info.bottom-info.top-buthei) / 2 ;
yt=yt1+19;  yb=yt1+buthei-1;
while (xt+width+11>info.right) xt--;
xb=xt+width-1 ;
getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
yok=ysort = ydel = yb-46;
xdel = xtepl+2 ;  
searx = (delon) ? xdel+40 : xdel ; 
xfrba = searx + 35 ;
yfrba = yb-52 ;
xsort = xfrba+56;
xvice=xsort+38; yversa=ysort+8;
yicob = yb-9;
drax=xb-38 ; dray=yok+8;
xok=drax-80 ; 
seary=dray ;
xfo=xb-19;

_areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);

// ΕΠΙΚΕΦΑΛΙΔΑ
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL); free(mem0); return 0;} 
_puticon(xt+1,yt1+1,mem_arrs,255);

chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 
_outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);
refresh();

chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
slxr[0]=190; slxr[1]=228; slxr[2]=0;
xrep[0]=xrep[1]=xrep[2] = 0;
xrkl[0]=216 ; xrkl[1] = xrkl[2] = 0;
slkl[1]=162 ; slkl[0] = slkl[2] = 0;

_bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
_areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);

// TELOS EPIKEFALIDAS

//FORTVMA LOIPVN EIKONIDIVN

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }


strcpy (file_1,path_name);
strcat (file_1,"ICD/sortascend.ico");
mem_front = icontomem (file_1,255);
if (mem_front==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/unsorted.ico");
mem_back = icontomem (file_1,255);
if (mem_back==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

if(delon) {
strcpy (file_1,path_name);
strcat (file_1,"ICD/delete_35.ico");
mem_del = icontomem (file_1,255);
if (mem_del==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }
}

strcpy (file_1,path_name);
strcat (file_1,"ICD/sort_arrows.ico");
mem_sort = icontomem (file_1,255);
if (mem_sort==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_vice.ico");
mem_S0 = icontomem (file_1,255);
if (mem_S0==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/Sort_versa.ico");
mem_S1 = icontomem (file_1,255);
if (mem_S1==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/sortdescend.ico");
mem_desc = icontomem (file_1,255);
if (mem_desc==NULL) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/UpDown.ico");
mem_drag=icontomem(file_1,255);
if (mem_drag==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

strcpy (file_1,path_name);
strcat (file_1,"ICD/Search_30.ico");
mem_search = icontomem (file_1,255);
if (!mem_search) {information(2-keyb_gr,NULL,NULL);goto FYGE ; }

strcpy(file_1,path_name);
strcat(file_1,"ICD/Fonter_17.ico");
mem_fonter=icontomem(file_1,255);
if (mem_fonter==NULL) {information(2-keyb_gr,NULL,NULL); goto FYGE ;} 

    
//_bareacls (xtepl,ytepl,xtepr,ytepr,bkxr);

// EMFANISH EIKONIDIVN

if (delon) _puticon (xdel,ydel,mem_del,255);

if (key) _puticon (xfrba,yfrba,mem_front,255) ;
else _puticon (xfrba,yfrba,mem_back,255) ;

_puticon (xsort,ysort,mem_sort,255);

_puticon (xvice,yversa,mem_S1,255);

_puticon (xok,yok,mem_ok,255);

_puticon(drax,dray,mem_drag,255);

_puticon(searx,seary,mem_search,255);

_puticon(xfo,yt-18,mem_fonter,255);

a=0;k=0; a1=plbut; sort=0;bar=0; drag=0 ; search=0 ;fonter=0;
mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
    
        if (but[ar_dom[a]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[a]] , xtepl+10 , ytepl+k*fhe , xtepr);
        a++; a1--;k++;
    
}while (a1 && k<lines);

setcolor(5);
line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
refresh();
c=a;
kato=--a;
telos=a1;

// ΕΛΕΓΧΟΣ ΓΙΑ ΠΛΕΥΡΙΚΗ ΜΠΑΡΑ - ΕΜΦΑΝΙΣΗ 

    if (!sort) {
    proyt=pano ;
    metektos = plbut-kato-1; 
        }
    
    else {
    proyt=plbut-pano-1;
    metektos=kato;
        }
        
    if ( (proyt) || (metektos) ) {
    bar=1;
    setcolor (COLOR (0,255,0) );  
    rectangle (xb+1,ytepl,xb+10,ybarb);
    setcolor (COLOR (0,0,0) ); 
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
    if (y1==y2) y2++;
    bary1=y1 ; bary2=y2;
    setcolor (COLOR (255,165,0) );  
    for (f=xb+2 ; f<xb+10 ; f++) {
        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
    refresh();}

    
proenter=prodel=profrba=prosort=fyge=marrs=probar=drag=0;
protyx=tyx=lines; elem=proelem=-1 ;
bima= (sort) ? -1 : 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    while (SDL_PollEvent(&sdlev)) continue ;
    mx=sdlev.motion.x ; my=sdlev.motion.y;
     if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 25 επιλογών !!
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prodel) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255);hide_help(hdhlpxt , hdhlpyt); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
     tyx=(my-ytepl)/fhe;
    
     
         if (elem != -1) { // Έχω προηγουμένως κάνει κλικ σε ένα από τα 12 χρώματα !
         
          if (tyx==protyx) {
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);    
         continue ;}
             else {
                 ektos=1;
          cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
          SDL_SetCursor(cursor);   
          continue;       
            }
        }
        
        if (tyx>plbut-1) {
            
            if (protyx!=lines) {
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                el = (sort) ? pano-protyx : pano+protyx;
                if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
                refresh();
                protyx=lines;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>lines-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==lines) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
         _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr, xrep, slxr);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255) _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
        el = (sort) ? pano-tyx : pano+tyx;
        _bareacls(xtepl+1, ytepl+tyx*fhe,xtepr,ytepl+tyx*fhe+(fhe-2),slxr);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr );
        else _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+tyx*fhe , xtepr , xrep, slxr);     
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 25 EPILOGVN
    
    if (protyx!=lines && elem==-1) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        el = (sort) ? pano-protyx : pano+protyx;
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
        else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);       
        refresh();
        protyx=lines;
                }
    
    if(delon) {
    if (mx>xdel && mx<xdel+35 && my>ydel && my<yicob) {  // Επιλογή Delete
        ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
    
    if (prodel) continue ;
    prodel=1;
    putNOTicon (xdel,ydel,mem_del);
    if (keyb_gr) show_help("Διαγραφή στοιχείου", xdel, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Delete element", xdel, yb , &hdhlpxt , &hdhlpyt) ; 
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
        
    }}
    
    if ((delon) && (prodel) ) {prodel=0 ; puticon (xdel,ydel,mem_del,255); hide_help(hdhlpxt , hdhlpyt);}
                                
    if (mx>xfrba && mx<xfrba+43 && my>yfrba && my<yicob) {  // Επιλογή για sorting
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (profrba) continue ;
    profrba=1;
    if (key) putNOTicon (xfrba,yfrba,mem_front) ;
        else putNOTicon (xfrba,yfrba,mem_back) ; 
     if (keyb_gr) show_help("Ταξινόμηση ή , εμφάνιση στοιχείων με την αρχική τους σειρά", xfrba, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Sorting or , show data by their initial order", xfrba, yb , &hdhlpxt , &hdhlpyt) ;   
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (profrba) {
        profrba=0 ;
        hide_help(hdhlpxt , hdhlpyt);
        if (key) puticon (xfrba,yfrba,mem_front,255) ;
        else puticon (xfrba,yfrba,mem_back,255) ; }
        
    if (mx>xsort && mx<xsort+35 && my>ysort && my<yicob) {  // Επιλογή στο SORT - switch
    ektos=0;
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

    else if (proenter) { proenter=0 ; puticon (xok,yok,mem_ok,255); }
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}

    if (prosort) continue;
    prosort=1;
    putNOTicon (xsort,ysort,mem_sort);
     if (keyb_gr) show_help("Από την αρχή προς το τέλος ή αντίστροφα", xsort, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("From the start to the end or vice-verca ", xsort, yb , &hdhlpxt , &hdhlpyt) ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    }
    
    if (prosort) {prosort=0 ; puticon (xsort,ysort,mem_sort,255); hide_help(hdhlpxt , hdhlpyt);}

    if (mx>xok && mx<xok+35 && my>yok && my<yicob) {  // Επιλογή στο Enter
     ektos=0; 
    if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
       
    else if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
    if (proenter) continue;
    proenter=1;
     //BAFEI ENTER
    for (f=0;f<35;f++) {
    mem_int=(mem_ok +8 + (f*35*4));
    for (i=0;i<35;i++) {
    co.lor = *mem_int++;
    if (!co.rgb[3]) continue;
    red =  (255 * co.rgb[2]) / 255;
    green =  (0 * co.rgb[1]) / 255;
    blue =  (255 * co.rgb[0]) / 255 ;
    setcolor(COLOR (red,green,blue));
    _putpixel (xok+i , yok+f);}}
    refresh();
    
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor); 
    
    continue ;
    
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    ektos=0;
        
    if (probar) probar=0;
    else if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
    else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!marrs) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        marrs=1;
        putNOTicon(xt+1,yt-18,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", xt, yt , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", xt, yt , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(xt+1,yt-18,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}

        if (mx>drax && mx<xb && my>dray && my<yb) { // PONTIKI STO DRAG
        ektos=0;
        if (probar) probar=0;
        else if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        
        if (!drag) {
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        drag=1;
        putNOTicon(drax,dray,mem_drag);
        if (keyb_gr) show_help("Αλλαγή Ύψους Παραθύρου", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Change Window Height", xb-30, yb+2 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;

        }

        if(drag) {drag=0 ; puticon(drax,dray,mem_drag,255);hide_help(hdhlpxt , hdhlpyt);}
    
        if (mx>searx && mx<searx+30 && my>seary && my<seary+30) { // PONTIKI STO SEARCH
         
        ektos=0;
        if (probar) probar=0;
        else if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
        if (search) continue ;
        search=1;
        putNOTicon (searx,seary,mem_search);
        if (keyb_gr) show_help("Δεξί κλικ : Εισαγωγή κειμένου αναζήτησης / Αριστερό κλικ : Αναζήτηση", searx, yb , &hdhlpxt , &hdhlpyt) ;
        else show_help("Right Click : Input Search Text / Left Click : Search", searx, yb , &hdhlpxt , &hdhlpyt) ;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor); 
        continue ; 
     }
     
     if(search) {search=0 ; puticon(searx,seary,mem_search,255);hide_help(hdhlpxt , hdhlpyt);}
     
     if (mx>xfo && mx<xb && my>yt-18 && my<yt) { // PONTIKI STO fonter
     
        ektos=0;
        if (probar) probar=0;
        
        if (!fonter) {
            
          cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
          SDL_SetCursor(cursor);
          fonter=1;
          putNOTicon(xfo,yt-18,mem_fonter);
          if (keyb_gr) show_help(" Επιλογή Γραμματοσειράς ", xfo , yt , &hdhlpxt , &hdhlpyt) ;
          else show_help(" Choose Font ", xfo , yt, &hdhlpxt , &hdhlpyt) ;
          continue; }
          else continue;
        }
    
    if (fonter) {fonter=0 ; puticon(xfo,yt-18,mem_fonter,255); hide_help(hdhlpxt , hdhlpyt);}
     
    if (bar) {
        ektos=0;
        if (mx>xb && mx<xb+11 && my>ytepl && my<ybarb) { // Sto BAR Scroll
        if (probar) continue;
        probar=1;
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        continue ;
        }
    probar=0;
        
    } else {probar=0 ;}

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            if (profrba) information (32-keyb_gr,0,0);
            else if (prosort) information(34-keyb_gr,0,0);
            else if (delon && prodel) {
                if (keyb_gr) information (0,"Διαγραφή Λίστας από τη Μνήμη !",0); else information (0,"Unload a List from the Memory!",0);
            }
            else if (search) {
                newsea=1;
                user_ans=input_dbsearch_text(neodeigma1_text , -1);
                if (user_ans!=1) continue ;
                if (neodeigma1_text[1]==255) neodeigma1_text[0]=255;
                red=mystrcmp (deigma1_text,neodeigma1_text);
                if (red) {mystrcpy(deigma1_text,neodeigma1_text);redline=0;}
                goto FROMNEWSEARCH;
            }
            continue ;
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ; klik= sdlev.button.clicks; 
        //printf ("klik= %d \n" , klik);
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( (protyx!=lines) && (!prosort) && (!proenter) && (!marrs)  && (!prodel) && (!profrba) && (!probar) && (!drag) && (!search) && (!fonter) ) { // Επιλογή κάποιου από τα 25 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        if (elem==proelem && klik==1) { // Ακυρώνεται η επιλογή !
            elem=proelem=-1 ; 
        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
        if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
         else {_outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
         if (krit[ar_dom[el]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
            protyx=lines;
            refresh();
            continue ;
        }

        _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),slkl);
        if (but[ar_dom[el]][0]==255) _outfanis_colxr(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl );
        else { _outfanis_colxr(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr , xrkl, slkl);
        if (krit[ar_dom[el]]) {setrgbcolor (dbred) ; line(xtepl+10,ytepl+protyx*fhe+(fhe-1),xtepr-1, ytepl+protyx*fhe+(fhe-1)); }}
        proelem=elem;
        refresh(); 
        if (klik>1) goto DIPLO_KLIK ;
         
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
       else if (prosort) {    // Από κάτω προς τα πάνω ή από πάνω προς τα κάτω ....
           
            if (protyx!=lines) { 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            elem=proelem=-1 ; 
            protyx=lines;
            }
        _areacls (xvice,yversa,xvice+23,yversa+17,0,0,0);
        
        sort = abs (sort-1) ;
        // if (sort) puticon (xvice,yversa,mem_S1,255); else puticon (xvice,yversa,mem_S0,255);
        if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);
        if (key) {
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0); 
            if (sort) _puticon (xfrba,yfrba,mem_desc,255) ; else _puticon (xfrba,yfrba,mem_front,255) ;}
        refresh();
        bima= (sort) ? -1 : 1 ;
        if (!sort) c=0; else c=plbut-1 ;
        telos=plbut ;
        goto emfan;
        }
                    
        else if (delon && prodel) {
            if (elem==-1) {information(16-keyb_gr,0,0); continue; }
            if (keyb_gr) user_ans=alert(0,"Θέλετε να διαγραφεί η λίστα από τη μνήμη ;" ,"Η λίστα δεν διαγράφεται από το δίσκο !! \nΜπορείτε να τη φορτώσετε ξανά όποτε θέλετε."); else user_ans=alert(0,"Do you want the this list to be unloaded?" , "The list remains in the disk !! \n You can reload it any time you want.");
            if (user_ans != 1) continue;
            kati=ar_dom[elem];
            data[0]=255;
            fyge=1;
            // Διαγραφή κάποιου button - Μάλλον return με συγκεκριμένη τιμή
        }
        
        else if (profrba) {
            
            if (protyx!=lines) { // Ακυρώνεται τυχόν επιλογή !
            elem=proelem=-1 ; 
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            el= (sort) ? pano-protyx : pano+protyx;
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            refresh();
            protyx=lines;
            refresh();
        }
        
            
         key=(1-key);
        for (f=0;f<plbut;f++) ar_dom[f]=f;
        if (key) {
        item_mem=malloc(plbut*24);
        if (!item_mem) {information (2-keyb_gr,0,0); key=(1-key); continue; }
        item=item_mem;
        for (f=0;f<plbut;f++) {
        bitem[0].big=bitem[1].big=bitem[2].big=0;
        i=0;by=23;
        do {
        what=but[f][i];
        if (what>163) break;
        if (keyb_gr){
                switch (what) {

                    case 96:
                    case 101:
                    case 104:
                    case 107:
                    case 116:
                    case 122:
                    case 129:
                    case 132:
                    case 137:
                    case 140:
                    case 143:
                    case 151:
                    case 157:
                    case 163:
                    what--;
                    break;

                    case 108:
                    case 123:
                    case 144:
                    case 158:
                    what-=2;
                    break;


                    case 109:
                    case 124:
                    what-=3;
                    break;

                    case 130:
                    what=119;

                }

        }
        
        rby=by%8; low=(2-(by/8));
        //if (by>7) {low=0;rby=by-8;} else low=1;
        bitem[low].sma[rby]=what;
        by-- ; i++;
        } while (by>=0);
        item[f].fg=bitem[0].big;
        item[f].sg=bitem[1].big;
        item[f].tg=bitem[2].big;
    
    }

// SORTING !!
    pro_sort_24b(item_mem,ar_dom,plbut);  // QUICK SORT !!!!!
    free (item_mem) ; item_mem=0;
}

             *sorton=key;
            _areacls(xfrba,yfrba,xfrba+45,yfrba+40,0,0,0);
            if (key) puticon (xfrba,yfrba,mem_front,255) ;
            else puticon (xfrba,yfrba,mem_back,255) ;
            
            c = (sort) ? plbut-1 : 0 ;
            telos=plbut;
            goto emfan ;
            
        }  // TELOS profrba
        
        else if (search) {

FROMNEWSEARCH:
            if (deigma1_text[0]==255) { // Δεν υπάρχει τίποτε για αναζήτηση !!

                if (protyx!=lines) { 
                    el= (sort) ? pano-protyx : pano+protyx;
                    _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                    if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                    refresh();
                    elem=proelem=-1 ; 
                    protyx=lines;
                }
                
                pa=pano;
                telos1=(sort) ? pa+1 : plbut-pa ;
                setcolor (COLOR (bkxr[0], bkxr[1], bkxr[2]) );
                k=0;
                do {
                    if (but[ar_dom[pa]][0]!=255) {
                        if (krit[ar_dom[pa]]) line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1));}
                pa+=bima ; telos1--; k++;
                }while (telos1 && k<lines);
                refresh();

            for (f=0;f<plbut;f++) krit[f]=0;
            redline=0; 
            if(!newsea) information (48-keyb_gr,0,0) ; // Οδηγία για δεξί κλικ προηγουμένως
            newsea=1; // Σημαία αρχικής ενημέρωσης για δεξί κλικ 
            search=0; puticon (searx,seary,mem_search,255);
            continue ;
            }
            
            if (protyx!=lines) { 
                el= (sort) ? pano-protyx : pano+protyx;
                _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
                if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
                else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
                refresh();
                elem=proelem=-1 ; 
                protyx=lines;
            }
                if (redline) {

                    redline=1;
                    if ( (pano==pano_1) && (sort==sort_1) && (key==key_1) ) { // Προχωράει στην επόμενη lineάδα....
                        c=pano+(bima*lines) ;
                        if (!sort && c>plbut-1) {c=0 ; telos=plbut;}
                        if (sort && c<0) {c=plbut-1 ; telos=plbut ; }
                        telos=(sort) ? c+1 : plbut-c;
                        if (!sort) {
                            if (c<0) {c=0 ; telos=plbut;}
                            else if ((c+lines)>plbut) {
                                if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                    
                        else if (sort) {
                            if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                            else if ( (c-lines+1)<0 ) { 
                                c=lines-1; telos=lines; 
                                if (plbut<lines) {c=plbut-1; telos=plbut; }}}
                                pano=c; telos=(sort) ? c+1 : plbut-c;
                    }
                    //pano_1=pano ; sort_1=sort ; key_1=key;
                    telos1=(sort) ? pano+1 : plbut-pano ;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                
                    if (redline==2) {
                        telos=(sort) ? pano+1 : plbut-pano ;
                    }
                    else {
                        pano=(sort) ? plbut-1 : 0 ;
                        telos1=plbut;
                        f=0;
                        do {
                            c=pano+(bima*f) ;
                            i=ar_dom[c];
                            if (krit[i]) {redline=2; break;}  
                            f++;
                        }while (f<telos1);
                        
                        telos=(sort) ? c+1 : plbut-c ;
                    }
                    SDL_PollEvent(&sdlev);
                    mx=sdlev.motion.x ; my=sdlev.motion.y;
                    if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                    search=0; puticon (searx,seary,mem_search,255);
                    goto emfan ;
                }
            else {
                
                        // Μετατροπή του αλφαριθμητικού που εισάχθηκε για αναζήτηση σε .. κάτι καλύτερο-μετρήσιμο !!
                        //Όλα μικρά και χωρίς τόνους !! 
                        // To deigma1_text είναι μεγέθους 20 - έχει ήδη εισαχθεί από τον χρήστη !
                            
                            i=0;
                            while (deigma1_text[i]!=255) i++;
                            by=i; //strlen (deigma1) (χωρίς το 255)

                            for (f=0;f<i;f++) {
                                if (keyb_gr) {
                                    switch (deigma1_text[f]) {

                                        case 96:
                                        case 131:
                                        case 132:
                                        deigma1_text[f]=95;
                                        break;
                                        
                                        case 133:
                                        case 134:
                                        case 135:
                                        case 138:
                                        case 141:
                                        deigma1_text[f]-=36;
                                        break;
                                        
                                        case 101:
                                        case 136:
                                        case 137:
                                        deigma1_text[f]=100;
                                        break;
                                        
                                        case 104:
                                        case 139:
                                        case 140:
                                        deigma1_text[f]=103;
                                        break;
                                        
                                        case 107:
                                        case 108:
                                        case 109:
                                        case 142:
                                        case 143:
                                        case 144:
                                        deigma1_text[f]=106;
                                        break;
                                        
                                        case 145 :
                                        case 146 :
                                        case 147 :
                                        case 148 :
                                        case 149 :
                                        case 152 :
                                        case 153 :
                                        case 154 :
                                        case 155 :
                                        deigma1_text[f]-=35;
                                        break ;
                                        
                                        case 116 :
                                        case 150 :
                                        case 151 :
                                        deigma1_text[f]=115;
                                        break;
                                        
                                        case 122 :
                                        case 123 :
                                        case 124 :
                                        case 156 :
                                        case 157 :
                                        case 158 :
                                        deigma1_text[f]=121;
                                        break;
                                        
                                        case 159 :
                                        case 160 :
                                        case 161 :
                                        deigma1_text[f]-=34;
                                        break;
                                        
                                        case 129 :
                                        case 162 :
                                        case 163 :
                                        deigma1_text[f]=128;
                                        break;

                                        case 130:
                                        deigma1_text[f]=119;
                                    }
                                }
                                if ( (deigma1_text[f]>68) && (deigma1_text[f]<95) ) deigma1_text[f]-=26;
                            }
                
                pa=0 ;
                telos1=plbut ;
                while (pa<telos1) {
                    if (but[pa][0]==255) {krit[pa]=0; pa++; continue;}
                            
                            // mystrstr(deigma,deigma1) // Αν υπάρχει το deigma1 μέσα στο δείγμα !!

                            i=0;
                            do {
                                what=gbut[pa][i];
                                f=0; w=by; rby=0;a=i;
                                while( (what!=255) && (w) ) {
                                    if (what==deigma1_text[f++]) {rby++; i++; w--; what=gbut[pa][i];continue;}
                                    else break;}
                                    
                                    if (rby==by) { i=-1; break ;}
                                    else i=a+1;
                                    
                            }while (what!=255);
                            krit[pa] = (i==-1) ? 1 : 0;
                            pa++;  continue;
                    
                }
            }

            i=0;
            for(f=0;f<plbut;f++) if (krit[f]) { i++ ;}
            if (i) redline=1;
            if (!redline) {
                if (keyb_gr) information (0,"Δεν βρέθηκε τίποτε !",0);
                else information(0,"Nothing found !",0);
            }
            else {
                if (keyb_gr) sprintf(str1024,"Προέκυψε ταύτιση σε %d σημεία!", i);
                else sprintf(str1024,"Identity occurred in %d points!", i);
                information(0,str1024,0);
            }
            
            if (redline) {
               telos1=(sort) ? pano+1 : plbut-pano ;
                f=0;
                do {
                    c=pano+(bima*f) ;
                    i=ar_dom[c];
                    if (krit[i]) {redline=2; break;}  
                    f++;
                }while (f<telos1);
            
                if (redline==2) {
                    telos=(sort) ? c+1 : plbut-c ;
                    }
                 else {
                    pano=(sort) ? plbut-1 : 0 ;
                    telos1=plbut;
                    f=0;
                    do {
                        c=pano+(bima*f) ;
                        i=ar_dom[c];
                        if (krit[i]) {redline=2; break;} 
                        f++;
                    }while (f<telos1);
                    
                    telos=(sort) ? c+1 : plbut-c ;

                }
                SDL_PollEvent(&sdlev);
                mx=sdlev.motion.x ; my=sdlev.motion.y;
                if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
                search=0; puticon (searx,seary,mem_search,255);
                goto emfan ;
            }
            c=pano;
            telos=(sort) ? pano+1 : plbut-pano ;
            SDL_PollEvent(&sdlev);
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx>searx && mx<searx+30 && my>seary && my<yb) {
                    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    ektos=0;
                    goto emfan ;}
            search=0; puticon (searx,seary,mem_search,255);
            goto emfan;
            
        }
        
        else if (proenter) {
            
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            fyge=1;
            
            if (elem!=-1) {
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                        data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                    continue ;
                              }
        }
        
        else if (marrs) {
            
            xt1=xt; 
            xb1=xb+10; 
            yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            xb1-=10;
            mem_zer=malloc(size);
            if (!mem_zer) {information(2-keyb_gr,NULL,NULL); yt1=yt-19; continue ;}

            if (bar) {
            mem_bar1=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar1) {information(2-keyb_gr,NULL,NULL); free(mem_zer); yt1=yt-19; continue ;}
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar1); // Αντιγράφει τη μπάρα.
            putimage(xb+1,ytepl , mem_bar , 0) ; // Αποκαθιστά πίσω από μπάρα στην παλαιά θέση !
            }

            // Αντιγράφει το button/list όπως είναι αυτήν τη στιγμή !
            getimage(xt,yt-19,xb,yb,mem_zer);
            putimage(xt,yt-19,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση του readyinks

            xt=xt1; yt=yt1+19;
            xb=xt+width-1 ; yb=yt1+buthei-1;
            getimage(xt,yt1,xb,yb,mem0); //κλέβει οθόνη για να αποκαταστήσει όποτε... !
            putimage(xt,yt1,mem_zer,0);
            free(mem_zer);

            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel=xtepl+2;
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            seary=dray;
            xfo=xb-19;
            
            if (bar) {
            y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            }
            
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            if (bar) {
                putimage(xb+1,ytepl,mem_bar1,0);
                free(mem_bar1);
            }

            refresh();
            continue ;
        }
        
        else if (drag) {
            drag=0;
            xt1=xt;
            xb1=(bar) ? xb+10 : xb ; 
            yb1=yb ;
            change_hei(xt1, yt1 , xb1 , &yb1);
            newhei = yb1 - yt1 + 1 ;
            if (newhei<100+fhe*5) newhei=100+fhe*5;
            newhei=(newhei-100)/fhe;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            refresh();
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            lines=newhei ;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46; yversa=ysort+8;
            yfrba = yb-52 ;
            yicob = yb-9;
            dray=yok+8;
            seary=dray;
            
            _areacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,0,89,0);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);

            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            refresh();

            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ytepl+lines*fhe,bkxr);
            _areacls(xtepl,ytepl+lines*fhe+2,xtepr,ytepr,0,0,0);
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(searx,seary,mem_search,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (fonter) {
            fonter=0; puticon(xfo,yt-18,mem_fonter,255);
            for (f=0 ; f<3 ; f++) { proxchxr[f]=chxr[f] ; proxbkxr[f]=bkxr[f] ; proxslxr[f]=slxr[f] ; }  
            user_ans=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, xrep, xrkl, slkl );
            for (f=0 ; f<3 ; f++) { chxr[f] = proxchxr[f] ; bkxr[f] = proxbkxr[f] ; slxr[f] = proxslxr[f] ; }  
            if (user_ans<0) continue;
            fo=1;
            gouv=myfont[user_ans];
            fnt = (unsigned short int) user_ans ;
            putimage(xt,yt1,mem0,0); // αποκαθιστά οθόνη στην παλαιά θέση 
            if (bar) putimage(xb+1,ytepl,mem_bar,0);
            if (mem_bar) { free (mem_bar) ; mem_bar=0; }
            free(mem0); mem0=0;
            refresh();
            i=orio*myfont_wid[fnt];
            fhe=myfont_hei[fnt]+2;
            if (i <320) width =320 ; else {width=(i>600) ? 600-8 : i+8 ;} 
            while  ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (yt1>=info.top) ) yt1--;
            while ( ((lines*fhe + 100 + yt1) >= info.bottom-35) && (lines>5) ) lines--;
            while (xt+width+11>info.right) xt--;
            xb=xt+width-1;
            buthei=lines*fhe+100;
            yb=yt1+buthei-1;
            size=imagesize(xt,yt1,xb,yb);
            mem0=malloc(size); 
            if (!mem0) {information(2-keyb_gr,NULL,NULL);goto FYGE;}
            
            getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
            elem=proelem=-1 ; 
            protyx=lines;
            bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
            // Rectangles
            yt=yt1+19;
            setcolor(5);
            rectangle (xt,yt1,xb,yb) ;
            areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
            setcolor(5);
            line (xt+1,yt1+18,xb-1,yt1+18);
            line (xt+1,yt1+19,xb-1,yt1+19);
            rectangle (xt+8,yt+8,xb-8,yb-8);
            xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+lines*fhe+1;
            yok=ysort = ydel = yb-46;
            xdel = xtepl+2 ;  
            searx = (delon) ? xdel+40 : xdel ; 
            xfrba = searx + 35 ;
            yfrba = yb-52 ;
            xsort = xfrba+56;
            xvice=xsort+38; yversa=ysort+8;
            yicob = yb-9;
            drax=xb-38 ; dray=yok+8;
            xok=drax-80 ; 
            xfo=xb-19 ;
            seary=dray ;
            _areacls (xtepl,ytepl,xtepr,ybarb-1,0,89,0);
            
            // ΕΠΙΚΕΦΑΛΙΔΑ

            _puticon(xt+1,yt1+1,mem_arrs,255);

            chxr[0]=chrprnt[0]; chxr[1]=chrprnt[1]; chxr[2]=chrprnt[2];
            bkxr[0]=cbrown[0] ; bkxr[1]=cbrown[1] ; bkxr[2]=cbrown[2] ; 

            _outfanis_center_col(0, but_name , xtepl, yt1+1, xtepr);

            
            chxr[0]=0 ; chxr[1]=255; chxr[2]=24;
            bkxr[0]=0 ; bkxr[1]=61; bkxr[2]=170;
            slxr[0]=190; slxr[1]=228; slxr[2]=0;
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            _areacls(xtepl,ybarb+1,xtepr,ytepr,0,0,0);
            refresh();
            
            if (delon) _puticon (xdel,ydel,mem_del,255);

            if (key) _puticon (xfrba,yfrba,mem_front,255) ;
            else _puticon (xfrba,yfrba,mem_back,255) ;

            _puticon (xsort,ysort,mem_sort,255);

            if (sort) _puticon (xvice,yversa,mem_S0,255); else _puticon (xvice,yversa,mem_S1,255);

            _puticon (xok,yok,mem_ok,255);

            _puticon(drax,dray,mem_drag,255);
            
            _puticon(xfo,yt-18,mem_fonter,255);
            
            _puticon(searx,seary,mem_search,255);

            bar=0; probar=0;
            mem_bar=malloc(imagesize(xb+1,ytepl,xb+10,ybarb));
            if (!mem_bar) {information(2-keyb_gr,NULL,NULL); goto FYGE ; }
            getimage(xb+1,ytepl,xb+10,ybarb,mem_bar); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ PISV APO BARA

            c=pano ;
            telos=(sort) ? c+1 : plbut-c;
            goto emfan ;
        }
        
        else if (probar) {
            
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}

    // KLIK STHN MPARA !!

        if (my1<bary1) {
            
            if ( (!pano) && (!sort) ) continue ;
            if ( (pano==plbut-1) && (sort) ) continue ;
            c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
            goto emfan;
        }
        
        if (my1>bary2) {
            
            if ( (kato==plbut-1) && (!sort) ) continue ;
            if ( (!kato) && (sort) ) continue ;         
            goto emfan;
            }
            
            fyge=0;
            
        do {

            y3=bary1 + (bary2-bary1+1)/2 ;
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           
        my= sdlev.button.y ;
        if (my>=ybarb) my=ybarb-1;
        if(my<=ytepl) my=ytepl+1;
        if (y3==my) continue;
        dy=my-y3;
    
            
        if (dy<0) {
            if (bary1==ytepl+1) continue;
            dy=abs(dy);
            
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1-dy; if (y1<=ytepl) y1=ytepl+1;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;    
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        else {
            if (bary2==ybarb-1) continue;
            setcolor (COLOR (0,0,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
            y1 = bary1+dy;
            y2=( ( (ybarb-ytepl-1)*lines) / plbut )+y1;
            if (y2>ybarb-1) { y2=ybarb-1; y1=y2- (((ybarb-ytepl-1)*lines) / plbut );}
            if (y1==y2) y2++;
            bary1=y1 ; bary2=y2;
            setcolor (COLOR (255,165,0) );  
            for (f=xb+2 ; f<xb+10 ; f++) {
                for (i=y1 ; i < y2; i++) _putpixel (f,i); }
            refresh();
        }
        
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        if ((!sort) && (pano==a1)) continue;
        else if ( (sort) && (pano==plbut-1-a1) ) continue ;
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1; 
        
    // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ ΕΝΩ ΠΑΙΖΩ ΜΕ ΜΠΑΡΑ
    _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
    k=0;

    if (!sort) {
        if (c<0) {c=0 ; telos=plbut;}
        else if ((c+lines-1)>plbut-1) {
            if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
        
    else if (sort) {
        if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
        else if ( (c-lines+1)<0 ) { 
            c=lines-1; telos=lines; 
            if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
    pano=c;
    do {                                           

        if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
        else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
        if (krit[ar_dom[c]]) {setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
        c+=bima ; telos--; k++;
        
    }while (telos && k<lines);

    setcolor(5);
    line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
    refresh();
    kato = (sort) ? c+1 : c-1;

        } while (sdlev.type!=SDL_MOUSEBUTTONUP && (!fyge) ) ; 
        
        fyge=0;
        dy=bary1-ytepl;
        a1=( dy*plbut)  / (ybarb-ytepl-1) ; // Σε πόσα στοιχεία αντιστοιχούν τα pixels
        telos=plbut-a1;
        if (!sort) c=a1; else c=plbut-a1-1;
        goto emfan ;        

        }
        
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
        
    case SDL_MOUSEWHEEL :
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
            if (protyx!=lines) {
            elem=proelem=-1 ; 
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}    
        
            if(sdlev.wheel.y > 0) // scroll up
        {
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-3*bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+3*bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
        }
        
         break;
        
    case SDL_KEYDOWN:
            if (mem_small) hide_help(hdhlpxt , hdhlpyt);
          if (protyx!=lines) {
            
            el= (sort) ? pano-protyx : pano+protyx;
            _bareacls(xtepl+1, ytepl+protyx*fhe,xtepr,ytepl+protyx*fhe+(fhe-2),bkxr);
            if (but[ar_dom[el]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+protyx*fhe , xtepr);
            else _outfanis_col(fnt, but[ar_dom[el]] , xtepl+10 , ytepl+protyx*fhe , xtepr);
            protyx=lines;
            refresh();}        
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ; 
               c = pano+bima ; telos=(sort) ? c+1 : plbut-c;
               goto emfan;
                
            case SDL_SCANCODE_UP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-bima; telos=(sort) ? c+1 : plbut-c;
                goto emfan;
                
            case SDL_SCANCODE_PAGEDOWN :
                elem=proelem=-1 ; 
                if ( (kato==plbut-1) && (!sort) ) continue ;
                if ( (!kato) && (sort) ) continue ;         
                goto emfan;
                
            case SDL_SCANCODE_PAGEUP :
                elem=proelem=-1 ; 
                if ( (!pano) && (!sort) ) continue ;
                if ( (pano==plbut-1) && (sort) ) continue ;
                c = pano-(bima*lines); telos=(sort) ? c+1 : plbut-c;
emfan :
                // ΔΙΑΡΚΗΣ ΠΑΡΟΥΣΙΑΣΗ
            _bareacls (xtepl,ytepl,xtepr,ybarb-1,bkxr);
            k=0;

            if (!sort) {
                if (c<0) {c=0 ; telos=plbut;}
                else if ((c+lines-1)>plbut-1) {
                    if ( (plbut-lines)>=0)  { c=plbut-lines ; telos=lines;} else {c=0 ; telos=plbut;} } }
                
            else if (sort) {
                if (c>plbut-1) {c=plbut-1 ; telos=plbut;}
                else if ( (c-lines+1)<0 ) { 
                    c=lines-1; telos=lines; 
                    if (plbut<lines) {c=plbut-1; telos=plbut; }}}
            
            sparky=0;        
            pano=c;
            do {                                           

                if (but[ar_dom[c]][0]==255)  _outfanis_col(fnt, keno , xtepl+10 , ytepl+k*fhe , xtepr);
                else {_outfanis_col(fnt, but[ar_dom[c]] , xtepl+10 , ytepl+k*fhe , xtepr);
                if (krit[ar_dom[c]]) {sparky=1; setrgbcolor (dbyel) ; line(xtepl+10,ytepl+k*fhe+(fhe-1),xtepr-1, ytepl+k*fhe+(fhe-1)); }}
                c+=bima ; telos--; k++;
                
            }while (telos && k<lines);

            setcolor(5);
            line(xtepl,ytepl+k*fhe+1,xtepr,ytepl+k*fhe+1);
            refresh();
            kato = (sort) ? c+1 : c-1;
            if (sparky) {pano_1=pano ; sort_1=sort ; key_1=key;} else sort_1=65000;

barovios :

                    if ( (!bar) ) {
                    if (!sort) {
                    proyt=pano ;
                    metektos = plbut-kato-1; 
                        }

                    else {
                    proyt=plbut-pano-1;
                    metektos=kato;
                        }
                    
                    if ( (!proyt) && (!metektos) ) continue ;
                    bar=1;
                    setcolor (COLOR (0,255,0) );  
                    rectangle (xb+1,ytepl,xb+10,ybarb);
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                    continue ;
                            }
                else
                                {
                                    
                    if (!sort) {
                    proyt1=pano ;
                    metektos1 = plbut-kato-1; 
                        }

                    else {
                    proyt1=plbut-pano-1;
                    metektos1=kato;
                        }
                    if ( (!proyt1) && (!metektos1) ) {
                    putimage (xb+1,ytepl,mem_bar,0);
                    bar=0; probar=0;
                    continue ;}
                    if (proyt1==proyt && metektos1==metektos) continue;
                    proyt=proyt1 ; metektos=metektos1;
                    setcolor (COLOR (0,0,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=ytepl+1 ; i < ybarb; i++) _putpixel (f,i); }
                    y1 = ( ( (ybarb-ytepl-1)*proyt) / plbut ); y1+= ytepl;
                    y2=( ( (ybarb-ytepl-1)*lines) / plbut ); y2+=y1;    
                    if (y1==y2) y2++;
                    bary1=y1 ; bary2=y2;
                    setcolor (COLOR (255,165,0) );  
                    for (f=xb+2 ; f<xb+10 ; f++) {
                        for (i=y1 ; i < y2; i++) _putpixel (f,i); }
                    refresh();
                                }
                        continue;                
          
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                if (elem!=-1) {
    
                    kati=ar_dom[elem];
                    f=0;
                    what=but[ar_dom[elem]][f];
                    while (what!=255) {
                    data[f]=what;
                    what=but[ar_dom[elem]][++f];
                    } 
                    data[f]=255;
                    mytext_toclipboard (data);
                }
               
                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        elem=proelem=-1 ; 
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
                
            case SDL_QUIT :
               fyge=1;
               kati=-2;
               continue;
    
     default :
         if (ektos==1) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
 do {
        SDL_PollEvent(&sdlev);} while ( (sdlev.type == SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) && (SDL_PollEvent(&sdlev)));
for (f=0;f<3;f++) {
    bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
}
if(mem0) fidicls(xt,yt1,xb,yb,bkxr[0],bkxr[1],bkxr[2]);
if(mem0) putimage(xt,yt1,mem0,0); //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
if (bar) putimage(xb+1,ytepl,mem_bar,0); 
if (mem_bar) free(mem_bar); 
if (ardom_mem) free(ardom_mem); 
if (mem_ok) free (mem_ok);
if(mem_ghost) free(mem_ghost );
if(mem_drag) free(mem_drag);
if (mem_search) free(mem_search);
if (mem_front) free(mem_front);
if (mem_fonter) free(mem_fonter);
if (mem_back) free(mem_back);
if (mem_del) free(mem_del);
if (mem_sort) free(mem_sort);
if (mem_S0) free(mem_S0);
if (mem_S1) free(mem_S1);
if (mem_desc) free(mem_desc);
if(mem0) free (mem0); if (mem_arrs) free(mem_arrs);
refresh();
gouv=whouv;
return kati ;
}



void _field_txt_show (int arped, char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,a,ar,elax,bh,ektos,maxline;
int diaf1,diaf2 ;
short int wrap ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , red, green, blue, neg ;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

xl++ ; yt++ ; xr-- ; yb--;
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,colbkxr);
if (!ptr_pedio[arped]->fitype) _bareacls (xr+2,yt-1,xr+11,yb,dbbkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; return; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
          
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
        green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
        blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
        
        if (!ptr_pedio[arped]->fitype) 
            {
            xr++;
            
            if (pos[0][1]<yt) {
                
            setrgbcolor(dbmag);
            line(xr+6,yt-1,xr+6,yt+10);
            line(xr+7,yt-1,xr+7,yt+10);
            line(xr+2,yt+3,xr+6,yt-1);
            line(xr+2,yt+4,xr+6,yt);
            line(xr+2,yt+5,xr+6,yt+1);
            line(xr+11,yt+5,xr+7,yt+1);
            line(xr+11,yt+4,xr+7,yt);
            line(xr+11,yt+3,xr+7,yt-1);
            
            }


                    
            if (pos[ar-1][1]>=ektos) {
            setrgbcolor(dbmag);
            line(xr+6,yb-10,xr+6,yb);
            line(xr+7,yb-10,xr+7,yb);
            line(xr+2,yb-6,xr+6,yb-2);
            line(xr+2,yb-5,xr+6,yb-1);
            line(xr+2,yb-4,xr+6,yb);
            line(xr+11,yb-6,xr+7,yb-2);
            line(xr+11,yb-5,xr+7,yb-1);
            line(xr+11,yb-4,xr+7,yb);
            }

        }
}



int proodos(char *str, int cur, int hm , int fun)

// Επιστρέφει 0 όταν υπάρχει έλλειψη μνήμης...
// Στον str περνάμε κανονικό κείμενο επικεφαλίδας !
// Στέλνουμε έναν δείκτη mem όπου διαφυλάττει την mem0 για να μπορεί στο τέλος να αποκαθιστά την οθόνη.
// Αν έχουμε μια λούπα που ξεκινάει από το 0 και τελειώνει στο 5000 for (f=0;f<5000;f++) ...τότε cur=με το κάθε φορά f... και hm=5000 !
// Αν ο fun=0 λειτουργεί κανονικά αλλιώς είτε αποκαθιστά οθόνη άμεσα , είτε δεν κάνει τίποτε !! 
// Αρχικά ο δείκτης mem να είναι 0 ! Μετά τον μηδενίζει η συνάρτηση κάθε φορά που πρέπει .

{

void *mem0=0;
static int sxed , vima ,ppl ,ypl , plus;
static int nxt,nyt,nyb ;
static int xt,yt ;
int paspro[3] , pblack[3] , pyellow[3];
int f , nxb , xb, yb , wid , cur1 ;


    if (fun) {
        mem0=pomem;
        if (mem0) {putimage(xt,yt,mem0,0); refresh(); pomem=0;}
        sxed=0;plus=0;
        return 0;
    }

    if (!hm) return 0;    
    
    if (!sxed) {
        

        mem0=malloc(imagesize(0,0,599,99));
        if (!mem0) {sxed=0; pomem=0; plus=0; return 0;}
        paspro[0]=paspro[1]=paspro[2]=255;
        pblack[0]=pblack[1]=pblack[2]=0;
        pyellow[0]=255 ; pyellow[1]=255 ; pyellow[2]=153 ;
        pomem=mem0;
        sxed=1;
        vima=1 ;
        xt=(info.right-info.left-599) / 2 ; yt=(info.bottom-info.top-99) / 2 ;
        xb=xt+599;
        yb=yt+99;
        getimage(xt,yt,xb,yb,mem0);

        setrgbcolor (dbred) ;
        rectangle (xt,yt,xb,yb);
        rectangle (xt+1,yt+1,xb-1,yb-1);
        setrgbcolor (dbaspro) ;
        rectangle (xt+2,yt+2,xb-2,yb-2);
        rectangle (xt+3,yt+3,xb-3,yb-3);
        setrgbcolor (dbblack) ;
        rectangle (xt+4,yt+4,xb-4,yb-4);
        rectangle (xt+5,yt+5,xb-5,yb-5);
        setrgbcolor (dbyel) ;
        rectangle (xt+6,yt+6,xb-6,yb-6);
        //refresh();
        _bareacls (xt+7, yt+7, xb-7, yt+48,pyellow) ;
        setrgbcolor (dbred) ;
        line (xt+8,yt+49,xb-7,yt+49);
        line (xt+8,yt+50,xb-7,yt+50);
        normtext_tomy(str,file_3);
        _outmystr_center_col(6, file_3 , xt+7, yt+7, xb-7, yt+48, pblack , pyellow);
        nxt=xt+7 ;
        nyt=yt+51; nxb=xb-7; nyb=yb-7 ;
        _bareacls(nxt,nyt,nxb,nyb,paspro);
        _outmystr_center_col(1, please_wait , nxt,nyt,nxb,nyb, pblack , paspro);
        wid=nxb-nxt+1 ;
        while ( ((vima*wid)/hm) < 1 ) vima++; 
        if (vima>1) { ypl= (vima*wid) % hm ; }
        else { ppl=wid/hm; ypl = wid % hm ; }
        refresh ();
        return 1;
    }
    
    cur1=cur;
    setrgbcolor (dbgreen);
    if (vima==1) {
        for (f=0;f<ppl;f++) {
            line (nxt,nyt,nxt,nyb);
            nxt++;
        }
        plus+=ypl;
        if (plus>=hm) {
            line (nxt,nyt,nxt,nyb);
            nxt++;
            plus-=hm;
        }
        refresh ();
    }
    else {
        cur++;
        cur = cur % vima ;
            if (!cur) {
                line (nxt,nyt,nxt,nyb);
                nxt++;
            
            plus+=ypl;
            if (plus>=hm) {
                line (nxt,nyt,nxt,nyb);
                nxt++;
                plus-=hm;
            }
            refresh();
        }
    }
       
    
    if (cur1==hm-1) {
        mem0=pomem;
        if (mem0) {putimage(xt,yt,mem0,0); refresh();}
        sxed=0;plus=0;
        pomem=0;
        return 3;
    }
    else return 2;
}



void _nofield_txt_show (char *str , unsigned short int cur, short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,a,ar,elax,bh,ektos,maxline;
int diaf1,diaf2 ;
short int wrap ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , red, green, blue, neg ;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

xl++ ; yt++ ; xr-- ; yb--;
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,colbkxr);

ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; return; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
          
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
        green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
        blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
}



double anal_parast(short int arped, unsigned char *algebra , short int *problem , short int diskos)
// Πρέπει να είναι ενήμερος ο πίνακας empl_mem - συνεπώς προηγείται η κλήση της συνάρτησης check_pediaola_math()
// Η παράσταση έρχεται αρχικά σε δικό μου στυλ χαρακτήρων μέσω κάποιας συνάρτησης input
// To arped είναι ο πραγματικός αριθμός πεδίου που ισχύει σε όλη τη βάση δεδομένων.
// Στον πίνακα algebra είναι το αλφαριθμητικό της παράστασης.
// Όταν ο diskos=1 δεν κάνει έλεγχο σε κάποια στοιχεία....διότι έχει ήδη εγκριθεί η αλφαριθμητική παράσταση.
// problem=1 σημαίνει ότι , δεν υπήρχε τίποτε έγκυρο ή ήταν ένα άδειο string ή δεν είχε διαθέσιμη μνήμη !
// problem=2 Συντακτικό σφάλμα
// problem=3 μπέρδεμα τελεστών
// problem=4 Εσφαλμένη χρήση παρενθέσεων
// problem=5  Απαγορευμένη αλληλοσυσχέτιση πεδίων !! 
// problem=6 αριθμός με πολλά ψηφία > 14
// problem=7 για τον υπολογισμό του πεδίου Χ , ο χρήστης εμπλέκει στην παράσταση και το ίδιο το πεδίο Χ !!
// problem=8 Υπολογιστική αδυναμία !
// problem=9 Συσχέτιση με πεδίο που δεν υπάρχει !
// problem=10 Συσχέτιση με πεδίο μη αριθμητικό ! 
// problem=12 Λανθασμένη συσχέτιση με άγνωστο πεδίο υπολογισμών. 
// problem=13 Συσχέτιση με πεδίο υπολογισμών χωρίς αλγεβρική παράσταση! 

{

register int f,i ;
unsigned char what , what1;
int l , dx ;
void *mem_ier=0;
double kati=0 ;
short int paa=0 , pak=0 , posar=0 ;
short int a , b , hook=0 , ypd ;
unsigned char parped[6] , parnum[16];
short int fiopagk , laclagk , inopagk , inclagk ;
char apagor[100];
short int apa , inoptimi ;
unsigned char *keimk_1;

    if (!algebra) {*problem=1 ; return 0 ;}
    i=0; 
    *problem=0;
    while (algebra[i] != 255) i++;
    if (!i) {*problem=1 ; return 0 ;}
    l=i;
    i=0;
    // Αρχικός έλεγχος εγκυρότητας - αφαίρεση κενών , τελειών και Enter !

    what=algebra[i];
    while (what!=255) {
        if ( (what>7) && (what<26) ) { i++; what=algebra[i]; continue ; }
        if ( (what==3) || (what==5) || (what==36) || (what==48) || (what==74) ){ i++; what=algebra[i]; continue ; }
        if (!i && what==29) {
            for (f=i;f<l;f++) { algebra[f]=algebra[f+1]; }
            l--; 
            what=algebra[i];
        }
        else if ( (!what) || (what==14) || (what==200) ) {
            for (f=i;f<l;f++) { algebra[f]=algebra[f+1]; }
            l--; 
            what=algebra[i];
        }
        else {*problem=2 ; return 0 ;}
    }
    if (!l) {*problem=1 ; return 0 ;}
    
    
    if (!diskos)
    {
        // Ειδικοί έλεγχοι
        // Έλεγχος μπερδεμένων τελεστών
        if (l==1) {
            what=algebra[0];
            if (what>2 && what<16) {*problem=3 ; return 0 ;}
            if (what==36 || what==48 || what==74) {*problem=3 ; return 0 ;}
        }
        i=0;
        while (i+1<l) {
            what=algebra[i];
            what1=algebra[i+1];
            
            switch (what) {
                case 11 : // +
                    if (what1==what || what1==13 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36 ) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 13 : // -
                    if (what1==what || what1==11 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    break;
                    
                case 10 :  // *
                    if (what1==what || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 15 : // διαίρεση
                    if (what1==what || what1==5 || what1==12 || what1==10 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 5 : // %
                    if ( what1==what || what1==12 || what1==8 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if ( what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if ( what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 36 : // ^
                    if (what1==what || what1==5) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 48 : // f
                    if (what1==what || what1==74 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 74 : // F
                    if (what1==what || what1==48 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 8 : // (
                    if (what1==5 || what1==9 || what1==10 || what1==12 || what1==15 || what1==36) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 9 : // )
                    if (what1==8 || what1==12 || what1==3)  {*problem=3 ; return 0 ;}
                    if (what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if (what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 12 : // ,
                    if (what1==5 || what1==36 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 3 : // # Τετραγωνική Ρίζα
                    if (what1==what || what1==5 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                default : // κάποιος αριθμός
                    if (what1==8 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
            }
            i++;
        }
        
        // Έλεγχος για εσφαλμένη αρχή ..
        what=algebra[0];
        if (what==5 || what==9 || what==10 || what==12 || what==15 || what==36) {*problem=3 ; return 0 ;}
        
        // Έλεγχος για εσφαλμένο τέλος ..
        what=algebra[l-1];
        if (what==8 || what==10 || what==11 || what==12 || what==13 || what==15 || what==36 || what==48 || what==74 || what==3) {*problem=3 ; return 0 ;}    
    }

    
    //Προετοιμασία-καθαρισμός της δομής prst
    
    for (f=0 ; f<1024 ; f++) {
        prst[f].sths=0;
        prst[f].agk=0;
        prst[f].steos=-1;
        prst[f].field=-1;
    }
    
// Ελεγχος πεδίων που εξαρτώνται δυναμικά από το arped και για τα οποία απαγορεύεται η αντίστροφη εξάρτηση !
    apa=0;
    apagor[apa]=-1;
    if (empl_mem) {
        i=0; a=0;
        while (empl_mem[i]!=-2) i++;
        if (i) {
            a=i;
            for (f=0; f<a ; f++) {
                if (empl_mem[f]==arped) {
                    if (empl_mem[f-1] == -1) {
                        i=f;
                        while (empl_mem[i]>=0) i++;
                        if (empl_mem[i]==-2) break;
                        f=i; continue;
                    }
                    i=f-1;
                    while (empl_mem[i] != -1) i--;
                    what=0;
                    for (dx=0; dx<apa ; dx++) {
                        if ( empl_mem[i+1] == apagor[dx] ) {what=1; break;} 
                    }
                    if (!what) {
                        apagor[apa] = empl_mem[i+1] ;
                        apa++;
                    }
                    i=f;
                    while (empl_mem[i]>=0) i++;
                    if (empl_mem[i]==-2) break;
                    f=i; continue;
                }
            }
        }
    }
    
    // Μεταφορά στοιχείων από algebra στη δομή prst και μεταφορά τυχόν αριθμών στον πίνακα ier
    i=0;a=0;
    while (i<l) {
        what=algebra[i];
        
        switch (what) {
            case 3: // # sqrt
                prst[a].sths='#';
                a++; i++;
                break ;
            
            case 5: // %
                prst[a].sths='%';
                a++; i++;
                break ;
                
            case 8 : // (
                paa++;
                if (!paa) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=paa;
                a++; i++;
                break ;
            
            case 9 : // )
                pak = -paa ;
                paa--;
                if (!pak) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=pak;
                a++; i++;
                break ;
                
            case 10 : // *
                prst[a].sths='*';
                a++; i++;
                break ;
                
            case 11 : // +
                prst[a].sths='+';
                a++; i++;
                break ;
                
            case 13 : // -
                prst[a].sths='-';
                a++; i++;
                break ;
                
            case 15 : // διαίρεση
                prst[a].sths='/';
                a++; i++;
                break ;
                
            case 36 : // ^
                prst[a].sths='^';
                a++; i++;
                break ;
                
            case 48:  // f
            case 74:  // F
                i++;
                f=0; dx=0;
                while(i<l && f<3) {
                    what=algebra[i];
                    if (!f && what<17 && what>25) {*problem=2 ; goto FYGE ;}
                    if (!f && what>16 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ; dx++;
                    }
                    else if ((f) && what>15 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ;dx++;
                    }
                    else break ;
                }
                if (!dx) {*problem=2 ; goto FYGE ;}
                dx=0;
                if (f<3) {
                    if (what==3 || what==8 || what==12 || what==48 || what==74) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=algebra[i];
                    if (what1>15 && what1<26) {*problem=2 ; goto FYGE ;}
                    if (what1==3 || what1==8 || what1==12 || what1==48 || what1==74) {*problem=2 ; goto FYGE ;}
                }
                parped[f]=255;
                b = (short int) convert_str(f , parped);
                b--;
                if (b>dbfinum) {*problem=9 ; dx=1 ;}
                else if (ptr_pedio[b]->fitype!=3 && ptr_pedio[b]->fitype!=4) {*problem=10 ;dx=1 ;}
                else if (arped == b) {*problem=7 ; dx=1 ;}
                else if  (ptr_pedio[b]->mathtype) {
                    if (!alg_str[b]) {*problem=11 ; dx=1 ;}
                    else if (alg_str[b][0]==255) {*problem=12 ; dx=1 ;}
                } 
                
                for (f=0 ; f<apa ; f++) {
                    if ( b == apagor[f] ) {*problem=5 ; goto FYGE ;}
                }
                prst[a].field = b ; 
                
                prst[a].steos = posar ;
                posar++;
                
                if (posar==1) {mem_ier=malloc (sizeof(double));}
                else mem_ier=realloc (mem_ier,posar*sizeof(double));
                if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                ier = mem_ier ;
                if ( (xmemk) && (!dx) ) {  
                    keimk_1=memk[b];
                    if (keimk_1[0]==255) ier[posar-1] = 0 ;
                    else {ier[posar-1] = convert_str(ptr_pedio[prst[a].field]->fiorio , keimk_1);}
                }
                else  { ier[posar-1] = 0 ; }
                dx=0; a++;
                break ;
                
            default : // Κάποιος αριθμός
                f=0;
                parnum[f]=what;
                i++; ypd=0;
                while(i<l && f<13) {
                    what=algebra[i];
                    if ((what>15 && what<26) || (what==12) ) {
                        f++;
                        parnum[f]=what;
                        if (what==12) ypd++;
                        i++ ;
                    }
                    else break ;
                }
                f++; parnum[f]=255;
                if (f<14) {
                    if (what==3 || what==8 || what==48 || what==74) {*problem=3 ; goto FYGE ;}
                    if (ypd>1) {*problem=2 ; goto FYGE ;}
                    if (ypd==1 && parnum[f-1]==12) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=algebra[i];
                    if (what1>15 && what1<26) {*problem=6 ; goto FYGE ;}
                    if (what1==12) {*problem=3 ; goto FYGE ;}
                    if (what1==48 || what1==74 || what1==8 || what1==3) {*problem=3 ; goto FYGE ;}
                }
                prst[a].steos = posar ;
                posar++;
                if (posar==1) mem_ier=malloc (sizeof(double));
                else mem_ier=realloc (mem_ier,posar*sizeof(double));
                if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                ier = mem_ier ;
                ier[posar-1] = convert_str(f , parnum);
                a++;
        }
    }
    
    if (paa) {*problem=4 ; goto FYGE ;}
    maxprst=a;
    
    
    // Αφαίρεση τυχόν παρενθέσεων
    
    f=0;
    if (hook) {
        while (f<maxprst) {
            
            if (!prst[f].agk) {f++; continue ;}
            fiopagk=f;
            inoptimi=1;
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) { 
                if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                i++; 
            }
                        
            while (inoptimi>1) {
                f=inopagk+1;
                while (prst[f].agk != (-inoptimi) ) f++;
                inclagk=f;
                // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα inopagk - inclagk)
                dx = calc_rem_agk (inopagk , inclagk , 1);
                if (dx<0) {*problem=8 ; goto FYGE ;}
                hook-=2;
                i=fiopagk+1;
                inoptimi=1;
                while ( prst[i].agk != (-1) ) { 
                    if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                    i++; 
                }
            }
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) i++;
            laclagk=i;
            // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα fiopagk - laclagk
            dx = calc_rem_agk (fiopagk , laclagk , 1);
            if (dx<0) {*problem=8 ; goto FYGE ;}
            f=0 ;
        } // telos while (f<maxprst)
        
    } // telos if hook
 
 // ΥΠΟΛΟΓΙΣΜΟΣ ΑΘΡΟΙΣΜΑΤΟΣ
    
    dx = calc_rem_agk (0 , maxprst , 0);
    if (dx<0) {*problem=8 ; goto FYGE ;}
    
    
    kati = ier[prst[0].steos];
    
    
    //if (prst[0].sths=='-') kati = -1*kati ;
    
    if (kati == HUGE_VAL) {
    kati=0; *problem=8;
    }
 
FYGE :
if (mem_ier) free(mem_ier);
mem_ier=0;
return kati ;
    
}


int calc_rem_agk (short int start , short int telos, short int hook)
{
register int f , i ;
short int a ;

    for (f=start ; f<telos ; f++) {
        
        if (prst[f].sths=='#') {
            if (ier[prst[f+1].steos] < 0) return -1;
            ier[prst[f+1].steos] = sqrt (ier[prst[f+1].steos]);
            for (i=f ; i<maxprst-1 ; i++) {
                prst[i].sths = prst[i+1].sths ;
                prst[i].agk = prst[i+1].agk ;
                prst[i].steos = prst[i+1].steos ;
                prst[i].field = prst[i+1].field ;
            }
        maxprst--;
        telos--;
        }
    }

    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='%') {
            ier[prst[f-1].steos] /= 100;
            for (i=f ; i<maxprst-1 ; i++) {
                prst[i].sths = prst[i+1].sths ;
                prst[i].agk = prst[i+1].agk ;
                prst[i].steos = prst[i+1].steos ;
                prst[i].field = prst[i+1].field ;
            }
        maxprst--;
        telos--;
        f-- ;
        }
    }
        
       
    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='^') {
            if ( !ier[prst[f-1].steos] && ier[prst[f+1].steos]<=0 ) {
                
                return -1;
            }
            ier[prst[f-1].steos] = pow( ier[prst[f-1].steos] ,ier[prst[f+1].steos] );
            if (ier[prst[f-1].steos] == HUGE_VAL) {
                return -1;
            }
            for (i=f ; i<maxprst-2 ; i++) {
                prst[i].sths = prst[i+2].sths ;
                prst[i].agk = prst[i+2].agk ;
                prst[i].steos = prst[i+2].steos ;
                prst[i].field = prst[i+2].field ;
            }
        maxprst-=2;
        telos-=2;
        f--;
        }
    }
    

    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='*') {
            ier[prst[f-1].steos] *= ier[prst[f+1].steos];
            if (ier[prst[f-1].steos] == HUGE_VAL) {
                return -1;
            }
            for (i=f ; i<maxprst-2 ; i++) {
                prst[i].sths = prst[i+2].sths ;
                prst[i].agk = prst[i+2].agk ;
                prst[i].steos = prst[i+2].steos ;
                prst[i].field = prst[i+2].field ;
            }
        maxprst-=2;
        telos-=2;
        f--;
        }
    }
        
        
    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='/') {
            if (!ier[prst[f+1].steos]) {
                
                return -1;
            }
            ier[prst[f-1].steos] /= ier[prst[f+1].steos];
            for (i=f ; i<maxprst-2 ; i++) {
                prst[i].sths = prst[i+2].sths ;
                prst[i].agk = prst[i+2].agk ;
                prst[i].steos = prst[i+2].steos ;
                prst[i].field = prst[i+2].field ;
            }
        maxprst-=2;
        telos-=2;
        f--;
        }
    }
        

    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='-') {
            a=0;
            if (!f) a=1 ; 
            else if (f) {
                if (prst[f-1].agk) a=1;
            }     
            if (a) {
                ier[prst[f+1].steos] *= -1 ;
                for (i=f ; i<maxprst-1 ; i++) {
                    prst[i].sths = prst[i+1].sths ;
                    prst[i].agk = prst[i+1].agk ;
                    prst[i].steos = prst[i+1].steos ;
                    prst[i].field = prst[i+1].field ;
                }
                
            maxprst--;
            telos--;
            continue ;
            }
            else {
        
                ier[prst[f-1].steos] -= ier[prst[f+1].steos] ;
                if (ier[prst[f-1].steos] == HUGE_VAL) {
                    return -1;
                }
                for (i=f ; i<maxprst-2 ; i++) {
                    prst[i].sths = prst[i+2].sths ;
                    prst[i].agk = prst[i+2].agk ;
                    prst[i].steos = prst[i+2].steos ;
                    prst[i].field = prst[i+2].field ;
                }
                
            maxprst-=2;
            telos-=2;
            f--;
            }
        }
    }
        
        
    for (f=start ; f<telos ; f++) {
        if (prst[f].sths=='+') {
            a=0;
            if (!f) a=1 ; 
            else if (f) {
                if (prst[f-1].agk) a=1;
            }     
            if (a) {
                            
                for (i=f ; i<maxprst-1 ; i++) {
                    prst[i].sths = prst[i+1].sths ;
                    prst[i].agk = prst[i+1].agk ;
                    prst[i].steos = prst[i+1].steos ;
                    prst[i].field = prst[i+1].field ;
                }
                
            maxprst--;
            telos--;
            continue ;
            }
        
            ier[prst[f-1].steos] += ier[prst[f+1].steos] ;
            if (ier[prst[f-1].steos] == HUGE_VAL) {
                return -1;
            }
            for (i=f ; i<maxprst-2 ; i++) {
                prst[i].sths = prst[i+2].sths ;
                prst[i].agk = prst[i+2].agk ;
                prst[i].steos = prst[i+2].steos ;
                prst[i].field = prst[i+2].field ;
            }
            
        maxprst-=2;
        telos-=2;
        f--;
        }
    }
    
    // ΑΠΑΛΟΙΦΗ ΠΑΡΕΝΘΕΣΕΩΝ ΑΝ ΥΠΑΡΧΟΥΝ - ΥΠΟΛΟΓΙΣΜΟΣ ΑΘΡΟΙΣΜΑΤΟΣ
    
    if (hook) {
        
        dfx=0;
        for (f=start+1 ; f<telos ; f++) {
            dfx += ier[prst[f].steos] ;  
        }
        if (dfx==HUGE_VAL) {dfx=0; return -1;}
        
        i=start;
        ier [prst[i+1].steos] = dfx;
        prst[i].sths = 0 ;
        prst[i].agk = 0 ;
        prst[i].steos = prst[i+1].steos;
        prst[i].field = -1 ;
        
        a=telos-start;
        
        
        for (i=start+1 ; i<maxprst-a ; i++) {
            prst[i].sths = prst[i+a].sths ;
            prst[i].agk = prst[i+a].agk ;
            prst[i].steos = prst[i+a].steos ;
            prst[i].field = prst[i+a].field ;
        }
        maxprst-=a;

    }
    else {
        dfx=0;
        for (f=start ; f<telos ; f++) {
            dfx += ier[prst[f].steos] ;  
        }
        if (dfx==HUGE_VAL) {return -1;}
        ier[prst[0].steos] = dfx ;
        dfx=0;
    }
    
    return 1;
}


int check_orio_write_mathped(short int arped, short int orio, short int eggr)
// Έχει προηγουμένως υπολογιστεί ο dfx και ο alg_err με τον αναλυτή παραστάσεων !!
// Χρησιμοποιεί την str1kb
// Το όριο είναι το ptr_pedio[arped]->fiorio
// Αν ο eggr==1 κάνει κανονικά ενημέρωση του πεδίου . Αν ο eggr==0 δεν ενημερώνει το πεδίο.
// Επιστρέφει 1 αν το όριο αριθμού χαρακτήρων του πεδίου είναι οκ και χωράει το αποτέλεσμα afx το οποίο πρέπει να έχει υπολογισθεί πριν την κλήση της συνάρτησης. Ειδάλλως επιστρέφει -1. Όταν επιστρέφει -1, το πεδίο γίνεται κενό (αν ο eggr==1).
{

register int i,f ;
unsigned char w;
unsigned char *leimk=0;
int i1;

    if (eggr && xmemk) leimk=memk[arped];
    if (alg_err>0 && alg_err<9  && leimk) { leimk[0]=255; return -1; }
    posmax=0;
    negmax=0;
    bigd=1;
    
    if (dfx>0) {
        
        for (f=0;f<orio;f++){
            posmax+=(9*bigd);
            bigd*=10;
        }
        if (dfx>posmax) {
            if (leimk ) leimk[0]=255; 
            return -2; 
        }
    }
    else {
        if (orio==1) return -2;
        for(f=0; f<orio-1;f++) {
            negmax-=(9*bigd);
            bigd*=10;
        }
        if (dfx<negmax) {
            if (leimk) leimk[0]=255; 
            return -2; 
        }
    }

    if (leimk ) {
        if (ptr_pedio[arped]->fitype==3) {
            lfx = (long int) dfx;
            sprintf(str1kb,"%ld",lfx);
            normtext_tomy(str1kb,0);
            f=0;
            w=str1kb[f];
            while (w!=255){
                w=str1kb[++f];
            }
            i1=f;
            for (i=0;i<i1;i++) {
                w=str1kb[i];
                if (w==13) continue;
                if (w>15 && w<26) continue;
                for (f=i ; f<i1 ; f++) {
                    str1kb[f]=str1kb[f+1];
                }
                i1--;
                i--;
            }
        }
        else if (ptr_pedio[arped]->fitype==4) {
            sprintf(str1kb,"%.2lf",dfx);
            normtext_tomy(str1kb,0);
            f=0;
            w=str1kb[f];
            while (w!=255){
                w=str1kb[++f];
            }
            i1=f;
            str1kb[f-3]=12;
            for (i=0;i<i1;i++) {
                w=str1kb[i];
                if (w==13 || w==12) continue;
                if (w>15 && w<26) continue;
                for (f=i ; f<i1 ; f++) {
                    str1kb[f]=str1kb[f+1];
                }
                i1--;
                i--;
            }
        }
        
        mystrcpy_lim(leimk,str1kb,orio);
    }
    return 1;
}


int check_pediaola_math()
// Προηγείται το διάβασμα των alg_str[]
// Ενημέρωση του πίνακα empl_mem που αφορά στα εμπλεκόμενα πεδία για κάθε πεδίο τύπου mathtype
// Αρχική ενημέρωση του πίνακα prot_calc με εκείνα τα πεδία mathtype που δεν εξαρτώνται από τίποτε ! Υπόψη καθολική μεταβλητή roca.
// Ενημερώνει την enmath !!

{

register int f,i ;
unsigned char *nalgebra;
unsigned char what ;
int l , dx ;
short int a , b , c , d;
unsigned char parped[6] ;
void *mem1 ;
unsigned int p ;

    if (empl_mem) {mem1=empl_mem; free(mem1);}
    empl_mem=0; empl_size=1024 ; 
    mem1=malloc(empl_size);
    if (!mem1) {return -1;}
    empl_mem=mem1;
    p=0; enmath=0; roca=0;
    
    for (f=0 ; f<=dbfinum ; f++) {
        if (!ptr_pedio[f]->mathtype) continue ;
        enmath++;
        i=0;
        if (alg_str[f]) {
            while (alg_str[f][i] != 255) i++;
        }
        if (!i) {continue ;}
        l=i;
        c=0;
        // Αφαίρεση κενών , τελειών και Enter !
        nalgebra=alg_str[f];
        what=nalgebra[c];
        while (what!=255) {
            if (!c && what==29) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else if ( (!what) || (what==14) || (what==200) ) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else { c++; what=nalgebra[c];}
        }
        
        i=0; a=0;
        
        while (i<l) {
            what=nalgebra[i];
            
            if (what==48 || what==74) {

                    i++;
                    c=0; dx=0;
                    while(i<l && c<3) {
                        what=nalgebra[i];
                        
                        if (what>15 && what<26) {
                            parped[c]=what;
                            i++ ; c++ ;
                        }
                        else break ;
                    }

                    parped[c]=255;
                    if (!c) {continue;}
                    b = (short int) convert_str(c , parped);
                    b--;
                    if (b>dbfinum) { dx=1 ;}
                    else if (ptr_pedio[b]->fitype!=3 && ptr_pedio[b]->fitype!=4) { dx=1 ; }
                    else if (f == b) { dx=1; }
                    else if (ptr_pedio[b]->mathtype) {
                        if (!alg_str[b]) dx=1;
                    }
                    else if (!ptr_pedio[b]->mathtype) dx=1;
                    
                    if (!dx) {
                        if ( (empl_size-p)<104 ) {
                            mem1=empl_mem;
                            empl_size += 512;
                            mem1=realloc(mem1,empl_size);
                            if (!mem1) {return -1;}
                            empl_mem=mem1;
                        }
                        if (!a) { empl_mem[p++]=-1; empl_mem[p++]=f; a=1; }
                        empl_mem[p++] = b ;
                    }
                       
                }
            else { i++ ; }
        }
        if (!a) {
            d=0;
            for (i=0 ; i<roca ; i++) {
                if (f==prot_calc[i]) {d=1; break;}
            }
            if (!d) {
                prot_calc[roca]=f;
                roca++;
            }
        }
    }
    empl_mem[p]=-2;
    return 1;
}



int proter_calc_pedivn() // Προτεραιότητα υπολογισμού των mathtype πεδίων !
// Να έχει προηγουμένως ενημερωθεί ο πίνακας empl_mem  (Συνάρτηση check_pediaola_math() )
// Επιστρέφει -1 αν δεν υπάρχουν mathtype πεδία !
// Αν επιστρέψει αρνητική τιμή σημαίνει ότι δεν υπάρχει κάποια προτεραιότητα ούτε αλληλεξαρτήσεις
// Επιστρέφει 1 αν όλα είναι οκ 
// Ολοκληρώνει την ενημέρωση του πίνακα prot_calc και καθορίζει τη μεταβλητή enmath_1
{
    
register int i,f ;
short int a, d , y , z , ro=0 ;
char ch , ch1 ;
char elegx[100];

    if(!enmath) return -1;
    if (!empl_mem) return -1 ;
    z=roca;
    a=0; y=0; 
    while (empl_mem[a] != -2) {
        ch = empl_mem[a];
        if (ch>=0) {
            d=0;
            for (i=0 ; i < roca ; i++) {
                if (ch==prot_calc[i]) {d=1;break;}
            }
            if (d) {a++ ; continue ;}
            
            for (f=0;f<y;f++) {
                if (ch==elegx[f]) {d=1; break ;}
            }
            if (!d) { elegx[y]=ch; y++; } 
        }
        a++;
    }
    
    enmath_1=y; 
    //y=0;
    
    if (a) {
        
        ch=elegx[0] ; // mathtype field που είναι ίσο με ....
               
        while (ro!=enmath_1) {      
            for (f=a;f>=0;f--) {
                if (empl_mem[f]==ch) {
                    if (empl_mem[f-1]==-1) { // το βρήκαμε το elegx[ro]
                        i=f+1;
                        ch1=empl_mem[i]; // ελέγχω το πρώτο σχετιζόμενο... 
                        
                        while (ch1>=0) { // sxetizomeno pedio ch1
                            
                            d=0;
                            for (y=0 ; y < roca ; y++) {
                                if (ch1==prot_calc[y]) {d=1;break;}
                            }
                            if (d) {i++ ; ch1=empl_mem[i]; continue;}
                            else { ch=ch1; f=a; break ; }
                        }
                        
                        if (f==a) {continue ;}
                        
                        // ..ώσπου να φθάσουμε σε -1
                        d=0;
                        for (y=0 ; y < roca ; y++) {
                            if (ch==prot_calc[y]) {d=1;break;}
                        }
                        if (!d) {prot_calc[roca]=ch; roca++; ro++; }
                    }
                }
            }
            
           
            if (ro==enmath_1) break ;
            
            for (f=0;f<enmath_1;f++) {
                d=0;
                for (i=0; i<roca; i++) {
                    if (elegx[f]==prot_calc[i]) {d=1; break ;}
                }
                if (!d) { ch=elegx[f]; break ; }
            }
            
            if (d) break ;
        }
    }
    enmath_1 += z; return 1;
}
            


void zero_pediaola_math(short int arped)
// Τα alg_str[] να μην έχουν πειραχθεί και το dbfinum να μην έχει μειωθεί !!
// arped είναι το προς διαγραφή πεδίο

{

register int f,i ;
unsigned char *nalgebra ;
unsigned char what ;
short int l ;
short int b , c , d ,x ;
unsigned char parped[6] ;

    
    for (f=0 ; f<=dbfinum ; f++) {
        if (f==arped) continue;
        if (!ptr_pedio[f]->mathtype) continue ;
        i=0;
        if (alg_str[f]) {
            while (alg_str[f][i] != 255) i++;
        }
        if (!i) {continue ;}
        l=i;
        c=0;
        // Αφαίρεση κενών , τελειών και Enter !
        nalgebra = alg_str[f] ;
        what=nalgebra[c];
        while (what!=255) {
            if (!c && what==29) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else if ( (!what) || (what==14) || (what==200) ) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else { c++; what=nalgebra[c];}
        }
        
        i=0;
        
        while (i<l) {
            what=nalgebra[i];
            
            if (what==48 || what==74) {
                
                    x=i;
                    i++;
                    c=0; 
                    while(i<l && c<3) {
                        what=nalgebra[i];
                        
                        if (what>15 && what<26) {
                            parped[c]=what;
                            i++ ; c++ ;
                        }
                        else break ;
                    }
                    if (!c) {nalgebra[x]=16 ; continue ;}
                    parped[c]=255;
                    b = (short int) convert_str(c , parped);
                    b--;
                    if (b!=arped) {continue ;}
                    nalgebra[x]=16 ;
                    
                    for (d=x+1 ; d<l-c+1 ; d++) {nalgebra[d]=nalgebra[d+c];}
                    l-=c;
                    i-=c;
            }
            else {i++;}
        }
    }
}


void meion_pediaola_math(short int arped)
// Τα alg_str[] να μην έχουν πειραχθεί (όχι μετακίνηση) και το dbfinum να είναι ακόμη το παλιό !!
// Εκτελείται πρώτα η συνάρτηση μηδενισμού zero_pediaola_math (arped)
// arped είναι ο αριθμός του πεδίου που θα διαγραφεί (από 0 έως...)

{

register int f,i ;
unsigned char *nalg ;
unsigned char what ;
short int l ;
short int b , c , d ,x ,a ;
unsigned char parped[6] ;

    
    for (f=0 ; f<=dbfinum ; f++) {
        if (f==arped) continue;
        if (!ptr_pedio[f]->mathtype) continue ;
        i=0;
        if (alg_str[f]) {
            while (alg_str[f][i] != 255) i++;
        }
        if (!i) {continue ;}
        l=i;
        c=0;
        // Αφαίρεση κενών , τελειών και Enter !
        nalg = alg_str[f] ;
        what=nalg[c];
        while (what!=255) {
            if (!c && what==29) {
                for (i=c;i<l;i++) { nalg[i]=nalg[i+1]; }
                l--; 
                what=nalg[c];
            }
            else if ( (!what) || (what==14) || (what==200) ) {
                for (i=c;i<l;i++) { nalg[i]=nalg[i+1]; }
                l--; 
                what=nalg[c];
            }
            else { c++; what=nalg[c];}
        }
        
        i=0;
        
        while (i<l) {
            what=nalg[i];
            
            if (what==48 || what==74) {
                
                x=i;
                i++;
                c=0; 
                while(i<l && c<3) {
                    what=nalg[i];
                    
                    if (what>15 && what<26) {
                        parped[c]=what;
                        i++ ; c++ ;
                    }
                    else break ;
                }
                if (!c) {nalg[x]=16 ; continue ;}
                parped[c]=255;
                b = (short int) convert_str(c , parped);
                if (b>arped+1) {
                    b--;
                    if (b<9) {
                       nalg[x+1]=16+b;
                       continue ;
                    }
                    else if (b==9) {
                        nalg[x+1]=25;
                        for (d=x+2; d<l ; d++) { nalg[d]=nalg[d+1]; }
                        l--;
                        i--;
                        continue ;
                    }
                    else if (b>9 && b<99) {
                        a = b%10;
                        nalg[x+2]=16+a;
                        a = b/10;
                        nalg[x+1]=16+a;
                        continue ;
                    }
                    else {
                        nalg[x+1]=nalg[x+2]=25;
                        for (d=x+3; d<l ; d++) { nalg[d]=nalg[d+1]; }
                        l--;
                        i--;
                        continue ;
                    }
                }
            }
            else {i++;}
        }
    }
}



double anal_parast_rem (short int arped, unsigned char *algebra , short int *problem , short int arped_rem)
// unsigned char *Nemk

{

register int f,i ;
unsigned char what , what1;
int l , dx ;
void *mem_ier=0;
double kati=0 ;
short int paa=0 , pak=0 , posar=0 ;
short int a , b , hook=0 , ypd ;
unsigned char parped[6] , parnum[16];
short int fiopagk , laclagk , inopagk , inclagk , op ;
char apagor[100];
short int apa , inoptimi ;
unsigned char *keimk_1;

    if (!algebra) {*problem=1 ; return 0 ;}
    i=0; 
    *problem=0;
    while (algebra[i] != 255) i++;
    if (!i) {*problem=1 ; return 0 ;}
    l=i;
    i=0;
    // Αρχικός έλεγχος εγκυρότητας - αφαίρεση κενών , τελειών και Enter !

    what=algebra[i];
    while (what!=255) {
        if ( (what>7) && (what<26) ) { i++; what=algebra[i]; continue ; }
        if ( (what==3) || (what==5) || (what==36) || (what==48) || (what==74) ){ i++; what=algebra[i]; continue ; }
        if (!i && what==29) {
            for (f=i;f<l;f++) { algebra[f]=algebra[f+1]; }
            l--; 
            what=algebra[i];
        }
        else if ( (!what) || (what==14) || (what==200) ) {
            for (f=i;f<l;f++) { algebra[f]=algebra[f+1]; }
            l--; 
            what=algebra[i];
        }
        else {*problem=2 ; return 0 ;}
    }
    if (!l) {*problem=1 ; return 0 ;}
    
    
        // Ειδικοί έλεγχοι
        // Έλεγχος μπερδεμένων τελεστών
        if (l==1) {
            what=algebra[0];
            if (what>2 && what<16) {*problem=3 ; return 0 ;}
            if (what==36 || what==48 || what==74) {*problem=3 ; return 0 ;}
        }
        i=0;
        while (i+1<l) {
            what=algebra[i];
            what1=algebra[i+1];
            
            switch (what) {
                case 11 : // +
                    if (what1==what || what1==13 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36 ) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 13 : // -
                    if (what1==what || what1==11 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    break;
                    
                case 10 :  // *
                    if (what1==what || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 15 : // διαίρεση
                    if (what1==what || what1==5 || what1==12 || what1==10 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 5 : // %
                    if ( what1==what || what1==12 || what1==8 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if ( what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if ( what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 36 : // ^
                    if (what1==what || what1==5) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 48 : // f
                    if (what1==what || what1==74 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 74 : // F
                    if (what1==what || what1==48 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 8 : // (
                    if (what1==5 || what1==9 || what1==10 || what1==12 || what1==15 || what1==36) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 9 : // )
                    if (what1==8 || what1==12 || what1==3)  {*problem=3 ; return 0 ;}
                    if (what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if (what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 12 : // ,
                    if (what1==5 || what1==36 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 3 : // # Τετραγωνική Ρίζα
                    if (what1==what || what1==5 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                default : // κάποιος αριθμός
                    if (what1==8 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
            }
            i++;
        }
        
        // Έλεγχος για εσφαλμένη αρχή ..
        what=algebra[0];
        if (what==5 || what==9 || what==10 || what==12 || what==15 || what==36) {*problem=3 ; return 0 ;}
        
        // Έλεγχος για εσφαλμένο τέλος ..
        what=algebra[l-1];
        if (what==8 || what==10 || what==11 || what==12 || what==13 || what==15 || what==36 || what==48 || what==74 || what==3) {*problem=3 ; return 0 ;}    

    
    //Προετοιμασία-καθαρισμός της δομής prst
    
    for (f=0 ; f<1024 ; f++) {
        prst[f].sths=0;
        prst[f].agk=0;
        prst[f].steos=-1;
        prst[f].field=-1;
    }
    
// Ελεγχος πεδίων που εξαρτώνται δυναμικά από το arped και για τα οποία απαγορεύεται η αντίστροφη εξάρτηση !
    apa=0;
    apagor[apa]=-1;
    if (empl_mem) {
        i=0; a=0;
        while (empl_mem[i]!=-2) i++;
        if (i) {
            a=i;
            for (f=0; f<a ; f++) {
                if (empl_mem[f]==arped) {
                    if (empl_mem[f-1] == -1) {
                        i=f;
                        while (empl_mem[i]>=0) i++;
                        if (empl_mem[i]==-2) break;
                        f=i; continue;
                    }
                    i=f-1;
                    while (empl_mem[i] != -1) i--;
                    what=0;
                    for (dx=0; dx<apa ; dx++) {
                        if ( empl_mem[i+1] == apagor[dx] ) {what=1; break;} 
                    }
                    if (!what) {
                        apagor[apa] = empl_mem[i+1] ;
                        apa++;
                    }
                    i=f;
                    while (empl_mem[i]>=0) i++;
                    if (empl_mem[i]==-2) break;
                    f=i; continue;
                }
            }
        }
    }
    
    // Μεταφορά στοιχείων από algebra στη δομή prst και μεταφορά τυχόν αριθμών στον πίνακα ier
    i=0;a=0;
    while (i<l) {
        what=algebra[i];
        
        switch (what) {
            case 3: // # sqrt
                prst[a].sths='#';
                a++; i++;
                break ;
            
            case 5: // %
                prst[a].sths='%';
                a++; i++;
                break ;
                
            case 8 : // (
                paa++;
                if (!paa) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=paa;
                a++; i++;
                break ;
            
            case 9 : // )
                pak = -paa ;
                paa--;
                if (!pak) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=pak;
                a++; i++;
                break ;
                
            case 10 : // *
                prst[a].sths='*';
                a++; i++;
                break ;
                
            case 11 : // +
                prst[a].sths='+';
                a++; i++;
                break ;
                
            case 13 : // -
                prst[a].sths='-';
                a++; i++;
                break ;
                
            case 15 : // διαίρεση
                prst[a].sths='/';
                a++; i++;
                break ;
                
            case 36 : // ^
                prst[a].sths='^';
                a++; i++;
                break ;
                
            case 48:  // f
            case 74:  // F
                i++;
                f=0; dx=0;
                while(i<l && f<3) {
                    what=algebra[i];
                    if (!f && what<17 && what>25) {*problem=2 ; goto FYGE ;}
                    if (!f && what>16 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ; dx++;
                    }
                    else if ((f) && what>15 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ;dx++;
                    }
                    else break ;
                }
                if (!dx) {*problem=2 ; goto FYGE ;}
                dx=0;
                if (f<3) {
                    if (what==3 || what==8 || what==12 || what==48 || what==74) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=algebra[i];
                    if (what1>15 && what1<26) {*problem=2 ; goto FYGE ;}
                    if (what1==3 || what1==8 || what1==12 || what1==48 || what1==74) {*problem=2 ; goto FYGE ;}
                }
                parped[f]=255;
                b = (short int) convert_str(f , parped);
                b--;
                op = (b>=arped_rem) ? 1 : 0 ;
                if (b>dbfinum-1) {*problem=9 ; dx=1 ;}
                else if (ptr_pedio[b+op]->fitype!=3 && ptr_pedio[b+op]->fitype!=4) {*problem=10 ;dx=1 ;}
                else if (arped == b) {*problem=7 ; dx=1 ;}
                else if  (ptr_pedio[b+op]->mathtype) {
                    if (!alg_str[b]) {*problem=11 ; dx=1 ;}
                    else if (alg_str[b][0]==255) {*problem=12 ; dx=1 ;}
                } 
                
                for (f=0 ; f<apa ; f++) {
                    if ( b == apagor[f] ) {*problem=5 ; goto FYGE ;}
                }
                prst[a].field = b ; 
                
                prst[a].steos = posar ;
                posar++;
                if ( !dx ) {
                    if (posar==1) {mem_ier=malloc (sizeof(double));}
                    else mem_ier=realloc (mem_ier,posar*sizeof(double));
                    if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                    ier = mem_ier ;
                    keimk_1=Nemk[b];
                    if (keimk_1[0]==255) ier[posar-1] = 0 ;
                    else {ier[posar-1] = convert_str(ptr_pedio[b+op]->fiorio , keimk_1);}
                }
                else  { ier[posar-1] = 0 ; }
                dx=0; a++;
                break ;
                
            default : // Κάποιος αριθμός
                f=0;
                parnum[f]=what;
                i++; ypd=0;
                while(i<l && f<13) {
                    what=algebra[i];
                    if ((what>15 && what<26) || (what==12) ) {
                        f++;
                        parnum[f]=what;
                        if (what==12) ypd++;
                        i++ ;
                    }
                    else break ;
                }
                f++; parnum[f]=255;
                if (f<14) {
                    if (what==3 || what==8 || what==48 || what==74) {*problem=3 ; goto FYGE ;}
                    if (ypd>1) {*problem=2 ; goto FYGE ;}
                    if (ypd==1 && parnum[f-1]==12) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=algebra[i];
                    if (what1>15 && what1<26) {*problem=6 ; goto FYGE ;}
                    if (what1==12) {*problem=3 ; goto FYGE ;}
                    if (what1==48 || what1==74 || what1==8 || what1==3) {*problem=3 ; goto FYGE ;}
                }
                prst[a].steos = posar ;
                posar++;
                if (posar==1) mem_ier=malloc (sizeof(double));
                else mem_ier=realloc (mem_ier,posar*sizeof(double));
                if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                ier = mem_ier ;
                ier[posar-1] = convert_str(f , parnum);
                a++;
        }
    }
    
    if (paa) {*problem=4 ; goto FYGE ;}
    maxprst=a;
    
    
    // Αφαίρεση τυχόν παρενθέσεων
    
    f=0;
    if (hook) {
        while (f<maxprst) {
            
            if (!prst[f].agk) {f++; continue ;}
            fiopagk=f;
            inoptimi=1;
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) { 
                if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                i++; 
            }
                        
            while (inoptimi>1) {
                f=inopagk+1;
                while (prst[f].agk != (-inoptimi) ) f++;
                inclagk=f;
                // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα inopagk - inclagk)
                dx = calc_rem_agk (inopagk , inclagk , 1);
                if (dx<0) {*problem=8 ; goto FYGE ;}
                hook-=2;
                i=fiopagk+1;
                inoptimi=1;
                while ( prst[i].agk != (-1) ) { 
                    if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                    i++; 
                }
            }
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) i++;
            laclagk=i;
            // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα fiopagk - laclagk
            dx = calc_rem_agk (fiopagk , laclagk , 1);
            if (dx<0) {*problem=8 ; goto FYGE ;}
            f=0 ;
        } // telos while (f<maxprst)
        
    } // telos if hook
 
 // ΥΠΟΛΟΓΙΣΜΟΣ ΑΘΡΟΙΣΜΑΤΟΣ
    
    dx = calc_rem_agk (0 , maxprst , 0);
    if (dx<0) {*problem=8 ; goto FYGE ;}
    
    
    kati = ier[prst[0].steos];
    
    
    //if (prst[0].sths=='-') kati = -1*kati ;
    
    if (kati == HUGE_VAL) {
    kati=0; *problem=8;
    }
 
FYGE :
if (mem_ier) free(mem_ier);
mem_ier=0;
return kati ;
    
}



int check_orio_write_math_rem(short int arped, short int eggr, short int arped_rem)
// unsigned char *Nemk
// Έχει προηγουμένως υπολογιστεί ο dfx και ο alg_err με τον αναλυτή παραστάσεων !!
// Χρησιμοποιεί την str1kb
// Το όριο είναι το ptr_pedio[arped]->fiorio
// Αν ο eggr==1 κάνει κανονικά ενημέρωση του πεδίου . Αν ο eggr==0 δεν ενημερώνει το πεδίο.
// Επιστρέφει 1 αν το όριο αριθμού χαρακτήρων του πεδίου είναι οκ και χωράει το αποτέλεσμα afx το οποίο πρέπει να έχει υπολογισθεί πριν την κλήση της συνάρτησης. Ειδάλλως επιστρέφει -1. Όταν επιστρέφει -1, το πεδίο γίνεται κενό (αν ο eggr==1).
{

register int i,f ;
unsigned char w;
unsigned char *leimk=0;
int i1;
short int op;
short int orio ;

    if (eggr) {
        leimk=Nemk[arped];
        op = (arped>=arped_rem) ? 1 : 0 ;
        orio = ptr_pedio[arped+op]->fiorio ;
    }
    if (alg_err>0 && alg_err<9  && leimk) { leimk[0]=255; return -1; }
    posmax=0;
    negmax=0;
    bigd=1;
    
    if (dfx>0) {
        
        for (f=0;f<orio;f++){
            posmax+=(9*bigd);
            bigd*=10;
        }
        if (dfx>posmax) {
            if (leimk ) leimk[0]=255; 
            return -1; 
        }
    }
    else {
        if (orio==1) return -1;
        for(f=0; f<orio-1;f++) {
            negmax-=(9*bigd);
            bigd*=10;
        }
        if (dfx<negmax) {
            if (leimk) leimk[0]=255; 
            return -1; 
        }
    }

    if (leimk ) {
        
        if (ptr_pedio[arped+op]->fitype==3) {
            lfx = (long int) dfx;
            sprintf(str1kb,"%ld",lfx);
            normtext_tomy(str1kb,0);
            f=0;
            w=str1kb[f];
            while (w!=255){
                w=str1kb[++f];
            }
            i1=f;
            for (i=0;i<i1;i++) {
                w=str1kb[i];
                if (w==13) continue;
                if (w>15 && w<26) continue;
                for (f=i ; f<i1 ; f++) {
                    str1kb[f]=str1kb[f+1];
                }
                i1--;
                i--;
            }
        }
        else if (ptr_pedio[arped+op]->fitype==4) {
            sprintf(str1kb,"%.2lf",dfx);
            normtext_tomy(str1kb,0);
            f=0;
            w=str1kb[f];
            while (w!=255){
                w=str1kb[++f];
            }
            i1=f;
            str1kb[f-3]=12;
            for (i=0;i<i1;i++) {
                w=str1kb[i];
                if (w==13 || w==12) continue;
                if (w>15 && w<26) continue;
                for (f=i ; f<i1 ; f++) {
                    str1kb[f]=str1kb[f+1];
                }
                i1--;
                i--;
            }
        }
        
        mystrcpy_lim(leimk,str1kb,orio);
    }
    return 1;
}


int check_pediaola_rem_math(short int arped)
// arped : το προς διαγραφή πεδίο
// Προηγείται το διάβασμα των alg_str[]
// Ενημέρωση του πίνακα empl_mem που αφορά στα εμπλεκόμενα πεδία για κάθε πεδίο τύπου mathtype
// Αρχική ενημέρωση του πίνακα prot_calc με εκείνα τα πεδία mathtype που δεν εξαρτώνται από τίποτε ! Υπόψη καθολική μεταβλητή roca.
// Ενημερώνει την enmath !!

{

register int f,i ;
unsigned char *nalgebra;
unsigned char what ;
int l , dx ;
short int a , b , c , d , tr=0, op ;
unsigned char parped[6] ;
void *mem1 ;
unsigned int p ;

    if (empl_mem) {mem1=empl_mem; free(mem1);}
    empl_mem=0; empl_size=1024 ; 
    mem1=malloc(empl_size);
    if (!mem1) {return -1;}
    empl_mem=mem1;
    p=0; enmath=0; roca=0;
    
    for (f=0 ; f<dbfinum ; f++) {
        tr = (f>=arped) ? 1 : 0 ;
        if (!ptr_pedio[f+tr]->mathtype) continue ;
        enmath++;
        i=0;
        if (alg_str[f]) {
            while (alg_str[f][i] != 255) i++;
        }
        if (!i) {continue ;}
        l=i;
        c=0;
        // Αφαίρεση κενών , τελειών και Enter !
        nalgebra=alg_str[f];
        what=nalgebra[c];
        while (what!=255) {
            if (!c && what==29) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else if ( (!what) || (what==14) || (what==200) ) {
                for (i=c;i<l;i++) { nalgebra[i]=nalgebra[i+1]; }
                l--; 
                what=nalgebra[c];
            }
            else { c++; what=nalgebra[c];}
        }
        
        i=0; a=0;
        
        while (i<l) {
            what=nalgebra[i];
            
            if (what==48 || what==74) {

                    i++;
                    c=0; dx=0;
                    while(i<l && c<3) {
                        what=nalgebra[i];
                        
                        if (what>15 && what<26) {
                            parped[c]=what;
                            i++ ; c++ ;
                        }
                        else break ;
                    }

                    parped[c]=255;
                    if (!c) {continue;}
                    b = (short int) convert_str(c , parped);
                    b--;
                    if (b>dbfinum-1) { dx=1 ;}
                    op = (b>=arped) ? 1 : 0 ;
                    if (ptr_pedio[b+op]->fitype!=3 && ptr_pedio[b+op]->fitype!=4) { dx=1 ; }
                    else if (f == b) { dx=1; }
                    else if ( ptr_pedio[b+op]->mathtype) {
                        if (!alg_str[b]) dx=1;
                    }
                    else if ( ! ptr_pedio[b+op]->mathtype) { dx=1; }
                    
                    if (!dx) {
                        if ( (empl_size-p)<104 ) {
                            mem1=empl_mem;
                            empl_size += 512;
                            mem1=realloc(mem1,empl_size);
                            if (!mem1) {return -1;}
                            empl_mem=mem1;
                        }
                        if (!a) { empl_mem[p++]=-1; empl_mem[p++]=f; a=1; }
                        empl_mem[p++] = b ;
                    }
                }
            else { i++ ; }
        }
        if (!a) {
            d=0;
            for (i=0 ; i<roca ; i++) {
                if ( f == prot_calc[i] ) {d=1; break;}
            }
            if (!d) {
                prot_calc[roca]=f;
                roca++;
            }
        }
    }
    empl_mem[p]=-2;
    return 1;
}


/*
int proter_calc_pedivn_rem (short int arped) // Προτεραιότητα υπολογισμού των mathtype πεδίων !
// Να έχει προηγουμένως ενημερωθεί ο πίνακας empl_mem  (Συνάρτηση check_pediaola_math() )
// Επιστρέφει -1 αν δεν υπάρχουν mathtype πεδία !
// Αν επιστρέψει αρνητική τιμή σημαίνει ότι δεν υπάρχει κάποια προτεραιότητα ούτε αλληλεξαρτήσεις
// Επιστρέφει 1 αν όλα είναι οκ 
// Ολοκληρώνει την ενημέρωση του πίνακα prot_calc και καθορίζει τη μεταβλητή enmath_1
// arped : το προς διαγραφή
{
    
register int i,f ;
int a , b , ro=0 ;
short int d,y,z,op;
char ch , ch1, ch2 ;
char elegx[100];

    if(!enmath) return -1;
    if (!empl_mem) return -1 ;
    for (f=0;f<100;f++) elegx[f]=-1;
    z=roca;
    i=0; y=0; 
    while (empl_mem[i] != -2) {
        ch = empl_mem[i];
        if (ch>=0) {
            op = (ch>=arped) ? 1 : 0 ;
            if (!ptr_pedio[ch+op]->mathtype) {i++; continue;}
            d=0;
            for (f=0;f<y;f++) {
                if (ch==elegx[f]) {d=1; break ;}
            }
            if (!d) { elegx[y]=ch; y++; } 
        }
        i++;
    }
        
    enmath_1=y;
        
    if (i) {
        
        a=i;       
        i=1;
        ch=empl_mem[i]; // mathtype field
        i++;       
        
        while (ro!=enmath_1) {
            ch1=empl_mem[i]; // Πεδίo εξάρτησης του πεδίου ch ή -1 ή -2
            if ( ch1 >= 0 ) {
                op = (ch1>=arped) ? 1 : 0 ;
                if (ptr_pedio[ch1+op]->mathtype) {
                    d=0;
                    for (f=0; f<roca; f++) {
                        if (ch1==prot_calc[f]){ d=1; break; }
                    }
                    if (!d) {
                        ch2=ch;
                        ch=ch1;
                        y=0;
                        for (f=a;f>=0;f--) {
                            if (empl_mem[f]==ch) {
                                if (empl_mem[f-1]==-1) {
                                    i=f+1;
                                    y=1;
                                    break ;
                                }
                            }
                        }
                        if (!y)  // Σημαίνει ότι το ch1 δεν έχει συσχετιστεί με πεδίο - έχει απλά μια τιμή , αλλά το ch2 έχει συσχετιστεί με το ch1 !
                        { 
                            d=0;
                            for (f=0;f<roca;f++) {
                                if (ch1==prot_calc[f]) {d=1; break;}
                            }
                            if (!d) {
                            prot_calc[roca]=ch1; roca++; ro++; 
                            if (ro==enmath_1) break; }
                            i++; 
                            ch=ch2; 
                            continue; 
                        }
                            
                        else continue ;
                    }
                    else { i++; continue; }
                }
                else {i++ ; continue; }
            }
            else {
                d=0;
                for (f=0;f<roca;f++) {
                    if (ch==prot_calc[f]) {d=1; break;}
                }
                if (!d) { 
                    prot_calc[roca]=ch; roca++; ro++;}
                if (ro==enmath_1) break;
                
                i=0;
                
                do {
                    i++;
                    ch=empl_mem[i]; // mathtype field
                    d=0;
                    for (f=0; f<roca; f++) {
                        if (ch==prot_calc[f]) { d=1; break; }
                    }
                    i++;
                    if (d) {
                        while (i<a) { if (empl_mem[i]>=0) i++; else break ;}
                    }
                } while (d);
            }
        }
    }
    else { return -1; }
    enmath_1 += z;
    return 1;
}
*/


void _alg_txt_show (unsigned char *str , short int xl , short int yt , short int xr , short int yb , unsigned short int orio , int *colchxr, int  *colbkxr , int *algbkxr)
{
    
SDL_Cursor* cursor;
register int i,f ;
unsigned short int x,y,x1,y1,a,ar,elax,bh,ektos,maxline;
int diaf1,diaf2 ;
short int wrap , cur = 0 ;
unsigned short int wherp ;
unsigned char what ;
int mx , my , red, green, blue, neg ;
int *mem_int ;
int pos[orio+1][2] ;

union whatcols{
unsigned int lor ;
unsigned char rgb[4];
} co ;


elax=gouv[0].wid;
bh=gouv[0].hei;
for (f=1;f<164;f++) {
    if (bh<gouv[f].hei) bh=gouv[f].hei;
    if (elax > gouv[f].wid) continue ; else elax=gouv[f].wid;}

xl++ ; yt++ ; xr-- ; yb--;
diaf1=yb-yt+1; diaf2=diaf1/bh;maxline=diaf2; ektos=yt+(diaf2*bh);
_bareacls (xl,yt,xr,yb,colbkxr);
_bareacls (xr+2,yt-1,xr+11,yb,algbkxr);
ar=0;wherp=0;


elax=(xr-xl)/elax;

x1=x=xl ; y1=y=yt ;

//ELEGXOS TOY ALFARIUMHTIKOY str kai parousiash tou keimenou //

            // ELEGXOS !! 

        what=str[0];
        if (what==255) {cur=0 ; return; }

        f=0; diaf2=0;
        while ( (what!=255) && (orio-f) ) {
        if (what==200) {f++;what=str[f];continue;}
        if ( (what>=0) && (what<164) ) {f++;what=str[f];continue;}
        diaf2=1; break; 
            } 
        str[f]=255; diaf1=f;
        ar=diaf1;
        if (ar>orio) ar=orio;
        if (cur>=ar) cur=ar-1;
                     
       // ΕΣΩΤΕΡΙΚΗ ΑΝΑΔΙΑΤΑΞΗ       

        for (a=0; a<ar; a++) {
        what=str[a];
        if (what==200) { pos[a][0]=x1 ; pos[a][1]=y1 ; x1=xl ; y1+=bh; continue ;}
        wrap=0 ;  
        if ((x1+gouv[what].wid) > xr-2) {
            if ( (what) ) {  
                i=a;
                while ( (str[i]) && (str[i]!=200) ) {if (!i) {wrap=1; break;} else wrap++; i--;}
                i++;wrap--;
                if (elax<wrap+1) wrap=0;}
                x1=xl ; y1+=bh; }
        
        do {
        pos[a-wrap][0]=x1 ; pos[a-wrap][1]=y1 ;
        what=str[a-wrap];
            x1+=gouv[what].wid;
            wrap--;
            } while (wrap>=0);
        }
            str[ar]=255 ;
            pos[ar][0]=x1 ; pos[ar][1]=y1;
            // for (f=ar+1;f<orio;f++) {pos[f][0]=-1 ; pos[f][1]=-1;}  (έχει ήδη γίνει αυτό)
            // ΝΕΑ ΕΜΦΑΝΙΣΗ

        if (cur) {
            f=0;
            while (pos[cur-f][0] !=xl)  f++;
            diaf1=pos[cur-f][1]-yt;
            for (i=0;i<=ar;i++) pos[i][1]-=diaf1;
            wherp=cur-f;
            }
            
          
       
        for (a=wherp; a<ar; a++) {
        what=str[a];
            
        if (what==200) continue ;
        x1=pos[a][0]; y1=pos[a][1];
        if (y1>=ektos) break ;
        mem_int=gouv[what].where ;
        for(f=0; f<gouv[what].hei ; f++) {
        for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) continue;
        neg=255-co.rgb[0];
        red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
        green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
        blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x1+i , y1+f);}}
        }
        
            xr++;
            
            if (pos[0][1]<yt) {
                
            setrgbcolor(dbmag);
            line(xr+6,yt-1,xr+6,yt+10);
            line(xr+7,yt-1,xr+7,yt+10);
            line(xr+2,yt+3,xr+6,yt-1);
            line(xr+2,yt+4,xr+6,yt);
            line(xr+2,yt+5,xr+6,yt+1);
            line(xr+11,yt+5,xr+7,yt+1);
            line(xr+11,yt+4,xr+7,yt);
            line(xr+11,yt+3,xr+7,yt-1);
            
            }


                    
            if (pos[ar-1][1]>=ektos) {
            setrgbcolor(dbmag);
            line(xr+6,yb-10,xr+6,yb);
            line(xr+7,yb-10,xr+7,yb);
            line(xr+2,yb-6,xr+6,yb-2);
            line(xr+2,yb-5,xr+6,yb-1);
            line(xr+2,yb-4,xr+6,yb);
            line(xr+11,yb-6,xr+7,yb-2);
            line(xr+11,yb-5,xr+7,yb-1);
            line(xr+11,yb-4,xr+7,yb);
            }

        
}



int alg_help (unsigned char *ptralg , short int arped)
// Καλεί τον αναλυτή αριθμητικών παραστάσεων - δείχνει όλα τα αριθμητικά πεδία με τον α/α τους !

// Eπιστρέφει 1 αν πατηθεί οκ !

{
register int f,i ;
short int inpxt, inpyt , inpxb, inpyb , repxt, repyt , repxb, repyb;
SDL_Cursor* cursor;
struct fansouv *trampa1 , *trampa ;
void *mem0=0 , *mem_go=0 , *mem_yes=0, *mem_arrs =0 ,*mem_zer=0 , *mem_plh=0 , *mem1 ;
short int xb, yb , yo ;
unsigned char what ;
char b;
short int yesxt,yesyt,yesxb,yesyb,goxt,goyt,goxb,goyb,arrsxt,arrsyt,fiext,fieyt,fiexb,fieyb , plhxt, plhyt  ;
int mx,my,mx1, my1, xt1, yt1, xb1, yb1, fyge=0 , dx ;
unsigned int size ;
int choxr_w[3], chobkxr[3] ;
int chochxr[3] ; 
int efchxr[3] , efbkxr[3], efslxr[3] ;
int smabkxr[3] , numbkxr[3], mathbkxr[3] , smachxr[3], numchxr[3] ;
int notchxr[3] , notbkxr[3] ;
//unsigned char mystr[1024];
short int loop=1 , ektos=1 , yes=0, cancel=0 , marrs=0, inptex=0 , plhr=0 ;
short int ds=60 , ke=2 , d , u  , aptxt, aptyt , aptxb, aptyb ;
short int c , hhei , bw = 240 , bh = 21 ;
unsigned char localg[1026];
int or_prob ;
int inpx, inpy, inpx1, inpy1 ;
static short int xt,yt ;


 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

//dx=check_pediaola_math();
//if (dx<0) return -1;
mystrcpy (localg,ptralg);
c=0;
for (f=0 ; f<=dbfinum ; f++) {
    if (f==arped) continue ;
    if (ptr_pedio[f]->fitype==3 || ptr_pedio[f]->fitype==4) c++;
}
u = (c%4) ? 1 : 0 ;
d = c/4;
hhei = 140 + (d*22) + (u*22) + 55 ;
if (!xt && !yt) {
    xt=(info.right-info.left-999) / 2 ; yt=(info.bottom-info.top-hhei) / 2 ;
}
else {
    while (yt+hhei > info.bottom-50) yt--;
}
xb=xt+999; yb=yt+hhei-1;
size=imagesize(xt,yt,xb,yb);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0); return -1;}
trampa=gouv;
getimage(xt,yt,xb,yb,mem0);


    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 

    choxr_w[0]=255; choxr_w[1]=255;  choxr_w[2]=255;
// smabkxr[3] , numbkxr[3], mathbkxr[3] , smachxr[3], numchxr[3]
    smabkxr[0]=36 ; smabkxr[1]=15 ; smabkxr[2]=48 ;
    smachxr[0]=62 ; smachxr[1]=228 ; smachxr[2]=83 ;
    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    mathbkxr[0] = 79; mathbkxr[1] = 205; mathbkxr[2] = 202 ;
    notchxr[0] = 14 ; notchxr[1] = 27 ; notchxr[2] = 41 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 128 ;
 
    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    refresh();

    // Μεταφορέας
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/hand_17.ico");
    mem_arrs=icontomem(file_1,255);
    if (!mem_arrs) {information(2-keyb_gr,file_1,NULL); goto FYGE;} 


    // Yes : 35 Χ 35
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Sym_OK_35.ico");
    mem_yes= icontomem (file_1,255);
    if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    // Cancel : 94 Χ 36
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_40.ico");
    mem_go = icontomem (file_1,255);
    if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/Info_25.ico");
    mem_plh=icontomem(file_1,255);
    if (!mem_plh) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }
    
    // SYNTETAGMENES
    arrsxt = xt+9 ; arrsyt = yt+8 ;
    inpxt=xt+9; inpyt=yt+36; inpxb=xb-25; inpyb=inpyt+70;
    inpx = inpxt; inpy=inpyt ; inpx1=inpxb; inpy1=inpyb ;
    repxt=inpxt+150 ; repyt = inpyb+3; repyb=repyt+27; repxb=xb-9;
    yesxt = xb-50; yesyt=goyt=yb-42;
    yesxb = yesxt+35; yesyb=goyb=yesyt+36;
    goxt=xt+12; goxb=goxt+96;
    plhxt=goxb+5; plhyt=yesyt+5;
    aptxt=plhxt+60 ; aptxb=yesxt-35; aptyt=plhyt; aptyb=aptyt+27;
    yo=repyb+5;

    _puticon(yesxt,yesyt,mem_yes,255);
    _puticon(goxt,goyt,mem_go,255);
    _puticon(arrsxt,arrsyt,mem_arrs,255);
    _puticon(plhxt,plhyt,mem_plh,255);

    refresh();
    c=0;
    for (f=0; f<=dbfinum; f++) {
        if (f==arped) continue ;
        b=ptr_pedio[f]->fitype;
        if (b!=3 && b!=4) continue ;
        b=ptr_pedio[f]->mathtype;
        d=c/4;
        u=c%4;
        c++;
        fiext=inpxt+u*bw+u*ke;
        fiexb=fiext+bw;
        fieyt=yo+2+d*bh+d;
        fieyb = fieyt+bh;
        
        setcolor (2);
        rectangle (fiext,fieyt,fiexb,fieyb);
        line (fiext+ds , fieyt, fiext+ds , fieyb);
        sprintf(str1kb,"F%d",f+1);
        normtext_tomy (str1kb,0);


            _bareacls (fiext+1,fieyt+1, fiext+ds-1, fieyb-1, smabkxr);
            _outmystr_center_col(3, str1kb , fiext+1,fieyt+1, fiext+ds-1, fieyb-1, smachxr, smabkxr);
                
            if (b) {_bareacls (fiext+ds+1,fieyt+1, fiexb-1, fieyb-1, mathbkxr);
            _outmystr_center_col(3, ptr_pedio[f]->finame ,fiext+ds+1,fieyt+1, fiexb-1, fieyb-1, numchxr, mathbkxr);
            }
            else {_bareacls (fiext+ds+1,fieyt+1, fiexb-1, fieyb-1, numbkxr);
            _outmystr_center_col(3, ptr_pedio[f]->finame , fiext+ds+1,fieyt+1, fiexb-1, fieyb-1, numchxr, numbkxr);
            }
        
    }

    //refresh();
    
    //EPIKEFALIDA
    mytext_tonorm (ptr_pedio[arped]->finame , str1kb,60);
    if (keyb_gr) sprintf (str1024,"Επεξεργαστής Αριθμ. Παράστασης για F%d : %s" , arped+1, str1kb );
    else sprintf (str1024,"Νumer. Description Analyst for F%d : %s",arped+1, str1kb);
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt+8, yt+7, xb-8, yt+34, chochxr , chobkxr);
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    
    //Παρατηρήσεις
    if (keyb_gr) strcpy (str1024,"ΑΝΑΦΟΡΑ :");
    else strcpy (str1024,"REPORT :");
    normtext_tomy (str1024,0);
    _outmystr_col (7,str1024, inpxt  , repyt , repxb , chochxr , chobkxr);
    
    setcolor(2);
    rectangle (inpxt,inpyt,inpxb,inpyb);
    //_bareacls(inpxt+1 , inpyt+1 , inpxb-1 , inpyb-1 , numchxr);
    refresh ();
    trampa1 = gouv ;
    gouv=myfont[7];
    _alg_txt_show (localg , inpxt , inpyt , inpxb , inpyb ,1024 , choxr_w, numchxr, chobkxr );
    gouv=trampa1;
    dfx = proanal_parast (arped, localg , &alg_err );
    or_prob = check_orio_write_mathped(arped, ptr_pedio[arped]->fiorio, 0);
    
    strcpy (str1kb,alg_prob[alg_err]);
    if (or_prob==-2){
        if (keyb_gr) strcat (str1kb , " / Εκτός ορίων πεδίου..");
        else strcat (str1kb , " / Οut of limits..");
    } 
    normtext_tomy (str1kb,0);
    _outmystr_col(7, str1kb , repxt  , repyt , repxb , chochxr , chobkxr);
    refresh();
    
    if (!alg_err>0 || alg_err>8) {
    
        if (ptr_pedio[arped]->fitype==3) {
            lfx = (long int) dfx;
            sprintf(str1kb,"F%d = %ld",arped+1, lfx);
        }
        else if (ptr_pedio[arped]->fitype==4) {
            sprintf(str1kb,"F%d = %.2lf", arped+1,dfx);
        }

        normtext_tomy (str1kb,0) ; 
        setcolor (3) ;
        rectangle (aptxt, aptyt,aptxb,aptyb);
        _bareacls (aptxt+1, aptyt+1,aptxb-1,aptyb-1,choxr_w);
         _outmystr_center_col(7, str1kb , aptxt+1, aptyt+1,aptxb-1,aptyb-1, numchxr , choxr_w );
         refresh();
    }
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor); 

    do {

    if (!SDL_PollEvent(&sdlev)) continue;
            switch (sdlev.type) {
            
            case SDL_MOUSEMOTION:
            while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
            mx=sdlev.motion.x ; my=sdlev.motion.y;
    
        if (mx>inpxt && mx<inpxb && my>inpyt && my<inpyb) {

            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); hide_help(hdhlpxt , hdhlpyt);}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (plhr) {plhr=0 ; puticon(plhxt,plhyt,mem_plh,255);}
            
            if (inptex) continue ;
            inptex=1;
            setcolor(1);
            rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1);
            refresh();
            continue ;
        }
        
        if (inptex) {inptex=0; setcolor(2); rectangle(inpxt,inpyt,inpxb,inpyb); rectangle(inpxt-1,inpyt-1,inpxb+1,inpyb+1); refresh ();}
        
        if (mx>yesxt && mx<yesxb && my>yesyt && my<yesyb) {
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                ektos=0;
            }
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            else if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (plhr) {plhr=0 ; puticon(plhxt,plhyt,mem_plh,255);}
            
            if (yes) continue ;
            yes=1;
            putNOTicon(yesxt,yesyt,mem_yes);
            if (keyb_gr) show_help("ΠΡΟΣΟΧΗ : Μετά από εδώ, κλικ στο \"ΥΕΣ\" για να επέλθει τυχόν μεταβολή!", yesxt, yesyt-20 , &hdhlpxt , &hdhlpyt) ;
            else show_help("NOTE : After here, click on \"ΥΕΣ\" to save any change!", yesxt, yesyt-20 , &hdhlpxt , &hdhlpyt) ;
            continue ;
        }
        
        if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); hide_help(hdhlpxt , hdhlpyt);}
        
        
        if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
            
            if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
            }
            
            if (marrs) {
            marrs=0;
            puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (plhr) {plhr=0 ; puticon(plhxt,plhyt,mem_plh,255);}
            
            if (cancel) continue ;
            cancel=1;
            putNOTicon(goxt,goyt,mem_go);
            continue ;
        }
        
        
        if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
      
    if (mx>arrsxt && mx<arrsxt+18 && my>arrsyt && my<arrsyt+18) {
        
        if (ektos) {
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
        }
        
        if (plhr) {plhr=0 ; puticon(plhxt,plhyt,mem_plh,255);}
        
        if (!marrs) {
        marrs=1;
        putNOTicon(arrsxt,arrsyt,mem_arrs);
        if (keyb_gr) show_help("Μετακίνηση παραθύρου", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
        else show_help("Move the window", arrsxt, arrsyt+18 , &hdhlpxt , &hdhlpyt) ;
        continue ;}
        else continue ;
        
    }
    
        if (marrs) {
        marrs=0;
        puticon(arrsxt,arrsyt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
        
        
    if (mx>plhxt && mx<plhxt+25 && my>plhyt && my<plhyt+18) { // Info
        
        if (ektos) {
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ektos=0;
        }
        
        
        if (plhr) continue ;
        plhr=1;
        putNOTicon(plhxt,plhyt,mem_plh);
        continue ;
    }
    
    if (plhr) {plhr=0 ; puticon(plhxt,plhyt,mem_plh,255);}
        
        
    // ΤΕΛΟΣ ΤΑ ΠΙΘΑΝΑ ΣΗΜΕΙΑ !!
        if (!ektos) {
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
        SDL_SetCursor(cursor);
        ektos=1;
        }
            
            break ;
            
            case SDL_MOUSEBUTTONDOWN:
            
            if(sdlev.button.button==SDL_BUTTON_LEFT) {   
                mx1 = sdlev.button.x ; my1= sdlev.button.y ;
                if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                    do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONDOWN);
                    continue ;
                }
                
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                
                if (marrs) {
                
                xt1=xt;
                yt1=yt;
                xb1=xb;
                yb1=yb;
                change_pos(&xt1, &yt1 ,&xb1 , &yb1);

                mem_zer=malloc(size);
                if (!mem_zer) {information(2-keyb_gr,NULL,NULL); continue ;}

                getimage(xt,yt,xb,yb,mem_zer);
                putimage(xt,yt,mem0,0); 
                
                getimage (xt1,yt1,xb1,yb1,mem0);
                
                xt=xt1 ; yt=yt1; xb=xb1; yb=yb1;
                putimage (xt,yt,mem_zer,0);
                free(mem_zer) ; mem_zer=0;
                
                // Προσαρμογή Νέων Συντεταγμένων !
                arrsxt = xt+9 ; arrsyt = yt+8 ;
                inpxt=xt+9; inpyt=yt+36; inpxb=xb-25; inpyb=inpyt+70;
                inpx = inpxt; inpy=inpyt ; inpx1=inpxb; inpy1=inpyb ;
                repxt=inpxt+150 ; repyt = inpyb+3; repyb=repyt+27; repxb=xb-9;
                yesxt = xb-50; yesyt=goyt=yb-42;
                yesxb = yesxt+35; yesyb=goyb=yesyt+36;
                goxt=xt+12; goxb=goxt+96;
                plhxt=goxb+5; plhyt=yesyt+5;
                aptxt=plhxt+60 ; aptxb=yesxt-35; aptyt=plhyt; aptyb=aptyt+27;
                refresh();
                continue ;
                }
                
                if (inptex) {

                    for (f=0 ; f< 3 ; f++) {
                        efchxr[f] = chxr[f];
                        efbkxr[f] = bkxr[f];
                        efslxr[f] = slxr[f];
                    }
                    trampa1=gouv ;

                            
                    chxr[0]=chxr[1]=chxr[2]=255;
                    bkxr[0]=bkxr[1]=bkxr[2]=0;
                    slxr[0]=0 ; slxr[1]=120 ; slxr[2]=0;
                    gouv=myfont[7];
            
                    _bareacls (inpxb+1,inpyt,inpxb+10,inpyb,chobkxr);
                    inpx = inpxt; inpy=inpyt ; inpx1=inpxb; inpy1=inpyb ;
                    dx=alg_input(7,localg, &inpx, &inpy, &inpx1, &inpy1, 1024, -1);
                    while (dx==-10) dx=alg_input(7,localg, &inpx, &inpy, &inpx1, &inpy1, 1024 , -1);
                    
                    _alg_txt_show (localg , inpxt , inpyt , inpxb , inpyb ,1024 , choxr_w, numchxr,chobkxr);
                    dfx = proanal_parast (arped, localg , &alg_err );
                    or_prob = check_orio_write_mathped(arped, ptr_pedio[arped]->fiorio, 0);
                    
                    strcpy (str1kb,alg_prob[alg_err]);
                    if (or_prob==-2){
                        if (keyb_gr) strcat (str1kb , " / Προσοχή στη χωρητικότητα..");
                        else strcat (str1kb , " / Check out the capacity..");
                    } 
                    normtext_tomy (str1kb,0);
                    _bareacls (repxt  , repyt , repxb , repyb, chobkxr);
                    _outmystr_col(7, str1kb , repxt  , repyt , repxb , chochxr , chobkxr);
                    
                    if (!alg_err>0 || alg_err>8) {
                    
                        if (ptr_pedio[arped]->fitype==3) {
                            lfx = (long int) dfx;
                            sprintf(str1kb,"F%d = %ld",arped+1, lfx);
                        }
                        else if (ptr_pedio[arped]->fitype==4) {
                            sprintf(str1kb,"F%d = %.2lf",arped+1, dfx);
                        }

                        normtext_tomy (str1kb,0) ; 
                        setcolor (3) ;
                        rectangle (aptxt, aptyt,aptxb,aptyb);
                        _bareacls (aptxt+1, aptyt+1,aptxb-1,aptyb-1,choxr_w);
                        _outmystr_center_col(7, str1kb , aptxt+1, aptyt+1,aptxb-1,aptyb-1, numchxr , choxr_w );
                        refresh();
                    }
                    
                    gouv=trampa1;
                    for (f=0 ; f<3 ; f++) {
                        chxr[f] = efchxr[f];
                        bkxr[f] = efbkxr[f];
                        slxr[f] = efslxr[f];
                    }
                        
                    refresh();
                    continue ;
                }
                
                if (plhr) {
                    str1kb[0] = '\0';
                    if (keyb_gr) {
                    strcat (str1kb, "Τα αριθμητικά πεδία αντιστοιχούνται με F ή f και τον αντίστοιχο αύξοντα αριθμό τους.\n");
                    strcat (str1kb, "Ως αριθμητικά νοούνται και τα πεδία υπολογισμών.\n");
                    strcat (str1kb ,"Συμβατοί Τελεστές : + , - , * , / , % , # (τετραγ. ρίζα) , ^ (ύψωση σε δύναμη).\n");
                    strcat (str1kb ,"Χρησιμοποιείτε παρενθέσεις για αποφυγή σφαλμάτων.\n");
                    strcat (str1kb ,"Η χρήση κενών και νέων γραμμών επιτρέπεται.\n");
                    strcat (str1kb ,"Παράδειγμα : (f4 * (f2 - f8) ) / 4 \n");
                    strcat (str1kb ,"Για να υπολογιστεί επί τόπου το αποτέλεσμα της αριθμητικής παράστασης, θα πρέπει να βρίσκεστε σε καρτέλα με ενημερωμένα πεδία.");}
                    else {
                    strcat (str1kb, "The numeric fields are assigned with F or f and their respective serial number.\n");
                    strcat (str1kb, "Calculation fields are also numeric fields.\n");
                    strcat (str1kb ,"Compatible operators : + , - , * , / , % , # (square root) , ^ (rise to power).\n");
                    strcat (str1kb ,"Use parentheses to avoid errors.\n");
                    strcat (str1kb ,"Empty spaces and new lines  are allowed.\n");
                    strcat (str1kb ,"Example : (f4 * (f2 - f8) ) / 4 \n");
                    strcat (str1kb ,"To calculate the result of the arithmetic expression (on the spot), you should be on a DB card  with updated fields.");
                    }
                    normtext_tomy (str1kb,0);
                    c=plhxt;
                    u=130;
                    if (yb+u+2<info.bottom-50) { d=yb+2; }
                    else if (yt-(u+4)>info.top) { d=yt-(u+4);}
                    else { c=(info.right-info.left-600) / 2 ; d=(info.bottom-info.top-u) / 2 ;}
                    mem1 = malloc (imagesize (c,d,c+599,d+u-1));
                    if (!mem1) break;
                    getimage(c,d,c+599,d+u-1,mem1);
                    setcolor (1);
                    rectangle (c,d,c+599,d+u-1);
                    rectangle (c+1,d+1,c+598,d+u-2);
                    refresh();
                    gouv=myfont[2];
                    _nofield_txt_show (str1kb , 0, c+2 , d+2 , c+597 , d+u-3 , 800 , notchxr , notbkxr);
                    refresh();
                    do {
                        if (SDL_PollEvent(&sdlev) && (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN)) break ;
                        if (sdlev.type == SDL_WINDOWEVENT) refresh();
                        } while (1);
                        do {
                    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
                    putimage(c,d,mem1,0);
                    free(mem1);
                    plhr=0 ; _puticon(plhxt,plhyt,mem_plh,255);
                    refresh();
                    break ;
                    
                }
                
                if (yes) {
                    loop=0;
                    fyge=1;
                    mystrcpy (ptralg,localg);
                    break ;
                }
                
                if (cancel) {
                    fyge=0;
                    loop=0;
                    break ;
                }
            
            }
            else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            continue ;
            }
        break ;
        
        case SDL_KEYDOWN:
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        if (sdlev.key.keysym.scancode == SDL_SCANCODE_ESCAPE) {
            fyge=0;
            loop=0;
        }
        break;
        
        case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        refresh(); 
        continue;        
        
        case SDL_QUIT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        fyge=0;
            loop=0;
        break;   

        }
    } while (loop);
    
    

FYGE:

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem_go) free (mem_go);
    if (mem_yes) free(mem_yes);
    if (mem_arrs) free(mem_arrs);
    if (mem_zer) free (mem_zer) ;
    if (mem_plh) free (mem_plh) ;

    gouv=trampa;
    cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return fyge;
}



double proanal_parast(short int arped, unsigned char *algebra , short int *problem )

{

register int f,i ;
unsigned char what , what1;
int l , dx ;
void *mem_ier=0;
double kati=0 ;
short int paa=0 , pak=0 , posar=0 ;
short int a , b , hook=0 ,ypd ;
unsigned char parped[6] , parnum[16];
short int fiopagk , laclagk , inopagk , inclagk ;
char apagor[100];
short int apa , inoptimi ;
unsigned char *keimk_1;
unsigned char stalega[1026];

    if (!algebra) {*problem=1 ; return 0 ;}
    i=0; 
    *problem=0;
    mystrcpy (stalega,algebra);
    while (stalega[i] != 255) i++;
    if (!i) {*problem=1 ; return 0 ;}
    l=i;
    i=0;
    // Αρχικός έλεγχος εγκυρότητας - αφαίρεση κενών , τελειών και Enter !

    what=stalega[i];
    while (what!=255) {
        if ( (what>7) && (what<26) ) { i++; what=stalega[i]; continue ; }
        if ( (what==3) || (what==5) || (what==36) || (what==48) || (what==74) ){ i++; what=stalega[i]; continue ; }
        if (!i && what==29) {
            for (f=i;f<l;f++) { stalega[f]=stalega[f+1]; }
            l--; 
            what=stalega[i];
        }
        else if ( (!what) || (what==14) || (what==200) ) {
            for (f=i;f<l;f++) { stalega[f]=stalega[f+1]; }
            l--; 
            what=stalega[i];
        }
        else {*problem=2 ; return 0 ;}
    }
    if (!l) {*problem=1 ; return 0 ;}
    
    
        // Ειδικοί έλεγχοι
        // Έλεγχος μπερδεμένων τελεστών
        if (l==1) {
            what=stalega[0];
            if (what>2 && what<16) {*problem=3 ; return 0 ;}
            if (what==36 || what==48 || what==74) {*problem=3 ; return 0 ;}
        }
        i=0;
        while (i+1<l) {
            what=stalega[i];
            what1=stalega[i+1];
            
            switch (what) {
                case 11 : // +
                    if (what1==what || what1==13 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36 ) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 13 : // -
                    if (what1==what || what1==11 || what1==10 || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    break;
                    
                case 10 :  // *
                    if (what1==what || what1==15 || what1==5 || what1==12 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 15 : // διαίρεση
                    if (what1==what || what1==5 || what1==12 || what1==10 || what1==9 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1==11 || what1==13) {*problem=2 ; return 0 ;}
                    break ;
                    
                case 5 : // %
                    if ( what1==what || what1==12 || what1==8 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if ( what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if ( what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 36 : // ^
                    if (what1==what || what1==5) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 48 : // f
                    if (what1==what || what1==74 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 74 : // F
                    if (what1==what || what1==48 || what1==5 || what1==36 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 8 : // (
                    if (what1==5 || what1==9 || what1==10 || what1==12 || what1==15 || what1==36) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 9 : // )
                    if (what1==8 || what1==12 || what1==3)  {*problem=3 ; return 0 ;}
                    if (what1>15 && what1<26) {*problem=3 ; return 0 ;}
                    if (what1==48 || what1==74) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 12 : // ,
                    if (what1==5 || what1==36 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
                    if (what1>7 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                case 3 : // # Τετραγωνική Ρίζα
                    if (what1==what || what1==5 || what1==36) {*problem=3 ; return 0 ;}
                    if (what1>8 && what1<16) {*problem=3 ; return 0 ;}
                    break ;
                    
                default : // κάποιος αριθμός
                    if (what1==8 || what1==48 || what1==74 || what1==3) {*problem=3 ; return 0 ;}
            }
            i++;
        }
        
        // Έλεγχος για εσφαλμένη αρχή ..
        what=stalega[0];
        if (what==5 || what==9 || what==10 || what==12 || what==15 || what==36) {*problem=3 ; return 0 ;}
        
        // Έλεγχος για εσφαλμένο τέλος ..
        what=stalega[l-1];
        if (what==8 || what==10 || what==11 || what==12 || what==13 || what==15 || what==36 || what==48 || what==74 || what==3) {*problem=3 ; return 0 ;}    


    
    //Προετοιμασία-καθαρισμός της δομής prst
    
    for (f=0 ; f<1024 ; f++) {
        prst[f].sths=0;
        prst[f].agk=0;
        prst[f].steos=-1;
        prst[f].field=-1;
    }
    
// Ελεγχος πεδίων που εξαρτώνται δυναμικά από το arped και για τα οποία απαγορεύεται η αντίστροφη εξάρτηση !
    apa=0;
    apagor[apa]=-1;
    if (empl_mem) {
        i=0; a=0;
        while (empl_mem[i]!=-2) i++;
        if (i) {
            a=i;
            for (f=0; f<a ; f++) {
                if (empl_mem[f]==arped) {
                    if (empl_mem[f-1] == -1) {
                        i=f;
                        while (empl_mem[i]>=0) i++;
                        if (empl_mem[i]==-2) break;
                        f=i; continue;
                    }
                    i=f-1;
                    while (empl_mem[i] != -1) i--;
                    what=0;
                    for (dx=0; dx<apa ; dx++) {
                        if ( empl_mem[i+1] == apagor[dx] ) {what=1; break;} 
                    }
                    if (!what) {
                        apagor[apa] = empl_mem[i+1] ;
                        apa++;
                    }
                    i=f;
                    while (empl_mem[i]>=0) i++;
                    if (empl_mem[i]==-2) break;
                    f=i; continue;
                }
            }
        }
    }
    
    // Μεταφορά στοιχείων από stalega στη δομή prst και μεταφορά τυχόν αριθμών στον πίνακα ier
    i=0;a=0;
    while (i<l) {
        what=stalega[i];
        
        switch (what) {
            case 3: // # sqrt
                prst[a].sths='#';
                a++; i++;
                break ;
            
            case 5: // %
                prst[a].sths='%';
                a++; i++;
                break ;
                
            case 8 : // (
                paa++;
                if (!paa) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=paa;
                a++; i++;
                break ;
            
            case 9 : // )
                pak = -paa ;
                paa--;
                if (!pak) {*problem=4 ; goto FYGE ;}
                hook++;
                prst[a].agk=pak;
                a++; i++;
                break ;
                
            case 10 : // *
                prst[a].sths='*';
                a++; i++;
                break ;
                
            case 11 : // +
                prst[a].sths='+';
                a++; i++;
                break ;
                
            case 13 : // -
                prst[a].sths='-';
                a++; i++;
                break ;
                
            case 15 : // διαίρεση
                prst[a].sths='/';
                a++; i++;
                break ;
                
            case 36 : // ^
                prst[a].sths='^';
                a++; i++;
                break ;
                
            case 48:  // f
            case 74:  // F
                i++;
                f=0; dx=0;
                while(i<l && f<3) {
                    what=stalega[i];
                    if (!f && what<17 && what>25) {*problem=2 ; goto FYGE ;}
                    if (!f && what>16 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ; dx++;
                    }
                    else if ((f) && what>15 && what<26) {
                        parped[f]=what;
                        i++ ; f++ ;dx++;
                    }
                    else break ;
                }
                if (!dx) {*problem=2 ; goto FYGE ;}
                dx=0;
                if (f<3) {
                    if (what==3 || what==8 || what==12 || what==48 || what==74) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=stalega[i];
                    if (what1>15 && what1<26) {*problem=2 ; goto FYGE ;}
                    if (what1==3 || what1==8 || what1==12 || what1==48 || what1==74) {*problem=2 ; goto FYGE ;}
                }
                parped[f]=255;
                b = (short int) convert_str(f , parped);
                b--;
                if (b>dbfinum) {*problem=9 ; dx=1 ;}
                else if (ptr_pedio[b]->fitype!=3 && ptr_pedio[b]->fitype!=4) {*problem=10 ;dx=1 ;}
                else if (arped == b) {*problem=7 ; dx=1 ;}
                else if  (ptr_pedio[b]->mathtype) {
                    if (!alg_str[b]) {*problem=11 ; dx=1 ;}
                    else if (alg_str[b][0]==255) {*problem=12 ; dx=1 ;}
                } 
                
                for (f=0 ; f<apa ; f++) {
                    if ( b == apagor[f] ) {*problem=5 ; goto FYGE ;}
                }
                prst[a].field = b ; 
                
                prst[a].steos = posar ;
                posar++;
                
                if (posar==1) {mem_ier=malloc (sizeof(double));}
                else mem_ier=realloc (mem_ier,posar*sizeof(double));
                if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                ier = mem_ier ;
                if ( (xmemk) && (!dx) ) {  
                    keimk_1=memk[b];
                    if (keimk_1[0]==255) ier[posar-1] = 0 ;
                    else {ier[posar-1] = convert_str(ptr_pedio[prst[a].field]->fiorio , keimk_1);}
                }
                else  { ier[posar-1] = 0 ; }
                dx=0; a++;
                break ;
                
            default : // Κάποιος αριθμός
                f=0;
                parnum[f]=what;
                i++; ypd=0;
                while(i<l && f<13) {
                    what=stalega[i];
                    if ((what>15 && what<26) || (what==12) ) {
                        f++;
                        parnum[f]=what;
                        if (what==12) ypd++;
                        i++ ;
                    }
                    else break ;
                }
                f++; parnum[f]=255;
                if (f<14) {
                    if (what==3 || what==8 || what==48 || what==74) {*problem=3 ; goto FYGE ;}
                    if (ypd>1) {*problem=2 ; goto FYGE ;}
                    if (ypd==1 && parnum[f-1]==12) {*problem=2 ; goto FYGE ;}
                }
                else if (i<l) {
                    what1=stalega[i];
                    if (what1>15 && what1<26) {*problem=6 ; goto FYGE ;}
                    if (what1==12) {*problem=3 ; goto FYGE ;}
                    if (what1==48 || what1==74 || what1==8 || what1==3) {*problem=3 ; goto FYGE ;}
                }
                prst[a].steos = posar ;
                posar++;
                if (posar==1) mem_ier=malloc (sizeof(double));
                else mem_ier=realloc (mem_ier,posar*sizeof(double));
                if (!mem_ier) {information (2-keyb_gr,0,0); goto FYGE ;}
                ier = mem_ier ;
                ier[posar-1] = convert_str(f , parnum);
                a++;
        }
    }
    
    if (paa) {*problem=4 ; goto FYGE ;}
    maxprst=a;
    
    
    // Αφαίρεση τυχόν παρενθέσεων
    
    f=0;
    if (hook) {
        while (f<maxprst) {
            
            if (!prst[f].agk) {f++; continue ;}
            fiopagk=f;
            inoptimi=1;
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) { 
                if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                i++; 
            }
                        
            while (inoptimi>1) {
                f=inopagk+1;
                while (prst[f].agk != (-inoptimi) ) f++;
                inclagk=f;
                // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα inopagk - inclagk)
                dx = calc_rem_agk (inopagk , inclagk , 1);
                if (dx<0) {*problem=8 ; goto FYGE ;}
                hook-=2;
                i=fiopagk+1;
                inoptimi=1;
                while ( prst[i].agk != (-1) ) { 
                    if (prst[i].agk>inoptimi) {inoptimi=prst[i].agk ; inopagk=i; }
                    i++; 
                }
            }
            i=fiopagk+1;
            while ( prst[i].agk != (-1) ) i++;
            laclagk=i;
            // ΚΛΗΣΗ ΣΥΝΑΡΤΗΣΗΣ ΑΦΑΙΡΕΣΗΣ ΑΓΚΥΛΩΝ (ορίσματα fiopagk - laclagk
            dx = calc_rem_agk (fiopagk , laclagk , 1);
            if (dx<0) {*problem=8 ; goto FYGE ;}
            f=0 ;
        } // telos while (f<maxprst)
        
    } // telos if hook
 
 // ΥΠΟΛΟΓΙΣΜΟΣ ΑΘΡΟΙΣΜΑΤΟΣ
    
    dx = calc_rem_agk (0 , maxprst , 0);
    if (dx<0) {*problem=8 ; goto FYGE ;}
    
    
    kati = ier[prst[0].steos];
    
    
    //if (prst[0].sths=='-') kati = -1*kati ;
    
    if (kati == HUGE_VAL) {
    kati=0; *problem=8;
    }
 
FYGE :
if (mem_ier) free(mem_ier);
mem_ier=0;
return kati ;
    
}

            
            
void clear_alg(unsigned char *str)


{

register int i ;
unsigned char what ;
int l ;
short int c;

    i=0;
    while (str[i] != 255) i++;
    if (!i) return ;
    l=i;
    c=0;
        // Αφαίρεση κενών , τελειών και Enter !
        
        what=str[c];
        while (what!=255) {
            if (!c && what==29) {
                for (i=c;i<l;i++) { str[i]=str[i+1]; }
                l--; 
                what=str[c];
            }
            else if ( (!what) || (what==14) || (what==200) ) {
                for (i=c;i<l;i++) { str[i]=str[i+1]; }
                l--; 
                what=str[c];
            }
            else { c++; what=str[c];}
        }
return ;
}


void pro_sort_double_si (double *item,int count)
{
    if (count<2) return;
    qui_sort_double_si(item,0,count-1);
}

void qui_sort_double_si (double *item , int left , int right)
{
    register int i , j ;
    double x,y;
    
    i=left ; j=right ;
    x=item[(left+right)/2];
    do {
        while (item[i]<x && i<right) i++;
        while (x<item[j] && j>left) j--;
        if (i<=j) {
            y=item[i];
            item[i]=item[j];
            item[j]=y;
            i++; j--;
        }
    } while (i<=j);
    
    if (left<j) qui_sort_double_si(item,left,j);
    if (i<right) qui_sort_double_si(item,i,right);
}


int pedaba_statistics(short int arped , unsigned short int *disk_dom , short int choose)
//epil = 0 αναλύονται όλα
//epil = 1 αναλύονται μόνον οι επιλογές
{

struct fansouv *trampa ;
void *mem1=0 ,*mem2=0 , *mem0=0 , *memd2=0;
double *stem=0 , *stems=0 , *data2 ;
register int f,i ;
int dx , mx , my , mx1, my1 ;
unsigned short int  p , ma , oldcount, count , c ;
unsigned long int alma=0;
int v , num ;
unsigned char deigma[16];
short int vimata=3 , vima=0 , bh , x, y, x1, ypb , w ;
double mean , diam , epitimi, mean2 , oldmode , d , typ_apo , sumd , bp , bn , logos , cor ,  a , b, x_avg, y_avg, temp, temp2;
short int pla=1 , maxpla=30, spa=0, maxspa=6, swide , shei, ana=1 ,prs ;
short int xt,yt,xb,yb , sxeyt , olneg ;
int chochxr[3] , chobkxr[3] ;
unsigned char what ;
int numbkxr[3] , numchxr[3] , mathbkxr[3] , notchxr[3] , notbkxr[3] , bluexr[3] , redxr[3] , blabkxr[3] , greenbkxr[3] ;
//int *pioxr;

    if (dbfinum==-1 || !dbplgr ) return 0;
    bh=800;
    xt=(info.right-info.left-1199) / 2 ; yt=(info.bottom-info.top-bh-1) / 2 ;
    xb=xt+1199; yb=yt+bh-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); return 0;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    dx=0;
    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        
        if ( arped==f ) { 
            dx=mystrcmp(keimk,ceimk);
            if (dx) break;}
    }
    
    if (dx) {
        if (keyb_gr) information (0,"Έχετε αλλάξει το περιεχόμενο του πεδίου..\n..αλλά δεν σώσατε την καρτέλα!\nΔεν θα ληφθεί τώρα υπόψη η τροποποίηση!",0);
        else information (0,"You have changed the data in this field..\n..but you have not saved the DB card!\nThis change will not be taken into account now!",0);
    }
    

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    if (!choose) {
        ma=dbplgr;
    }
    else {
       if (!tot_opts || !epil_pos) return 0;
       ma=tot_opts;
    }
    
    if (!ma) goto FYGE ;
    
    mem1=malloc ( ma*(sizeof(double)) );
    mem2=malloc ( ma*(sizeof(double)) );
    memd2=malloc (2*ma*(sizeof(double)));
    if (!mem1 || !mem2 || !memd2) goto FYGE;
    
    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 
    bluexr[0]=bluexr[1]=0 ; bluexr[2]=255;
    redxr[1]=redxr[2]=0 ; redxr[0]=255;

    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    mathbkxr[0] = 79; mathbkxr[1] = 205; mathbkxr[2] = 202 ;
    notchxr[0] = 14 ; notchxr[1] = 27 ; notchxr[2] = 41 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 128 ;
    blabkxr[0]=blabkxr[1]=blabkxr[2]=0;
    greenbkxr[0] = 0 ; greenbkxr[1] = 255; greenbkxr[2] = 0 ; 

    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    mytext_tonorm (ptr_pedio[arped]->finame , str1kb,60);
    if (keyb_gr) sprintf (str1024,"Στατιστική Ανάλυση για F%d : %s" , arped+1, str1kb );
    else sprintf (str1024,"Statistics for F%d : %s",arped+1, str1kb);
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt, yt+7, xb, yt+34, chochxr , chobkxr);
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    refresh();
    
    if (choose){
        if (keyb_gr) sprintf (str1kb , "Δείγμα : Επιλογή %u Καρτελών" , tot_opts);
        else sprintf (str1kb , "Sample : %u chosen DB Cards" , tot_opts);
    }
    else {
        if (keyb_gr) strcpy (str1kb , "Δείγμα : Το σύνολο των Καρτελών");
        else strcpy (str1kb , "Sample : All DB Cards");
    }
    normtext_tomy (str1kb,0);
    setcolor (5) ;
    rectangle (xt+450 , yt+37 , xt+750, yt+51) ;
    _bareacls (xt+451 , yt+38 , xt+749, yt+50,notbkxr) ;
    
    _outmystr_center_col(2, str1kb , xt+451 , yt+38 , xt+749, yt+51, notchxr, notbkxr);
   
        
    
    stem=mem1;
    stems=mem2;
    data2=memd2;
     
    // Περνάω στα memcp (ceimk) τις τρέχουσες τιμές των memk (keimk)
    /*
    for (f=0;f<=dbfinum;f++) {
        keimk=memk[f];
        ceimk=memcp[f];
        i=0;
        if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
        else {
            if(keimk[i]!=255) strcpy (ceimk,keimk); 
            else ceimk[i]=255;
        }
    }
    */
    
    for (f=0;f<=dbfinum;f++) { 
        if (f==arped) break; // Υπολογισμός του άλματος fseek ανάλογα με το arped !
        alma+=xlimk[f];
    }
    
    dx=0;
    
    if (!choose) {
        
        for (f=0;f<dbplgr;f++) {
            dx=fseek(fpcard , ((disk_dom[f] * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[f]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[f] = stem[f];
        }
        
        if (dx) {rewind (fpcard); clearerr(fpcard);  
            information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}
        
    }
    else {
        
        for (i=0 ; i<tot_opts ; i++) {
            p=epil_pos[i];
            dx=fseek(fpcard , ((p * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[i]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[i] = stem[i];
        }
    }
    
    if (dx) {rewind (fpcard); clearerr(fpcard);  
        information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}

    
    pro_sort_double_si (stems, (int) ma);
    
    // Διάμεσος
    diam=stems[ma/2];    
       
    // Άθροισμα και Μέση τιμή
    sumd=mean=0;dx=0;
    for (i=0;i<ma;i++) {
    mean+=stem[i]/ma;
    sumd+=stem[i];
    if (mean==HUGE_VAL) { dx=1; break ;}
    //if(sumd==HUGE_VAL) {};
    }
    
    if (dx) {goto FYGE;}
    
    y_avg=mean;
    num=ma;
    
    // Μέση τiμή Χ
    
    x_avg=0;
    for (f=1 ; f<=num  ; f++) x_avg += f ;
    x_avg /= num ;
    
    // Επικρατούσα Τιμή
    
    oldmode=0 ; oldcount=0;
    for (f=0 ; f<ma ; f++) {
        d=stems[f];
        count=1;
        for (i=f+1; i<ma ; i++ ) {
            if (d==stems[i]) count++;
            else break;
        }
        if (count>oldcount) {
            oldmode=d;
            oldcount=count;
        }
    }
    
    epitimi=oldmode;
    
    // Τυπική Απόκλιση 
    
    mean2=0;
    for (f=0 ; f<ma ; f++) {
        d=stem[f]-mean;
        d *= d ;
        if (d==HUGE_VAL) { dx=1; break ;}
        mean2 += d/ma;
        if (mean2==HUGE_VAL) { dx=1; break ;}
    }
    
    if (dx) { goto FYGE;}
    typ_apo=sqrt(mean2);
    
        // Ypologismos b (Y = b*x + a)
    dx=0;
    temp=0 ; temp2=0;
    for (f=1 ; f<=num ; f++) {
        temp += ( (stem[f-1] - y_avg) * (f-x_avg) ) ;
        if (temp==HUGE_VAL) { dx=1 ; temp=0; break; }
        temp2 += ( (f-x_avg) * (f-x_avg) ) ;
    }
    
    b = temp / temp2 ;
     if (dx) { b=0; y_avg=0; }
    // Ypologismos a (Y = b*x + a)
    
    a = y_avg - (b*x_avg) ;
    
    // Ypologismos syntelesth sysxetishw
    
    for (f=0 ; f<num ; f++) { data2[f] = f+1 ;}
    cor = temp/num;
    d = std_dev(data2,num) ;
    if (d==HUGE_VAL) cor=0 ;
    else { cor =  (cor / ( typ_apo * d )); }
    
    // Εμφάνιση αποτελεσμάτων
    
    y=yt+55;
    x=xt+9;
    w=290;
    gouv=myfont[3];
    
    // Ελάχιστο k1
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    
    if (ptr_pedio[arped]->fitype==3) {
    lfx = (long int) stems[0];
    sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Ελάχιστο : %s",str1024);
    else sprintf(str1kb,"Min. : %s",str1024);
    }
    else {
    sprintf(file_3,"%.2lf",stems[0]); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Ελάχιστο : %s",str1024);
    else sprintf(str1kb,"Min. : %s",str1024);
    }  
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+20, numchxr , numbkxr);
    
    
    // Διάμεσος κ2
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",diam); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Διάμεσος : %s",str1024);
    else sprintf(str1kb,"Median : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);    
    
    // Μέση Τιμή κ3
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",mean); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέσος Όρος : %s",str1024);
    else sprintf(str1kb,"Average : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);   

    // Μέγιστο k4
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    if (ptr_pedio[arped]->fitype==3) {
    lfx = (long int) stems[ma-1];
    sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέγιστο : %s",str1024);
    else sprintf(str1kb,"Max. : %s",str1024);
    }
    else {
    sprintf(file_3,"%.2lf",stems[ma-1]); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέγιστο : %s",str1024);
    else sprintf(str1kb,"Max. : %s",str1024);
    
    }
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    
    // Επικρατούσα Τιμή κ5
    
    //x=x+w+2;
    x=xt+9;
    y=y+23;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;    
    sprintf(file_3,"%.2lf",epitimi); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Επικρατ. Τιμή : %s",str1024);
    else sprintf(str1kb,"Prevail. price : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    
    // Τυπική Απόκλιση κ6
    
    x=x+w+2;
    //x=xt+9;
    //y=y+23;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;    
    sprintf(file_3,"%.2lf",typ_apo); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Τυπική Απόκλιση : %s",str1024);
    else sprintf(str1kb,"Standard deviation : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);

    // Άθροισμα k7
        
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    if (sumd != HUGE_VAL) {
        if (ptr_pedio[arped]->fitype==3) {
        lfx = (long int) sumd;
        sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
        mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
        if (keyb_gr) sprintf(str1kb,"Άθροισμα : %s",str1024);
        else sprintf(str1kb,"Sum : %s",str1024);
        }
        else {
        sprintf(file_3,"%.2lf",sumd); normtext_tomy(file_3,0);
        mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
        if (keyb_gr) sprintf(str1kb,"Άθροισμα : %s",str1024);
        else sprintf(str1kb,"Sum : %s",str1024);
        }
        normtext_tomy(str1kb,0);
        _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    }
    
    else {
        normtext_tomy("Error",str1kb);
        _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    }
    
       // Core k8
        
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",cor); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf (str1kb , "Συντελ. Συσχέτισ.= %s" , str1024 ); 
    else sprintf (str1kb , "Correl. Factor = %s" , str1024 );
    normtext_tomy (str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    refresh() ;
    
    // Σχεδιάγραμμα
    
    sxeyt = y+50;
    x1=xt+40;
    swide=xb-50-xt ;
    shei=yb-35-sxeyt;
    ana=1;
    
    while ( ((ma/ana)*pla + ((ma-1)/ana)*spa) > swide ) ana++;
    
    if (ana>1) {
        dx = ma % ana;
        c = (dx) ? (ma/ana) + 1 : ma/ana ;
    }
    else {c = ma ;}
    
    while ( (c*pla + (c-1)*spa ) < swide ) {
        if (pla==maxpla && spa==maxspa) break ;
        if (pla<maxpla && spa>0) {pla++; continue ;}
        if (spa<maxspa) spa++;
    }
    
    while (  (c*pla + (c-1)*spa ) > swide ){
        if (spa>1) { spa--; continue ; }
        pla--;
    }
    
        
    olneg=0;
    bn= (stems[0]<0) ? stems[0] : 0 ;
    bp= stems[ma-1];
    if (bp<=0) {
        bp = fabs (bn) ;
        prs=1;
        bn=0;
        olneg=1;
    }
    else {
        prs = (bn) ? 2 : 1 ;
        bn = fabs (bn);
        if (bn>bp) bp=bn ;
    }
    
    f=0 ; // bp : bigger pos , bn : bigger neg
    
    if (prs==1) { ypb = sxeyt + shei ; logos=shei/bp;}
    else {
        ypb = sxeyt + (shei/2) ; // y pos bottom
        logos=(shei/2)/bp ;
        }
    
    if (olneg) {
        setcolor (4) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else if (prs==1) {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        
        setcolor (4) ;
        line (x1-19,ypb+1,x1-19,ypb+shei/2) ;
        line (x1-20,ypb+1,x1-20,ypb+shei/2) ;
        _velos_down (x1-20,x1-19,ypb+shei/2);
    }
    refresh();
    
    // Ένδειξη μέγιστης τιμής στο πάνω βέλος
    dx=0 ; 
    lfx = (long int) bp;
    if (stems[ma-1]>0) sprintf(str1kb,"%ld",lfx);
    else { sprintf(str1kb,"%ld",-lfx); dx=1; }

    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , sxeyt-23 , xt+150, sxeyt-7) ;
    if (dx) {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , sxeyt-22 , xt+149, sxeyt-8,redxr, blabkxr);
    }
    else {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , sxeyt-22 , xt+149, sxeyt-8,bluexr, greenbkxr);
    }
    
    
    dx=0;
    // Ένδειξη ελάχιστης τιμής στο κάτω βέλος
    if (prs==1) lfx = 0 ;
    else { dx=1; lfx = (long int) -bp ;}
    sprintf(str1kb,"%ld",lfx);  
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , yb-26 , xt+150, yb-11) ;
    
       
    if (dx) {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, bluexr, greenbkxr);
    } 
    
    refresh();
    setfillstyle (1,2) ;
    
    i=0;
    while (i<ma) {
        d=0;
        for (f=0; i<ma && f<ana ; f++) {
            d += stem[i++];
        }
        if (d==HUGE_VAL) { x1 = x1+pla+spa ; continue ;}
        d /= f ;
        
        if (d>=0) {
            bh= (short int) ( d*logos );
            bar (x1,ypb-bh,x1+pla-1,ypb);
        }
        else {
            bh= (short int) ( abs ( ( d*logos ) ) ) ;
            if (prs==2) bar (x1,ypb,x1+pla-1,ypb+bh);
            else bar (x1,ypb-bh,x1+pla-1,ypb);
        }
        x1 = x1+pla+spa ;
    }
    refresh ();
    // Περιμένει κάτι...
    x1=xt+40;
    mx1=my1=0;
    count = c*pla + (c-1)*spa ;
    dx = x1+count-1 ;
    
    do {
        if (SDL_PollEvent(&sdlev)){
            if (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) break ;
            if (sdlev.type==SDL_MOUSEMOTION) {mx=sdlev.motion.x ; my=sdlev.motion.y;continue ;}
            if (sdlev.type == SDL_WINDOWEVENT) { refresh(); continue ; }
        }
            
        if (mx>dx || mx<x1 || my>yb-35 || my<sxeyt) continue ;
        if (mx1==mx && my1==my) continue ;
        mx1=mx ; my1=my ;
        w=mx-x1;
        p=(ma*w/count)+1;
        if (p && p>ma) p--;

        if (prs==1) {
           bh=ypb-my;
           d=bh*bp/shei;
           if (stems[ma-1]<=0) sprintf(str1kb,"(%u , %.0lf)",p,-d);
           else sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
        else {
            if (my<=ypb) {
                bh=ypb-my;
                d= 2*bh*bp/shei;
            }
            else {
                bh=my-ypb;
                d=-2*(bh*bp/shei);
            }
           
           
           sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
    } while (1);
        
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    
        do {
    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    //
    
FYGE_1 :
    // Φεύγοντας διαβάζει πάλι τρέχουσα καρτέλα
    /*
    if (dbcard<=dbplgr) {
            dx = fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            if (dx) {
                information (6-keyb_gr,Strcardfp,0) ;
                rewind (fpcard) ; clearerr(fpcard) ;
                fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            }
            
            for (f=0;f<=dbfinum;f++) {
                // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
                keimk=memk[f];
                ceimk=memcp[f];
                i=0;
                if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                else {
                    if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                    else keimk[i]=255;
                }
                
                fread (memcp[f] , 1, xlimk[f], fpcard);
                if (ferror(fpcard)) information (6-keyb_gr,Strcardfp,0) ;
            }
        }
    else {
        for (f=0;f<=dbfinum;f++) {
            // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
            keimk=memk[f];
            ceimk=memcp[f];
            i=0;
            if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
            else {
                if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                else keimk[i]=255;
            }
            
            ceimk[0]=255;
        }
    }
    */
    
FYGE :

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem1) free(mem1);
    if (mem2) free(mem2);
    if (memd2) free(memd2);
    gouv=trampa;
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return 1;
}


void _velos_up(short int xl,short int xr,short int yt)
{
    line (xl-6,yt+6,xl, yt);
    line (xl-5,yt+6,xl, yt+1);
    line (xr+6,yt+6,xr,yt);
    line (xr+5,yt+6,xr, yt+1);
}

void _velos_down(short int xl,short int xr,short int yb)
{
    line (xl-6,yb-6,xl,yb);
    line (xl-5,yb-6,xl,yb-1);
    line (xr+6,yb-6,xr,yb);
    line (xr+5,yb-6,xr,yb-1);
}


void ypodiastol (char *str) 

{

register int i=0;

    while (str[i]!='\0') {
        if (  (i) && (str[i]=='.')  && (isdigit(str[i-1]) )  ) { str[i] =  ',' ;}
        i++;
    }
    if (i) { if (str[i-1]==',') str[i-1]='.' ; }
}

void multi_statistics(short int fifi, unsigned short int *disk_dom , short int choose)
//choose = 0 αναλύονται όλα
//choose = 1 αναλύονται μόνον οι επιλογές
// fifi = αυτό το πεδίο με το οποίο κλήθηκε
{
short int maxflds = 5 ;

unsigned short int arped[maxflds] , arpx ;
int lr[maxflds] ;
void *mem[maxflds] ; 
double *stem[maxflds] , *stemx ;
unsigned long int alma[maxflds] , salto ;

void *mem0=0, *memf=0 , *mem1=0 ;
struct fansouv *trampa ;
register int f,i ;
int dx , m ;
unsigned short int  p , ma , c , s , count ;

int v , mx, my, mx1, my1 ;
unsigned char deigma[16];
short int bh , x, y, x1, x2, ypb , w , pe ;
double  d , bp , bn , logos , elaxisto, megisto ;
short int pla=1 , maxpla=30, spa=0, maxspa=6, swide , shei, ana=1 ,prs , plas ;
short int xt,yt,xb,yb , sxeyt , olneg ;
int chochxr[3] , chobkxr[3] ;
unsigned char what ;
int numbkxr[3] , numchxr[3] , mathbkxr[3] , notchxr[3] , notbkxr[3] , bluexr[3] , redxr[3] , blabkxr[3] , greenbkxr[3] ;
//int *pioxr;

unsigned char *synolo_fnum;
struct {
    unsigned short int fd_orio;
    unsigned short int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    short int fd_sorton;
} dbfnum ;
unsigned int size_fnum=512;
static short int fsorton;
unsigned char *eplfi ;

    if (dbfinum==-1 || !dbplgr ) return;
    
    if (!tot_opts && choose) return ;
    
    for (i=0 ; i<maxflds ; i++) mem[i]=0;

    memf=malloc(size_fnum) ; 
    if (!memf) return ;
    synolo_fnum=memf;
    
    m=0; s=0; dx=0;
    dbfnum.fd_orio=0;

    pe=1;
    arped[0]=fifi;

    for (f=0;f<=dbfinum;f++) {
        
        if (fifi==f) continue ;
        if (ptr_pedio[f]->fitype !=3  && ptr_pedio[f]->fitype !=4) continue ;
        
        dx++;
        
        if ( (m+31) > (size_fnum-40) ) {
            size_fnum+=256;
            memf=realloc(memf,size_fnum);
            if (!memf) goto FYGE ;
            synolo_fnum=memf;
        }
        
        for (i=0;i<31;i++) {
            what=ptr_pedio[f]->finame[i];
            synolo_fnum[s] = what ;
            m++; s++;
            if (what==255) break;
        }
        
        if (dbfnum.fd_orio<i) dbfnum.fd_orio=i;
    }

    if (s) {
        dbfnum.fd_ar = s ;
        synolo_fnum[s]=254;
    }
    else {
    synolo_fnum[0]=255;
    synolo_fnum[1]=254;
    dbfnum.fd_ar=0;
    }
    dbfnum.mem_fd = (void*) synolo_fnum;
    dbfnum.fd_data[0]=255;
    dbfnum.fd_sorton=fsorton;
    
    if (dx) {
        if (keyb_gr) sprintf(str1024,"Επιλέξτε περισσότερα πεδία.."); else sprintf(str1024,"Select more fields..");
        normtext_tomy(str1024 , dbfnum.fd_name);
        mem1 = mulbutton_show(dbfnum.mem_fd, dbfnum.fd_ar, dbfnum.fd_orio, dbfnum.fd_name, &dbfnum.fd_sorton,0 );
        fsorton = dbfnum.fd_sorton ;
        if (mem1) {
            eplfi=mem1; x=0 ;
            for (f=0;f<=dbfinum;f++) {
                if (pe==maxflds) break ;
                if (fifi==f) continue ;
                if (ptr_pedio[f]->fitype ==3  || ptr_pedio[f]->fitype ==4) {
                    if (eplfi[x]) { arped[pe]=f; pe++ ; }
                    x++;
                }
            }
        }
    }
    
    if (memf) {free (memf); memf=0; }
    if (mem1) {free (mem1); mem1=0; }

    bh=800;
    xt=(info.right-info.left-1199) / 2 ; yt=(info.bottom-info.top-bh-1) / 2 ;
    xb=xt+1199; yb=yt+bh-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); goto FYGE ;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    // Ταξινόμηση της arped
    
    pro_sort_usint(arped,(int) pe);
    
    dx=0;x=0;
    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        if (arped[x]==f) {
            dx=mystrcmp(keimk,ceimk);
            if (dx) break;
            if (x<pe) x++ ;
            else break ;
        }
    }
    
    if (dx) {
        if (keyb_gr) information (0,"Έχετε αλλάξει το περιεχόμενο πεδίων..\n..αλλά δεν σώσατε την καρτέλα!\nΔεν θα ληφθεί τώρα υπόψη η τροποποίηση!",0);
        else information (0,"You have changed data in these fields..\n..but you have not saved the DB card!\nThis change will not be taken into account now!",0);
    }
    

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    if (!choose) {
        ma=dbplgr;
    }
    else {
       if (!tot_opts || !epil_pos) goto FYGE ;
       ma=tot_opts;
    }
    
    if (!ma) goto FYGE ;
  
        
    for (f=0 ; f<pe ; f++) {
    mem[f] =malloc ( ma*(sizeof(double)) );
    if (!mem[f]) goto FYGE;
    stem[f]=mem[f];
    }
    
    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 
    bluexr[0]=bluexr[1]=0 ; bluexr[2]=255;
    redxr[1]=redxr[2]=0 ; redxr[0]=255;

    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    mathbkxr[0] = 79; mathbkxr[1] = 205; mathbkxr[2] = 202 ;
    notchxr[0] = 0 ; notchxr[1] = 0 ; notchxr[2] = 0 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 0 ;
    blabkxr[0]=blabkxr[1]=blabkxr[2]=0;
    greenbkxr[0] = 0 ; greenbkxr[1] = 255; greenbkxr[2] = 0 ; 

    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    
    if (keyb_gr) strcpy (str1024,"Γραφική Απεικόνιση Πεδίων");
    else strcpy (str1024,"Fields Graph");
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt, yt+7, xb, yt+34, chochxr , chobkxr);
    
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    refresh();
    
    if (choose){
        if (keyb_gr) sprintf (str1kb , "Δείγμα : Επιλογή %u Καρτελών" , tot_opts);
        else sprintf (str1kb , "Sample : %u chosen DB Cards" , tot_opts);
    }
    else {
        if (keyb_gr) strcpy (str1kb , "Δείγμα : Το σύνολο των Καρτελών");
        else strcpy (str1kb , "Sample : All DB Cards");
    }
    normtext_tomy (str1kb,0);
    setcolor (5) ;
    rectangle (xt+450 , yt+37 , xt+750, yt+51) ;
    _bareacls (xt+451 , yt+38 , xt+749, yt+50,notbkxr) ;
    
    _outmystr_center_col(2, str1kb , xt+451 , yt+38 , xt+749, yt+51, notchxr, notbkxr);
   
    y=yt+55;
     
    
    // Υπολογισμός του άλματος fseek ανάλογα με τa arped !
    dx=0; x=0;
    for (f=0;f<=dbfinum;f++) { 
        if (f==arped[x]) {
            alma[x]=dx ; dx=0;
            x++;
            if (x==pe) break ;
            else continue ;
        }
        dx += xlimk[f];
    }
    

    dx=0;
    rewind (fpcard);
    
    if (!choose) {
        
        for (f=0;f<dbplgr;f++) {
            p=disk_dom[f] ;
            for (x=0 ; x<pe ; x++) {
                v = (!x) ? SEEK_SET : SEEK_CUR ;
                salto = (!x) ? ( (p * dbcardsize) + alma[x] ) : alma [x] ;
                if (salto) { dx=fseek(fpcard , salto , v); if (dx) break ;}
                fread(deigma,1,xlimk[arped[x]],fpcard);
                if (ferror(fpcard)) { dx=1 ; break ; }
                stem[x][f]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped[x]]-1 , deigma) : 0 ;
            }
            if (dx) break ;
        }
        
        if (dx) {rewind (fpcard); clearerr(fpcard);  
            information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}
        
    }
    else {
        
        for (i=0 ; i<tot_opts ; i++) {
            p=epil_pos[i];
            for (x=0 ; x<pe ; x++) {
                v = (!x) ? SEEK_SET : SEEK_CUR ; 
                salto = (!x) ? ( (p * dbcardsize) + alma[x] ) : alma [x] ;
                if (salto) { dx=fseek(fpcard , salto , v); if (dx) break ; }
                fread(deigma,1,xlimk[arped[x]],fpcard);
                if (ferror(fpcard)) { dx=1 ; break ; }
                stem[x][i]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped[x]]-1 , deigma) : 0 ;
            }
            if (dx) break ;
        }
    }
    
    if (dx) {rewind (fpcard); clearerr(fpcard);   
        information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}
    
    //pro_sort_double_si (stems, (int) ma);
    
    // ELAXISTO - MEGISTO  !!
    
    for (f=0 ; f<pe ; f++) {
        if (arped[f] == fifi) break ;
    }
    
    if (f) {
        stemx = stem[0]; stem[0]=stem[f]; stem[f]=stemx;
        arpx = arped[0]; arped[0]=arped[f]; arped[f]=arpx ;
    }
    
    bp=0; bn=0 ;
    for (x=0 ; x<pe ; x++) {
        for (i=0;i<ma;i++) {
            if (bn>stem[x][i]) { bn=stem[x][i] ; continue ;}
            if (bp<stem[x][i]) { bp=stem[x][i] ;}
        }
    }
    // Σχεδιάγραμμα
    elaxisto = bn ;
    megisto = bp ;
            
    sxeyt = y+30;
    x1=xt+40;
    swide=xb-50-xt ;
    shei=yb-35-sxeyt;
   
    plas=pe*pla;
    while ( ((ma/ana)*plas + ((ma-1)/ana)*spa) > swide ) ana++;
    
    if (ana>1) {
        dx = ma % ana;
        c = (dx) ? (ma/ana) + 1 : ma/ana ;
    }
    else {c = ma ;}
    
    while ( (c*plas + (c-1)*spa ) < swide ) {
        if (pla==maxpla && spa==maxspa) break ;
        if (pla<maxpla && (spa) ) {pla++; plas=pe*pla; continue ;}
        if (spa<maxspa) spa++;
    }
    
    while ( ( (c*plas + (c-1)*spa ) > swide ) && pla>2 ){
        if (spa) { spa--; continue ; }
        pla--; plas = pe*pla ;
    }
    p=c;
    
    olneg=0;
    if (bp<=0) {
        bp = fabs (bn) ;
        prs=1;
        bn=0;
        olneg=1;
    }
    else {
        prs = (bn) ? 2 : 1 ;
        bn = fabs (bn);
        if (bn>bp) bp=bn ;
    }
    
    f=0 ; // bp : bigger pos , bn : bigger neg
    
    if (prs==1) { ypb = sxeyt + shei ; logos=shei/bp;}
    else {
        ypb = sxeyt + (shei/2) ; // y pos bottom
        logos=(shei/2)/bp ;
        }
        
    if (olneg) {
        setcolor (4) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else if (prs==1) {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        
        setcolor (4) ;
        line (x1-19,ypb+1,x1-19,ypb+shei/2) ;
        line (x1-20,ypb+1,x1-20,ypb+shei/2) ;
        _velos_down (x1-20,x1-19,ypb+shei/2);
    }
    refresh();
    
    // Ένδειξη μέγιστης τιμής στο πάνω βέλος
    
    dx=0 ;
    
    if (prs==1) {
        if (megisto<=0) { sprintf(str1kb,"%.0lf",-bp); dx=1; }
        else sprintf(str1kb,"%.0lf",bp);
    } 
    else sprintf(str1kb,"%.0lf",bp);
    
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , sxeyt-23 , xt+150, sxeyt-7) ;
    
    //if (megisto<0) pioxr=redxr ; else pioxr = bluexr ; 
    //_outmystr_center_col(2, str1kb , xt+11 , sxeyt-22 , xt+149, sxeyt-8,pioxr, greenbkxr);
    
    if (dx) {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, blabkxr) ;
        _outmystr_center_col(2, str1kb ,  xt+11 , sxeyt-22 , xt+149, sxeyt-8, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, greenbkxr) ;
        _outmystr_center_col(2, str1kb ,  xt+11 , sxeyt-22 , xt+149, sxeyt-8, bluexr, greenbkxr);
    } 
    
    dx=0 ;
    // Ένδειξη ελάχιστης τιμής στο κάτω βέλος
    if (prs==1) elaxisto=0;
    else { elaxisto=-bp ; dx=1 ; } 
    sprintf(str1kb,"%.0lf",elaxisto);
    
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , yb-26 , xt+150, yb-11) ;
    
    
    if (dx) {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, bluexr, greenbkxr);
    } 
    
    refresh();
    
    lr[0]=2 ; lr[1]=6; lr[2]=3 ; lr[3]=0; lr[4]=15;
    x2=xt+160 ; y=yb-25; 
    
    for (x=0 ; x<pe ; x++) {
        i=0;
        x1=xt+40+x*pla;
        setfillstyle (1,lr[x]) ;
        while (i<ma) {
            d=0;
            for (f=0; i<ma && f<ana ; f++) {
                d += stem[x][i++];
            }
            if (d==HUGE_VAL) { x1 = x1+plas+spa ; continue ;}
            d /= f ;
            
            if (d>=0) {
                bh= (short int) ( d*logos );
                bar (x1,ypb-bh,x1+pla-1,ypb);
            }
            else {
                bh= (short int) abs (  ( d*logos )  );
                if (prs==2) bar (x1,ypb,x1+pla-1,ypb+bh);
                else bar (x1,ypb-bh,x1+pla-1,ypb);
            }
            x1 = x1+plas+spa ;
        }
        c=x2+x*190;
        setcolor (0) ;
        bar3d(c,y,c+20,y+15,0,0);
        c+=21;
        rectangle (c,y,c+160,y+14) ;
        _bareacls (c+1,y+1,c+159,y+14, notbkxr);
        _outmystr_center_col(2, ptr_pedio[arped[x]]->finame , c+1,y+1,c+159,y+14, notchxr , notbkxr);
        refresh ();
    }
    // yb-25 , xt+149,
    // Περιμένει κάτι...
    c=p;
    x1=xt+40;
    mx1=my1=0;
    count = c*plas + (c-1)*spa ;
    dx = x1+count-1 ;
    
    do {
        if (SDL_PollEvent(&sdlev)){
            if (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) break ;
            if (sdlev.type==SDL_MOUSEMOTION) {mx=sdlev.motion.x ; my=sdlev.motion.y;continue ;}
            if (sdlev.type == SDL_WINDOWEVENT) { refresh(); continue ; }
        }
            
        if (mx>dx || mx<x1 || my>yb-35 || my<sxeyt) continue ;
        if (mx1==mx && my1==my) continue ;
        mx1=mx ; my1=my ;
        w=mx-x1;
        p=(ma*w/count)+1;
        if (p && p>ma) p--;

        if (prs==1) {
           bh=ypb-my;
           d=bh*bp/shei;
           if (megisto<=0) sprintf(str1kb,"(%u , %.0lf)",p,-d);
           else sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
        else {
            if (my<=ypb) {
                bh=ypb-my;
                d= 2*bh*bp/shei;
            }
            else {
                bh=my-ypb;
                d=-2*(bh*bp/shei);
            }
           sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
    } while (1);
        
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        
        do {
    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    //
    
FYGE_1 :
    // Φεύγοντας διαβάζει πάλι τρέχουσα καρτέλα
    /*
    if (dbcard<=dbplgr) {
            dx = fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            if (dx) {
                information (6-keyb_gr,Strcardfp,0) ;
                rewind (fpcard) ; clearerr(fpcard) ;
                fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            }
            
            for (f=0;f<=dbfinum;f++) {
                // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
                keimk=memk[f];
                ceimk=memcp[f];
                i=0;
                if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                else {
                    if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                    else keimk[i]=255;
                }
                
                fread (memcp[f] , 1, xlimk[f], fpcard);
                if (ferror(fpcard)) information (6-keyb_gr,Strcardfp,0) ;
            }
        }
    else {
        for (f=0;f<=dbfinum;f++) {
            // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
            keimk=memk[f];
            ceimk=memcp[f];
            i=0;
            if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
            else {
                if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                else keimk[i]=255;
            }
            
            ceimk[0]=255;
        }
    }
    */
    
FYGE :

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem1) free (mem1) ;
    if (memf) free (memf);
    for (i=0 ; i<maxflds ; i++) {
        if (mem[i]) free (mem[i]);
    }
    gouv=trampa;
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return ;
}


double mesoros (double *data , int num)
// Μέσος Όρος
{
register int t;
double avg;

    avg=0;
    for (t=0 ; t<num ; t++) { avg += (data[t]/num) ; if (avg==HUGE_VAL) break ; }
    return avg;
}


double std_dev (double *data , int num)
// Τυπική Απόκλιση
{
register int t;
double std , avg ;

    avg = mesoros (data,num);
    if (avg==HUGE_VAL) return avg ;
    std=0;
    for (t=0 ; t<num ; t++) {
        std += ( ((data[t]-avg) * (data[t]-avg))/num );
        if (std==HUGE_VAL) return std;
    }
    std = sqrt (std) ;
    return std ;
}



int regress(short int arped , unsigned short int *disk_dom , short int choose)
//choose = 0 αναλύονται όλα
//choose = 1 αναλύονται μόνον οι επιλογές

{

struct fansouv *trampa ;
void *mem1=0 ,*mem2=0 , *mem0=0 , *memd2=0;
double *stem=0 , *stems=0 , *data2;
register int f,i ;
int dx , mx , my , mx1, my1 ;
int  p , ma , count , c , ju;
unsigned long int alma=0;
int v , num ;
unsigned char deigma[16];
short int bh , x, y, x1, ypb , w ,x0,y0 ;
double mean , mean2 , d , typ_apo , bp , bn , logos , a , b, x_avg, y_avg, temp, temp2 , elaxisto , megisto , cor ;
short int pla=1 , maxpla=30, spa=0, maxspa=6, swide , shei, ana=1 ,prs ;
short int xt,yt,xb,yb , sxeyt , olneg ;
int chochxr[3] , chobkxr[3] ;
unsigned char what ;
int numbkxr[3] , numchxr[3] , mathbkxr[3] , notchxr[3] , notbkxr[3] , bluexr[3] , redxr[3] , blabkxr[3] , greenbkxr[3] ;
int *pioxr;

    if (dbfinum==-1 || !dbplgr ) return 0;
    bh=800;
    xt=(info.right-info.left-1199) / 2 ; yt=(info.bottom-info.top-bh-1) / 2 ;
    xb=xt+1199; yb=yt+bh-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); return 0;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    dx=0;
    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        
        if ( arped==f ) { 
            dx=mystrcmp(keimk,ceimk);
            if (dx) break;}
    }
    
    if (dx) {
        if (keyb_gr) information (0,"Έχετε αλλάξει το περιεχόμενο του πεδίου..\n..αλλά δεν σώσατε την καρτέλα!\nΔεν θα ληφθεί τώρα υπόψη η τροποποίηση!",0);
        else information (0,"You have changed the data in this field..\n..but you have not saved the DB card!\nThis change will not be taken into account now!",0);
    }
    

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    if (!choose) {
        ma=dbplgr;
    }
    else {
       if (!tot_opts || !epil_pos) return 0;
       ma=tot_opts;
    }
    
    if (!ma) goto FYGE ;
    
    mem1=malloc ( ma*(sizeof(double)) );
    mem2=malloc ( ma*(sizeof(double)) );
    memd2=malloc (2*ma*(sizeof(double)));
    if (!mem1 || !mem2 || !memd2) goto FYGE;
    
    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 
    bluexr[0]=bluexr[1]=0 ; bluexr[2]=255;
    redxr[1]=redxr[2]=0 ; redxr[0]=255;

    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    mathbkxr[0] = 79; mathbkxr[1] = 205; mathbkxr[2] = 202 ;
    notchxr[0] = 0 ; notchxr[1] = 0 ; notchxr[2] = 0 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 0 ;
    blabkxr[0]=blabkxr[1]=blabkxr[2]=0;
    greenbkxr[0] = 0 ; greenbkxr[1] = 255; greenbkxr[2] = 0 ; 

    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    mytext_tonorm (ptr_pedio[arped]->finame , str1kb,60);
    if (keyb_gr) sprintf (str1024,"Γραμμή Παλινδρόμησης για F%d : %s" , arped+1, str1kb );
    else sprintf (str1024,"Regression line for F%d : %s",arped+1, str1kb);
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt, yt+7, xb, yt+34, chochxr , chobkxr);
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    refresh();
    
    if (choose){
        if (keyb_gr) sprintf (str1kb , "Δείγμα : Επιλογή %u Καρτελών" , tot_opts);
        else sprintf (str1kb , "Sample : %u chosen DB Cards" , tot_opts);
    }
    else {
        if (keyb_gr) strcpy (str1kb , "Δείγμα : Το σύνολο των Καρτελών");
        else strcpy (str1kb , "Sample : All DB Cards");
    }
    normtext_tomy (str1kb,0);
    setcolor (5) ;
    rectangle (xt+450 , yt+37 , xt+750, yt+51) ;
    _bareacls (xt+451 , yt+38 , xt+749, yt+50,notbkxr) ;
    
    _outmystr_center_col(2, str1kb , xt+451 , yt+38 , xt+749, yt+51, notchxr, notbkxr);
        
    
    stem=mem1;
    stems=mem2;
    data2=memd2;

    
    for (f=0;f<=dbfinum;f++) { 
        if (f==arped) break; // Υπολογισμός του άλματος fseek ανάλογα με το arped !
        alma+=xlimk[f];
    }
    
    dx=0;
    
    if (!choose) {
        
        for (f=0;f<dbplgr;f++) {
            dx=fseek(fpcard , ((disk_dom[f] * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[f]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[f] = stem[f];
        }
        
        if (dx) {rewind (fpcard); clearerr(fpcard);  
            information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}
        
    }
    else {
        
        for (i=0 ; i<tot_opts ; i++) {
            p=epil_pos[i];
            dx=fseek(fpcard , ((p * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[i]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[i] = stem[i];
        }
    }
    
    if (dx) {rewind (fpcard); clearerr(fpcard);  
        information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}

    
   pro_sort_double_si (stems, (int) ma);
   num=ma;
       
    // Μέση τιμή Y
    mean=0;dx=0;
    for (i=0;i<ma;i++) {
    mean+=stem[i]/ma;
    if (mean==HUGE_VAL) { dx=1; break ;}
    }
    
    if (dx) {goto FYGE;}
    y_avg=mean;
    
    // Μέση τιμή Χ
    
    x_avg=0;
    for (f=1 ; f<=num  ; f++) x_avg += f ;
    x_avg /= num ;
    
    // Τυπική Απόκλιση Y
    
    mean2=0;
    for (f=0 ; f<ma ; f++) {
        d=stem[f]-mean;
        d *= d ;
        if (d==HUGE_VAL) { dx=1; break ;}
        mean2 += d/ma;
        if (mean2==HUGE_VAL) { dx=1; break ;}
    }
    
    if (dx) { goto FYGE;}
    typ_apo=sqrt(mean2);
    
    // Ypologismos b (Y = b*x + a)
    dx=0;
    temp=0 ; temp2=0;
    for (f=1 ; f<=num ; f++) {
        temp += ( (stem[f-1] - y_avg) * (f-x_avg) ) ;
        if (temp==HUGE_VAL) { dx=1 ; temp=0; break; }
        temp2 += ( (f-x_avg) * (f-x_avg) ) ;
    }
    
    b = temp / temp2 ;
     if (dx) { b=0; y_avg=0; }
    // Ypologismos a (Y = b*x + a)
    
    a = y_avg - (b*x_avg) ;
    
    // Ypologismos syntelesth sysxetishw
    
    for (f=0 ; f<num ; f++) { data2[f] = f+1 ;}
    cor = temp/num;
    d = std_dev(data2,num) ;
    if (d==HUGE_VAL) cor=0 ;
    else { cor = (cor / ( typ_apo * d )); }
    
        
    y=yt+55;
    x=xt+50;
    w=1100;
    
    // Εδώ σημειώνεται η εξίσωση και ο cor !!
          
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    if (keyb_gr) sprintf (str1kb , " Υ = (%.2lf) * X + (%.2lf) , Συντελεστής Συσχέτισης = %.2lf " , b , a , cor ); 
    else sprintf (str1kb , " Υ = (%.2lf) * X + (%.2lf) , Correlation Factor = %.2lf " , b , a , cor );
    ypodiastol(str1kb);
    normtext_tomy (str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+20, numchxr, numbkxr);
    refresh();
    
    // Τα νέα Υ σύμφωνα με την τάση για διπλάσιο εύρος (εξίσωση παλινδρόμησης)
    elaxisto=0 ; megisto=0 ;
    for (f=0 ; f<2*num ; f++) {
        data2[f] = a + (b*(f+1)) ;
        if (elaxisto>data2[f]) { elaxisto = data2[f]; continue ; }
        if (megisto<data2[f]) megisto = data2[f] ;
    }
    
    ju=0;
    
    if ( stems[0]>=0 && stems[ma-1]>0 && data2[(2*num)-1]>0 ) { 
        for (f=0 ; f<2*num ; f++) {
            if (data2[f]>=0) break ;
        }
        ju=f; elaxisto=data2[ju];
    }
    else if (stems[0]<0 && stems[ma-1]<=0 && data2[(2*num)-1]<0) {
        for (f=0 ; f<2*num ; f++) {
            if (data2[f]<0) break ;
        }
        ju=f; megisto=data2[ju];
    }

    
    if (elaxisto > stems[0]) elaxisto = stems[0] ;
    if (megisto < stems[ma-1]) megisto = stems[ma-1] ;
    
    ma = 2 * num ;
    
    
    // Εμφάνιση αποτελεσμάτων
    
    y=yt+80;
    sxeyt = y+25;
    x1=xt+40;
    swide=xb-50-xt ;
    shei=yb-35-sxeyt;
    
    while ( ((ma/ana)*pla + ((ma-1)/ana)*spa) > swide ) ana++;
    
    if (ana>1) {
        dx = ma % ana;
        c = (dx) ? (ma/ana) + 1 : ma/ana ;
    }
    else {c = ma ;}
    
    while ( (c*pla + (c-1)*spa ) < swide ) {
        if (pla==maxpla && spa==maxspa) break ;
        if (pla<maxpla && spa>0) {pla++; continue ;}
        if (spa<maxspa) spa++;
    }
    
    while ( ( (c*pla + (c-1)*spa ) > swide ) && pla>1 ){
        if (spa) { spa--; continue ; }
        pla--;
    }
    
        
    olneg=0;
    bn= (elaxisto<0) ? elaxisto : 0 ;
    bp= megisto;
    if (bp<=0) {
        bp = fabs (bn) ;
        prs=1;
        bn=0;
        olneg=1;
    }
    else {
        prs = (bn) ? 2 : 1 ;
        bn = fabs (bn);
        if (bn>bp) bp=bn ;
    }
    
    f=0 ; // bp : bigger pos , bn : bigger neg
    
    if (prs==1) { ypb = sxeyt + shei ; logos=shei/bp;}
    else {
        ypb = sxeyt + (shei/2) ; // y pos bottom
        logos=(shei/2)/bp ;
        }
    
    if (olneg) {
        setcolor (4) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else if (prs==1) {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        
        setcolor (4) ;
        line (x1-19,ypb+1,x1-19,ypb+shei/2) ;
        line (x1-20,ypb+1,x1-20,ypb+shei/2) ;
        _velos_down (x1-20,x1-19,ypb+shei/2);
    }
    refresh();
    
    // Ένδειξη μέγιστης τιμής στο πάνω βέλος
    dx=0 ; 
    if (prs==1) {
        if (megisto<=0) { sprintf(str1kb,"%.0lf",-bp); dx=1 ; }
        else sprintf(str1kb,"%.0lf",bp);
    } 
    else sprintf(str1kb,"%.0lf",bp);
    
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , sxeyt-23 , xt+150, sxeyt-7) ;

    if (dx) {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, blabkxr) ;
        _outmystr_center_col(2, str1kb ,  xt+11 , sxeyt-22 , xt+149, sxeyt-8, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, greenbkxr) ;
        _outmystr_center_col(2, str1kb ,  xt+11 , sxeyt-22 , xt+149, sxeyt-8, bluexr, greenbkxr);
    } 
    
    dx=0;
    // Ένδειξη ελάχιστης τιμής στο κάτω βέλος
    if (prs==1) elaxisto=0;
    else { elaxisto=-bp; dx=1 ; } 
    sprintf(str1kb,"%.0lf",elaxisto);
    
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , yb-26 , xt+150, yb-11) ;
    
    
    if (dx) {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, bluexr, greenbkxr);
    } 
    
    refresh();
    
    setfillstyle (1,15) ;
    
    i=0;
    while (i<ma/2) {
        d=0;
        for (f=0; i<ma/2 && f<ana ; f++) {
            d += stem[i++];
        }
        if (d==HUGE_VAL) { x1 = x1+pla+spa ; continue ;}
        d /= f ;
        
        if (d>=0) {
            bh= (short int) ( d*logos );
            bar (x1,ypb-bh,x1+pla-1,ypb);
        }
        else {
            bh= (short int) abs  (  ( d*logos ) );
            if (prs==2) bar (x1,ypb,x1+pla-1,ypb+bh);
            else bar (x1,ypb-bh,x1+pla-1,ypb);
        }
        x1 = x1+pla+spa ;
    }
    refresh ();
    
    
    // SXEDIASH GRAMMHS PALINDROMHSHS
    
    setcolor (0) ;
    x1=xt+40;
    i=0;x0=-1;
    
    while (i<ma) {
        d=0;
        for (f=0; i<ma && f<ana ; f++) {
            d += data2[i];
        }
        if (ju) {
            if (i<ju) { i++; x1 = x1+pla+spa ; continue ; }
            if (i>=ju) {ju=0; i++; x1 = x1+pla+spa ; continue ; }
        }
        i++;
        if (d==HUGE_VAL) { x1 = x1+pla+spa ; continue ; }
        d /= f ;
        
        if (d>=0) {
            bh= (short int) ( d*logos );
            if (x0<0) {x0=x1; y0=ypb-bh;}
            else {
                line (x0,y0,x1,ypb-bh);
                x0=x1; y0=ypb-bh;
            }
        }
        else {
            bh= (short int) abs (  ( d*logos ) );
            if (x0<0) {
                x0=x1;
                y0 = (prs==1) ? ypb-bh : ypb+bh ;
            }
            else {
                if (prs==1) {line (x0,y0,x1,ypb-bh); x0=x1; y0=ypb-bh;}
                else {
                    line (x0,y0,x1,ypb+bh); 
                    x0=x1; 
                    y0=ypb+bh;
                }
            }
        }
        x1 = x1+pla+spa ;
    }
    refresh ();
    
    
    // Περιμένει κάτι...
    x1=xt+40;
    mx1=my1=0;
    count = c*pla + (c-1)*spa ;
    dx = x1+count-1 ;
    
    do {
        if (SDL_PollEvent(&sdlev)){
            if (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) break ;
            if (sdlev.type==SDL_MOUSEMOTION) {mx=sdlev.motion.x ; my=sdlev.motion.y;continue ;}
            if (sdlev.type == SDL_WINDOWEVENT) { refresh(); continue ; }
        }
            
        if (mx>dx || mx<x1 || my>yb-35 || my<sxeyt) continue ;
        if (mx1==mx && my1==my) continue ;
        mx1=mx ; my1=my ;
        w=mx-x1;
        p=(ma*w/count)+1;
        if (p && p>ma) p--;

        if (prs==1) {
           bh=ypb-my;
           d=bh*bp/shei;
           if (megisto<=0) sprintf(str1kb,"(%d , %.0lf)",p,-d);
           else sprintf(str1kb,"(%d , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
        else {
            if (my<=ypb) {
                bh=ypb-my;
                d= 2*bh*bp/shei;
            }
            else {
                bh=my-ypb;
                d=-2*(bh*bp/shei);
            }
           
           
           sprintf(str1kb,"(%d , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
    } while (1);
        
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    
        do {
    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    //
    
FYGE_1 :

    
FYGE :

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem1) free(mem1);
    if (mem2) free(mem2);
    if (memd2) free(memd2);
    gouv=trampa;
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return 1;
}


int pedaba_statistics_3d(short int arped , unsigned short int *disk_dom , short int choose)
//epil = 0 αναλύονται όλα
//epil = 1 αναλύονται μόνον οι επιλογές
{

struct fansouv *trampa ;
void *mem1=0 ,*mem2=0 , *mem0=0 ,*memd2=0 ;
double *stem=0 , *stems=0 , *data2;
register int f,i ;
int dx , mx , my , mx1, my1 ;
unsigned short int  p , ma , oldcount, count , c ;
unsigned long int alma=0;
int v , va , num;
unsigned char deigma[16];
short int vimata=3 , vima=0 , bh , x, y, x1, ypb , w ;
double mean , diam , epitimi, mean2 , oldmode , d , typ_apo , sumd , bp , bn , logos , cor ,  a , b, x_avg, y_avg, temp, temp2 ;
short int pla=8 , maxpla=24, spa=3, maxspa=7, swide , shei, ana=1 ,prs ;
short int xt,yt,xb,yb , sxeyt , olneg ;
int chochxr[3] , chobkxr[3] ;
unsigned char what ;
int numbkxr[3] , numchxr[3] , mathbkxr[3] , notchxr[3] , notbkxr[3] , bluexr[3] , redxr[3] , blabkxr[3] , greenbkxr[3] ;
//int *pioxr;

    if (dbfinum==-1 || !dbplgr ) return 0;
    bh=800;
    xt=(info.right-info.left-1199) / 2 ; yt=(info.bottom-info.top-bh-1) / 2 ;
    xb=xt+1199; yb=yt+bh-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); return 0;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    dx=0;
    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        
        if ( arped==f ) { 
            dx=mystrcmp(keimk,ceimk);
            if (dx) break;}
    }
    
    if (dx) {
        if (keyb_gr) information (0,"Έχετε αλλάξει το περιεχόμενο του πεδίου..\n..αλλά δεν σώσατε την καρτέλα!\nΔεν θα ληφθεί τώρα υπόψη η τροποποίηση!",0);
        else information (0,"You have changed the data in this field..\n..but you have not saved the DB card!\nThis change will not be taken into account now!",0);
    }
    

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    if (!choose) {
        ma=dbplgr;
    }
    else {
       if (!tot_opts || !epil_pos) return 0;
       ma=tot_opts;
    }
    
    if (!ma) goto FYGE ;
    
    mem1=malloc ( ma*(sizeof(double)) );
    mem2=malloc ( ma*(sizeof(double)) );
    memd2=malloc (2*ma*(sizeof(double)));
    if (!mem1 || !mem2 || !memd2) goto FYGE;
    
    num=ma;
    
    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 
    bluexr[0]=bluexr[1]=0 ; bluexr[2]=255;
    redxr[1]=redxr[2]=0 ; redxr[0]=255;

    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    mathbkxr[0] = 79; mathbkxr[1] = 205; mathbkxr[2] = 202 ;
    notchxr[0] = 14 ; notchxr[1] = 27 ; notchxr[2] = 41 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 128 ;
    blabkxr[0]=blabkxr[1]=blabkxr[2]=0;
    greenbkxr[0] = 0 ; greenbkxr[1] = 255; greenbkxr[2] = 0 ; 

    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    mytext_tonorm (ptr_pedio[arped]->finame , str1kb,60);
    if (keyb_gr) sprintf (str1024,"Στατιστική Ανάλυση για F%d : %s" , arped+1, str1kb );
    else sprintf (str1024,"Statistics for F%d : %s",arped+1, str1kb);
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt, yt+7, xb, yt+34, chochxr , chobkxr);
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    refresh();
    
    if (choose){
        if (keyb_gr) sprintf (str1kb , "Δείγμα : Επιλογή %u Καρτελών" , tot_opts);
        else sprintf (str1kb , "Sample : %u chosen DB Cards" , tot_opts);
    }
    else {
        if (keyb_gr) strcpy (str1kb , "Δείγμα : Το σύνολο των Καρτελών");
        else strcpy (str1kb , "Sample : All DB Cards");
    }
    normtext_tomy (str1kb,0);
    setcolor (5) ;
    rectangle (xt+450 , yt+37 , xt+750, yt+51) ;
    _bareacls (xt+451 , yt+38 , xt+749, yt+50,notbkxr) ;
    
    _outmystr_center_col(2, str1kb , xt+451 , yt+38 , xt+749, yt+51, notchxr, notbkxr);
   
        
    
    stem=mem1;
    stems=mem2;
    data2=memd2;
     
    // Περνάω στα memcp (ceimk) τις τρέχουσες τιμές των memk (keimk)
    /*
    for (f=0;f<=dbfinum;f++) {
        keimk=memk[f];
        ceimk=memcp[f];
        i=0;
        if (ptr_pedio[f]->fitype !=5) { while (keimk[i] != 255) {ceimk[i]=keimk[i] ; i++;} ceimk[i] = 255; }
        else {
            if(keimk[i]!=255) strcpy (ceimk,keimk); 
            else ceimk[i]=255;
        }
    }
    */
    
    for (f=0;f<=dbfinum;f++) { 
        if (f==arped) break; // Υπολογισμός του άλματος fseek ανάλογα με το arped !
        alma+=xlimk[f];
    }
    
    dx=0;
    
    if (!choose) {
        
        for (f=0;f<dbplgr;f++) {
            dx=fseek(fpcard , ((disk_dom[f] * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[f]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[f] = stem[f];
        }
        
        if (dx) {rewind (fpcard); clearerr(fpcard);  
            information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}
        
    }
    else {
        
        for (i=0 ; i<tot_opts ; i++) {
            p=epil_pos[i];
            dx=fseek(fpcard , ((p * dbcardsize) + alma) , 0);
            if (dx) {  break ;}
            fread(deigma,1,xlimk[arped],fpcard);
            if (ferror(fpcard)) { dx=1 ; break ; }
            stem[i]= (deigma[0]!=255) ? (double) convert_str(xlimk[arped]-1 , deigma) : 0 ;
            stems[i] = stem[i];
        }
    }
    
    if (dx) {rewind (fpcard); clearerr(fpcard);  
        information (6-keyb_gr,Strcardfp,0) ; goto FYGE_1;}

    
    pro_sort_double_si (stems, (int) ma);
    
    // Διάμεσος
    diam=stems[ma/2];    
       
    // Άθροισμα και Μέση τιμή
    sumd=mean=0;dx=0;
    for (i=0;i<ma;i++) {
    mean+=stem[i]/ma;
    sumd+=stem[i];
    if (mean==HUGE_VAL) { dx=1; break ;}
    //if(sumd==HUGE_VAL) {};
    }
    
    if (dx) {goto FYGE;}
    
    y_avg=mean;
    
    // Μέση τiμή Χ
    
    x_avg=0;
    for (f=1 ; f<=num  ; f++) x_avg += f ;
    x_avg /= num ;
    
    // Επικρατούσα Τιμή
    
    oldmode=0 ; oldcount=0;
    for (f=0 ; f<ma ; f++) {
        d=stems[f];
        count=1;
        for (i=f+1; i<ma ; i++ ) {
            if (d==stems[i]) count++;
            else break;
        }
        if (count>oldcount) {
            oldmode=d;
            oldcount=count;
        }
    }
    
    epitimi=oldmode;
    
    // Τυπική Απόκλιση 
    
    mean2=0;
    for (f=0 ; f<ma ; f++) {
        d=stem[f]-mean;
        d *= d ;
        if (d==HUGE_VAL) { dx=1; break ;}
        mean2 += d/ma;
        if (mean2==HUGE_VAL) { dx=1; break ;}
    }
    
    if (dx) { goto FYGE;}
    typ_apo=sqrt(mean2);
    
        // Ypologismos b (Y = b*x + a)
    dx=0;
    temp=0 ; temp2=0;
    for (f=1 ; f<=num ; f++) {
        temp += ( (stem[f-1] - y_avg) * (f-x_avg) ) ;
        if (temp==HUGE_VAL) { dx=1 ; temp=0; break; }
        temp2 += ( (f-x_avg) * (f-x_avg) ) ;
    }
    
    
    b = temp / temp2 ;
    if (dx) { b=0; y_avg=0; }
    
    // Ypologismos a (Y = b*x + a)
    
    a = y_avg - (b*x_avg) ;
    
    // Ypologismos syntelesth sysxetishw
    
    for (f=0 ; f<num ; f++) { data2[f] = f+1 ;}
    cor = temp/num;
    d = std_dev(data2,num) ;
    if (d==HUGE_VAL) cor=0 ;
    else { cor = (cor / ( typ_apo * d )); }
    
    // Εμφάνιση αποτελεσμάτων
    
    y=yt+55;
    x=xt+9;
    w=290;
    gouv=myfont[3];
    
    // Ελάχιστο k1
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    
    if (ptr_pedio[arped]->fitype==3) {
    lfx = (long int) stems[0];
    sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Ελάχιστο : %s",str1024);
    else sprintf(str1kb,"Min. : %s",str1024);
    }
    else {
    sprintf(file_3,"%.2lf",stems[0]); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Ελάχιστο : %s",str1024);
    else sprintf(str1kb,"Min. : %s",str1024);
    }  
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+20, numchxr , numbkxr);
    
    
    // Διάμεσος κ2
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",diam); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Διάμεσος : %s",str1024);
    else sprintf(str1kb,"Median : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);    
    
    // Μέση Τιμή κ3
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",mean); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέσος Όρος : %s",str1024);
    else sprintf(str1kb,"Average : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);   

    // Μέγιστο k4
    
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    if (ptr_pedio[arped]->fitype==3) {
    lfx = (long int) stems[ma-1];
    sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέγιστο : %s",str1024);
    else sprintf(str1kb,"Max. : %s",str1024);
    }
    else {
    sprintf(file_3,"%.2lf",stems[ma-1]); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Μέγιστο : %s",str1024);
    else sprintf(str1kb,"Max. : %s",str1024);
    
    }
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    
    // Επικρατούσα Τιμή κ5
    
    //x=x+w+2;
    x=xt+9;
    y=y+23;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;    
    sprintf(file_3,"%.2lf",epitimi); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Επικρατ. Τιμή : %s",str1024);
    else sprintf(str1kb,"Prevail. price : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    
    // Τυπική Απόκλιση κ6
    
    x=x+w+2;
    //x=xt+9;
    //y=y+23;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;    
    sprintf(file_3,"%.2lf",typ_apo); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf(str1kb,"Τυπική Απόκλιση : %s",str1024);
    else sprintf(str1kb,"Standard deviation : %s",str1024);
    normtext_tomy(str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);

    // Άθροισμα k7
        
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    if (sumd != HUGE_VAL) {
        if (ptr_pedio[arped]->fitype==3) {
        lfx = (long int) sumd;
        sprintf(file_3,"%ld",lfx); normtext_tomy(file_3,0);
        mynum_teleies (file_3 , 3); mytext_tonorm (file_3,str1024,50);
        if (keyb_gr) sprintf(str1kb,"Άθροισμα : %s",str1024);
        else sprintf(str1kb,"Sum : %s",str1024);
        }
        else {
        sprintf(file_3,"%.2lf",sumd); normtext_tomy(file_3,0);
        mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
        if (keyb_gr) sprintf(str1kb,"Άθροισμα : %s",str1024);
        else sprintf(str1kb,"Sum : %s",str1024);
        }
        normtext_tomy(str1kb,0);
        _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    }
    
    else {
        normtext_tomy("Error",str1kb);
        _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    }
    
       // Core k8
        
    x=x+w+2;
    setcolor (0);
    rectangle (x,y,x+w,y+21) ;
    _bareacls (x+1,y+1,x+w-1,y+20 , numbkxr) ;
    
    sprintf(file_3,"%.2lf",cor); normtext_tomy(file_3,0);
    mynum_teleies (file_3 , 4); mytext_tonorm (file_3,str1024,50);
    if (keyb_gr) sprintf (str1kb , "Συντελ. Συσχέτισ.= %s" , str1024 ); 
    else sprintf (str1kb , "Correl. Factor = %s" , str1024 );
    normtext_tomy (str1kb,0);
    _outmystr_center_col(3, str1kb , x+1,y+1,x+w-1,y+21, numchxr , numbkxr);
    refresh() ;
    
    // Σχεδιάγραμμα
    
    sxeyt = y+50;
    x1=xt+40;
    swide=xb-50-xt ;
    shei=yb-35-sxeyt;
    
    while ( ((ma/ana)*pla + ((ma-1)/ana)*spa) > swide ) ana++;
    
    if (ana>1) {
        dx = ma % ana;
        c = (dx) ? (ma/ana) + 1 : ma/ana ;
    }
    else {c = ma ;}
    
    while ( (c*pla + (c-1)*spa ) < swide ) {
        if (pla==maxpla && spa==maxspa) break ;
        if (pla<12 && spa>=3) {pla++; continue ;}
        if (pla<16 && spa>=4) {pla++; continue ;}
        if (pla<20 && spa>=5) {pla++; continue ;}
        if (pla<24 && spa>=6) {pla++; continue ;}
        if (spa<maxspa) spa++;
    }
    
    while ( ( (c*pla + (c-1)*spa ) > swide ) && pla>7 ){
        if (spa>3) { spa--; continue ; }
        pla--;
    }
    
    va=pla/4; if (va>spa-1) va=spa-1 ;
        
    olneg=0;
    bn= (stems[0]<0) ? stems[0] : 0 ;
    bp= stems[ma-1];
    if (bp<=0) {
        bp = fabs (bn) ;
        prs=1;
        bn=0;
        olneg=1;
    }
    else {
        prs = (bn) ? 2 : 1 ;
        bn = fabs (bn);
        if (bn>bp) bp=bn ;
    }
    
    f=0 ; // bp : bigger pos , bn : bigger neg
    
    if (prs==1) { ypb = sxeyt + shei ; logos=shei/bp;}
    else {
        ypb = sxeyt + (shei/2) ; // y pos bottom
        logos=(shei/2)/bp ;
        }
    
    if (olneg) {
        setcolor (4) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else if (prs==1) {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        _velos_down (x1-20,x1-19,ypb);
    }
    else {
        setcolor (1) ;
        line (x1-19,sxeyt,x1-19,ypb) ;
        line (x1-20,sxeyt,x1-20,ypb) ;
        _velos_up(x1-20,x1-19,sxeyt);
        
        setcolor (4) ;
        line (x1-19,ypb+1,x1-19,ypb+shei/2) ;
        line (x1-20,ypb+1,x1-20,ypb+shei/2) ;
        _velos_down (x1-20,x1-19,ypb+shei/2);
    }
    refresh();
    
    // Ένδειξη μέγιστης τιμής στο πάνω βέλος
    dx=0 ; 
    lfx = (long int) bp;
    if (stems[ma-1]>0) sprintf(str1kb,"%ld",lfx);
    else { sprintf(str1kb,"%ld",-lfx); dx=1; }

    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , sxeyt-23 , xt+150, sxeyt-7) ;
    if (dx) {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , sxeyt-22 , xt+149, sxeyt-8,redxr, blabkxr);
    }
    else {
        _bareacls (xt+11 , sxeyt-22 , xt+149, sxeyt-8, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , sxeyt-22 , xt+149, sxeyt-8,bluexr, greenbkxr);
    }
    
    
    dx=0;
    // Ένδειξη ελάχιστης τιμής στο κάτω βέλος
    if (prs==1) lfx = 0 ;
    else { dx=1; lfx = (long int) -bp ;}
    sprintf(str1kb,"%ld",lfx);  
    normtext_tomy(str1kb,0);
    setcolor (5) ;
    rectangle (xt+10 , yb-26 , xt+150, yb-11) ;
    
       
    if (dx) {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, blabkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, redxr, blabkxr);
    }  
    else {
        _bareacls (xt+11 , yb-25 , xt+149, yb-12, greenbkxr) ;
        _outmystr_center_col(2, str1kb , xt+11 , yb-25 , xt+149, yb-12, bluexr, greenbkxr);
    } 
    
    refresh();
    setfillstyle (1,6) ;
    setcolor (15);
    i=0;
    while (i<ma) {
        d=0;
        for (f=0; i<ma && f<ana ; f++) {
            d += stem[i++];
        }
        if (d==HUGE_VAL) { x1 = x1+pla+spa ; continue ;}
        d /= f ;
        
        if (d>=0) {
            bh= (short int) ( d*logos );
            bar3d (x1,ypb-bh,x1+pla-1,ypb,va,1);
        }
        else {
            bh= (short int) abs  (  ( d*logos ) );
            if (prs==2) bar3d (x1,ypb,x1+pla-1,ypb+bh,va,1);
            else bar3d (x1,ypb-bh,x1+pla-1,ypb,va,1);
        }
        x1 = x1+pla+spa ;
    }
    refresh ();
    // Περιμένει κάτι...
    x1=xt+40;
    mx1=my1=0;
    count = c*pla + (c-1)*spa ;
    dx = x1+count-1 ;
    
    do {
        if (SDL_PollEvent(&sdlev)){
            if (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) break ;
            if (sdlev.type==SDL_MOUSEMOTION) {mx=sdlev.motion.x ; my=sdlev.motion.y;continue ;}
            if (sdlev.type == SDL_WINDOWEVENT) { refresh(); continue ; }
        }
            
        if (mx>dx || mx<x1 || my>yb-35 || my<sxeyt) continue ;
        if (mx1==mx && my1==my) continue ;
        mx1=mx ; my1=my ;
        w=mx-x1;
        p=(ma*w/count)+1;
        if (p && p>ma) p--;

        if (prs==1) {
           bh=ypb-my;
           d=bh*bp/shei;
           if (stems[ma-1]<=0) sprintf(str1kb,"(%u , %.0lf)",p,-d);
           else sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
        else {
            if (my<=ypb) {
                bh=ypb-my;
                d= 2*bh*bp/shei;
            }
            else {
                bh=my-ypb;
                d=-2*(bh*bp/shei);
            }
           
           
           sprintf(str1kb,"(%u , %.0lf)",p,d);
           if (mem_small) hide_help(hdhlpxt , hdhlpyt);
           show_help(str1kb, mx, my-15 , &hdhlpxt , &hdhlpyt) ;
        }
    } while (1);
        
    if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    
        do {
    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    //
    
FYGE_1 :
    // Φεύγοντας διαβάζει πάλι τρέχουσα καρτέλα
    /*
    if (dbcard<=dbplgr) {
            dx = fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            if (dx) {
                information (6-keyb_gr,Strcardfp,0) ;
                rewind (fpcard) ; clearerr(fpcard) ;
                fseek (fpcard , disk_dom[dbcard-1]*dbcardsize , 0) ;
            }
            
            for (f=0;f<=dbfinum;f++) {
                // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
                keimk=memk[f];
                ceimk=memcp[f];
                i=0;
                if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
                else {
                    if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                    else keimk[i]=255;
                }
                
                fread (memcp[f] , 1, xlimk[f], fpcard);
                if (ferror(fpcard)) information (6-keyb_gr,Strcardfp,0) ;
            }
        }
    else {
        for (f=0;f<=dbfinum;f++) {
            // Επαναφέρω τιμές στις memk αντιγράφοντας από τις memcp !
            keimk=memk[f];
            ceimk=memcp[f];
            i=0;
            if (ptr_pedio[f]->fitype !=5) { while (ceimk[i] != 255) {keimk[i]=ceimk[i] ; i++;} keimk[i] = 255; }
            else {
                if(ceimk[i]!=255) strcpy (keimk,ceimk); 
                else keimk[i]=255;
            }
            
            ceimk[0]=255;
        }
    }
    */
    
FYGE :

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem1) free(mem1);
    if (mem2) free(mem2);
    gouv=trampa;
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return 1;
}


void piesl_stats (short int fifi, unsigned short int *disk_dom , short int choose)
//choose = 0 αναλύονται όλα
//choose = 1 αναλύονται μόνον οι επιλογές
// fifi = αυτό το πεδίο με το οποίο κλήθηκε
{
short int maxflds = 10 ;
unsigned short int arped[maxflds] , arpx ;
int lr[maxflds][3] ; //χρώματα
unsigned long int alma[maxflds] , salto ;
double sum [maxflds]  , sumx ;
int mires_a[maxflds]  , mires_t[maxflds];
int a , t  , dx  ,r ;
void *mem0=0, *memf=0 , *mem1=0 ;
struct fansouv *trampa ;
register int f,i ;
unsigned short int  p , ma , c , s ,m, count ;
int mx, my, mx1, my1 ,v ;
unsigned char deigma[16];
short int kx, ky, x, x1, y, x2, w , pe ,bh ;
double  d , d1, d2 , d3 , gsum ,xar ;
short int swide , shei  ;
short int xt,yt,xb,yb , sxeyt ;
int chochxr[3] , chobkxr[3] ;
unsigned char what ;
int numbkxr[3] , numchxr[3] , asprobkxr[3] , notchxr[3] , notbkxr[3] , bluexr[3] , redxr[3] , blabkxr[3] , greenbkxr[3] ;
//int *pioxr;

unsigned char *synolo_fnum;
struct {
    unsigned short int fd_orio;
    unsigned short int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    short int fd_sorton;
} dbfnum ;
unsigned int size_fnum=512;
static short int fsorton;
unsigned char *eplfi ;

    if (dbfinum==-1 || !dbplgr ) return;
    
    if (!tot_opts && choose) return ;
    
    memf=malloc(size_fnum) ; 
    if (!memf) return ;
    synolo_fnum=memf;
    
    m=0; s=0; dx=0;
    dbfnum.fd_orio=0;

    pe=1;
    arped[0]=fifi; 

    for (f=0;f<=dbfinum;f++) {
        
        if (fifi==f) continue ;
        if (ptr_pedio[f]->fitype !=3  && ptr_pedio[f]->fitype !=4) continue ;
        
        dx++;
        
        if ( (m+31) > (size_fnum-40) ) {
            size_fnum+=256;
            memf=realloc(memf,size_fnum);
            if (!memf) goto FYGE ;
            synolo_fnum=memf;
        }
        
        for (i=0;i<31;i++) {
            what=ptr_pedio[f]->finame[i];
            synolo_fnum[s] = what ;
            m++; s++;
            if (what==255) break;
        }
        
        if (dbfnum.fd_orio<i) dbfnum.fd_orio=i;
    }

    if (s) {
        dbfnum.fd_ar = s ;
        synolo_fnum[s]=254;
    }
    else {
    synolo_fnum[0]=255;
    synolo_fnum[1]=254;
    dbfnum.fd_ar=0;
    }
    dbfnum.mem_fd = (void*) synolo_fnum;
    dbfnum.fd_data[0]=255;
    dbfnum.fd_sorton=fsorton;
    
    if (dx) {
        if (keyb_gr) sprintf(str1024,"Επιλέξτε περισσότερα πεδία.."); else sprintf(str1024,"Select more fields..");
        normtext_tomy(str1024 , dbfnum.fd_name);
        mem1 = mulbutton_show(dbfnum.mem_fd, dbfnum.fd_ar, dbfnum.fd_orio, dbfnum.fd_name, &dbfnum.fd_sorton,0 );
        fsorton = dbfnum.fd_sorton ;
        if (mem1) {
            eplfi=mem1; x=0 ;
            for (f=0;f<=dbfinum;f++) {
                if (pe==maxflds) break ;
                if (fifi==f) continue ;
                if (ptr_pedio[f]->fitype ==3  || ptr_pedio[f]->fitype ==4) {
                    if (eplfi[x]) { arped[pe]=f; pe++ ; }
                    x++;
                }
            }
        }
    }
    
    if (memf) {free (memf); memf=0; }
    if (mem1) {free (mem1); mem1=0; }

    bh=800;
    xt=(info.right-info.left-1199) / 2 ; yt=(info.bottom-info.top-bh-1) / 2 ;
    xb=xt+1199; yb=yt+bh-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); goto FYGE ;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    // Ταξινόμηση της arped
    
    pro_sort_usint(arped,(int) pe);
    
    dx=0;x=0;
    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        if (arped[x]==f) {
            dx=mystrcmp(keimk,ceimk);
            if (dx) break;
            if (x<pe) x++ ;
            else break ;
        }
    }
    
    if (dx) {
        if (keyb_gr) information (0,"Έχετε αλλάξει το περιεχόμενο πεδίων..\n..αλλά δεν σώσατε την καρτέλα!\nΔεν θα ληφθεί τώρα υπόψη η τροποποίηση!",0);
        else information (0,"You have changed data in these fields..\n..but you have not saved the DB card!\nThis change will not be taken into account now!",0);
    }
    

    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

    if (!choose) {
        ma=dbplgr;
    }
    else {
       if (!tot_opts || !epil_pos) goto FYGE ;
       ma=tot_opts;
    }
    
    if (!ma) goto FYGE ;
  
    
    chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
    chochxr[0]=255 ; chochxr[1]=148 ; chochxr[2]=31 ; 
    bluexr[0]=bluexr[1]=0 ; bluexr[2]=255;
    redxr[1]=redxr[2]=0 ; redxr[0]=255;

    numbkxr[0] = 79; numbkxr[1] = 172 ; numbkxr[2] = 87;
    numchxr[0] = numchxr[1] = numchxr[2] = 0 ; 
    asprobkxr[0] = asprobkxr[1] = asprobkxr[2] = 255 ;
    notchxr[0] = 0 ; notchxr[1] = 0 ; notchxr[2] = 0 ;
    notbkxr[0] = notbkxr[1] = 255 ; notbkxr[2] = 0 ;
    blabkxr[0]=blabkxr[1]=blabkxr[2]=0;
    greenbkxr[0] = 0 ; greenbkxr[1] = 255; greenbkxr[2] = 0 ; 

    _bareacls(xt,yt,xb,yb,chobkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    
    if (keyb_gr) strcpy (str1024,"Κυκλικό Διάγραμμα Κατανομής Αθροισμάτων (Απόλυτες τιμές)");
    else strcpy (str1024,"Sum Total Piechart (Αbsolute Values)");
    normtext_tomy (str1024,0);
    _outmystr_center_col(1, str1024 , xt, yt+7, xb, yt+34, chochxr , chobkxr);
    
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(4);
    line (xt+i, yt+34, xb-i, yt+34);
    refresh();
    
    if (choose){
        if (keyb_gr) sprintf (str1kb , "Δείγμα : Επιλογή %u Καρτελών" , tot_opts);
        else sprintf (str1kb , "Sample : %u chosen DB Cards" , tot_opts);
    }
    else {
        if (keyb_gr) strcpy (str1kb , "Δείγμα : Το σύνολο των Καρτελών");
        else strcpy (str1kb , "Sample : All DB Cards");
    }
    normtext_tomy (str1kb,0);
    setcolor (5) ;
    rectangle (xt+450 , yt+37 , xt+750, yt+51) ;
    _bareacls (xt+451 , yt+38 , xt+749, yt+50,notbkxr) ;
    
    _outmystr_center_col(2, str1kb , xt+451 , yt+38 , xt+749, yt+51, notchxr, notbkxr);
   
    y=yt+55;
     
    
    // Υπολογισμός του άλματος fseek ανάλογα με τa arped !
    dx=0; x=0;
    for (f=0;f<=dbfinum;f++) { 
        if (f==arped[x]) {
            alma[x]=dx ; sum[x]=0; dx=0;
            x++;
            if (x==pe) break ;
            else continue ;
        }
        dx += xlimk[f];
    }
    

    dx=0; a=0 ; 
    rewind (fpcard);
    
    if (!choose) {
        
        for (f=0;f<dbplgr;f++) {
            p=disk_dom[f] ;
            for (x=0 ; x<pe ; x++) {
                v = (!x) ? SEEK_SET : SEEK_CUR ;
                salto = (!x) ? ( (p * dbcardsize) + alma[x] ) : alma [x] ;
                if (salto) { dx=fseek(fpcard , salto , v); if (dx) break ;}
                fread(deigma,1,xlimk[arped[x]],fpcard);
                if (ferror(fpcard)) { dx=1 ; break ; }
                d = (deigma[0]!=255) ? (double) convert_str(xlimk[arped[x]]-1 , deigma) : 0 ;
                sum[x] += d ;
                if (sum[x]==HUGE_VAL) {a=1 ; break ;}
            }
            if (dx) break ;
        }
        
        if (a) {goto FYGE;}
        if (dx) {rewind (fpcard); clearerr(fpcard);  
            information (6-keyb_gr,Strcardfp,0) ; goto FYGE;}
        
    }
    else {
        
        for (i=0 ; i<tot_opts ; i++) {
            p=epil_pos[i];
            for (x=0 ; x<pe ; x++) {
                v = (!x) ? SEEK_SET : SEEK_CUR ; 
                salto = (!x) ? ( (p * dbcardsize) + alma[x] ) : alma [x] ;
                if (salto) { dx=fseek(fpcard , salto , v); if (dx) break ; }
                fread(deigma,1,xlimk[arped[x]],fpcard);
                if (ferror(fpcard)) { dx=1 ; break ; }
                d = (deigma[0]!=255) ? (double) convert_str(xlimk[arped[x]]-1 , deigma) : 0 ;
                sum[x] += d ;
                if (sum[x]==HUGE_VAL) {a=1 ; break ;}
            }
            if (dx) break ;
        }
    }
    
    if (a) {goto FYGE;}
    if (dx) {rewind (fpcard); clearerr(fpcard);   
        information (6-keyb_gr,Strcardfp,0) ; goto FYGE;}
    
   
    // Πεδίο fifi στη πρώτη θέση  !!
    
    for (f=0 ; f<pe ; f++) {
        if (arped[f] == fifi) break ;
    }
    if (f) {
        arpx = arped[0]; arped[0]=arped[f]; arped[f]=arpx ;
        sumx = sum[0] ; sum[0]=sum[f] ; sum[f]=sumx;
    }
    
    gsum=0;a=0;
    for (f=0 ; f<pe ; f++) {
        gsum += fabs (sum[f]) ;
         if (gsum==HUGE_VAL) {a=1 ; break ;}
    }
    
    if (a) {goto FYGE;}
    d1 = 0.5 ; d3=0 ;
     t=0 ; xar=0;
    for (f=0 ; f<pe ; f++) {
        mires_a[f]=t;
        lfx= (360/gsum)*labs (sum[f]);
        dfx=(360/gsum)*fabs (sum[f]);
        d2 = dfx-lfx ;
        if (d2>d1) {  lfx++;  xar+=(1-d2); }   
        else d3+=d2;
        mires_t[f] = t + (int) lfx ;
        if (d3-xar < 1)  t = mires_t[f] ; 
        else {
            d3-=xar;
            xar = 0;
            t=mires_t[f]+1; }
    }
    if (mires_t[pe-1]>360) mires_t[pe-1]=360 ;
    
    // SXEDIASH
    
    lr[0][0] = 0 ; lr[0][1] = 255 ; lr[0][2] = 0; // Πράσινο 
    
    lr[1][0] =  0; lr[1][1] = 160;  lr[1][2] = 160 ; // Σιέλ 
    
    lr[2][0] =  255 ; lr[2][1] = 255 ; lr[2][2] = 0 ; // Κίτρινο
    
    lr[3][0] =  217;  lr[3][1] = 69;  lr[3][2] = 207 ; // Μώβ
    
    lr[4][0] =  255;  lr[4][1] = 127;  lr[4][2] = 0 ; // Xryso
    
    lr[5][0] =  143; lr[5][1] = 99;  lr[5][2] = 220;
    
    lr[6][0] = 196 ; lr[6][1] = 53;  lr[6][2] = 46;
    
    lr[7][0] =  171;  lr[7][1] = 119;  lr[7][2] = 0;
    
    lr[8][0] = 0 ; lr[8][1] = 255;  lr[8][2] =255 ;
    
    lr[9][0] =  255;  lr[9][1] = 191;  lr[9][2] = 255;

    sxeyt = y+30;
    x1=xt+10 ;
    swide=xb-200-xt ;
    shei=yb-10-sxeyt;
    ky = sxeyt + shei/2 - 20 ;
    kx=x1 + swide/2-180 ;
    r = (shei/2-40);
    setcolor (0) ;
    circle (kx,ky,r) ;
    circle (kx+2,ky+3,r+6);
    setfillstyle(1,COLOR(18,29,33));
    floodfill(kx, ky+r+2 , 0);
    
    for (f=0 ; f<pe ; f++) {
        
        if (mires_a[f]==mires_t[f]) continue ;
        setfillstyle (1, (COLOR (lr[f][0] , lr[f][1] , lr[f][2])) ) ;
        pieslice (kx,ky,mires_a[f], mires_t[f],r) ;
    }
   
   
   refresh ();
    x2 = kx +r + 30 ;
    y=sxeyt+10;
    x1 = x2+255 ;
    
    if (keyb_gr) strcpy (str1024,"Υ Π Ο Μ Ν Η Μ Α");
    else strcpy (str1024,"Ν Ο Τ Ε");
    normtext_tomy(str1024,0);
    _outmystr_center_col(1, str1024 , x2, y, xb-10, y+25, chochxr , chobkxr);
    
    
    i=0;f=0;
    gouv=myfont[1];
    what=str1024[i];
    while (what!=255) {  f+=gouv[what].wid; what=str1024[i++]; }
    i= (xb-10-x2-f+1) / 2 ;
    setcolor(4);
    line (x2+i, y+34, xb-9-i, y+34);
    refresh();
    
    y+=50 ;
    
    for (f=0 ; f<pe ; f++) {
        setcolor(0);
        rectangle (x2 , y , x2+250 , y+25) ;
        rectangle (x1 , y , x1+210 , y+25) ;
        mystrcpy (str1024,ptr_pedio[arped[f]]->finame );
        mytext_perikop(str1024,25);
        sprintf (str1kb ,"%.2lf" , sum[f]);
        normtext_tomy(str1kb,file_3);
        mynum_teleies (file_3 , 4 );
        
        if (mires_a[f]==mires_t[f]) {
        _bareacls (x2+1,y+1,x2+249,y+24,asprobkxr);
        _bareacls (x1+1,y+1,x1+209,y+24,asprobkxr);
        _outmystr_center_col(3, str1024 ,x2+1,y+1,x2+209,y+24, blabkxr, asprobkxr);
        _outmystr_right_col(3, file_3 ,x1+1,y+1,x1+209,y+24, blabkxr, asprobkxr);
        }
        else {
        _bareacls (x2+1,y+1,x2+249,y+24,lr[f]);
        _bareacls (x1+1,y+1,x1+209,y+24,lr[f]);
        _outmystr_center_col(3, str1024 ,x2+1,y+1,x2+249,y+24, blabkxr, lr[f]);
        _outmystr_right_col(3, file_3 ,x1+1,y+1,x1+209,y+24, blabkxr, lr[f]);
        }
        
         y+=60;
    }
    
    refresh ();
   
    do {
        if (SDL_PollEvent(&sdlev)){
            if (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN) break ;
            if (sdlev.type == SDL_WINDOWEVENT) { refresh(); continue ; }
        }
    } while (1);
        
    
    //if (mem_small) hide_help(hdhlpxt , hdhlpyt);
        
        do {
    SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

FYGE :

    if (mem0) {
        fidicls(xt,yt,xb,yb,55,84,112); 
        putimage (xt,yt,mem0,0);
        refresh();
        free (mem0) ;
    }
    if (mem1) free (mem1) ;
    if (memf) free (memf);
    gouv=trampa;
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    return ;
}

void mytext_perikop (unsigned char *str , short int a) 
{
register int i=0 ;

while (str[i] != 255)  i++;
if (a>=i) return ;
if (a) str[a-1]=15;
str[a]=255;
}


void mynum_teleies (char *num , char type) 
// type = 3 για ακέραιους , type = 4 δεκαδικούς
{
register int f,i ;
int l , a , b ;
int t , y , c ;
unsigned char *str ; 

    str=num;

    i=0;
    if (type==3) {
        while (str[i] != 255) i++;
        l=i;
        f = (str[0]==13) ? 1 : 0 ; 
        a= (l-f)/3 ; b=(l-f) %3;
        
        t= (b) ? a : a-1 ;
        
        for (f=0 ; f<t ; f++) {
            a=(f*3)+f+4;
            b=l;
            for (i=0; i<a; i++) {
                str[b+1]=str[b];
                b--;
            }
            b++;
            str[b]=14;
            l++;
        }
    }
    
    else if (type==4) {
        y=-1;
        while (str[i] != 255) {
            if (str[i]==14) { y=i ; str[y]=12; }
            else if (str[i]==12) y=i ;
            i++;
        }
        l=i;
        if (y==-1) {
            
            f = (str[0]==13) ? 1 : 0 ; 
            a = (l-f)/3 ; b=(l-f) %3;
            
            t= (b) ? a : a-1 ;
            
            for (f=0 ; f<t ; f++) {
                a=(f*3)+f+4;
                b=l;
                for (i=0; i<a; i++) {
                    str[b+1]=str[b];
                    b--;
                }
                b++;
                str[b]=14;
                l++;
            }
        }
        else {
            
            c=l-y;
            
            f = (str[0]==13) ? 1 : 0 ;
            a = (y-f)/3 ; b = (y-f) % 3;
            
            t= (b) ? a : a-1 ;
            
            for (f=0 ; f<t ; f++) {
                a=(f*3)+f+4+c;
                b=l;
                for (i=0; i<a; i++) {
                    str[b+1]=str[b];
                    b--;
                }
                b++;
                str[b]=14;
                l++;
            }
        }
    }
}


int _outmystr_right_col(short int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr)

// Επιστρέφει 0 αν δεν χωράει ΚΑΘΟΛΟΥ το κείμενο μέσα στο rectangle
// Επιστρέφει 1 αν το κείμενο δεν χώρεσε κατά μήκος αλλά γράφτηκε μέρος αυτού !
// Επιστρέφει 2 αν όλα πήγαν καλά !

{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, dy, neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;


a=xr-x+1;
if (a<myfont_wid[font]) return 0;
dy=yb-y+1;
if (dy<myfont_hei[font]) return 0;
dy=(dy-myfont_hei[font])/2 ;
f=0;
neg=0;
what=str[f];
if (what==255) return 0;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

c=xr-neg;
if (c<x) c=x; else x=c;
y+=dy;
dy=2;

    a=0;
    what=str[a];
    while (what<164 ) {
    if ( x> (xr-gouv[what].wid) +1 ) {dy=1;break;}
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
    green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
    blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
    return (int) dy;
} 


void _outmystr_rcol(short int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr, int *colchxr, int *colbkxr)

// ΔΕΝ κεντράρει ούτε ελέγχει καθ' ύψος !!! (δεν ζητάει καν yb)
// Επιστρέφει 0 αν δεν χωράει ΚΑΘΟΛΟΥ το κείμενο μέσα στο rectangle
// Επιστρέφει 1 αν το κείμενο δεν χώρεσε κατά μήκος αλλά γράφτηκε μέρος αυτού !
// Επιστρέφει 2 αν όλα πήγαν καλά !

{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;


a=xr-x+1;
if (a<myfont_wid[font]) return ;

f=0;
neg=0;
what=str[f];
if (what==255) return ;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

c=xr-neg;
if (c<x) c=x; else x=c;


    a=0;
    what=str[a];
    while (what<164 ) {
    if ( x> (xr-gouv[what].wid) +1 ) {break;}
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
    green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
    blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    x+=gouv[what].wid;
    what=str[++a];
    }
    gouv=trampa;
    return ;
} 



int choise_alert_3 (char *astr1,char *astr2, char *astr3, short int akyro)
// akyro=0 : χωρίς δυνατότητα να μην επιλέξω κάτι από τα τρία
// Επιστρέφει -1 αν προέκυψε πρόβλημα !
// Τα astr1 , astr2 , astr3 είναι κανονικά strings που τελειώνουν σε 0 ! Να μην υπερβαίνουν τους 600 χαρακτήρες ! Να μην χρησιμοποιήσω τη γενική μεταβλητή char file_1 !!!!!!
// Επιστρέφτει 1 για 1η περίπτωση , 2 για 2η , 3 για 3η και 0 για άκυρο !
{

register int f,i ;
int d , f1 ;
SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0=0 , *mem_ni=0 , *mem_go=0 , *mem_yes=0, *mem_alert=0;
short int xt,yt,xb,yb , br ;
short int rxt[3],ryt[3],boxt[3],boyt[3],rxb[3],ryb[3],boxb[3], boyb[3] ;
short int yesxt,yesyt,yesxb,yesyb,goxt,goyt,goxb,goyb,alext,aleyt ;
int mx,my,mx1, my1, fyge=-1;
unsigned int size ;
unsigned short int ch_scan ;
int choxr_r[3] , choxr_b[3], chobkxr[3] , boxbkxr[3] ;
unsigned char mystr[1024];
char *str[3];
short int loop=1 , ejo=1 , yes=0, cancel=0 , nep;
short int bo[3] , re[3] ;

SDL_EventState(SDL_DROPFILE, SDL_DISABLE);

 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

size=imagesize(0,0,599,549);
mem0=malloc(size);
if (!mem0) {information (2-keyb_gr,0,0); goto FYGE;}
xt=(info.right-info.left-599) / 2 ; yt=(info.bottom-info.top-549) / 2 ;
xb=xt+599;
yb=yt+549;
getimage(xt,yt,xb,yb,mem0);

// Yes : 54 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/Yel_ok_39.ico");
mem_yes= icontomem (file_1,255);
if (!mem_yes) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

// Cancel : 94 Χ 36
strcpy (file_1,path_name);
strcat (file_1,"ICD/go_40.ico");
mem_go = icontomem (file_1,255);
if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


// Ένδειξη "νι-οκ" μέσα σε κουτί 35 Χ 35
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ni= icontomem (file_1,255);
if (mem_ni==NULL) {information(2-keyb_gr,file_1,NULL); goto FYGE ; }

strcpy (file_1,path_name);
strcat (file_1,"ICD/notif_1.ico");
mem_alert=icontomem (file_1,255);
if (!mem_alert) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

chobkxr[0]=55; chobkxr[1]=84;  chobkxr[2]=112;
choxr_r[0]=0; choxr_r[1]=0;  choxr_r[2]=0;
choxr_b[0]=255; choxr_b[1]=255;  choxr_b[2]=255;
boxbkxr[0]=253 ; boxbkxr[1]=106 ; boxbkxr[2]=2 ; 
whouv=gouv;
gouv=myfont[7];

str[0]=astr1; str[1]=astr2; str[2]=astr3;

alext=xt+(600-90)/2;
aleyt=yt+10;

for (f=0; f<3; f++) {
rxt[f] = xt+12;
rxb[f] = rxt[f]+500;
if (!f) ryt[0] = aleyt+100 ; else ryt[f]=ryb[f-1]+20 ; 
ryb[f] = ryt[f]+110;
boxt[f]=rxb[f]+25;
boyt[f]=ryt[f];
boxb[f]=boxt[f]+40;
boyb[f]=boyt[f]+40;
}

yesxt=xb-65; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
goxt=rxt[0]+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;
yesxt=xb-65; yesyt=yb-45; yesxb=yesxt+54; yesyb=yesyt+36;
goxt=rxt[0]+50; goyt=yb-45; goxb=goxt+94; goyb=goyt+36 ;


_bareacls(xt,yt,xb,yb,chobkxr);
setrgbcolor (dbred) ;
rectangle (xt,yt,xb,yb);
rectangle (xt+1,yt+1,xb-1,yb-1);
setrgbcolor (dbaspro) ;
rectangle (xt+2,yt+2,xb-2,yb-2);
rectangle (xt+3,yt+3,xb-3,yb-3);
setrgbcolor (dbblack) ;
rectangle (xt+4,yt+4,xb-4,yb-4);
rectangle (xt+5,yt+5,xb-5,yb-5);
setrgbcolor (dbyel) ;
rectangle (xt+6,yt+6,xb-6,yb-6);
refresh();

for (f=0; f<3; f++){
    normtext_tomy (str[f] , mystr);
    _nofield_txt_show (mystr , 0, rxt[f]+2 , ryt[f]+1 , rxb[f]-1 , ryb[f]-1 , 600 , choxr_r, chobkxr);
    
    setrgbcolor (dbblack) ;
    rectangle (boxt[f],boyt[f],boxb[f],boyb[f]);
    rectangle (boxt[f]+1,boyt[f]+1,boxb[f]-1,boyb[f]-1);
    _bareacls (boxt[f]+2,boyt[f]+2,boxb[f]-2,boyb[f]-2,boxbkxr);
}

    setrgbcolor (dbmag) ;
    rectangle (rxt[0] , ryt[0], rxb[0] , ryb[0]) ;

refresh();

_puticon(alext,aleyt,mem_alert,255);
_puticon(yesxt,yesyt,mem_yes,255);
if (akyro) _puticon(goxt,goyt,mem_go,255);
_puticon(boxt[0]+3,boyt[0]+3,mem_ni,255);

refresh();
fyge=1 ;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor); 
bo[0]=re[0]=nep=1; bo[1]=bo[2]=re[1]=re[2]=0 ;

do {

if (!SDL_PollEvent(&sdlev)) continue;
        switch (sdlev.type) {
        
        case SDL_MOUSEMOTION:
        while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
        mx=sdlev.motion.x ; my=sdlev.motion.y;
        if (mx<xt || mx>xb || my<yt || my>yb) {
            if (ejo) continue ;
            ejo=1;
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor); 
            for (f=0; f<3; f++) {
                if (!bo[f] && re[f]) {re[f]=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (rxt[f] , ryt[f], rxb[f] , ryb[f]) ;
                    refresh();}
            }

            continue ;
        }
        
        if (ejo) {
            cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            ejo=0;
        }
        
        br=0; f1=-1;
        
        for (f=0; f<3 ; f++) {
            if (mx>boxt[f] && mx<boxb[f] && my>boyt[f] && my<boyb[f]) { f1=f; break; }
            if (mx>rxt[f] && mx<rxb[f] && my>ryt[f] && my<ryb[f]) { f1=f; break; }
        }
        
        if (f1>=0) {
                
                if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
                else if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
                
                if (bo[f1]) {
                    d=-1;
                    for (i=0;i<3;i++) {
                        if (i==f1) continue;
                        if (re[i]) {d=i; break;}
                    }
                    if (d<0) continue ;
                    re[d]=0;
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (rxt[d] , ryt[d], rxb[d] , ryb[d]) ;
                    refresh();
                    continue ;
                }
                
                if (re[f1]) continue ;
                re[f1]=1 ; 
                setrgbcolor (dbaspro);
                rectangle (rxt[f1] , ryt[f1], rxb[f1] , ryb[f1]) ;
                refresh();
                continue ;
            }
              
        
        for (f=0; f<3; f++) {
            if (!bo[f] && re[f]) {
                re[f]=0; setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                rectangle (rxt[f] , ryt[f], rxb[f] , ryb[f]) ;
                refresh();
            }
        }
        
        if (mx>yesxt && mx<yesxb && my>yesyt && my<yesyb) {
            
            if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
            
            if (yes) continue ;
            yes=1;
            putNOTicon(yesxt,yesyt,mem_yes);
            continue ;
        }
        
        if (yes) {yes=0; puticon(yesxt,yesyt,mem_yes,255); }
        
        if (akyro) {
        
            if (mx>goxt && mx<goxb && my>goyt && my<goyb) {
                
                if (cancel) continue ;
                cancel=1;
                putNOTicon(goxt,goyt,mem_go);
                continue ;
            }
        }
        
        if (cancel) {cancel=0 ; puticon(goxt,goyt,mem_go,255);}
        
        break ; // break of SDL_MOUSEMOTION
        
        case SDL_MOUSEBUTTONDOWN:
        if(sdlev.button.button==SDL_BUTTON_LEFT) {   
            mx1 = sdlev.button.x ; my1= sdlev.button.y ;
            if ( (abs (mx1-mx) > 40) || (abs (my1-my) > 40) ) {
                do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONDOWN);
                continue ;
            }
        
            nep=0;
            for (f=0; f<3; f++) {
                if (mx1>boxt[f] && mx1<boxb[f] && my1>boyt[f] && my1<boyb[f]) { nep=f+1 ; break; }
                else if (mx1>rxt[f] && mx1<rxb[f] && my1>ryt[f] && my1<ryb[f]) { nep=f+1 ; break; }
            }

            
            br=0;d=-1;
            if (nep) {
                for (f=0; f<3; f++) {
                    
                    if (bo[f]) {
                        for (i=0; i<3; i++) {
                            if (i==nep-1) continue ;
                            if (re[i]) { d=i; break ;}
                        }
                        if (d<0) { br=1; break ;}
                        re[d]=0;bo[d]=0;
                        setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                        rectangle (rxt[d] , ryt[d], rxb[d] , ryb[d]) ;
                        refresh();
                        break ;
                    }
                }
                    
                    bo[nep-1]=1; re[nep-1]=1;
                    if (br) continue ;
                    
                    f=nep-1;
                         
                    _puticon(boxt[f]+3,boyt[f]+3,mem_ni,255);
                    setrgbcolor (dbmag);
                    rectangle (rxt[f] , ryt[f], rxb[f] , ryb[f]) ;
                    normtext_tomy (str[f] , mystr);
                    _nofield_txt_show (mystr , 0, rxt[f]+2 , ryt[f]+1 , rxb[f]-1 , ryb[f]-1 , 600 , choxr_r, chobkxr);

                        
                    _bareacls (boxt[d]+2,boyt[d]+2,boxb[d]-2,boyb[d]-2,boxbkxr);
                    setcolor (COLOR (chobkxr[0] , chobkxr[1] , chobkxr[2]));
                    rectangle (rxt[d] , ryt[d], rxb[d] , ryb[d]) ;
                    normtext_tomy (str[d] , mystr);
                    _nofield_txt_show (mystr , 0, rxt[d]+2 , ryt[d]+1 , rxb[d]-1 , ryb[d]-1 , 600 , choxr_b, chobkxr); 
                    
                    refresh();
                    continue ;
                    }
                    
            if (!nep) {
                for (f=0; f<3; f++) {
                    if (bo[f]) {nep=f+1;break;}
                }
            }
                
                        
            if (yes) {
                for (f=0; f<3; f++) {
                    if (bo[f]) { fyge=f+1 ; break; }
                }
                loop=0;
                break ;
            }
            
            if (akyro && cancel) {
                fyge=0;
                loop=0;
                break ;
            }
            
        }
        else if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            continue ;
        }
        break ;
        
        case SDL_KEYDOWN:
            
            ch_scan=sdlev.key.keysym.scancode;
                        
            switch (ch_scan) { 
                        
                case SDL_SCANCODE_ESCAPE :  
                    if (!akyro) break;
                    fyge=0;
                    loop=0;
                    break ;
                    
                case SDL_SCANCODE_RETURN :
                
                    for (f=0; f<3; f++) {
                        if (bo[f]) { fyge=f+1 ; break; }
                    }
                    loop=0;
                    break ;
                
            }
            
        break ;

        case SDL_WINDOWEVENT :
        refresh(); 
        continue;
    }
        
} while (loop);

FYGE:
if (mem0) {
    fidicls(xt,yt,xb,yb,55,84,112); 
    putimage (xt,yt,mem0,0);
    refresh();
    free (mem0) ;
}
if (mem_ni) free (mem_ni);
if (mem_go) free (mem_go);
if (mem_yes) free(mem_yes);
if (mem_alert) free(mem_alert);

gouv=whouv;
cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
return fyge;
}


int fields_rec_move (unsigned char *giam, short int aa, int mx, int my, int *xl, int *yt ,int *xr , int *yb)
// Ελέγχει αν το rectangle βρίσκει με άλλα ... 
// Επιστρέφει 0 αν επιτρέπεται η αλλαγή θέσης και περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt , ext, eyt, exb , eyb , dx1, dy1 ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy , dwel , dwproel  ;
short int c , shift , d , e , xm , ym , k , dx, dy ;
short int a;
const Uint8 *state ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dx=(short int) abs(mx-prxl); 
dy=(short int) abs(my-pryt); 
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}

getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(dbgreen);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);
shift=0;
xm=dxa; ym=dya+25;

 do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEMOTION  &&  SDL_PollEvent(&sdlev) ); 
        mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
        if (mxl<0 || myt<0) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) { refresh(); continue ;}
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=-1;break;}
        
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
        
        //if ((!mxl) || (!myt) ) continue ;
        e=d=0;
        mxl -=dx; myt-=dy;
        if (mxl<info.left+2) {d=1; mxl=info.left+2;}
        else if (mxl>info.right) mxl=info.right;
        if (myt<info.top+2) { myt=info.top+2; e=1; }
        else if (myt>info.bottom-25) myt=info.bottom-25 ;
        

        
       //if (mxl<info.left+3) { mxl=info.left+3; d=1; } 
       //if (myt<info.top+3) { myt=info.top+3; e=1; } 
               
       if (shift) {
           if (!d) {
                c=mxl-3; c=c%8 ;
                if (c) mxl += (8-c) ;
                if (mxl+xm>info.right) {
                    mxl=info.right-xm;
                    c=mxl-3; c=c%8 ;
                    mxl -= c ;
                }
            }
            if (!e) {
                c = myt-3; c=c%8; 
                if (c) myt += (8-c );
                if (myt>info.bottom-ym) {
                    myt=info.bottom-ym;
                    c=myt-3; c=c%8 ;
                    myt -= c;
                }
            }
            shift=0;
        }
        else { 
            if (mxl+xm>info.right) mxl=info.right-xm;
            if (myt>info.bottom-ym) myt=info.bottom-ym;
        }
       
       if (mxl==prxl && myt==pryt) continue;
       
       dx1 = mxl - (*xl);
       dy1 = myt - (*yt);
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
       
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);
        
        a=0; 
        for (f=0 ; f<dbar ; f++) {
            k=0;
            for (i=0; i<aa; i++) {
                if (f==giam[i]) {k=1; break;}
            }
            if (k) continue ;
            
            if (!db_elem[f][1]) dwel=7;
            else { dwel = (ptr_pedio[db_elem[f][0]]->fitype) ? 7 : 15 ; }
            
                for (i=0; i<aa ; i++) {
                    if (!db_elem[giam[i]][1]) dwproel=7;
                    else { dwproel = (ptr_pedio[db_elem[giam[i]][0]]->fitype) ? 7 : 15 ; }
                    ext=dbx1[giam[i]]+dx1 ; eyt=dby1[giam[i]]+dy1 ;
                    exb=dbx2[giam[i]]+dx1 ; eyb=dby2[giam[i]]+dy1 ;
                    if ( (ext>dbx2[f]+dwel) || (eyt>dby2[f]+8) || (exb+dwproel<dbx1[f]) || (eyb+8<dby1[f]) ) continue ; 
                    else { a=2; break;}
                }
                if (a) break ;
            }    

        //c = (a) ? dbred : dbgreen ;
        
        if (!a) {
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       // setrgbcolor(c);
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=4-a) {for (f=mxl+1 ; f<sx; f+=4-a) _putpixel (f,i);}}
        else
        {
         setrgbcolor(dbred);   
         for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
         for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
         bar(mxl+1,myt+1,sx-1,sy-1);   
        }
        
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
    putimage (prxl,pryt,mem1,0); 
    free(mem1);
    *xl=fxl ; *yt=fyt ;*xr=fxl+dxa ; *yb=fyt+dya;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int multi_change_pos(int xt1 , int yt1)
{
// Αν επιστρέψει 0 , δεν έγινε τίποτε !!
    
SDL_Cursor* cursor;
void *mem0;
register int f, i ;
int xt,yt, xb,yb,lex,ley,rix,riy,d , mx1, my1 , dx, dy ; 
short int arped , dw , aa ,loop=0 ,loop2=0, entos ;
unsigned char giam[dbar+1];
unsigned char piap[dbar+1];
unsigned int ds ;
unsigned short int ch_scan;
    
    xt=xt1; yt=yt1;
    d = collect_fields(&xt, &yt ,&xb , &yb);
    do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);
    if (d<=0) return 0;
    aa=0;
    
    
    for (f=0 ; f<dbar ; f++) {
        if (dbx1[f]>=xt && dbx2[f]<=xb && dby1[f]>=yt && dby2[f]<=yb) {
            arped = db_elem[f][0];
            if ( (db_elem[f][1]) && (ptr_pedio[arped]->fivar[1]) ) continue ;
            else if ( (!db_elem[f][1]) && (ptr_pedio[arped]->fivar[5]) ) continue ;
            dw = ( (db_elem[f][1]) && (!ptr_pedio[arped]->fitype) ) ? 15 : 7 ;
            giam[aa]=f ; aa++ ;
            if (aa==1) {
                lex=dbx1[f]; ley=dby1[f]; rix=dbx2[f]+dw; riy=dby2[f];
            }
            else {
                if (lex>dbx1[f]) lex = dbx1[f];
                if (ley>dby1[f]) ley = dby1[f];
                if (rix<dbx2[f]+dw) rix = dbx2[f]+dw;
                if (riy<dby2[f]) riy = dby2[f];
            }
        }
    }
    
        
    if (!aa) return 0;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    setrgbcolor(dbtop);
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
    sprintf(top_str,"%04d",(rix-lex+1)); _outsouv_col(Wt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",(riy-ley+1)); _outsouv_col(Ht,1,top_str,0,topchxr,topbkxr);
    
RESTARTBABY:

    setrgbcolor(dbtop); 
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
    sprintf(top_str,"%04d",lex); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",ley); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
    refresh();

    mem0 = malloc (imagesize (lex,ley,rix,riy) );
    if (!mem0) {information (2-keyb_gr,0,0) ; return 0 ;}
    
    getimage (lex,ley,rix,riy,mem0);
    setcolor (COLOR(255,69,0)) ; // orangered 
    rectangle(lex,ley,rix,riy);
    rectangle(lex+1,ley+1,rix-1,riy-1);
    if (keyb_gr) show_help(" Για Μετακίνηση .. ", lex,riy+3 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" To Move .. ", lex,riy+3  , &hdhlpxt , &hdhlpyt) ;
    xt=lex; yt=ley;
    entos=0;
    refresh();
    
    
    for (;;) {
        
        if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
       
            case SDL_MOUSEMOTION:
                while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) );
                mx1 = sdlev.motion.x ; my1 = sdlev.motion.y ;
                if (mx1>=lex && mx1<=rix && my1>=ley && my1<=riy) {
                    if (entos) continue ;
                    entos=1;
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                }
                else {
                    if (!entos) continue ;
                    entos=0;
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                    SDL_SetCursor(cursor);
                }
                continue ;
                
            case SDL_MOUSEBUTTONDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                if(sdlev.button.button==SDL_BUTTON_RIGHT) {aa=0; goto FYGE;}
                mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
                d=1;
                if (mx1>=lex && mx1<=rix && my1>=ley && my1<=riy) {
                    d=fields_rec_move (giam, aa, mx1, my1, &lex, &ley ,&rix , &riy); //επιστρέφει 0 αν επιτρέπεται αλλαγή
                }
                if (d) {aa=0; goto FYGE;}
                loop=1;loop2=0;
                break ;
                
            case SDL_KEYDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                ch_scan=sdlev.key.keysym.scancode;
                
                switch (ch_scan) {
                
                    case SDL_SCANCODE_LEFT :
                        dx=-1; dy=0; 
                        d=multi_change_mikropos(giam, aa, dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                    
                    case SDL_SCANCODE_RIGHT :
                        dx=1; dy=0; 
                        d=multi_change_mikropos(giam, aa, dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                    
                    case SDL_SCANCODE_UP :
                        dx=0; dy=-1;
                        d=multi_change_mikropos(giam, aa, dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                        
                    case SDL_SCANCODE_DOWN :
                        dx=0; dy=1;
                        d=multi_change_mikropos(giam, aa, dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                        
                    case SDL_SCANCODE_ESCAPE :
                        aa=0; loop=1 ; loop2=0; lex=xt; ley=yt; 
                        break ;
                        
                }
                continue ;
                
                    case SDL_WINDOWEVENT :
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        refresh();
                        break ;
                        
                    case SDL_QUIT:
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        aa=0; loop=1 ; loop2=0; lex=xt; ley=yt; 
                        break ;  
        }
        
        if (loop) break ;
    }
    
    if (xt==lex && yt==ley) {aa=0; goto FYGE;}
    if (mem0) free(mem0); mem0=0;
    
    dx = lex - xt; 
    dy = ley - yt;
    dw=0 ;
    
    for (f=0; f<aa; f++) {
                
        arped = db_elem[giam[f]][0];
        if (arped>99) continue ;
        
        d=0;
        for (i=0 ; i<dw ; i++) {
            if (arped==piap[i]) {d=1; break;}
        }
        if (!d) { piap[dw]=arped; dw++; }
        
        if (db_elem[giam[f]][1]) {
            if (dx>0) ptr_pedio[arped]->fixt += dx ; else ptr_pedio[arped]->fixt -= abs(dx) ;
            if (dy>0) ptr_pedio[arped]->fiyt += dy ; else ptr_pedio[arped]->fiyt -= abs(dy) ;
        }
        else {
            if (dx>0) ptr_pedio[arped]->filaxt += dx ; else ptr_pedio[arped]->filaxt -= abs(dx) ;
            if (dy>0) ptr_pedio[arped]->filayt += dy ; else ptr_pedio[arped]->filayt -= abs(dy) ;
        }
        
        if (aa==1) fidimundo_call(1,giam[f]);
        else if (!f) fidimundo_call(7,giam[f]);
        else if (f==aa-1) fidimundo_call(6,giam[f]);
        else fidimundo_call(5,giam[f]);
        
        if (dx>0) {
            dbx1[giam[f]] += (short int) dx;
            dbx2[giam[f]] += (short int) dx;
        }
        else {
            dbx1[giam[f]] -= (short int) abs(dx);
            dbx2[giam[f]] -= (short int) abs(dx);
        }
        
        if (dy>0) {
            dby1[giam[f]] += (short int) abs(dy);
            dby2[giam[f]] += (short int) abs(dy);
        }
        else {
            dby1[giam[f]] -= (short int) abs(dy);
            dby2[giam[f]] -= (short int) abs(dy);
        }
    }
    
    for (f=0; f<dw; f++) {
        arped = piap[f];
        ds=(arped*dbfisize)+104;
        fseek(fpdb,ds,0);
        fwrite (ptr_pedio[arped],1,dbfisize,fpdb);
        fdatasync (fide_fpdb);
    }
    
    if (loop2) {dbdecor_show (); dbrecs_show(); if (mem0) free(mem0); mem0=0; loop=0; goto RESTARTBABY ;}
    
FYGE :

    if (mem0) {putimage (xt,yt,mem0,0); refresh(); free(mem0);}
    do {
            SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    return aa;    
}



int multi_change_mikropos(unsigned char *giam, short int aa, int dx, int dy, int *xl, int *yt ,int *xr , int *yb)
// Ελέγχει αν το rectangle βρίσκει με άλλα ... 
// Επιστρέφει 0 αν επιτρέπεται η αλλαγή θέσης και περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ ή αν δεν επιτρέπεται από τον χρήστη η αλλαγή.

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt , ext, eyt, exb , eyb ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ,dwproel ,dwel ;
unsigned short int c ;
short int a , k;


cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}
//dwproel = (db_elem[proel][1]) ? 15 : 7 ;
getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setfillstyle(8,4);


       mxl = prxl+dx ; myt = pryt+dy;  

       if (mxl<info.left+3) mxl=info.left+3;
       else if (mxl+dxa>info.right) mxl=info.right-dxa;
       if (myt<info.top+3) myt=info.top+3;
       else if (myt+dya>info.bottom-25) myt=info.bottom-dya-25 ;
       
       if (mxl==prxl && myt==pryt) {free (mem1) ; mem1=0; return -1; }
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
             
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);
        a=0; 
        for (f=0 ; f<dbar ; f++) {
            
            k=0;
            for (i=0; i<aa; i++) {
                if (f==giam[i]) {k=1; break;}
            }
            if (k) continue ;       
            if (!db_elem[f][1]) dwel=7;
            else { dwel = (ptr_pedio[db_elem[f][0]]->fitype) ? 7 : 15 ; }
            
            for (i=0; i<aa ; i++) {
                if (!db_elem[giam[i]][1]) dwproel=7;
                else { dwproel = (ptr_pedio[db_elem[giam[i]][0]]->fitype) ? 7 : 15 ; }
                ext=dbx1[giam[i]]+dx ; eyt=dby1[giam[i]]+dy ;
                exb=dbx2[giam[i]]+dx ; eyb=dby2[giam[i]]+dy ;
                if ( (ext>dbx2[f]+dwel) || (eyt>dby2[f]+8) || (exb+dwproel<dbx1[f]) || (eyb+8<dby1[f]) ) continue ; 
                else { a=2; break;}
            }
            if (a) break ;
            }    

          
        if (!a) {
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       // setrgbcolor(c);
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=4-a) {for (f=mxl+1 ; f<sx; f+=4-a) _putpixel (f,i);}}
        else
        {
         setrgbcolor(dbred);   
         for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
         for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
         bar(mxl+1,myt+1,sx-1,sy-1);   
        }
        
        refresh(); 
        for(f=1;f<200000;f++) continue ;
    
    putimage (prxl,pryt,mem1,0); free(mem1); mem1=0;
    *xl=fxl ; *yt=fyt ;*xr= fxl+dxa ; *yb= fyt+dya;
    //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    //SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int collect_fields(int *xl1, int *yt1 ,int *x1p , int *y1p)
// αν επιστρέψει τιμή<=0 ... δεν έγινε δουλειά !
{
SDL_Cursor* cursor;
int x1 , y1 , sx, sy, prxr , pryb ,xl, yt , ex, ey ,d ,e , prx1, pry1, prxt, pryt ;
//unsigned int size , sizem=400000;
//void *mem1=NULL ;
register int i,f ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
SDL_SetCursor(cursor);
sx=*xl1 ; sy=*yt1;

if ( (sx+16) > info.right ) { 
    prxr=sx;
    xl=prxr-16;
}
else { prxr = sx+16; xl=sx; }

if ( (sy+16) > info.bottom-25 ) {
    pryb=sy;
    yt=pryb-16;
}
else {pryb=sy+16; yt=sy;}

//size=imagesize (xl,yt,prxr,pryb);
//if (size>sizem) sizem=size;
//mem1=malloc(sizem);
//if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
//SDL_SetCursor(cursor);return -1;}

getimage (xl,yt,prxr,pryb,mem_ouon);
ex=xl; ey=yt;
prx1 = pry1 = prxt= pryt = -1 ;
setcolor (COLOR(255,0,0)) ;  
rectangle (xl,yt,prxr,pryb);
setcolor (COLOR(255,255,0)) ;  
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<prxr; f+=3) _putpixel (f,i);}
refresh();

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       //SDL_GetRelativeMouseState (&x1 , &y1);
        x1 = sdlev.motion.x ; y1 = sdlev.motion.y ;
        if (x1<info.left || y1<info.top) continue ;
        if (x1>info.right) continue ;
        if (y1>info.bottom) continue;
        
        if (x1>sx) {xl=sx; prxr=x1;} else {xl=x1; prxr=sx;}
        if (y1>sy) {yt=sy ; pryb=y1;} else {yt=y1; pryb=sy;}
        
        if ( xl==prxt && yt==pryt && x1==prx1 && y1==pry1 ) continue;
       
        putimage (ex,ey,mem_ouon,0); 
        prxt=xl ; pryt=yt; prx1=x1; pry1=y1;
        //size = (imagesize (xl,yt,prxr,pryb) );
        ex=xl; ey=yt;
        /*
        if (size>sizem) {
            refresh();
            sizem=size ; 
            if (mem1) free(mem1);
            mem1=malloc(sizem);
            if (mem1==NULL) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);return -1;}
        }
        */
        getimage (xl,yt,prxr,pryb,mem_ouon);
        setcolor (COLOR(255,69,0)) ; // orangered 
        //rectangle (xl,yt,x1,y1);
        for(f=xl;f<=prxr;f++) {_putpixel(f,yt); _putpixel(f,pryb);}
        for(i=yt;i<=pryb;i++) {_putpixel(xl,i); _putpixel(prxr,i);}
        setcolor (COLOR(255,255,0)) ;  
        for (i=yt+1;i<pryb;i+=4) {for (f=xl+1 ; f<prxr; f+=4) _putpixel (f,i);} refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
     putimage (ex,ey,mem_ouon,0); 
     //free(mem1);
    *xl1=xl; *yt1=yt; *x1p=prxr ; *y1p=pryb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    if(sdlev.button.button==SDL_BUTTON_RIGHT) return 0;
    return 1;
}


int dbpage_decs()
{

// Εφόσον ο decor έχει τιμή τότε πρέπει να τρέχει η dbpage_decs αμέσως πριν την dbpage_recs.
// Επιστρέφει την dcar που είναι ο αριθμός των διακοσμητικών ετικετών στην τρέχουσα σελίδα της βάσης.
// Πάντα μιλάμε για την τρέχουσα σελίδα της Βάσης ! Δίνει τιμές και στον πίνακα dd_elem[]..
// ergo=0 σημαίνει τρέχει για πρώτη φορα στην αρχή !
// ergo=1 σημαίνει προστέθηκε ή τροποποιήθηκε ετικέτα

if (!decor) { dcar=0; return 0 ;}

register int i,f;

if (dmemx1) { free (dmemx1) ; dmemx1=0; }
if (dmemx2) { free (dmemx2) ; dmemx2=0; }
if (dmemy1) { free (dmemy1) ; dmemy1=0; }
if (dmemy2) { free (dmemy2) ; dmemy2=0; }

dcar=0;

dbdecs = 4*decor; // Τα rectangles...

    dmemx1=malloc(dbdecs) ;
    dmemy1=malloc(dbdecs);
    dmemx2=malloc(dbdecs);
    dmemy2=malloc(dbdecs);
    if ( (!dmemx1) || (!dmemy1) || (!dmemx2) || (!dmemy2) ) {information (2-keyb_gr,0,0); dcar=0; return 0;}

dbdx1=dmemx1 ;  dbdy1=dmemy1 ; dbdx2=dmemx2 ; dbdy2=dmemy2 ;
// Εξίσωση των dbdx με τα dmemx σε κάθε realloc !!
    i=0; 
    for (f=0; f<decor ; f++) {
        if (ptr_dec[f].depg == dbcurpage || ptr_dec[f].depg == 100 ) {
            dd_elem[i]=f;
            dbdx1[i]=ptr_dec[f].dext ; dbdy1[i]=ptr_dec[f].deyt;
            dbdx2[i]=dbdx1[i]+ptr_dec[f].dewid-1 ; dbdy2[i]=dbdy1[i]+ptr_dec[f].dehei-1;
            i++; 
            }
    }

    dcar=i; // Ο αριθμός των decs στην current page που πρέπει να επανυπολογίζεται κατά περίπτωση με την παραπάνω διαδικασία !!
return dcar;
}


int inkualizer_spec (int font, int *chrxr , int *bkgxr , int pop , int fu ,int* recgem)
// pop=0 για χρώμα σε κείμενο , 1 : για χρώμα γραμμής
// Όταν pop=1 ,παίζει και το rgb χρώμα recgem , οπότε έχουμε άλλο φόντο, άλλη γραμμή και άλλο γέμισμα σχήματος....
// Αν fu=0 τότε ρυθμίζεις μόνον χρώμα προσκηνίου (γραμμής ή κειμένου) , αν fu=1 τότε ρυθμίζεις μόνον φόντο !
// Αν fu=2 τότε ρυθμίζεις αμφότερα , φόντο και προσκήνιο.
{
SDL_Cursor* cursor;
void *mem0 , *mem_zer=0, *mem_bal, *mem_ok ,*mem_anak=0 , *mem_pick=0, *mem_propick=0 , *mem_txt=0 , *mem_sel=0 , *mem_cu=0;
void *mem_arrs , *mem_top , *mem_save=0 ;
int *mem_int;
short int *ar_dom ;
int xt1,yt1,xb1,yb1;
unsigned short int xt,yt,xb,yb,xzer,yzer,xok,yok,xtepi,ytepi,xanak,yanak,zone,xseltxt,yseltxt,fyge=0,x1,y1;
unsigned short int probal , tyx, protyx, proenter, proanak , textor=0 ,diak=0, marrs=0 , save_cols , xsave , ysave ,user_ans , plxr ,key ;
short int plera=0 ,thesi ;
int nowcol[3];
int fonto[3];
int chrpnt[3];
int cbrown[3];
char str[5];
int randchrxr[10][3];
int randbkgxr[10][3];
int testchrxr[3] , testbkgxr[3] ;
unsigned int a , a1 , time_metr=0;
int mx,my,mx1,my1,dx, dy,red,green,blue;
unsigned short int apejo=0;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;

union disk_bkxr{
    int dbkxr;
    unsigned char dbkrgb[4];
};

union disk_chxr{
    int dchxr;
    unsigned char dchrgb[4];
};

union disk_sexr{
    int dsexr;
    unsigned char dsergb[4];
};

struct disk_ink {
    union disk_bkxr dback;
    union disk_chxr dfront;
    union disk_sexr dsel;
} dink , dink1;

struct meter {
unsigned short int recxt;
unsigned short int recyt;
unsigned short int recxb;
unsigned short int recyb;
unsigned short int balxt;
unsigned short int balyt;
unsigned short int balxb;
unsigned short int balyb;
unsigned short int numxt;
unsigned short int numyt;
unsigned short int numxb;
unsigned short int numyb;
void *mem_bbal;
unsigned int curval;
unsigned int oldval;
} zer[6];

unsigned int ef_curval[6];
int ef_testbkgxr[3];

int maxcol[6][3];
register int i,f;
unsigned char izer[16];
short int rizos;

rizos = 26-myfont_hei[font];
zer[0].curval=chrxr[0] ; zer[1].curval=chrxr[1] ; zer[2].curval=chrxr[2] ;
zer[3].curval=bkgxr[0] ; zer[4].curval=bkgxr[1] ; zer[5].curval=bkgxr[2] ;

maxcol[0][0]=230 ; maxcol[0][1]=maxcol[0][2]=0;
maxcol[1][0]=0 ; maxcol[1][1]=230; maxcol[1][2]=0;
maxcol[2][0]=0 ; maxcol[2][1]=0; maxcol[2][2]=230;

maxcol[3][0]=230 ; maxcol[3][1]=maxcol[3][2]=0;
maxcol[4][0]=0 ; maxcol[4][1]=230; maxcol[4][2]=0;
maxcol[5][0]=0 ; maxcol[5][1]=0; maxcol[5][2]=230;

cbrown[0]=44 ; cbrown[1]=31 ; cbrown[2]=22;
chrpnt[0]=150 ; chrpnt[1]=255 ; chrpnt[2]=177 ; 

xt=(info.right-info.left-300) / 2 ; yt1=(info.bottom-info.top-396) / 2 ;
yt=yt1+19; 
xb=xt+299 ;
yb=yt+375;

mem0=malloc(imagesize (xt,yt,xb,yb)); //300 x 376
if (mem0==NULL) {information(2-keyb_gr,NULL,NULL);return 0;}
mem_top=malloc(imagesize(xt,yt1,xb,yt1+18)); // 300x19 
if (mem_top==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0); return 0;}



getimage(xt,yt,xb,yb,mem0);

// EPIKEFALIDA
getimage(xt,yt1,xb,yt1+18,mem_top);  // putimage(xt,yt-19,mem_top,0);
bareacls(xt+1,yt1+1,xb-1,yt1+17,cbrown);
setcolor(5);
rectangle (xt,yt1,xb,yt1+18) ; 
strcpy(file_1,path_name);
strcat(file_1,"ICD/hand_17.ico");
mem_arrs=icontomem(file_1,255);
if (mem_arrs==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_top); free(mem0); return 0;} 
puticon(xt+1,yt1+1,mem_arrs,255);

if (keyb_gr) {
a1=(xb-xt-88)/2;
outsouv_col(xt+a1,yt1+1,"XRVMATA",1,chrpnt,cbrown);} else { a1=(xb-xt-60)/2; outsouv_col(xt+a1,yt1+1,"COLORS",0,chrpnt,cbrown);}

// TELOS EPIKEFALIDAS

setcolor(5);
rectangle(xt,yt,xb,yb);


areacls(xt+1,yt+1,xb-1,yb-1,0,0,0);
fonto[0]= 20; fonto[1]=fonto[2]=100;
bareacls(xt+1,yt+61,xt+245,yt+76,fonto);
setcolor(5);
line (xt+1,yt+60,xt+246,yt+60);
// line (xt+1,yt+77,xb-1,yt+77);  //line (xt+1,yt+77,xt+246,yt+77);
line (xt+246,yt+1,xt+246,yb-1);
line (xt+1,yt+39,xt+246,yt+39);
line (xt+124,yt+40,xt+124,yb-1);   //line (xt+124,yt+40,xt+124,yt+76);
//rectangle (xt+2,yt+2,xt+244,yt+27);

//xok=xt+362;
xok=xt+262;
xseltxt=xt+248 ; yseltxt=yanak=yok=ysave=yb-36;
xanak = xt+286 ; 
xsave=xanak+39;
xzer=xt+2; yzer=yt+79;
// xtepi=xt+247; 
xtepi = xt+247 ;
ytepi=yt+77;
//for (f=1;f<11;f++) line (xtepi,ytepi+f*26,xb-1,ytepi+f*26);
//line (xtepi,ytepi,xb-1,ytepi);
//line (xtepi,ytepi,xb-1,ytepi+259);
//line (xb-1,ytepi,xtepi,ytepi+259);
//line (xtepi,ytepi+259,xb-1,ytepi+259);

//setcolor(2);
//rectangle (xt+2,yt+2,xt+244,yt+27);

/*
if (!keyb_gr) {
outnoto(xtepi+35,yt+15,"Random",0);
outnoto(xtepi+15,yt+40,"Suggestions",0);}
else {
outnoto(xtepi+35,yt+15,"Tyxai'ew",1);
outnoto(xtepi+30,yt+40,"Epiloge'w",1);}    
*/

strcpy (file_1,path_name);
strcat (file_1,"ICD/xrolizer.ico");
mem_zer=icontomem (file_1,255);
if (mem_zer==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0); free(mem_arrs);free(mem_top); return 0;}
strcpy (file_1,path_name);
strcat (file_1,"ICD/Sym_OK_35.ico");
mem_ok= icontomem (file_1,255);
if (mem_ok==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); return 0;}

strcpy (file_1,path_name);
strcat (file_1,"ICD/button_col.ico");
mem_bal= icontomem (file_1,255);
if (mem_bal==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_arrs);free(mem_top); return 0;}

//strcpy (file_1,path_name);
//strcat (file_1,"ICD/Repeat35.ico");
//mem_anak= icontomem (file_1,255);
//if (mem_anak==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_arrs);free(mem_top); return 0;}

//strcpy (file_1,path_name);
//strcat (file_1,"ICD/color-picker.ico");
//mem_pick= icontomem (file_1,255);
//if (mem_pick==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_arrs);free(mem_top); return 0;}

//mem_propick=malloc(2508);
//if (mem_propick==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_pick); free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); return 0;}
//strcpy (file_1,path_name);
//strcat (file_1,"ICD/text_cursor.ico");
//mem_txt= icontomem (file_1,255);
//if (mem_txt==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);return 0;}

//strcpy (file_1,path_name);
//strcat (file_1,"ICD/Save_35.ico");
//mem_save= icontomem (file_1,255);
//if (mem_save==NULL) {information(2-keyb_gr,NULL,NULL);free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_arrs);free(mem_top); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);return 0;}


_areacls(xzer,yzer,xzer+243,yzer+295,200,200,200);
//_areacls(xzer,yzer,xzer+143,yzer+295,200,200,200);
_puticon(xzer,yzer,mem_zer,255);
setcolor(5);
line (xt+124,yt+40,xt+124,yb-1); 
line (xt+123,yt+40,xt+123,yb-1);
refresh();
free(mem_zer); mem_zer=0;

//strcpy (file_1,path_name);
//strcat (file_1,"ICD/th_text_curs.ico");
//mem_sel= icontomem (file_1,255);
//if (mem_sel==NULL) {information(2-keyb_gr,NULL,NULL); free(mem_save); free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick); free(mem_arrs);free(mem_top); return 0;}
//mem_cu=malloc(1048);
//if (mem_cu==NULL) {information(2-keyb_gr,NULL,NULL); free(mem_save); free(mem_sel); free(mem_txt); free(mem_anak); free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); free(mem_pick); free(mem_propick);free(mem_arrs);free(mem_top); return 0;}


zer[0].recxt=xzer+6; zer[0].recxb=zer[0].recxt+30;
zer[0].recyb=zer[1].recyb=zer[2].recyb=zer[3].recyb=zer[4].recyb=zer[5].recyb=yb-21; 
zer[1].recxt=zer[0].recxb+11 ; zer[1].recxb=zer[1].recxt+29;
zer[2].recxt=zer[1].recxb+10 ; zer[2].recxb=zer[2].recxt+31;
zer[3].recxt=zer[2].recxb+9 ; zer[3].recxb=zer[3].recxt+31;
zer[4].recxt=zer[3].recxb+9 ; zer[4].recxb=zer[4].recxt+31;
zer[5].recxt=zer[4].recxb+9 ; zer[5].recxb=zer[5].recxt+31;
zer[0].numyt=zer[1].numyt=zer[2].numyt=zer[3].numyt=zer[4].numyt=zer[5].numyt=yt+60;
zer[0].numyb=zer[1].numyb=zer[2].numyb=zer[3].numyb=zer[4].numyb=zer[5].numyb=yzer-3;

if (!pop) {
    if (!keyb_gr) {outsouv(xt+134,yt+41,"Background",0);
    outsouv(xt+50,yt+41,"Text",0);}
    else {outsouv(xt+155,yt+41,"Fo'nto",1);
    outsouv(xt+27,yt+41,"Kei'meno",1);}
}
else {
    if (!keyb_gr) {outsouv(xt+134,yt+41,"Background",0);
    outsouv(xt+50,yt+41,"Line",0);}
    else {outsouv(xt+155,yt+41,"Fo'nto",1);
    outsouv(xt+27,yt+41,"Grammh'",1);}    
}
_puticon (xok,yok,mem_ok,255);
//_puticon (xanak,yanak,mem_anak,255);
//_puticon (xseltxt,yseltxt,mem_txt,255);
//_puticon (xsave,ysave,mem_save,255);

for (f=0;f<6;f++) { 
    zer[f].recyt=zer[f].recyb-zer[f].curval;
   
    zer[f].oldval=zer[f].curval;
    switch (f) {
        case 0 :
        case 3 :
            nowcol[0]=zer[f].curval; nowcol[1]=nowcol[2]=0;break;
        case 1:
        case 4:
            nowcol[1]=zer[f].curval; nowcol[0]=nowcol[2]=0;break;
        case 2:
        case 5:
            nowcol[2]=zer[f].curval; nowcol[0]=nowcol[1]=0;
    }
    
    bareacls(zer[f].recxt,zer[f].recyt,zer[f].recxb,zer[f].recyb,nowcol);
    zer[f].balxt=zer[f].recxt-3;zer[f].balxb=zer[f].balxt+37;
    zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
    zer[f].mem_bbal=malloc(5784);
    if (zer[f].mem_bbal==NULL) {information(2-keyb_gr,NULL,NULL);free(mem0);free(mem_zer); free(mem_ok); free(mem_bal); return 0;}
    getimage (zer[f].balxt,zer[f].balyt,zer[f].balxb,zer[f].balyb, zer[f].mem_bbal);
    _puticon (zer[f].balxt,zer[f].balyt,mem_bal,255);
    zer[f].numxt=zer[f].recxt; zer[f].numxb=zer[f].numxt+33;
    sprintf(str,"%03u",zer[f].curval);
    _outsouv_col(zer[f].numxt,zer[f].numyt+1,str,0,&maxcol[f][0],fonto);
}

_bareacls (xt+3,yt+3,xt+243,yt+35,bkgxr);
//if (!pop) _outnoto_col(xt+76,yt+5,"Inkualizer..",0,chrxr,bkgxr);

strcpy (str1024,"Inkualizer..");
normtext_tomy(str1024,izer);

if(!pop) _outmystr_col (font, izer , xt+76, yt+5+rizos, xt+243, chrxr,bkgxr);
else {
    _bareacls (xt+77,yt+9,xt+175,yt+29,recgem);
    setcolor (COLOR(chrxr[0],chrxr[1],chrxr[2]));
    rectangle (xt+76,yt+8,xt+176,yt+30);
}
refresh();

zone=6;
probal=6;
protyx=10;
proenter = proanak = save_cols = 0 ;
for (f=0;f<3;f++) {
testchrxr[f]=chrxr[f]; // testchrxr[1]=chrxr[1]; testchrxr[2]=chrxr[2];
testbkgxr[f]=bkgxr[f]; // testbkgxr[1]=bkgxr[1]; testbkgxr[2]=bkgxr[2];

}

if (!fu) a1=3;
else if (fu==1) {fu=3; a1=6;}
else {a1=6; fu=0;}


do {
    
 
    
   if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
   if (mx>xzer+3 && mx<xzer+240 && my>yzer+18 && my<yzer+296){  //Κίνηση εντός 6 ζωνών !!

       x1=mx-xzer-4; zone=x1/40; if (zone>5) zone=6;
       
                                                          
        if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
        else if (proanak) {proanak=0;puticon(xanak,yanak,mem_anak,255);}
        
        else if (save_cols==1) { save_cols = 0 ; puticon(xsave,ysave,mem_save,255);}
        
        else if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}

        
       if ( zone>=a1 || zone<fu ) { 
            if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
            if (apejo) continue;
            apejo=1;
           cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor); 
    
            continue ;}
            
       if (apejo) {
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);}
       apejo=0;
       
       for (a=fu;a<a1;a++) {
           if (mx>zer[a].balxt && mx<zer[a].balxb && my>zer[a].balyt && my<zer[a].balyb) {
               // KAPOIA MPALA AGGIZEI !!
                
               if (probal==6) {    // GIA PROTH FORA AGGIZEI MPALA
               
                    for (f=0;f<38;f++) {
                    mem_int=(mem_bal+8 + (f*38*4));
                    for (i=0;i<38;i++) {
                    co.lor = *mem_int++;
                    if (!co.rgb[3]) continue;
                    red =  abs(255-co.rgb[2]) ;
                    green = abs(255-co.rgb[1]) ;
                    blue =  abs(255-co.rgb[1]) ;
                    setcolor(COLOR (red,green,blue));
                    _putpixel (zer[a].balxt+i , zer[a].balyt+f);}}
                    refresh();
                    probal=a;
                   break ;
                }
                else 
                {
                if (probal==a) break; // PARAMENEI STHN IDIA MPALA
                puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
                // BAFEI NEA MPALA
                for (f=0;f<38;f++) {
                mem_int=(mem_bal+8 + (f*38*4));
                for (i=0;i<38;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  abs(255-co.rgb[2]) ;
                green = abs(255-co.rgb[1]) ;
                blue =  abs(255-co.rgb[1]) ;
                setcolor(COLOR (red,green,blue));
                _putpixel (zer[a].balxt+i , zer[a].balyt+f);}}
                refresh();
                probal=a;
                break;
                }
           }
           
       } // TELOS LOOP GIA TIS EJI MPALES
       if (a==a1) { // ENTOS ZVNVN ALLA OXI SE MPALA
            if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
           }
           continue;
   } 
   else //  TO MOUSE EINAI EKTOS TVN 6 ZVNVN !!
   {
       zone=6;
       if (probal!=6) {
            puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255); // KAUARIZEI PROHGOYMENH MPALA
            probal=6;   }
         
    
    if (mx>xok && mx<xok+35 && my>yok && my<yok+35) { // PONTIKI STO OK
        
        apejo=0;
        
        if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}

        
        if (proenter) continue;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);

        //BAFEI ENTER
        for (f=0;f<35;f++) {
        mem_int=(mem_ok +8 + (f*35*4));
        for (i=0;i<35;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  (255 * co.rgb[2]) / 255;
        green =  (0 * co.rgb[1]) / 255;
        blue =  (255 * co.rgb[0]) / 255 ;
        setcolor(COLOR (red,green,blue));
        _putpixel (xok+i , yok+f);}}
        refresh();
     proenter=1;
     continue;
    }
    
    if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
    
    
    if (mx>xt && mx<xt+18 && my>yt-20 && my<yt) { // PONTIKI STHN KEFALIDA METAFORAS SE ALLH UESH
    
        apejo=0;
        if (!marrs) {

        marrs=1;
        putNOTicon(xt,yt-18,mem_arrs);
        cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);
        /*
        setcolor ( COLOR ( 255 , 255 , 0 ) );  
        mem_int=(mem_arrs +8);
        for (f=0;f<17;f++) {
        
        for(i=0 ; i < 17; i++) {
        co.lor= *(mem_int++);
        if (co.lor) {setcolor(COLOR( co.rgb[2], co.rgb[1]+80, co.rgb[0]) ) ; _putpixel (xt+i,yt-18+f);}}} 
        refresh();
        */
        continue ;}
        else continue ;
        continue; }
        
        apejo=1;
        if (marrs) {
        marrs=0;
        puticon(xt,yt-18,mem_arrs,255);}
    
}
          
        if (!apejo) continue;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
    
   continue;
            
           
   
    case SDL_MOUSEBUTTONDOWN:
        
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {
            

           continue ; } 
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if (probal!=6) {
           if ( probal>=a1 || probal<fu ) break ;
           cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
           SDL_SetCursor(cursor);

           fyge=0;
           do {
           
                while (SDL_PollEvent(&sdlev)) 
                { 
                    fyge=0;
                    switch (sdlev.type) {
                        case SDL_MOUSEMOTION :
                            continue;
                            
                        case SDL_MOUSEBUTTONUP :
                            fyge=1;
                            
                        default :
                            break ;
                    }
                    break ;
           }
           my1 = sdlev.button.y ;
           dy = my1- (int)(zer[probal].recyt) ;
           if (!dy) continue ;
           // if ((!dy) || (abs(dy)<4)) continue;
           
           if (dy>0){
               zer[probal].curval = (zer[probal].curval > dy) ? zer[probal].curval-dy : 0 ;
                    if ( (!zer[probal].oldval) && (!zer[probal].curval) ) break; 
                    }
            else { 
                zer[probal].curval+=abs(dy) ;
                if (zer[probal].curval>255) zer[probal].curval = 255;
                 if ( (zer[probal].oldval==255) && (zer[probal].curval==255) ) break;
                    }

         zer[probal].oldval =  zer[probal].curval ;            
        putimage (zer[probal].balxt , zer[probal].balyt , zer[probal].mem_bbal , 0 ); 
        // bareacls( zer[probal].numxt , zer[probal].numyt ,zer[probal].numxb , zer[probal].numyb , fonto );
        
                  setcolor ( COLOR (fonto[0],fonto[1],fonto[2]) );
        for (i=zer[probal].numxt;i<=zer[probal].numxb;i++) {
            for (f= zer[probal].numyt+1 ; f<=zer[probal].numyb; f++) _putpixel (i,f);}
            
        if (probal<3) {
        testchrxr[probal] = zer[probal].curval ; }
        else {
        testbkgxr[probal-3] = zer[probal].curval; }
        
        zer[probal].recyt=zer[probal].recyb-zer[probal].curval;
        
        
            switch (probal) {
                case 0 :
                case 3 :
                    nowcol[0]=zer[probal].curval; nowcol[1]=nowcol[2]=0;break;
                case 1:
                case 4:
                    nowcol[1]=zer[probal].curval; nowcol[0]=nowcol[2]=0;break;
                case 2:
                case 5:
                    nowcol[2]=zer[probal].curval; nowcol[0]=nowcol[1]=0;
            }
            
        //areacls(zer[probal].recxt,yzer+21,zer[probal].recxb,zer[probal].recyb,200,200,200);
        setcolor ( COLOR (200,200,200) );
        for (i=zer[probal].recxt;i<=zer[probal].recxb;i++) {
            for (f= yzer+20 ; f<=zer[probal].recyb; f++) _putpixel (i,f);}
            
        // bareacls(zer[probal].recxt, zer[probal].recyt, zer[probal].recxb , zer[probal].recyb,nowcol);
        
          setcolor ( COLOR (nowcol[0],nowcol[1],nowcol[2]) );
        for (i=zer[probal].recxt;i<=zer[probal].recxb;i++) {
            for (f= zer[probal].recyt ; f<=zer[probal].recyb; f++) _putpixel (i,f);}
        
        zer[probal].balyt=zer[probal].recyt-18; zer[probal].balyb=zer[probal].balyt+37;
        getimage (zer[probal].balxt,zer[probal].balyt,zer[probal].balxb,zer[probal].balyb, zer[probal].mem_bbal);
        puticon (zer[probal].balxt,zer[probal].balyt,mem_bal,255);
        sprintf(str,"%03u",zer[probal].curval);
        outsouv_col(zer[probal].numxt,zer[probal].numyt+1,str,0,&maxcol[probal][0],fonto);

        // bareacls (xt+3,yt+3,xt+243,yt+26,testbkgxr);
        
          setcolor ( COLOR (testbkgxr[0],testbkgxr[1],testbkgxr[2]) );
        for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}        
        
        //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr);
        if(!pop) _outmystr_col (font, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);
        else {
            _bareacls (xt+77,yt+9,xt+175,yt+29,recgem);
            setcolor (COLOR(testchrxr[0],testchrxr[1],testchrxr[2]));
            rectangle (xt+76,yt+8,xt+176,yt+30);
        }
        
        refresh();
        
        } while (sdlev.type != SDL_MOUSEBUTTONUP && (!fyge) );
        
        fyge=0;
        
        // BAFEI NEA MPALA
        for (f=0;f<38;f++) {
        mem_int=(mem_bal+8 + (f*38*4));
        for (i=0;i<38;i++) {
        co.lor = *mem_int++;
        if (!co.rgb[3]) continue;
        red =  abs(255-co.rgb[2]) ;
        green = abs(255-co.rgb[1]) ;
        blue =  abs(255-co.rgb[1]) ;
        setcolor(COLOR (red,green,blue));
        _putpixel (zer[probal].balxt+i , zer[probal].balyt+f);}}
        refresh();            
        continue;
       }
       
       else if (zone!=6) {  // KLIK SE ZONH (OXI SE MPALA)
 
            
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
           SDL_SetCursor(cursor);
           
           my1 = sdlev.button.y ;
           dy = my1- (int)(zer[zone].recyt) ;  

           if ((!dy) || (abs(dy)<4)) continue;

AUTO_dy :

           if (zone>=a1 || zone<fu) break ;

           if (dy>0){
               
               zer[zone].curval = (zer[zone].curval > dy) ? zer[zone].curval-dy : 0 ;
               if ( (!zer[zone].oldval) && (!zer[zone].curval) ) break; 
                    }
            else { 
                zer[zone].curval+=abs(dy) ;
                if (zer[zone].curval>255) zer[zone].curval = 255;
                if ( (zer[zone].oldval==255) && (zer[zone].curval==255) ) break;
                    }
        zer[zone].oldval =  zer[zone].curval ; 
        putimage (zer[zone].balxt , zer[zone].balyt , zer[zone].mem_bbal , 0 ); 
        // bareacls( zer[probal].numxt , zer[probal].numyt ,zer[probal].numxb , zer[probal].numyb , fonto );
        
                  setcolor ( COLOR (fonto[0],fonto[1],fonto[2]) );
        for (i=zer[zone].numxt;i<=zer[zone].numxb;i++) {
            for (f= zer[zone].numyt+1 ; f<=zer[zone].numyb; f++) _putpixel (i,f);}
            
        if (zone<3) {
        testchrxr[zone] = zer[zone].curval ; }
        else {
        testbkgxr[zone-3] = zer[zone].curval; }
        
        zer[zone].recyt=zer[zone].recyb-zer[zone].curval;
        
        
            switch (zone) {
                case 0 :
                case 3 :
                    nowcol[0]=zer[zone].curval; nowcol[1]=nowcol[2]=0;break;
                case 1:
                case 4:
                    nowcol[1]=zer[zone].curval; nowcol[0]=nowcol[2]=0;break;
                case 2:
                case 5:
                    nowcol[2]=zer[zone].curval; nowcol[0]=nowcol[1]=0;
            }
            
        //areacls(zer[zone].recxt,yzer+21,zer[zone].recxb,zer[zone].recyb,200,200,200);
        setcolor ( COLOR (200,200,200) );
        for (i=zer[zone].recxt;i<=zer[zone].recxb;i++) {
            for (f= yzer+20 ; f<=zer[zone].recyb; f++) _putpixel (i,f);}
            
        // bareacls(zer[zone].recxt, zer[zone].recyt, zer[zone].recxb , zer[zone].recyb,nowcol);
        
          setcolor ( COLOR (nowcol[0],nowcol[1],nowcol[2]) );
        for (i=zer[zone].recxt;i<=zer[zone].recxb;i++) {
            for (f= zer[zone].recyt ; f<=zer[zone].recyb; f++) _putpixel (i,f);}
        
        zer[zone].balyt=zer[zone].recyt-18; zer[zone].balyb=zer[zone].balyt+37;
        getimage (zer[zone].balxt,zer[zone].balyt,zer[zone].balxb,zer[zone].balyb, zer[zone].mem_bbal);
        puticon (zer[zone].balxt,zer[zone].balyt,mem_bal,255);
        sprintf(str,"%03u",zer[zone].curval);
        outsouv_col(zer[zone].numxt,zer[zone].numyt+1,str,0,&maxcol[zone][0],fonto);

        // bareacls (xt+3,yt+3,xt+243,yt+26,testbkgxr);
        
        
          setcolor ( COLOR (testbkgxr[0],testbkgxr[1],testbkgxr[2]) );
        for (i=xt+3;i<=xt+243;i++) {
            for (f= yt+3 ; f<=yt+35; f++) _putpixel (i,f);}        
        
        //outnoto_col(xt+76,yt+5,"Inkualizer..",0,testchrxr,testbkgxr);
        if(!pop) _outmystr_col (font, izer , xt+76, yt+5+rizos, xt+243, testchrxr,testbkgxr);
        
        else {
            _bareacls (xt+77,yt+9,xt+175,yt+29,recgem);
            setcolor (COLOR(testchrxr[0],testchrxr[1],testchrxr[2]));
            rectangle (xt+76,yt+8,xt+176,yt+30);
        }
  
        refresh();       
        continue;           
    }
        
        
        else if (proenter) {
            
                
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =testbkgxr[f] ;
                 
                }

            fyge=1;
              
            //BAFEI ENTER ENTONA
            for (f=0;f<35;f++) {
            mem_int=(mem_ok +8 + (f*35*4));
            for (i=0;i<35;i++) {
            co.lor = *mem_int++;
            if (!co.rgb[3]) continue;
            red =  (0 * co.rgb[2]) / 255;
            green =  (0 * co.rgb[1]) / 255;
            blue =  255 ;
            setcolor(COLOR (red,green,blue));
            _putpixel (xok+i , yok+f);}}
            refresh();
            continue;
        }
        
    else if (marrs) {

            
            xt1=xt; yt1=yt-19; xb1=xb; yb1=yb ;
            change_pos(&xt1, &yt1 ,&xb1 , &yb1);

            mem_zer=malloc(imagesize(xt,yt-19,xb,yb));
            if (mem_zer==NULL) {information(2-keyb_gr,NULL,NULL); continue ;}
            getimage(xt,yt-19,xb,yb,mem_zer); // Αντιγράφει το inkualizer όπως είναι αυτήν τη στιγμή !
            putimage(xt,yt,mem0,0); // αποκαθιστά οθόνη
            putimage(xt,yt-19,mem_top,0);
            refresh();



            xt=xt1; yt=yt1+19;
            xb=xt+299 ; yb=yt+375;
            getimage(xt,yt1,xb,yt1+18,mem_top);
            getimage(xt,yt,xb,yb,mem0); //κλέβει οθόνη για να λερώσει μετά !
            putimage(xt,yt1,mem_zer,0);
            refresh();
            free(mem_zer); mem_zer=0;

            xok=xt+262;
            xseltxt=xt+248 ; yseltxt=yanak=yok=ysave=yb-36;
            xanak = xt+286 ; 
            xsave=xanak+39;
            xzer=xt+2; yzer=yt+79;
            xtepi=xt+247;ytepi=yt+77;

            zer[0].recxt=xzer+6; zer[0].recxb=zer[0].recxt+30;
            zer[0].recyb=zer[1].recyb=zer[2].recyb=zer[3].recyb=zer[4].recyb=zer[5].recyb=yb-21; 
            zer[1].recxt=zer[0].recxb+11 ; zer[1].recxb=zer[1].recxt+29;
            zer[2].recxt=zer[1].recxb+10 ; zer[2].recxb=zer[2].recxt+31;
            zer[3].recxt=zer[2].recxb+9 ; zer[3].recxb=zer[3].recxt+31;
            zer[4].recxt=zer[3].recxb+9 ; zer[4].recxb=zer[4].recxt+31;
            zer[5].recxt=zer[4].recxb+9 ; zer[5].recxb=zer[5].recxt+31;
            zer[0].numyt=zer[1].numyt=zer[2].numyt=zer[3].numyt=zer[4].numyt=zer[5].numyt=yt+60;
            zer[0].numyb=zer[1].numyb=zer[2].numyb=zer[3].numyb=zer[4].numyb=zer[5].numyb=yzer-3;

            for (f=0;f<6;f++) { 
                zer[f].recyt=zer[f].recyb-zer[f].curval;
                zer[f].balxt=zer[f].recxt-3;zer[f].balxb=zer[f].balxt+37;
                zer[f].balyt=zer[f].recyt-18; zer[f].balyb=zer[f].balyt+37;
                zer[f].numxt=zer[f].recxt; zer[f].numxb=zer[f].numxt+33;
            }

            break ;
            
        }
              
    } // No pressed Button Left 
               
       continue;
       
      case SDL_KEYDOWN:
      
                     
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                if (zone>=a1 || zone<fu) break ; 
                dy=1;
                goto AUTO_dy;
                
            case SDL_SCANCODE_UP :
                 if (zone>=a1 || zone<fu) break ;
                dy=-1;
                goto AUTO_dy;
                
            case SDL_SCANCODE_PAGEDOWN :
                if (zone>=a1 || zone<fu) break ;
                dy= 20;
                goto AUTO_dy;
                
            case SDL_SCANCODE_PAGEUP :
                 if (zone>=a1 || zone<fu) break ; 
                dy=-20;
                goto AUTO_dy;
                
            case SDL_SCANCODE_RETURN :
                
                //BAFEI ENTER ENTONA
                for (f=0;f<35;f++) {
                mem_int=(mem_ok +8 + (f*35*4));
                for (i=0;i<35;i++) {
                co.lor = *mem_int++;
                if (!co.rgb[3]) continue;
                red =  (0 * co.rgb[2]) / 255;
                green =  (0 * co.rgb[1]) / 255;
                blue =  255;
                setcolor(COLOR (red,green,blue));
                _putpixel (xok+i , yok+f);}}
                refresh();
                fyge=1;
                
                for (f=0;f<3;f++) {
                chrxr[f] = testchrxr[f] ;
                bkgxr[f] =testbkgxr[f] ;
                
                }

                continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               continue;
               
            }
        
        break;
        
         case SDL_MOUSEWHEEL :
             
            if (zone>=a1 || zone<fu) break ;
            
            if(sdlev.wheel.y > 0) // scroll up
        {
             dy=-3;
             goto AUTO_dy;
        }
        else if(sdlev.wheel.y < 0) // scroll down
        {
             dy=3;
             goto AUTO_dy;
        }
        
         break;
         
    case SDL_WINDOWEVENT :
    refresh(); continue;
    
                case SDL_QUIT :
               fyge=1;
               continue;
         
     default :
        if (mx1<xt || mx1>xb || my1<ytepi || my1>yb) {
            
            if (apejo) continue;
            apejo=1;
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_SetCursor(cursor);
            
        } else apejo=0;

    }  // TELOS TOY switch &sdlev.type
       
 } while (!fyge);

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
SDL_SetCursor(cursor);
fidicls(xt,yt,xb,yb,bkgxr[0],bkgxr[1],bkgxr[2]);
putimage(xt,yt,mem0,0);
putimage(xt,yt-19,mem_top,0);
refresh();
for (f=0;f<6;f++) {free(zer[f].mem_bbal);}
if (mem_propick) free(mem_propick) ; 
if (mem_pick) free (mem_pick); 
if (mem_txt) free (mem_txt); 
if (mem_sel) free(mem_sel);
if (mem_cu) free(mem_cu);
if (mem_save) free(mem_save);
free(mem0); 
if (mem_ok) free(mem_ok); 
free(mem_bal); 
if (mem_anak) free(mem_anak); 
free(mem_arrs);
free(mem_top); 
return 1;
}


void _underline(unsigned char *str , int xt, int xb, int yb , int font, int xromas)
// Για δικά μου text....
{
    
register int i ;
int f;
unsigned char what;
struct fansouv *gour ;


    i=0;f=0;
    gour=myfont[font];
    what=str[i];
    while (what!=255) {  f+=gour[what].wid; what=str[i++]; }
    i= (xb-xt-f+1) / 2 ;
    setcolor(xromas);
    line (xt+i, yb, xb-i, yb);
    
}


void _outmystr_centund_col(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xr,unsigned short int yb, int *colchxr, int *colbkxr)

// Επιστρέφει 0 αν δεν χωράει ΚΑΘΟΛΟΥ το κείμενο μέσα στο rectangle
// Επιστρέφει 1 αν το κείμενο δεν χώρεσε κατά μήκος αλλά γράφτηκε μέρος αυτού !
// Επιστρέφει 2 αν όλα πήγαν καλά !

{
register int i,f ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a , c, c1, dy, neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;


a=xr-x+1;
if (a<myfont_wid[font]) return;
dy=yb-y+1;
if (dy<myfont_hei[font]) return;
dy=(dy-myfont_hei[font])/2 ;
f=0;
neg=0;
what=str[f];
if (what==255) return;

trampa=gouv;
gouv=myfont[font];

while (what<164) {
    neg+=gouv[what].wid;
    what=str[++f];
}

if (neg>a) neg=a;
c=(a-neg)/2;
x+=c;
y+=dy;
dy=2;

    a=0;
    what=str[a];
    c=x; dy=y+myfont_hei[font]-2;
    while (what<164 ) {
    if ( x> (xr-gouv[what].wid) +1 ) {break;}
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
    co.lor = *mem_int++;
    if (!co.lor) continue;
    neg=255-co.rgb[0];
    red =  abs( (colchxr[0]*co.rgb[0]/255) - (colbkxr[0]*neg/255) );
    green =  abs( (colchxr[1]*co.rgb[0]/255) - (colbkxr[1]*neg/255) );
    blue =  abs( (colchxr[2]*co.rgb[0]/255) - (colbkxr[2]*neg/255) );
    setcolor(COLOR (red,green,blue));
    _putpixel(x+i , y+f);}}
    c1=x+i-1;
    x+=gouv[what].wid;
    what=str[++a];
    }
    setcolor (COLOR(colchxr[0], colchxr[1], colchxr[2]));
    line (c,dy,c1,dy);
    gouv=trampa;
} 


void _myfill_ellips (int x1, int y1 , int *gem)

// x1,y1 : κέντρο 
// gem[0] - gem[1] - gem[2] επιθμητό χρώμα γεμίσματος

{
    register int x,y ;
    
    union {
        unsigned int ak;
        unsigned char rgb[4];
    } fo ;  
    
    setcolor (COLOR (gem[0],gem[1],gem[2]));
    
    
    
    // ΑΝΩ ΔΕΞΙΑ
    x=x1; y=y1;
    fo.ak=getpixel(x,y);
    
    while (y>info.top+1) {
        while ( (getpixel(x,y) == fo.ak) && (x<info.right) ) { _putpixel(x++,y); }
        y--;x=x1;
        if (getpixel(x,y) != fo.ak) break;
    }
    
    // ΚΑΤΩ ΔΕΞΙΑ
    
    y=y1+1; x=x1;
    while (y<info.bottom-1) {
        while ( (getpixel(x,y) == fo.ak) && x<info.right ) { _putpixel(x++,y); }
        y++;x=x1;
        if (getpixel(x,y) != fo.ak) break;
    }
    
    // ΑΝΩ ΑΡΙΣΤΕΡΑ
    
    x=x1-1; y=y1;
    while (y>info.top+1) {
        while ( (getpixel(x,y) == fo.ak) && (x>info.left) ) { _putpixel(x--,y); }
        y--;x=x1-1;
        if (getpixel(x,y) != fo.ak) break;
    }
    
    // ΚΑΤΩ ΑΡΙΣΤΕΡΑ
    
    y=y1+1; x=x1-1;
    
    while (y<info.bottom-1) {
        while ( (getpixel(x,y) == fo.ak) && (x>info.left)) { _putpixel(x--,y); }
        y++;x=x1-1;
        if (getpixel(x,y) != fo.ak) break;
    }
}


void _outmystr_colsel(unsigned int font, unsigned char *str ,  unsigned short int x, unsigned short int y, unsigned short int xri,int *xxr, int *bbk, int *selxr)
{
register int f,i ;
int red,green,blue;
int *mem_int;
unsigned char what;
unsigned short int a=0 , neg ;
union {
unsigned int lor ;
unsigned char rgb[4];
} co ;
struct fansouv *trampa;

    trampa=gouv;
    gouv=myfont[font];
    what=str[a];
    while (what<164) {
    if ( x> (xri-gouv[what].wid+1) ) break;
    
    mem_int=gouv[what].where ;
    for(f=0; f<gouv[what].hei ; f++) {
    for(i=0;i<gouv[what].wid;i++) {
        co.lor = *mem_int++;
        if (!co.lor) {
            setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
            _putpixel(x+i , y+f); 
            continue ; } 
        neg=255-co.rgb[0];
        red =  abs( (xxr[0]*co.rgb[0]/255) - (bbk[0]*neg/255) );
        green =  abs( (xxr[1]*co.rgb[0]/255) - (bbk[1]*neg/255) );
        blue =  abs( (xxr[2]*co.rgb[0]/255) - (bbk[2]*neg/255) );
        setcolor(COLOR (red,green,blue));
        _putpixel(x+i , y+f);}}
    while (f<myfont_hei[font]) {
    setcolor (COLOR(selxr[0],selxr[1],selxr[2])) ;
    for(i=0;i<gouv[what].wid;i++) { _putpixel(x+i , y+f);} f++ ;} 
    x+=gouv[what].wid;
    what=str[++a];
    } 
   gouv=trampa;
}


int fastmenu_show(short int plbut, char *menux, short int meg, char *but_name, unsigned short int moux, unsigned short int mouy )
// Βλέπε array submenu...

{

SDL_Cursor* cursor;
struct fansouv *whouv;
void *mem0 =0;
int *mem_int ;
int bkxrepi[3] , chxrepi[3] , bkxrsel[3], chxrsel[3] , bkxrkef[3] , chxrkef[3] , bkxrm[3] , chxrm[3] ;
short int bima ,width ;
int xt1,xb1,yb1 ,kati ,a1 ,a , k  ;
unsigned short int yt,xb,yb , xtepl, ytepl, xtepr ,ytepr , ybarb ;
unsigned short int pano, kato , telos ,sort , protyx ;
unsigned short int tyx ,fyge , yicob ,el ;
register int f,i ;
int mx,my,mx1,my1,dx, dy ,red , green , blue , elem , el_pl, c ;
unsigned char what ;
unsigned int size;
unsigned short int orio;

union {
unsigned int lor ;
unsigned char rgb[4];
} co ;


unsigned short int xt;
int yt1;
unsigned char ektos=1;
unsigned char but[plbut][meg];
//char *menuy;

kati=-1; // Επιστροφή τιμής που δείχνει ότι δεν επιλέχθηκε τίποτε έγκυρο !
whouv=gouv;
gouv = myfont[0];
orio=0;
//menuy=*menux;
a=0;

for (f=0 ; f<plbut ; f++) {
    for (i=0;i<meg;i++) {but[f][i]=menux[a++];}
    normtext_tomy(but[f],0);
    i=0;
    while (but[f][i]!=255) i++;
    if (orio<i) orio=i;
}

// Sorting Procedure !!

sort=0;

bkxrkef[0]=35 ; bkxrkef[1]=81 ; bkxrkef[2]=36;
chxrkef[0]=255 ; chxrkef[1]=0 ; chxrkef[2]=135 ; 

chxrm[0]=chxrm[1]=chxrm[2]=0;
bkxrm[0]=bkxrm[1]=bkxrm[2]=100;

chxrepi[0]=0; chxrepi[1]=0; chxrepi[2]=255;
bkxrepi[0]=168 ; bkxrepi[1]=224 ; bkxrepi[2]=0 ;

chxrsel[0]=255; chxrsel[1]=0; chxrsel[2]=0;
bkxrsel[0]=0 ; bkxrsel[1]=30 ; bkxrsel[2]=232 ;

i=orio*myfont_wid[0];
if (i <234) width = 250 ; else {width=(i>500) ? 500-8 : i+8 ;} 
size=imagesize(0,0,width-1,(plbut*20+38));
mem0=malloc(size); //250 x ... ( όσο βγει το ύψος...προσοχή λίγο όμως...)
if (!mem0) {information(2-keyb_gr,NULL,NULL);return -1;}
xt=moux ; yt1=mouy ;
if ( (yt1+(plbut*20+38)>info.bottom-60)) yt1 = yt1 - (plbut*20+38) ;
yt=yt1+20;  yb=yt+(plbut*20+18);
while (xt+width>info.right) xt--;
xb=xt+width-1 ;

getimage(xt,yt1,xb,yb,mem0); // ΑΠΟΘΗΚΕΥΣΗ ΜΕΡΟΥΣ ΟΘΟΝΗΣ
_bareacls(xt+1,yt1+1,xb-1,yt1+19,bkxrkef); // Γέμισμα με καφέ χρώμα (κεφαλίδα)
// Rectangles
setcolor(5);
rectangle (xt,yt1,xb,yb) ;
_areacls(xt+1,yt+1,xb-1,yb-1,30,130,170);
setcolor(5);
line (xt+1,yt1+18,xb-1,yt1+18);
line (xt+1,yt1+19,xb-1,yt1+19);
setcolor(3);
line (xt+1,yt1+20,xb-1,yt1+20);
setcolor(5);
rectangle (xt+8,yt+8,xb-8,yb-8);
xtepl=xt+9; xtepr=xb-9; ytepl=yt+9 ; ytepr=yb-9; ybarb=ytepl+plbut*20;
yicob = yb-9;


//_outfanis_center_col(0, but_name , xtepl, yt1+2, xtepr);
_outmystr_center_col(0, but_name , xtepl, yt1+2, xtepr, yt1+20, chxrkef , bkxrkef);
_bareacls (xtepl,ytepl,xtepr,ytepl+(plbut*20),bkxrm);
//_areacls(xtepl,ytepl+ybarb,xtepr,ybarb+1,30,30,30);

// TELOS EPIKEFALIDAS

// EMFANISH EIKONIDIVN


a=0;k=0; a1=plbut; telos=0 ; 

pano=a;

do {                                        // ARXIKH ΠΑΡΟΥΣΙΑΣΗ   
        //_outfanis_col(0, but[a] , xtepl+10 , ytepl+k*20 , xtepr);
        _outmystr_center_col(0, but[a] , xtepl+1, ytepl+k*20, xtepr-1, ytepl+k*20+20, chxrm , bkxrm);
        a++; a1--;k++;
    
}while (a1 && k<plbut);

refresh();
c=a;
kato=--a;
telos=a1;
 
fyge=0;
protyx=tyx=20; elem=el_pl=-1 ;
bima= 1 ;



do {
    
    if (!SDL_PollEvent(&sdlev)) continue;

    switch (sdlev.type) {
        
    case SDL_MOUSEMOTION:
    mx=sdlev.motion.x ; my=sdlev.motion.y;
    if (mx<info.left || my<info.top) continue ;
    if (mx>xtepl && mx<xtepr && my>ytepl && my<ybarb ) {  //Κίνηση εντός 15 (το πολύ) επιλογών !!
        ektos=0;
        el_pl=-1;
       
     tyx=(my-ytepl)/20;
    
            
        if (tyx>plbut-1) {
            
            if (protyx!=20) {
                _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                el = (sort) ? pano-protyx : pano+protyx;
                //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                refresh();
                protyx=20;
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
                continue;
            }
            else continue;
        }
     
        if (tyx==protyx || tyx>plbut-1 ) continue ;
       ektos=0;   
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
       SDL_SetCursor(cursor);
     
    if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
        else {          // Επιλέγω άλλο κουτί από πριν...
        el = (sort) ? pano-protyx : pano+protyx;
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        el = (sort) ? pano-tyx : pano+tyx;
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
        _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
        refresh();
        protyx=tyx;
        continue;
        }
    }
    
    // PONTIKI EKTOS 15 EPILOGVN
    
    if (protyx!=20) { // Προηγούμενη επιλογή που δεν έχει κλικαρισθεί !
        //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
        el = (sort) ? pano-protyx : pano+protyx;
        //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);  
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
        refresh();
        protyx=20;
                }
                                 
       

    // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
    if (ektos) continue;
    else {
        ektos=1;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
   continue;}
    
    case SDL_MOUSEBUTTONDOWN:

       if(sdlev.button.button==SDL_BUTTON_RIGHT) {

            {kati=-2; fyge=1; continue;}
    }
       else if (sdlev.button.button==SDL_BUTTON_LEFT) {
        mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
        if ( mx1<xt || mx1>xb || my1<yt1 || my1>yb ) {kati=-2; fyge=1; continue;}
       dx=abs(mx1-mx); dy=abs(my1-my);
       if (dx>35 || dy>35) continue;
       
       if ( protyx!=20 ) { // Επιλογή κάποιου από τα 15 κουτιά
        
        if (tyx==protyx) {    
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);   
        elem= el= (sort) ? pano-protyx : pano+protyx;
        //slxr[0]= 0 ; slxr[1]=140 ; slxr[2]=215;  // Blue selection
        _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrsel);
        //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
        _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrsel , bkxrsel);
        refresh(); 
        goto DIPLO_KLIK ;
        //slxr[0]=slxr[2]=0; slxr[1]=140; // Επαναφέρω χρώμα !
        }
        else break ; // KANV KLIK SE LAUOS KOYTI !
       }
       
               
    } // SDL Button Left
       
        break ; // case MOUSE BUTTON DOWN 
        
              
    case SDL_KEYDOWN:
            
          switch (sdlev.key.keysym.scancode) {
           
            case SDL_SCANCODE_DOWN :
                
                    
                if (tyx>=plbut-1 || tyx==20 || protyx==20 ) tyx=0; else tyx=tyx+1;
       
                    
                if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl= (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_UP :
                    
                if ( !tyx || tyx==20 || protyx==20) tyx=plbut-1; else tyx-=1;
                        
                if (protyx==20) { // EPILEGV GIA PRVTH FORA KOYTI
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                     //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                    }
                else {          // Επιλέγω άλλο κουτί από πριν...
                    el = (sort) ? pano-protyx : pano+protyx;
                    //_bareacls(xtepl+10, ytepl+protyx*20,xtepr,ytepl+protyx*20+18,bkxr);
                    //_outfanis_col(0, but[el] , xtepl+10 , ytepl+protyx*20 , xtepr);
                    _bareacls(xtepl+1, ytepl+protyx*20,xtepr-1,ytepl+protyx*20+19,bkxrm);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+protyx*20, xtepr-1, ytepl+protyx*20+20, chxrm , bkxrm);
                    el = el_pl = (sort) ? pano-tyx : pano+tyx;
                    //_outfanis_colsel(0, but[el] , xtepl+10 , ytepl+tyx*20 , xtepr); 
                    _bareacls(xtepl+1, ytepl+tyx*20,xtepr-1,ytepl+tyx*20+19,bkxrepi);
                    _outmystr_center_col(0, but[el] , xtepl+1, ytepl+tyx*20, xtepr-1, ytepl+tyx*20+20, chxrepi , bkxrepi);
                    refresh();
                    protyx=tyx;
                    continue;
                }
                
            case SDL_SCANCODE_RETURN :
DIPLO_KLIK :              
                if (elem!=-1) {
                fyge=1;
                kati = elem ;
                }
                else if (el_pl!=1) {
                    kati=el_pl;
                    fyge=1;
                }
               continue;
                
            case SDL_SCANCODE_ESCAPE :
               fyge=1;
               kati=-2;
               continue;
               
            }
        
        break;  // Break case SDL KEYDOWN
            
    case SDL_WINDOWEVENT :
        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
    refresh(); continue;
    
            case SDL_QUIT :
                 if (mem_small) hide_help(hdhlpxt , hdhlpyt);
               fyge=1;
               kati=-2;
               continue;
                
     default :
         if (ektos) continue ;
         ektos=1;
       cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
       SDL_SetCursor(cursor);

        }  // TELOS TOY switch &sdlev.type
        
} while (!fyge);


FYGE :
 do {
        SDL_PollEvent(&sdlev);} while (sdlev.type ==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);

if(mem0) { putimage(xt,yt1,mem0,0); free(mem0) ; } //EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
refresh();
gouv=whouv;
return kati ;
}


int decor_coord(int new , int page )

{
void *_memx1=0 , *_memy1=0 , *_memx2 =0 , *_memy2=0 ;
int mw,mh , plaped , heiped, realpla , room ;
unsigned int ola;
unsigned short int xt,yt,xb,yb, a, su ,dw, dh , ar ,p ,per , dwel ;
unsigned short int *x1,*y1,*x2,*y2 ; 
register int f,i;

ola = 4*(dbfinum+1) + 4*(decor+1) ;
_memx1=malloc(ola) ;
_memy1=malloc(ola);
_memx2=malloc(ola);
_memy2=malloc(ola);
if ( (!_memx1) || (!_memy1) || (!_memx2) || (!_memy2) ) {information (2-keyb_gr,0,0); goto MPAMIA ;}
x1=_memx1; y1=_memy1 ; x2=_memx2 ; y2=_memy2;

i=0;
    
for (f=0; f<=dbfinum ; f++) {
    if (ptr_pedio[f]->fipg == page) {
    x1[i]=ptr_pedio[f]->fixt ; y1[i]=ptr_pedio[f]->fiyt;
    x2[i]=(ptr_pedio[f]->fitype) ? x1[i]+ptr_pedio[f]->fiwid+6 : x1[i]+ptr_pedio[f]->fiwid+14 ; 
    y2[i]=y1[i]+ptr_pedio[f]->fihei+7;
    i++; 
    if (ptr_pedio[f]->fivar[3]) {
        x1[i]=ptr_pedio[f]->filaxt ; y1[i]=ptr_pedio[f]->filayt;
        x2[i]=x1[i]+ptr_pedio[f]->filawid +6 ; y2[i]=y1[i]+ptr_pedio[f]->filahei+7;
        i++;
        }
    }
}

for (f=0 ; f<decor; f++) {
    if (f==new) continue ;
    if (ptr_dec[f].depg == page || ptr_dec[f].depg == 100) {
        x1[i]=ptr_dec[f].dext ; y1[i]=ptr_dec[f].deyt;
        x2[i]=x1[i]+ptr_dec[f].dewid-1 ; 
        y2[i]=y1[i]+ptr_dec[f].dehei-1;
        i++; 
    }
}


ar=i;
mw=info.right-info.left+1 ; mw-=10; // max width (mw)
mh=info.bottom-info.top+1 ; mh-=30 ; // max height (mh)
                        
        
        xt=ptr_dec[new].dext ; yt = ptr_dec[new].deyt;
        room = ( (!xt) && (!yt) ) ? 1 : 0 ;
        if (xt<info.left+3) xt=info.left+3;
        if (yt<info.top+3) yt=info.top+3;
        if (ptr_dec[new].dewid>mw) ptr_dec[new].dewid=mw;
        if (ptr_dec[new].dehei>mh) ptr_dec[new].dehei=mh;  
        //if (ptr_dec[new].dewid < ptr_dec[new].defo_wid+3) ptr_dec[new].dewid = ptr_dec[new].defo_wid+3;
        while ( (xt+ptr_dec[new].dewid >= info.right) && (xt>info.left+2) ) xt--;
        xb=xt+ptr_dec[new].dewid;
        while ( (yt+ptr_dec[new].dehei >= info.bottom-25)  && (yt>info.top+2) ) yt--;
        yb=yt+ptr_dec[new].dehei;
        plaped=ptr_dec[new].dewid ; heiped = ptr_dec[new].dehei;
        
if (!room) goto MPAMIA ;

su=0; a=0;

for (f=0 ; f<ar ; f++) { 

    if ( (xt>x2[f]) || (yt>y2[f]) || (xb<x1[f]) || (yb<y1[f]) ) continue ; else { a=1; break; }
}

if (!a) {
    su=1;

        
        ptr_dec[new].dext = xt;
        ptr_dec[new].deyt = yt;
        ptr_dec[new].dewid = plaped;
        ptr_dec[new].dehei = heiped;
        
        goto MPAMIA ;
    }

xt=info.left+3; yt=info.top+3;
xb=xt+plaped ; yb=yt+heiped;    
su=0;

do {
    a=0; 
    for (f=0 ; f<ar ; f++) {
            if ( (xt>x2[f]) || (yt>y2[f]) || (xb<x1[f]) || (yb<y1[f]) ) continue ; else { a=1; break;}
    }    

        if (a) { 
            xt++; xb++;
            if (xb<info.right) continue;
            else { 
                xt=info.left+3; xb=xt+plaped; 
                yt++ ; yb++; 
                continue;
                }
            }
            else {su=1; break ;} // ZHTO to brhkame}
        } while (yb<=info.bottom-25) ; 

if (su) {

    
        ptr_dec[new].dext = xt;
        ptr_dec[new].deyt = yt;
        ptr_dec[new].dewid = plaped;
        ptr_dec[new].dehei = heiped;
        
    }
else {
        ptr_dec[new].dext = info.left+3;
        ptr_dec[new].deyt = info.top+3;
        ptr_dec[new].dewid = plaped;
        ptr_dec[new].dehei = heiped;
    }
    
MPAMIA :
if (_memx1) free (_memx1);
if (_memy1) free (_memy1);
if (_memx2) free (_memx2);
if (_memy2) free (_memy2);
return (int) su;
}



void dbdecor_show ()
{

if (!dcar) return ;
FILE *fp_photo;
register int i,f ;
struct fansouv *whouv1;
int a1 , a , r1 , r2 , r ;
int tet_xt , tet_yt , tet_xb, tet_yb , kyk_xt , kyk_yt , ell_xt , ell_yt ;

    setrgbcolor(dbscrxr);
    for (i=info.left;i<=info.right;i++) {for (f=info.top ; f<=info.bottom; f++) _putpixel (i,f);}   
    refresh();
    for (f=0 ; f<dcar ; f++) {
        a1=dd_elem[f];
        
        if (ptr_dec[a1].delayer==1) continue ;
        
        if (ptr_dec[a1].detype[6]) {
            if (ptr_dec[a1].dephoto[0]!='\0') {
                fp_photo = fopen (ptr_dec[a1].dephoto , "rb");
                if (fp_photo==NULL) continue ;
                fclose (fp_photo);
                readimagefile (ptr_dec[a1].dephoto,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
            }
        }
            
        else if (ptr_dec[a1].detype[2]) {
            tet_xt=dbdx1[f]; tet_yt=dbdy1[f];
            r1=dbdx2[f]-tet_xt;
            if (r1<0) continue;
            r2=dbdy2[f]-tet_yt;
            if (r2<0) continue;
            r = (r1<r2) ? r1 : r2 ;
            tet_xb = tet_xt+r-1;
            tet_yb = tet_yt+r-1;
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            rectangle (tet_xt , tet_yt , tet_xb, tet_yb);
            if (ptr_dec[a1].delinefat>1) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
            if (ptr_dec[a1].delinefat>2) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
            a++;
            if (ptr_dec[a1].defill) _bareacls (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a , ptr_dec[a1].debkxr);
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[3]) {
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            rectangle (dbdx1[f] , dbdy1[f] , dbdx2[f], dbdy2[f]);
            if (ptr_dec[a1].delinefat>1) { a++; rectangle (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a); }
            if (ptr_dec[a1].delinefat>2) { a++; rectangle (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a); }
            a++;
            if (ptr_dec[a1].defill) _bareacls (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a , ptr_dec[a1].debkxr);
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[4]) {
            a=dbdx2[f]-dbdx1[f]+1;
            if (a<0) continue;
            if (!a%2) a--;
            r1=a/2;
            kyk_xt=r1+dbdx1[f];
            a=dbdy2[f] - dbdy1[f] +1 ;
            if (a<0) continue;
            if (!a%2) a--;
            r2=a/2;
            kyk_yt = r2+dbdy1[f];
            r = (r1<r2) ? r1 : r2 ;
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            circle (kyk_xt , kyk_yt , r);
            if (ptr_dec[a1].delinefat>1) { a++; circle (kyk_xt , kyk_yt , r-a); }
            if (ptr_dec[a1].delinefat>2) { a++; circle (kyk_xt , kyk_yt , r-a); }
            a++;
            if (ptr_dec[a1].defill) {
                //_myfill_ellips (kyk_xt,kyk_yt,ptr_dec[a1].debkxr);
                superfilled_circle(kyk_xt, kyk_yt, r-a , ptr_dec[a1].debkxr);
            }
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,kyk_xt-r+a , kyk_yt-ptr_dec[a1].defohei/2 , kyk_xt+r-a, kyk_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,kyk_xt-r+a , kyk_yt-ptr_dec[a1].defohei/2 , kyk_xt+r-a, kyk_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[5]) {
            a=dbdx2[f]-dbdx1[f]+1;
            if (a<0) continue;
            if (!a%2) a--;
            r1=a/2;
            ell_xt=r1+dbdx1[f];
            a=dbdy2[f] - dbdy1[f] +1 ;
            if (a<0) continue;
            if (!a%2) a--;
            r2=a/2;
            ell_yt = r2+dbdy1[f];
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            ellipse (ell_xt , ell_yt , 0, 360, r1 , r2);
            if (ptr_dec[a1].delinefat>1) { a++; ellipse (ell_xt , ell_yt , 0, 360, r1-a , r2-a); }
            if (ptr_dec[a1].delinefat>2) { a++;  ellipse (ell_xt , ell_yt , 0, 360, r1-a , r2-a); }
            a++;
            
            if (ptr_dec[a1].defill) {
                //_myfill_ellips (ell_xt,ell_yt,ptr_dec[a1].debkxr);
                superfilled_ellipse(ell_xt,ell_yt,r1-a,r2-a,ptr_dec[a1].debkxr);
            }
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,ell_xt-r1+a , ell_yt-ptr_dec[a1].defohei/2 , ell_xt+r1-a, ell_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,ell_xt-r1+a , ell_yt-ptr_dec[a1].defohei/2 , ell_xt+r1-a, ell_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[0]) {
            if (ptr_dec[a1].detext[0]!=255) {
                _outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f], ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);
            }
        }
                            
        else if (ptr_dec[a1].detype[1]) {
            if (ptr_dec[a1].detext[0]!=255) {
                _outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f],ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);
            }
        }
        refresh();
    }
    
    
    for (f=0 ; f<dcar ; f++) {
        a1=dd_elem[f];
        
        if (ptr_dec[a1].delayer==2) continue ;
        
        if (ptr_dec[a1].detype[6]) {
            if (ptr_dec[a1].dephoto[0]!='\0') {
                fp_photo = fopen (ptr_dec[a1].dephoto , "rb");
                if (fp_photo==NULL) continue ;
                fclose (fp_photo);
                readimagefile (ptr_dec[a1].dephoto,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
            }
        }
            
        else if (ptr_dec[a1].detype[2]) {
            tet_xt=dbdx1[f]; tet_yt=dbdy1[f];
            r1=dbdx2[f]-tet_xt;
            if (r1<0) continue;
            r2=dbdy2[f]-tet_yt;
            if (r2<0) continue;
            r = (r1<r2) ? r1 : r2 ;
            tet_xb = tet_xt+r-1;
            tet_yb = tet_yt+r-1;
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            rectangle (tet_xt , tet_yt , tet_xb, tet_yb);
            if (ptr_dec[a1].delinefat>1) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
            if (ptr_dec[a1].delinefat>2) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
            a++;
            if (ptr_dec[a1].defill) _bareacls (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a , ptr_dec[a1].debkxr);
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[3]) {
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            rectangle (dbdx1[f] , dbdy1[f] , dbdx2[f], dbdy2[f]);
            if (ptr_dec[a1].delinefat>1) { a++; rectangle (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a); }
            if (ptr_dec[a1].delinefat>2) { a++; rectangle (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a); }
            a++;
            if (ptr_dec[a1].defill) _bareacls (dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a , ptr_dec[a1].debkxr);
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f]+a , dbdy1[f]+a , dbdx2[f]-a, dbdy2[f]-a,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[4]) {
            a=dbdx2[f]-dbdx1[f]+1;
            if (a<0) continue;
            if (!a%2) a--;
            r1=a/2;
            kyk_xt=r1+dbdx1[f];
            a=dbdy2[f] - dbdy1[f] +1 ;
            if (a<0) continue;
            if (!a%2) a--;
            r2=a/2;
            kyk_yt = r2+dbdy1[f];
            r = (r1<r2) ? r1 : r2 ;
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            circle (kyk_xt , kyk_yt , r);
            if (ptr_dec[a1].delinefat>1) { a++; circle (kyk_xt , kyk_yt , r-a); }
            if (ptr_dec[a1].delinefat>2) { a++; circle (kyk_xt , kyk_yt , r-a); }
            a++;
            
            if (ptr_dec[a1].defill) {
                //_myfill_ellips (kyk_xt,kyk_yt,ptr_dec[a1].debkxr);
                superfilled_circle(kyk_xt, kyk_yt, r-a , ptr_dec[a1].debkxr);
            }
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,kyk_xt-r+a , kyk_yt-ptr_dec[a1].defohei/2 , kyk_xt+r-a, kyk_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,kyk_xt-r+a , kyk_yt-ptr_dec[a1].defohei/2 , kyk_xt+r-a, kyk_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[5]) {
            a=dbdx2[f]-dbdx1[f]+1;
            if (a<0) continue;
            if (!a%2) a--;
            r1=a/2;
            ell_xt=r1+dbdx1[f];
            a=dbdy2[f] - dbdy1[f] +1 ;
            if (a<0) continue;
            if (!a%2) a--;
            r2=a/2;
            ell_yt = r2+dbdy1[f];
            a=0;
            setcolor (COLOR(ptr_dec[a1].delinexr[0] ,ptr_dec[a1].delinexr[1] , ptr_dec[a1].delinexr[2] ));
            ellipse (ell_xt , ell_yt , 0, 360, r1 , r2);
            if (ptr_dec[a1].delinefat>1) { a++; ellipse (ell_xt , ell_yt , 0, 360, r1-a , r2-a); }
            if (ptr_dec[a1].delinefat>2) { a++;  ellipse (ell_xt , ell_yt , 0, 360, r1-a , r2-a); }
            a++;
            
            if (ptr_dec[a1].defill) {
                //_myfill_ellips (ell_xt,ell_yt,ptr_dec[a1].debkxr);
                superfilled_ellipse(ell_xt,ell_yt,r1-a,r2-a,ptr_dec[a1].debkxr);
            }
            if (ptr_dec[a1].detext[0]!=255) {
            if (ptr_dec[a1].detype[0]) {_outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,ell_xt-r1+a , ell_yt-ptr_dec[a1].defohei/2 , ell_xt+r1-a, ell_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            else if (ptr_dec[a1].detype[1]) {_outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,ell_xt-r1+a , ell_yt-ptr_dec[a1].defohei/2 , ell_xt+r1-a, ell_yt+ptr_dec[a1].defohei/2,ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);}
            }
        }
            
        else if (ptr_dec[a1].detype[0]) {
            if (ptr_dec[a1].detext[0]!=255) {
                _outmystr_center_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f], ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);
            }
        }
                            
        else if (ptr_dec[a1].detype[1]) {
            if (ptr_dec[a1].detext[0]!=255) {
                _outmystr_centund_col (ptr_dec[a1].defont,ptr_dec[a1].detext,dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f],ptr_dec[a1].dechxr, ptr_dec[a1].debkxr);
            }
        }
        refresh();
    }
    
 
}


int change_labdim(int xl, int yt ,int *mxright , int *mybottom)
// Επιστρέφει 1 αν πήγε καλώς !
// Περνάει την τελευταία εγκεκριμένη θέση στα *mxright - *mybottom

{
SDL_Cursor* cursor;
int mxr , myb , prxr , pryb ,fxr, fyb;
void *mem1=NULL ;
register int i,f ;
unsigned short int a  ;
const Uint8 *state ;
short int b , shift ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZENWSE);
SDL_SetCursor(cursor);
fxr=prxr=*mxright; fyb=pryb=*mybottom;
mem1=malloc( imagesize (xl,yt,info.right,info.bottom) );
if (!mem1) {information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
SDL_SetCursor(cursor);return -1;}

getimage (xl,yt,prxr,pryb,mem1);
setrgbcolor(dbrecxr);
rectangle (xl,yt,prxr,pryb);
setrgbcolor(dbgreen);
for (i=yt+1;i<pryb;i+=3) {for (f=xl+1 ; f<prxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);
a=1;

do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
       do { SDL_PollEvent(&sdlev);}
       while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) ); 
       if (sdlev.type==SDL_WINDOWEVENT) refresh();
       if (sdlev.type==SDL_QUIT) {a=-1;break;}
       if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=-1;break;}
       mxr = sdlev.motion.x ; myb = sdlev.motion.y ;
       
       if (mxr<0 || myb<0 || mxr>info.right || myb>info.bottom) continue ;
       
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
       
       if (shift) { 
           b=mxr%8;
           mxr = (b>4) ? mxr+8-b : mxr-b ;
           b=myb%8;
           myb = (b>4) ? myb+8-b : myb-b ;
        }
       
       if (mxr<=xl || myb<=yt) continue;
       if (mxr>info.right-4) mxr=info.right-4 ;
       if (myb>info.bottom-25) myb=info.bottom-25;
       if (mxr==prxr && myb==pryb) continue;
       if (mxr<xl+7 || myb<yt+7) continue;
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxr); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myb); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
        putimage (xl,yt,mem1,0); 
        prxr=mxr ; pryb=myb;
        getimage (xl,yt,mxr,myb,mem1);
        setrgbcolor(dbrecxr);
        fxr=mxr; fyb=myb;
        for(f=xl;f<=mxr;f++) {_putpixel(f,yt); _putpixel(f,myb);}
        for(i=yt+1;i<=myb;i++) {_putpixel(xl,i); _putpixel(mxr,i);}
        setrgbcolor(dbgreen);
        for (i=yt+1;i<myb;i+=4) {for (f=xl+1 ; f<mxr; f+=4) _putpixel (f,i);} 
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
        
     putimage (xl,yt,mem1,0); free(mem1);
         do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
    *mxright=fxr ; *mybottom=fyb ;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int change_labpos(int mx, int my, int *xl, int *yt ,int *xr , int *yb)

// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ,dx, dy ;
short int c , shift , d , e , xm , ym ;
int a;
const Uint8 *state ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dx=mx-prxl; 
dy=my-pryt; 
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}

getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(dbgreen);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);
shift=0;
xm=dxa ; ym=dya+25;

 do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

 a=1;
  do {
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEMOTION  &&  SDL_PollEvent(&sdlev) ); 
        mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
        if (mxl<0 || myt<0) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) { refresh(); continue ;}
        if (sdlev.type==SDL_QUIT) {a=-1;break;}
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=-1;break;}
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
        
        //if ((!mxl) || (!myt) ) continue ;
        mxl -=dx; myt-=dy;
        if (mxl+dx<info.left || myt+dy<info.top || mxl>info.right || myt>info.bottom) continue ;
        e=d=0;

        
       if (mxl<info.left+2) { mxl=info.left+2; d=1; } 
       if (myt<info.top+2) { myt=info.top+2; e=1; } 
               
       if (shift) {
           if (!d) {
                c=mxl-3; c=c%8 ;
                if (c) mxl += (8-c) ;
                if (mxl+xm>info.right) {
                    mxl=info.right-xm;
                    c=mxl-3; c=c%8 ;
                    mxl -= c ;
                }
            }
            if (!e) {
                c = myt-3; c=c%8; 
                if (c) myt += (8-c );
                if (myt>info.bottom-ym) {
                    myt=info.bottom-ym;
                    c=myt-3; c=c%8 ;
                    myt -= c;
                }
            }
            shift=0;
        }
        else { 
            if (mxl+xm>info.right) mxl=info.right-xm;
            if (myt>info.bottom-ym) myt=info.bottom-ym;
        }
       
       if (mxl==prxl && myt==pryt) continue;
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
       
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);    
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=4) {for (f=mxl+1 ; f<sx; f+=4) _putpixel (f,i);}
        
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
        
    putimage (prxl,pryt,mem1,0); free(mem1);
    do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
    *xl=fxl ; *yt=fyt ;*xr=fxl+dxa ; *yb=fyt+dya;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return a;
}


int change_mikrolabpos(int dx, int dy, int *xl, int *yt ,int *xr , int *yb)

// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ . Επιστρέφει 1 αν πήγε καλά !

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ;
short int a;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}

a=1;
getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setfillstyle(8,4);


       mxl = prxl+dx ; myt = pryt+dy;  

       if (mxl<info.left+3) mxl=info.left+3;
       else if (mxl+dxa>info.right) mxl=info.right-dxa;
       if (myt<info.top+3) myt=info.top+3;
       else if (myt+dya>info.bottom-25) myt=info.bottom-dya-25 ;
       
       if (mxl==prxl && myt==pryt) {free (mem1) ; mem1=0; return -1; }
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
             
        putimage (prxl,pryt,mem1,0);
        refresh();
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);         
    
        setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=2) {for (f=mxl+1 ; f<sx; f+=2) _putpixel (f,i);}

        
        refresh(); 
        for(f=1;f<200000;f++) continue ;
    
    putimage (prxl,pryt,mem1,0); free(mem1); mem1=0;
    *xl=fxl ; *yt=fyt ;*xr= fxl+dxa ; *yb= fyt+dya;
    //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    //SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int decs_rec_move (int mx, int my, int *xl, int *yt ,int *xr , int *yb)

// Επιστρέφει 0 αν όλα καλά kai περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt , ext, eyt, exb , eyb , dx1, dy1 ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ;
short int c , shift , d , e , xm , ym , k , dx, dy ;
short int a;
const Uint8 *state ;

cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
SDL_SetCursor(cursor);
mxr=*xr ; myb=*yb;
fxl=prxl=*xl; fyt=pryt=*yt;
dx=(short int) abs(mx-prxl); 
dy=(short int) abs(my-pryt); 
dxa=mxr-prxl; dya=myb-pryt;
mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
if (!mem1) {
    information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    SDL_SetCursor(cursor);return -1;}

getimage (prxl,pryt,mxr,myb,mem1);
setrgbcolor(dbrecxr);
rectangle (prxl,pryt,mxr,myb);
setrgbcolor(dbgreen);
for (i=pryt+1;i<myb;i+=3) {for (f=prxl+1 ; f<mxr; f+=3) _putpixel (f,i);}
refresh();
setfillstyle(8,4);
shift=0;
xm=dxa; ym=dya+25;
a=0;

 do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);

  do {
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEMOTION  &&  SDL_PollEvent(&sdlev) ); 
        mxl = sdlev.motion.x ; myt = sdlev.motion.y ;
        if (mxl<0 || myt<0) continue ;
        if (sdlev.type==SDL_WINDOWEVENT) { refresh(); continue ;}
        if (sdlev.type==SDL_QUIT) {a=-1;break;}
        if(sdlev.button.button==SDL_BUTTON_RIGHT) {a=-1;break;}
        
        state=SDL_GetKeyboardState(NULL);
        if ( (state[SDL_SCANCODE_LCTRL]) || (state[SDL_SCANCODE_RCTRL]) || (state[SDL_SCANCODE_LSHIFT]) || (state[SDL_SCANCODE_RSHIFT]) ) {
            shift=1;
        
        } else
        {
            shift=0 ;
        }
        
        e=d=0;
        mxl -=dx; myt-=dy;
        if (mxl<info.left+2) {d=1; mxl=info.left+2;}
        else if (mxl>info.right) mxl=info.right;
        if (myt<info.top+2) { myt=info.top+2; e=1; }
        else if (myt>info.bottom-25) myt=info.bottom-25 ;
        
               
       if (shift) {
           if (!d) {
                c=mxl-3; c=c%8 ;
                if (c) mxl += (8-c) ;
                if (mxl+xm>info.right) {
                    mxl=info.right-xm;
                    c=mxl-3; c=c%8 ;
                    mxl -= c ;
                }
            }
            if (!e) {
                c = myt-3; c=c%8; 
                if (c) myt += (8-c );
                if (myt>info.bottom-ym) {
                    myt=info.bottom-ym;
                    c=myt-3; c=c%8 ;
                    myt -= c;
                }
            }
            shift=0;
        }
        else { 
            if (mxl+xm>info.right) mxl=info.right-xm;
            if (myt>info.bottom-ym) myt=info.bottom-ym;
        }
       
       if (mxl==prxl && myt==pryt) continue;
       
       dx1 = mxl - (*xl);
       dy1 = myt - (*yt);
       
       setrgbcolor(dbtop); 
       for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
       sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
       sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
       
        putimage (prxl,pryt,mem1,0);
        prxl=mxl ; pryt=myt;
        sx=mxl+dxa ; sy=myt+dya;
        getimage (mxl,myt,sx,sy,mem1);
        

       setrgbcolor(dbrecxr);
       fxl=prxl ; fyt=pryt ;
       for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
       for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
       setrgbcolor(dbgreen);
       for (i=myt+1;i<sy;i+=4) {for (f=mxl+1 ; f<sx; f+=4) _putpixel (f,i);}
        
        refresh(); 
        } while (sdlev.type!=SDL_MOUSEBUTTONDOWN) ;
    
    putimage (prxl,pryt,mem1,0); 
    free(mem1);
    *xl=fxl ; *yt=fyt ;*xr=fxl+dxa ; *yb=fyt+dya;
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    refresh();
    return (int) a;
}


int multi_decs_mikropos(int dx, int dy, int *xl, int *yt ,int *xr , int *yb)
// Επιστρέφει 0 αν επιτρέπεται η αλλαγή θέσης και περνάει την τελευταία εγκεκριμένη θέση στα *xl, *yt κλπ!!
// Επιστρέφει -1 αν ακυρώθηκε η αλλaγή με δεξί κλικ ή αν δεν επιτρέπεται από τον χρήστη η αλλαγή.

{
SDL_Cursor* cursor;
int mxl , myt , mxr, myb, prxl , pryt , fxl, fyt , ext, eyt, exb , eyb ;
void *mem1=NULL ;
register int i,f ;
unsigned int dxa , dya , sx ,sy ;
unsigned short int c ;
short int a , k;


    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEALL);
    SDL_SetCursor(cursor);
    mxr=*xr ; myb=*yb;
    fxl=prxl=*xl; fyt=pryt=*yt;
    dxa=mxr-prxl; dya=myb-pryt;
    mem1=malloc( imagesize (prxl,pryt,mxr,myb) );
    if (!mem1) {
        information (2-keyb_gr,0,0) ; cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
        SDL_SetCursor(cursor);return -1;}

    getimage (prxl,pryt,mxr,myb,mem1);
    setrgbcolor(dbrecxr);
    rectangle (prxl,pryt,mxr,myb);
    setfillstyle(8,4);

    mxl = prxl+dx ; myt = pryt+dy;  

    if (mxl<info.left+3) mxl=info.left+3;
    else if (mxl+dxa>info.right) mxl=info.right-dxa;
    if (myt<info.top+3) myt=info.top+3;
    else if (myt+dya>info.bottom-25) myt=info.bottom-dya-25 ;
    
    if (mxl==prxl && myt==pryt) {free (mem1) ; mem1=0; return -1; }
    
    setrgbcolor(dbtop); 
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
    sprintf(top_str,"%04d",mxl); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",myt); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
            
    putimage (prxl,pryt,mem1,0);
    prxl=mxl ; pryt=myt;
    sx=mxl+dxa ; sy=myt+dya;
    getimage (mxl,myt,sx,sy,mem1);
     
    setrgbcolor(dbrecxr);
    fxl=prxl ; fyt=pryt ;
    for(f=mxl;f<=sx;f++) {_putpixel(f,myt); _putpixel(f,sy);}
    for(i=myt+1;i<=sy;i++) {_putpixel(mxl,i); _putpixel(sx,i);}
    // setrgbcolor(c);
    setrgbcolor(dbgreen);
    for (i=myt+1;i<sy;i+=2) {for (f=mxl+1 ; f<sx; f+=2) _putpixel (f,i);}
    
    refresh(); 
    for(f=1;f<200000;f++) continue ;
    
    putimage (prxl,pryt,mem1,0); free(mem1); mem1=0;
    *xl=fxl ; *yt=fyt ;*xr= fxl+dxa ; *yb= fyt+dya;
    //cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    //SDL_SetCursor(cursor);
    refresh();
    return 0;
}


int multi_decs_pos(int xt1 , int yt1)
{
// Αν επιστρέψει 0 , δεν έγινε τίποτε !!
    
SDL_Cursor* cursor;
void *mem0;
register int f, i ;
int xt,yt, xb,yb,lex,ley,rix,riy,d , mx1, my1 , dx, dy ,dw ; 
short int cur , aa ,loop=0 ,loop2=0, entos ;
unsigned char giam[dcar+1];
unsigned char piap[dcar+1];
unsigned int ds ;
unsigned short int ch_scan;
    
    xt=xt1; yt=yt1;
    d = collect_fields(&xt, &yt ,&xb , &yb);
    do {SDL_PollEvent(&sdlev);} while (sdlev.type !=SDL_MOUSEBUTTONUP);
    if (d<=0) return 0;
    aa=0;
        
    for (f=0 ; f<dcar ; f++) {
        if (dbdx1[f]>=xt && dbdx2[f]<=xb && dbdy1[f]>=yt && dbdy2[f]<=yb) {
            giam[aa]=f ; aa++ ;
            if (aa==1) {
                lex=dbdx1[f]; ley=dbdy1[f]; rix=dbdx2[f]; riy=dbdy2[f];
            }
            else {
                if (lex>dbdx1[f]) lex = dbdx1[f];
                if (ley>dbdy1[f]) ley = dbdy1[f];
                if (rix<dbdx2[f]) rix = dbdx2[f];
                if (riy<dbdy2[f]) riy = dbdy2[f];
            }
        }
    }
    
        
    if (!aa) return 0;
        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    setrgbcolor(dbtop);
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
    sprintf(top_str,"%04d",(rix-lex+1)); _outsouv_col(Wt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",(riy-ley+1)); _outsouv_col(Ht,1,top_str,0,topchxr,topbkxr);
    
RESTARTBABY:

    setrgbcolor(dbtop); 
    for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f);}}
    sprintf(top_str,"%04d",lex); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
    sprintf (top_str,"%04d",ley); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
    refresh();

    mem0 = malloc (imagesize (lex,ley,rix,riy) );
    if (!mem0) {information (2-keyb_gr,0,0) ; return 0 ;}
    
    getimage (lex,ley,rix,riy,mem0);
    setcolor (COLOR(255,69,0)) ; // orangered 
    rectangle(lex,ley,rix,riy);
    rectangle(lex+1,ley+1,rix-1,riy-1);
    xt=lex; yt=ley;
    if (keyb_gr) show_help(" Για Μετακίνηση .. ", lex,riy+3 , &hdhlpxt , &hdhlpyt) ;
    else show_help(" To Move .. ", lex,riy+3  , &hdhlpxt , &hdhlpyt) ;
    entos=0;
    refresh();
    
    
    for (;;) {
        
        if (!SDL_PollEvent(&sdlev)) continue;
        
        switch (sdlev.type) {
       
            case SDL_MOUSEMOTION:
                while (sdlev.type==SDL_MOUSEMOTION && ( SDL_PollEvent(&sdlev)) );
                mx1 = sdlev.motion.x ; my1 = sdlev.motion.y ;
                if (mx1>=lex && mx1<=rix && my1>=ley && my1<=riy) {
                    if (entos) continue ;
                    entos=1;
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                }
                else {
                    if (!entos) continue ;
                    entos=0;
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                    SDL_SetCursor(cursor);
                }
                continue ;
                
            case SDL_MOUSEBUTTONDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                if(sdlev.button.button==SDL_BUTTON_RIGHT) {aa=0; goto FYGE;}
                mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
                d=1;
                if (mx1>=lex && mx1<=rix && my1>=ley && my1<=riy) {
                    
                    d=decs_rec_move (mx1, my1, &lex, &ley ,&rix , &riy); //επιστρέφει 0 αν επιτρέπεται αλλαγή
                }
                
                if (d) {aa=0; goto FYGE;}
                loop=1;loop2=0;
                break ;
                
            case SDL_KEYDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                ch_scan=sdlev.key.keysym.scancode;
                
                switch (ch_scan) {
                
                    case SDL_SCANCODE_LEFT :
                        dx=-1; dy=0; 
                        d=multi_decs_mikropos(dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                    
                    case SDL_SCANCODE_RIGHT :
                        dx=1; dy=0; 
                        d=multi_decs_mikropos(dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                    
                    case SDL_SCANCODE_UP :
                        dx=0; dy=-1;
                        d=multi_decs_mikropos(dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                        
                    case SDL_SCANCODE_DOWN :
                        dx=0; dy=1;
                        d=multi_decs_mikropos(dx, dy, &lex, &ley ,&rix , &riy);
                        if (!d) {loop=1;loop2=1;}
                        break;
                        
                    case SDL_SCANCODE_ESCAPE :
                        aa=0; loop=1 ; loop2=0; lex=xt; ley=yt; 
                        break ;

                }
                continue ;
                
                    case SDL_WINDOWEVENT :
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        refresh();
                        break ;
                        
                    case SDL_QUIT:
                        if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                        aa=0; loop=1 ; loop2=0; lex=xt; ley=yt; 
                        break ;    
        }
        
        if (loop) break ;
    }
    
    if (xt==lex && yt==ley) {aa=0; goto FYGE;}
    if (mem0) free(mem0); mem0=0;
    
    
    sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
    fpdec=fopen(str1024,"r+b");
    if (fpdec==NULL) {information(6-keyb_gr,str1024,0); aa=0; goto FYGE ;}
    
    dx = lex - xt; 
    dy = ley - yt;
    dw=0 ;
    
    for (f=0; f<aa; f++) {
                
        cur = dd_elem[giam[f]];
        
        //d=0;
        //for (i=0 ; i<dw ; i++) {
        //    if (cur==piap[i]) {d=1; break;}
        //}
        
        piap[dw]=cur; dw++;
        
        
        if (dx>0) ptr_dec[cur].dext += dx ; else ptr_dec[cur].dext -= abs(dx) ;
        if (dy>0) ptr_dec[cur].deyt += dy ; else ptr_dec[cur].deyt -= abs(dy) ;
        
        if (aa==1) fidimundo_call(1,giam[f]);
        else if (!f) fidimundo_call(7,giam[f]);
        else if (f==aa-1) fidimundo_call(6,giam[f]);
        else fidimundo_call(5,giam[f]);
        
        if (dx>0) {
            dbdx1[giam[f]] += (short int) dx;
            dbdx2[giam[f]] += (short int) dx;
        }
        else {
            dbdx1[giam[f]] -= (short int) abs(dx);
            dbdx2[giam[f]] -= (short int) abs(dx);
        }
        
        if (dy>0) {
            dbdy1[giam[f]] += (short int) abs(dy);
            dbdy2[giam[f]] += (short int) abs(dy);
        }
        else {
            dbdy1[giam[f]] -= (short int) abs(dy);
            dbdy2[giam[f]] -= (short int) abs(dy);
        }
      
    }
    

    fide_fpdec = fileno (fpdec);
    
    for (f=0; f<dw; f++) {
        cur = piap[f];
        ds= cur*decorsize;
        fseek(fpdec , ds ,0);
        fwrite (&ptr_dec[cur] , decorsize, 1, fpdec);
        fdatasync(fide_fpdec);
    }
    
    fsync(fide_fpdec);
    fclose(fpdec);
    
    if (loop2) {dbdecor_show (); dbrecs_show(); if (mem0) free(mem0); mem0=0; loop=0; goto RESTARTBABY ;}
    
FYGE :

    if (mem0) {putimage (xt,yt,mem0,0); refresh(); free(mem0);}
    do {
        SDL_PollEvent(&sdlev);} while (sdlev.type==SDL_MOUSEBUTTONDOWN || sdlev.type==SDL_KEYDOWN);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor);
    return aa;    
}


void superfilled_circle(int kx, int ky, int r , int *gem)
{
    register int f , i ;
    double a , b , klasma, krat=0 ;

    setcolor (COLOR(gem[0],gem[1],gem[2]));
    
    for (f=0 ; f<=r; f++) {
        a = sqrt ((r*r) - (f*f));
        klasma = modf(a , &b);
        krat+=klasma;
        if (krat>=1) {b++; krat-=1;}
        for (i=kx; i<=kx+(int)b; i++) {
            _putpixel(i,ky-f);
            _putpixel(i,ky+f);
        }
    }
    
    krat = 0 ;
    for (f=0 ; f<=r; f++) {
        a =  sqrt ((r*r) - (f*f));
        klasma = modf(a , &b);
        krat+=klasma;
        if (krat>=1) {b++; krat-=1;}
        for (i=kx; i>=kx-(int)b; i--) {
            _putpixel(i,ky-f);
            _putpixel(i,ky+f);
        }
    }
     
}


void superfilled_ellipse(int kx, int ky, int r1 , int r2, int *gem)
// r1 : οριζόντια ακτίνα , r2 : κάθετη
{
    register int f , i ;
    //double ra , rb ;
    double a , b , klasma, krat=0 ;
    

    setcolor (COLOR(gem[0],gem[1],gem[2]));
    
    for (f=0 ; f<=r2; f++) {
        a = (double) (f*f) / (double) (r2*r2) ;
        a = 1 - a ;
        a = a * r1 * r1 ;
        a = sqrt (a);
        klasma = modf(a , &b);
        krat+=klasma;
        if (krat>=1) {b++; krat-=1;}
        for (i=kx; i<=kx+(int)b; i++) {
            _putpixel(i,ky-f);
            _putpixel(i,ky+f);
        }
    }
    
    krat=0; 
    for (f=0 ; f<=r2; f++) {
        a = (double) (f*f) / (double) (r2*r2) ;
        a= 1 - a ;
        a = a * r1 * r1 ;
        a = sqrt (a);
        klasma = modf(a , &b);
        krat+=klasma;
        for (i=kx; i>=kx-(int)b; i--) {
            _putpixel(i,ky-f);
            _putpixel(i,ky+f);
        }
    }
     
}


int fields_undo ()
{

    if (!dbplgr) return -1;
    if (dbfinum<0) return -1;

register int i,f ;
int dx ;
void *mem4 ;
unsigned char *chm4 ;
short int undo_arped[dbfinum+1] , arped_undo[dbfinum+1];
short int undo_max , max_undo, i4 , dy , s , m , a , b , proel ;
unsigned char what ;
short int Cx1, Cy1, Cx2, Cy2 ; 

struct {
     unsigned short int fd_orio;
    unsigned short int fd_ar;
    unsigned char fd_name[40];
    void *mem_fd;
    unsigned char fd_data[40];
    int fd_elem;
    unsigned short int fd_sorton;
} dbfundo ;

unsigned char *synolo_fundo;
unsigned int size_fundo = 1024 ;
struct fansouv *trampa ;
static short int fundo_sorton ;


    undo_max=0;
    for (f=0 ; f<=dbfinum ; f++) {
        if (ptr_pedio[f]->mathtype) continue ;
        keimk=memk[f];
        ceimk=memcp[f];
        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
        else {
            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
            else dx=1;
        }
        if (dx)  { undo_arped[undo_max++]=(short int) f ; }
    }
    
    for (f=0 ; f<=dbfinum ; f++) {
        if (!ptr_pedio[f]->mathtype) continue ;
        keimk=memk[f];
        ceimk=memcp[f];
        if ( (ceimk[0]!=255) && (keimk[0]==255) ) {
            mystrcpy (keimk,ceimk);
            b=0;
            for (i=0 ; i<dbar ; i++) {
                if (!db_elem[i][1]) continue ;
                if (f==db_elem[i][0]) {b=1; break ;}
            }
            
            if (!b) continue ;
            proel= (short int) i ; 
            _bareacls(dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1,ptr_pedio[f]->fibkxr);
            if (ptr_pedio[f]->fitype == 3) {
                mystrcpy (file_3, keimk) ;
                mynum_teleies (file_3 , 3 );
                _outmystr_right_col(ptr_pedio[f]->fifont,file_3,dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1,ptr_pedio[f]->fichxr, ptr_pedio[f]->fibkxr);
            }
            else {
                mystrcpy (file_3, keimk) ;
                mynum_teleies (file_3 , 4 );
                _outmystr_right_col(ptr_pedio[f]->fifont,file_3,dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1,ptr_pedio[f]->fichxr, ptr_pedio[f]->fibkxr);
            }
        }
    }
    
    refresh();
    
    if (!undo_max) {
        if (gundo_sit || gundo_but) {
            gundo_sit=0; gundo_but=0;
            bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
        }
        return -1;
    }
    
    dbfundo.fd_orio=32;
    if (keyb_gr) sprintf(str1024,"UNDO - Πολλαπλή Επιλογή"); else sprintf(str1024,"UNDO - Multi Selection");
    normtext_tomy(str1024 , dbfundo.fd_name);
    dbfundo.fd_sorton=fundo_sorton;

    dbfundo.mem_fd = malloc(size_fundo) ;
    if (!dbfundo.mem_fd) return -2 ;
    synolo_fundo = dbfundo.mem_fd ;

    m=0;s=0;
    dbfundo.fd_orio=0;

        for (f=0;f<undo_max;f++) {
            
            if ( (m+31) > (size_fundo-40) ) {
                size_fundo+=256;
                dbfundo.mem_fd=realloc(dbfundo.mem_fd,size_fundo);
                if (!dbfundo.mem_fd) return -2;
                synolo_fundo=dbfundo.mem_fd;
            }
            
                for (i=0;i<31;i++) {
                    what=ptr_pedio[undo_arped[f]]->finame[i];
                    synolo_fundo[s] = what ;
                    m++; s++;
                    if (what==255) break;
                }
                if (dbfundo.fd_orio<i) dbfundo.fd_orio=i;
                if (dbfundo.fd_orio<25) dbfundo.fd_orio=25 ;
        }


    if (s) {
        dbfundo.fd_ar = s ;
        synolo_fundo[s]=254;
    }
    else {
    synolo_fundo[0]=255;
    synolo_fundo[1]=254;
    dbfundo.fd_ar=0;
    }
    dbfundo.fd_data[0]=255;
    
    trampa = gouv ;
    mem4 = mulbutton_show(dbfundo.mem_fd, dbfundo.fd_ar, dbfundo.fd_orio, dbfundo.fd_name, &dbfundo.fd_sorton,0 );
    fundo_sorton = dbfundo.fd_sorton ;
    if (!mem4) {undo_max=-1; goto FYGE ;}
    chm4=mem4; max_undo=0;  
    for (f=0;f<undo_max;f++) {
        if (chm4[f]) { arped_undo[max_undo]=undo_arped[f] ; max_undo++; }
    }
    
    a=0;

    while (max_undo) {
        i=arped_undo[a++];
        keimk=memk[i];
        ceimk=memcp[i];
        if (ptr_pedio[i]->fitype != 5) {
            mystrcpy (keimk,ceimk);
        }
        else {
            if (ceimk[0]==255) keimk[0]=255;
            else strcpy (keimk,ceimk);
        }
        
        b=0;
        for (f=0 ; f<dbar ; f++) {
            if ( (i==db_elem[f][0]) && (db_elem[f][1]) ) {b=1; break ;}
        }
        
        if (!b) { max_undo--; continue ;}
        proel= (short int) f ; 


        gouv=myfont[ptr_pedio[i]->fifont];
        Cx1=dbx1[proel]+1; Cy1=dby1[proel]+1; Cx2=dbx2[proel]-1; Cy2=dby2[proel]-1; 

        switch (ptr_pedio[i]->fitype) {
            case 0:
            
                curk[i] = curk1[i] = 0 ;
                _field_txt_show (i,keimk , 0 , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
                refresh();
                break;
                
            case 1:
            case 2:
               _bareacls (dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fibkxr);
               _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                refresh();
                break ;
                
            case 3:
                    mystrcpy (file_3, keimk) ;
                    mynum_teleies (file_3 , 3 );
                    _bareacls (Cx1, Cy1, Cx2, Cy2,ptr_pedio[i]->fibkxr);
                    _outmystr_right_col(ptr_pedio[i]->fifont,file_3,Cx1, Cy1, Cx2, Cy2,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                    refresh();
                    
                        if (dpro>0) {
                            for (f=0 ; f<enmath_1; f++) {
                                i4=prot_calc[f];
                                dfx = anal_parast (i4, alg_str[i4] , &alg_err , 0);
                                check_orio_write_mathped(i4, ptr_pedio[i4]->fiorio, 1);
                            
                                for (dy=0;dy<dbar;dy++) {
                                    if (i4==db_elem[dy][0] && db_elem[dy][1]) {
                                        _bareacls(dbx1[dy]+1,dby1[dy]+1,dbx2[dy]-1,dby2[dy]-1,ptr_pedio[i4]->fibkxr);
                                        
                                        if (!ptr_pedio[i4]->fivar[2]){
                                        deimk=memk[i4];
                                        if (deimk[0]==255) continue ;
                                        mystrcpy (file_3, deimk) ;
                                        mynum_teleies (file_3 , ptr_pedio[i4]->fitype );
                                        _outmystr_right_col(ptr_pedio[i4]->fifont,file_3, dbx1[dy],dby1[dy],dbx2[dy],dby2[dy],ptr_pedio[i4]->fichxr, ptr_pedio[i4]->fibkxr);
                                        

                                        }
                                    }
                                }
                            }
                            refresh();
                        }
                
                break ;
            
            case 4:
                mystrcpy (file_3, keimk) ;
                mynum_teleies (file_3 , 4 );
                _bareacls (Cx1, Cy1, Cx2, Cy2,ptr_pedio[i]->fibkxr);
                _outmystr_right_col(ptr_pedio[i]->fifont,file_3,Cx1, Cy1, Cx2, Cy2,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                refresh();
                
                    
                        if (dpro>0) {
                            for (f=0 ; f<enmath_1; f++) {
                                i4=prot_calc[f];
                                dfx = anal_parast (i4, alg_str[i4] , &alg_err , 0);
                                check_orio_write_mathped(i4, ptr_pedio[i4]->fiorio, 1);
                            
                                for (dy=0;dy<dbar;dy++) {
                                    if (i4==db_elem[dy][0] && db_elem[dy][1] ) {
                                        _bareacls(dbx1[dy]+1,dby1[dy]+1,dbx2[dy]-1,dby2[dy]-1,ptr_pedio[i4]->fibkxr);
                                        
                                        if (!ptr_pedio[i4]->fivar[2]){
                                        deimk=memk[i4];
                                        if (deimk[0]==255) continue ;
                                        mystrcpy (file_3, deimk) ;
                                        mynum_teleies (file_3 , ptr_pedio[i4]->fitype );
                                        _outmystr_right_col(ptr_pedio[i4]->fifont,file_3, dbx1[dy],dby1[dy],dbx2[dy],dby2[dy],ptr_pedio[i4]->fichxr, ptr_pedio[i4]->fibkxr);

                                        }
                                    }
                                }
                            }
                            refresh();
                        }
                break;
                
            case 5 :
                if (keimk[0]==255) { bareacls (Cx1, Cy1, Cx2, Cy2 , ptr_pedio[i]->fibkxr); break ; }
                f=strlen(keimk);
                while (keimk[f] != '/') f-- ;
                for (i4=0;i4<=f;i4++) { photopath[i4] = keimk[i4]; }
                photopath[i4]='\0';
                readimagefile (keimk,Cx1, Cy1, Cx2, Cy2);
                
                break;
                
            case 6:

                //_field_txt_show (i,keimk , 0 , dbx1[proel],dby1[proel],dbx2[proel],dby2[proel], limk[i]-1,ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr );
               _bareacls (dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fibkxr);
               _outmystr_center_col(ptr_pedio[i]->fifont, keimk ,  dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1, ptr_pedio[i]->fichxr, ptr_pedio[i]->fibkxr);
                refresh();
                break ;

        } // Πέρας switch ..
            
        if (ptr_pedio[i]->fivar[2]) bareacls(Cx1, Cy1, Cx2, Cy2,ptr_pedio[i]->fibkxr);
        max_undo--;
    }
    
    
    for (f=0; f<=dbfinum; f++) {
        keimk = memk[f];
        ceimk = memcp[f];
        if (ptr_pedio[f]->mathtype) {
            if (ceimk[0]==255) {
                keimk[0]=255;
                b=0;
                for (i=0 ; i<dbar ; i++) {
                    if (!db_elem[i][1]) continue ;
                    if (f==db_elem[i][0]) {b=1; break ;}
                }
                
                if (!b) continue ;
                proel= (short int) i ; 
                _bareacls(dbx1[proel]+1,dby1[proel]+1,dbx2[proel]-1,dby2[proel]-1,ptr_pedio[f]->fibkxr);
            }
        }
    }
    
    gundo_sit=0; gundo_but=0;
    _bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);

    refresh(); 
    
FYGE :
    if (dbfundo.mem_fd) free (dbfundo.mem_fd);
    if (mem4) free(mem4) ;
    gouv = trampa ;
    return (int) undo_max;
}
                    

void eaninpundo()
// Επιστρέφει 1 αν κάτι άλλαξε και υπάρχει λόγος για undo,  αλλιώς επιστρέφει 0 !
{
    
    if (!dbplgr) {
        if (gundo_sit) {
        bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
        gundo_sit=0; gundo_but=0;
        }
    return ;
    }

register int f;
int dx;

    for (f=0 ; f<=dbfinum ; f++) {    
        keimk=memk[f];
        ceimk=memcp[f];
        if (ptr_pedio[f]->fitype != 5) dx=mystrcmp(keimk,ceimk);
        else {
            if ( (keimk[0]!=255) && (ceimk[0]!=255) ) dx=strcmp(keimk,ceimk) ;
            else if ( keimk[0]==255 && ceimk[0]==255 ) dx=0;
            else dx=1;
        }
        if (dx) {
            if (!gundo_but) {
                setcolor(5);
                rectangle (gundo_xt,topinfyt,gundo_xb,topinfyt+17);
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                refresh();
                gundo_sit=1;
            }
            break ;
        }
    }
    if (!dx) {
        if (gundo_sit) {
            gundo_sit=0;gundo_but=0;
            bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,eisag);
        }
    }
    return ;
}
              
               
void fidimundo_call(short int job , short int proel)
// job=0 καταργείται το undo-redo για κατάσταση σχεδίασης - σβήνει από την οθόνη !
// job=1 ενημερώνεται η δομή udim για ένα πεδίο που μετακινήθηκε κανονικά (όχι μικρομετακίνηση)
// job=2 απλά ανάβει το undo !!
//job=3 επαναφέρει ένα πεδίο στην προηγούμενη θέση του
{
    
    register int f , i;
    short int g , a , b , c , g1 ;
    unsigned int dx = 0  ;
    static short int hmud , hmre;
    short int Cx1 , Cy1, Cx2, Cy2 ,arped ;
    short int *mem1 , *mem2 ;
    unsigned char piap[200];
    
    switch (job) {
        
        case 0: // Μηδενισμός undo-redo
             
            f=0;
            
            if (hmud && mmed[3]==2) {
                if (!diax_dec) _bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,sxedom);
                else _bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,etikbkxr);
                f=1;
            }
            
            if (hmre && mmed[3]==2) {
                if (!diax_dec) _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,sxedom);
                else _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,etikbkxr);
                f=1;
            }
            
            if (f) { refresh(); }
            
            hmud=hmre=0;
            fidim_undo=0;
            fidim_but=0;
            fidim_redo=0;
            fidim_redobut=0;
            
            break ;
            
            
            
        case 1:  // Καταχώρηση για ένα στοιχείο ! Περνάμε νέα στοιχεία για πεδία δεδομένων στη δομή udim ..
            
            if (hmud==500) { // Πετάμε την πιο παλιά καταχώρηση....
                mem1 = (short int *) &udim[0];
                mem2 = (short int *) &udim[1];
                for (f=0 ; f<size_undo_dim; f++) {
                    *mem1++ = *mem2++ ;
                }
                
                mem1 = (short int *) &rdim[0];
                mem2 = (short int *) &rdim[1];
                for (f=0 ; f<size_undo_dim; f++) {
                    *mem1++ = *mem2++ ;
                }
            }
            else { hmud++; }
            
            if (!diax_dec) {
            
                f=hmud-1;
                
                udim[f].uarel = rdim[f].uarel = arped = db_elem[proel][0] ;
                udim[f].ped = rdim[f].ped = db_elem[proel][1] ;
                udim[f].ux1 = dbx1[proel]; udim[f].uy1=dby1[proel];
                udim[f].ux2 = dbx2[proel]; udim[f].uy2=dby2[proel];
                udim[f].multi = rdim[f].multi = 0 ;
                udim[f].telos = rdim[f].telos = 1 ;
                udim[f].arxh = rdim[f].arxh = 1;
                
                if(rdim[f].ped) {
                    rdim[f].ux1 = ptr_pedio[arped]->fixt;
                    rdim[f].uy1 = ptr_pedio[arped]->fiyt;
                    rdim[f].ux2 = rdim[f].ux1 + ptr_pedio[arped]->fiwid - 1 ; 
                    rdim[f].uy2 = rdim[f].uy1 + ptr_pedio[arped]->fihei - 1 ;
                    }
                else {
                    rdim[f].ux1 = ptr_pedio[arped]->filaxt;
                    rdim[f].uy1 = ptr_pedio[arped]->filayt;
                    rdim[f].ux2 = rdim[f].ux1 + ptr_pedio[arped]->filawid - 1 ; 
                    rdim[f].uy2 = rdim[f].uy1 + ptr_pedio[arped]->filahei - 1 ;
                }
            }
            else {
                f=hmud-1;
                
                udim[f].uarel = rdim[f].uarel = arped = dd_elem[proel] ;
                udim[f].ped = rdim[f].ped = 1 ;
                udim[f].ux1 = dbdx1[proel]; udim[f].uy1=dbdy1[proel];
                udim[f].ux2 = dbdx2[proel]; udim[f].uy2=dbdy2[proel];
                udim[f].multi = rdim[f].multi = 0 ;
                udim[f].telos = rdim[f].telos = 1 ;
                udim[f].arxh = rdim[f].arxh = 1;
                rdim[f].ux1 = ptr_dec[arped].dext;
                rdim[f].uy1 = ptr_dec[arped].deyt;
                rdim[f].ux2 = rdim[f].ux1 + ptr_dec[arped].dewid - 1 ; 
                rdim[f].uy2 = rdim[f].uy1 + ptr_dec[arped].dehei - 1 ;
            }

            if (hmud==1) {
                setcolor(1);
                rectangle (gundo_xt,topinfyt,gundo_xb,topinfyt+17);
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                dx=1;
            }
            
            fidim_undo=1;
            
            if (hmre) {
                hmre=0;
                fidim_redo=0;
                fidim_redobut=0;
                if (!diax_dec) _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,sxedom);
                else _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,etikbkxr);
                dx=1;
            }
            
            if (dx) {dx=0 ; refresh();}
            break;
            
            
        case 2 : // Απλά ανάβει το UNDO ή/και το REDO αφού ελέγξει ...
            if (hmud) {
                setcolor(1);
                rectangle (gundo_xt,topinfyt,gundo_xb,topinfyt+17);
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                fidim_undo=1;
                dx=1;
            }
            
            if (hmre) {
                setcolor(1);
                rectangle (gredo_xt,topinfyt,gredo_xb,topinfyt+17);
                _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                fidim_redo=1;
                dx=1;
            }
            
            if (dx) { refresh(); dx=0; }
            break ;
            
        case 3 : // Undo για πεδία δεδομένων
            
            if (!hmud) break;
            g=hmud-1; a=0 ; 
            do {
                f=hmud-1;
                a++;
                arped = udim[f].uarel;
                                
                Cx1=udim[f].ux1; Cy1=udim[f].uy1;
                Cx2=udim[f].ux2; Cy2=udim[f].uy2;
                
                if (!diax_dec) {
                
                    if(udim[f].ped) {
                        ptr_pedio[arped]->fixt=Cx1; ptr_pedio[arped]->fiyt=Cy1;
                        ptr_pedio[arped]->fiwid=Cx2-Cx1+1; ptr_pedio[arped]->fihei=Cy2-Cy1+1;
                        }
                    else {
                        ptr_pedio[arped]->filaxt=Cx1; ptr_pedio[arped]->filayt=Cy1;
                        ptr_pedio[arped]->filawid=Cx2-Cx1+1; ptr_pedio[arped]->filahei=Cy2-Cy1+1;
                    }
                                
                    dx=0;
                    for (i=0 ; i<dbar ; i++) {
                        if (db_elem[i][0] == arped) {
                            if (udim[f].ped && db_elem[i][1]) { dx=1; break ;}
                            if (!udim[f].ped && !db_elem[i][1]) { dx=1; break ;}
                        }
                    }
                    
                    if (dx) {
                        dbx1[i]=Cx1; dby1[i]=Cy1; 
                        dbx2[i]=Cx2 ; dby2[i]=Cy2;
                    }
                }
                else {
                    ptr_dec[arped].dext=Cx1; ptr_dec[arped].deyt=Cy1;
                    ptr_dec[arped].dewid=Cx2-Cx1+1; ptr_dec[arped].dehei=Cy2-Cy1+1;
                    dx=0;
                    for (i=0 ; i<dcar ; i++) {
                        if (dd_elem[i] == arped) { dx=1; break ;}
                    }
                    
                    if (dx) {
                        dbdx1[i]=Cx1; dbdy1[i]=Cy1; 
                        dbdx2[i]=Cx2 ; dbdy2[i]=Cy2;
                    }
                    
                }
                
                hmud--;
                
                if (!hmud) break ;
                if (udim[f].arxh) break ;
                if (!udim[f].multi) break;
                
            } while (udim[hmud-1].multi);
            
            
            if (!diax_dec) {
            
                if (! udim[g].multi) {
                    fseek(fpdb,((arped*dbfisize)+104),0);
                    fwrite (ptr_pedio[arped],1,dbfisize,fpdb);
                    fdatasync (fide_fpdb);
                }
                else {
                    b=0;
                    for (f=0 ; f<a ; f++) {
                    arped = udim[g].uarel;
                    c=0;
                    for (i=0; i<b; i++) {
                        if (arped==piap[i]) { c=1; break;}
                        }
                        
                        if (!c) { piap[b]=arped ; b++; }
                        g--;
                    }
                    
                    for (f=0 ; f<b; f++) {
                    arped = piap[f];
                        fseek(fpdb,((arped*dbfisize)+104),0);
                        fwrite (ptr_pedio[arped],1,dbfisize,fpdb);
                        fdatasync (fide_fpdb);
                    }
                }
            }
            else {
                sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                fpdec=fopen(str1024,"r+b");
                if (fpdec==NULL) { information(6-keyb_gr,str1024,0); break; }
                fide_fpdec = fileno (fpdec);

                if (! udim[g].multi) {
                        fseek(fpdec , (arped*decorsize) ,0);
                        fwrite (&ptr_dec[arped] , decorsize, 1, fpdec);
                        fdatasync(fide_fpdec);
                        fsync(fide_fpdec);
                        fclose(fpdec);
                }
                else {
                    for (f=0 ; f<a ; f++) {
                        arped = udim[g].uarel;
                        fseek(fpdec , (arped*decorsize) ,0);
                        fwrite (&ptr_dec[arped] , decorsize, 1, fpdec);
                        fdatasync(fide_fpdec);
                        g--;
                    }
                    fsync(fide_fpdec);
                    fclose(fpdec);
                }
            }
            
            g=0;
                
            if (!hmud) {
                if (!diax_dec) _bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,sxedom);
                else _bareacls (gundo_xt,topinfyt,gundo_xb,topinfyt+17,etikbkxr);
                fidim_undo=0;
                fidim_but=0;
                g=1 ;
            }
            
            if (!hmre) {
                setcolor(1);
                rectangle (gredo_xt,topinfyt,gredo_xb,topinfyt+17);
                _bareacls (gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redobkxr);
                _outmystr_center_col(2, redo_text , gredo_xt+1,topinfyt+1,gredo_xb-1,topinfyt+16,redochxr, redobkxr);
                fidim_redo=1;
                g=1;
            }
            
            hmre += a ;
            
            if (g) refresh();
            
            break ;
            
            
        case 4 : // Redo 1 level
            
                if (!hmre) break;
                g=hmud ; a=0 ; g1=g ;
                do {
                    f=hmud;
                    if (hmud<500) { hmud++; a++; } else break ;  
                    arped = rdim[f].uarel;
                    Cx1=rdim[f].ux1; Cy1=rdim[f].uy1;
                    Cx2=rdim[f].ux2; Cy2=rdim[f].uy2;
                    
                    if (!diax_dec) {
                    
                        if(rdim[f].ped) {
                            ptr_pedio[arped]->fixt=Cx1; ptr_pedio[arped]->fiyt=Cy1;
                            ptr_pedio[arped]->fiwid=Cx2-Cx1+1; ptr_pedio[arped]->fihei=Cy2-Cy1+1;
                            }
                        else {
                            ptr_pedio[arped]->filaxt=Cx1; ptr_pedio[arped]->filayt=Cy1;
                            ptr_pedio[arped]->filawid=Cx2-Cx1+1; ptr_pedio[arped]->filahei=Cy2-Cy1+1;
                        }
                        
                        dx=0;
                        for (i=0 ; i<dbar ; i++) {
                            if (db_elem[i][0] == arped) {
                                if (rdim[f].ped && db_elem[i][1]) { dx=1; break ;}
                                if (!rdim[f].ped && !db_elem[i][1]) { dx=1; break ;}
                            }
                        }
                        
                        if (dx) {
                            dbx1[i]=Cx1; dby1[i]=Cy1; 
                            dbx2[i]=Cx2 ; dby2[i]=Cy2;
                        }
                    }
                    else {
                        ptr_dec[arped].dext=Cx1; ptr_dec[arped].deyt=Cy1;
                        ptr_dec[arped].dewid=Cx2-Cx1+1; ptr_dec[arped].dehei=Cy2-Cy1+1;
                        dx=0;
                        for (i=0 ; i<dcar ; i++) {
                            if (dd_elem[i] == arped) { dx=1; break ;}
                        }
                        
                        if (dx) {
                            dbdx1[i]=Cx1; dbdy1[i]=Cy1; 
                            dbdx2[i]=Cx2 ; dbdy2[i]=Cy2;
                        }
                    }
                    
                    hmre--;
                    if (!hmre) break ;
                    if (rdim[f].telos) break ;
                    if (!rdim[f].multi) break ;
                    
                } while (rdim[hmud].multi);
                
                
            if (!diax_dec) {
            
                if (! rdim[g].multi) {
                    fseek(fpdb,((arped*dbfisize)+104),0);
                    fwrite (ptr_pedio[arped],1,dbfisize,fpdb);
                    fdatasync (fide_fpdb);
                }
                else {
                    b=0;
                    for (f=0 ; f<a ; f++) {
                    arped = rdim[g].uarel;
                    c=0;
                    for (i=0; i<b; i++) {
                        if (arped==piap[i]) { c=1; break;}
                        }
                        
                        if (!c) { piap[b]=arped ; b++; }
                        g++;
                    }
                    
                    for (f=0 ; f<b; f++) {
                        arped = piap[f];
                        fseek(fpdb,((arped*dbfisize)+104),0);
                        fwrite (ptr_pedio[arped],1,dbfisize,fpdb);
                        fdatasync (fide_fpdb);
                    }
                }
            }
            else {
                sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                fpdec=fopen(str1024,"r+b");
                if (fpdec==NULL) { information(6-keyb_gr,str1024,0); break; }
                fide_fpdec = fileno (fpdec);

                if (! rdim[g].multi) {
                        fseek(fpdec , (arped*decorsize) ,0);
                        fwrite (&ptr_dec[arped] , decorsize, 1, fpdec);
                        fdatasync(fide_fpdec);
                        fsync(fide_fpdec);
                        fclose(fpdec);
                }
                else {
                    for (f=0 ; f<a ; f++) {
                        arped = rdim[g].uarel;
                        fseek(fpdec , (arped*decorsize) ,0);
                        fwrite (&ptr_dec[arped] , decorsize, 1, fpdec);
                        fdatasync(fide_fpdec);
                        g++;
                    }
                    fsync(fide_fpdec);
                    fclose(fpdec);
                }
            }
                
                f=0;
                
            if (!hmre) {
                if (!diax_dec) _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,sxedom);
                else _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,etikbkxr);
                fidim_redo=0;
                fidim_redobut=0;
                f=1;
            }
            
            if (!g1) {
                setcolor(1);
                rectangle (gundo_xt,topinfyt,gundo_xb,topinfyt+17);
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                fidim_undo=1;
                f=1;
            }
            
            if (f) refresh() ;
            
            break ;
            
            
        case 5:  // Καταχώρηση multi !! Περνάμε νέα στοιχεία για  πεδία δεδομένων (multi) στη δομή udim ..
        case 6:
        case 7:
            
            if (hmud==500) { // Πετάμε την πιο παλιά καταχώρηση....
                mem1 = (short int *) &udim[0];
                mem2 = (short int *) &udim[1];
                for (f=0 ; f<size_undo_dim; f++) {
                    *mem1++ = *mem2++ ;
                }
                
                mem1 = (short int *) &rdim[0];
                mem2 = (short int *) &rdim[1];
                for (f=0 ; f<size_undo_dim; f++) {
                    *mem1++ = *mem2++ ;
                }
            }
            else { hmud++; }
            
            f=hmud-1;
            
            if (!diax_dec) {
            
                udim[f].uarel = rdim[f].uarel = arped = db_elem[proel][0] ;
                udim[f].ped = rdim[f].ped = db_elem[proel][1] ;
                udim[f].ux1 = dbx1[proel]; udim[f].uy1=dby1[proel];
                udim[f].ux2 = dbx2[proel]; udim[f].uy2=dby2[proel];
                udim[f].multi = rdim[f].multi = 1 ;
                udim[f].telos = (job==6) ? 1 : 0 ; 
                rdim[f].telos=udim[f].telos;
                udim[f].arxh = (job==7) ? 1 : 0 ; 
                rdim[f].arxh=udim[f].arxh;

                if(rdim[f].ped) {
                    rdim[f].ux1 = ptr_pedio[arped]->fixt;
                    rdim[f].uy1 = ptr_pedio[arped]->fiyt;
                    rdim[f].ux2 = rdim[f].ux1 + ptr_pedio[arped]->fiwid - 1 ; 
                    rdim[f].uy2 = rdim[f].uy1 + ptr_pedio[arped]->fihei - 1 ;
                    }
                else {
                    rdim[f].ux1 = ptr_pedio[arped]->filaxt;
                    rdim[f].uy1 = ptr_pedio[arped]->filayt;
                    rdim[f].ux2 = rdim[f].ux1 + ptr_pedio[arped]->filawid - 1 ; 
                    rdim[f].uy2 = rdim[f].uy1 + ptr_pedio[arped]->filahei - 1 ;
                }
            }
            else {
                udim[f].uarel = rdim[f].uarel = arped = dd_elem[proel] ;
                udim[f].ped = rdim[f].ped = 1 ;
                udim[f].ux1 = dbdx1[proel]; udim[f].uy1=dbdy1[proel];
                udim[f].ux2 = dbdx2[proel]; udim[f].uy2=dbdy2[proel];
                udim[f].multi = rdim[f].multi = 1 ;
                udim[f].telos = (job==6) ? 1 : 0 ; 
                rdim[f].telos=udim[f].telos;
                udim[f].arxh = (job==7) ? 1 : 0 ; 
                rdim[f].arxh=udim[f].arxh;
                rdim[f].ux1 = ptr_dec[arped].dext;
                rdim[f].uy1 = ptr_dec[arped].deyt;
                rdim[f].ux2 = rdim[f].ux1 + ptr_dec[arped].dewid - 1 ; 
                rdim[f].uy2 = rdim[f].uy1 + ptr_dec[arped].dehei - 1 ;
            }

            if (hmud==1) {
                setcolor(1);
                rectangle (gundo_xt,topinfyt,gundo_xb,topinfyt+17);
                _bareacls (gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undobkxr);
                _outmystr_center_col(2, undo_text , gundo_xt+1,topinfyt+1,gundo_xb-1,topinfyt+16,undochxr, undobkxr);
                dx=1;
            }
            
            fidim_undo=1;
            
            if (hmre) {
                hmre=0;
                fidim_redo=0;
                fidim_redobut=0;
                if (!diax_dec) _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,sxedom);
                else _bareacls (gredo_xt,topinfyt,gredo_xb,topinfyt+17,etikbkxr);
                dx=1;
            }
            
            if (dx) {dx=0 ; refresh();}
            break;
    }
    
    if (dx) {
        dbdecor_show ();
        dbrecs_show();
    }
    return ;
}
               

int add_edit_decor (short int new , short int *new1) 
{
    SDL_Cursor* cursor;
    FILE *fp_photo;
    struct fandecor cpy ;
    struct fansouv *trampa ;
    void *mem0=0 , *mem_arrs=0 , *mem_ok=0 , *mem_ri=0 , *mem_le=0 , *mem_del=0 , *mem1 ,*mem_yel=0 ,*mem_form=0;
    char *mem2 , *mem3 ;
    void *mem_go=0 ;
    register int f,i ;
    int xb, yb , x1 , y1 ;
    int mx,my,mx1,my1,dx,dy , dx1, dy1, dz, xt1,yt1,xb1,yb1 , user_ans ;
    short int arrxt, arryt , rixt, riyt, leyt, lext, xok, yok, xgo, ygo , delxt, delyt;
    short int ektos , fyge ,marrs , proenter , akyro, deldec, go_ri , go_le ;
    int wtype_xt , wtype_xb, wtype_yt, wtype_yb ;
    short int a , b, c;
    unsigned char keimeno[10] , eis_keim[20] , fonter[20] , photo[10] , xrkeimfose[22] , xrkeimgem[76] , sximgem[20];
    unsigned char xrperfose[40] , xrperfo[46] , aplgr[20] , diplgr[20] , page_t[12] , pageoles[22] ; 
    unsigned char coor_t[4][12] , lay_t[2][14] , nordim_t[70];
    unsigned char dragphoto[36] , kentrx_t[50] , kentry_t[50];
    unsigned char ipage[6] , icoorx[8], icoory[8] , iwid[8] , ihei[8];
    short int inptext_xt,inptext_yt,inptext_xb,inptext_yb ;
    short int font_xt , font_yt , font_xb , font_yb ;
    short int xrkeimfose_xt , xrkeimfose_yt , xrkeimfose_xb , xrkeimfose_yb ;
    short int xrkeimgem_xt , xrkeimgem_yt , xrkeimgem_xb , xrkeimgem_yb ;
    short int sximgem_xt, sximgem_yt , sximgem_xb, sximgem_yb ;
    short int xrperfose_xt , xrperfose_yt , xrperfose_xb , xrperfose_yb ;
    short int xrperfo_xt , xrperfo_yt , xrperfo_xb , xrperfo_yb ;
    short int aplgr_xt , aplgr_yt , aplgr_xb , aplgr_yb ;
    short int diplgr_xt , diplgr_yt , diplgr_xb , diplgr_yb ;
    short int coor_xt[4] , coor_yt[4], coor_xb[4], coor_yb[4];
    short int lay_xt[2] , lay_yt[2] ,lay_xb[2] ,lay_yb[2] ;
    short int page_xt[2] ,  page_yt[2] , page_xb[2] , page_yb[2] ;
    short int g_xt , g_yt ,g_xb ,g_yb ,ipage_xt;
    short int aa_xt , aa_yt, aa_xb, aa_yb ;
    short int kentrx_xt , kentrx_yt , kentrx_xb , kentrx_yb , kentry_xt , kentry_yt , kentry_xb , kentry_yb ; 
    short int nordim_xt,nordim_yt,nordim_xb,nordim_yb;
    short int icoor_xt[4] ;
    short int anan=0 ;

        // BUTTONS
    short int inptext_but=0 , font_but=0 , xrkeimfose_but=0, xrkeimgem_but=0 ;
    short int xrperfose_but=0 , xrperfo_but=0, aplgr_but=0 , diplgr_but=0 , sximgem_but=0;
    short int coorx_but=0 , coory_but=0, wid_but=0, hei_but=0;
    short int lay1_but=0 , lay2_but=0 ;
    short int pgcur_but=0 , pgall_but=0 ;
    short int kentrx_but=0 , kentry_but=0 , nordim_but=0 ;
    
    union {
        unsigned int co;
        unsigned char rgb[4];
    } fo ; 
    
    short int keaaxt , keaayt ;
    
    int kit[3] , bla[3] , kok[3] , energ[3] , enbkxr[3] , selkb[3];
    int *pioxr ,*piobkxr;
    int type;
    int ph_xt , ph_yt , ph_xb , ph_yb ;
    int tet_xt , tet_yt , tet_xb, tet_yb , par_xt, par_yt, par_xb, par_yb , kyk_xt, kyk_yt, kyk_r;
    int ell_xt,ell_yt,ell_r1,ell_r2;
    char intmenu[12][80];
    char secmenu[12][80];
    short int cross , proel , prodec ;
    unsigned short int ch_scan ;
    int norm_w , norm_h ;
    static int xt,yt ;
    
    b=500;fyge=2;
    if (!xt && !yt) {
    xt=(info.right-info.left-900) / 2 ; yt=(info.bottom-info.top-b-1) / 2 ;}
    xb=xt+899; yb=yt+b-1;
    mem0=malloc(imagesize(xt,yt,xb,yb));
    if (!mem0) {information (2-keyb_gr,0,0); goto FYGE ;}
    trampa=gouv;
    getimage(xt,yt,xb,yb,mem0);
    
    bla[0] = bla[1] = bla[2] = 0;
    kit[0] = 195 ; kit[1]=217; kit [2]=0;
    kok[0] = 181; kok[1]=kok[2]=0;
    energ[0]=0 ; energ[1]=230 ; energ[2]=157 ; 
    selkb[0]=0; selkb[1]=255; selkb[2]=219; 
    
    if (keyb_gr) {
        strcpy (intmenu[0] , "Λήψη Συντεταγμένων(Άνω & Αριστερά)");
        strcpy (intmenu[1] , "Υπολογισμός πλάτους-ύψους(Κάτω & Δεξιά)");
        strcpy (intmenu[2] , "Χρώμα σημείου ως φόντο");
        strcpy (intmenu[3] , "Αντέγραψε χρώματα Στοιχείου");
        strcpy (intmenu[4] , "Οριζ.στοίχιση στο μέσον ΠΕΔΙΟΥ");
        strcpy (intmenu[5] , "Οριζ.στοίχιση στο μέσον ΟΝΟΜΑΤΟΣ πεδίου");
        strcpy (intmenu[6] , "Αντέγραψε χρώματα ετικέτας");
        strcpy (intmenu[7] , "Αντέγραψε διαστάσεις ετικέτας");
        strcpy (intmenu[8] , "Στοίχιση Οριζόντια με ετικέτα");
        strcpy (intmenu[9] , "Στοίχιση Κάθετα με ετικέτα");
        strcpy (intmenu[10] , "Στοίχιση Οριζ. στο μέσον της ετικέτας");
        strcpy (intmenu[11] , "Στοίχιση Κάθετα στο μέσον της ετικέτας");
        
        normtext_tomy("Κείμενο",keimeno);
        normtext_tomy("Εισαγωγή Κειμένου",eis_keim);
        normtext_tomy("Εικόνα",photo);
        normtext_tomy("Χρώμα Κειμένου",xrkeimfose);
        normtext_tomy("Σχήμα με γέμισμα",sximgem);
        normtext_tomy("Χρώμα Γεμίσματος Σχήματος και Χρώμα Κειμένου (κείμενο εντός σχήματος)",xrkeimgem);
        normtext_tomy("Χρώμα Περιγράμματος στο τρέχων Φόντο",xrperfose);
        normtext_tomy("Χρώμα Περιγράμματος σε άλλο Φόντο",xrperfo);
        normtext_tomy("Πάχος Γραμμής : 2",aplgr); normtext_tomy("Πάχος Γραμμής : 3",diplgr);
        normtext_tomy("Συντ. Χ : ",coor_t[0]); normtext_tomy("Συντ. Υ : ",coor_t[1]);
        normtext_tomy("Πλάτος : ",coor_t[2]); normtext_tomy("Ύψος : ",coor_t[3]);
        normtext_tomy("Στρώση Εμπρός",lay_t[0]); normtext_tomy("Στρώση Πίσω",lay_t[1]);
        normtext_tomy("Σελίδα : ",page_t); normtext_tomy("Σε όλες τις Σελίδες",pageoles);
        normtext_tomy("Σύρε & Απόθεσε αρχείο Εικόνας",dragphoto);
        normtext_tomy("Στο Κέντρο Οριζ." , kentrx_t);
        normtext_tomy("Στο Κέντρο Καθέτ." , kentry_t);
        normtext_tomy("Λήψη κανον. διαστάσεων εικόν." , nordim_t);
    }
    else {
        strcpy (intmenu[0] , "Get Coordinates (Up & Left)");
        strcpy (intmenu[1] , "Width & Height Calculation (Down & Right)");
        strcpy (intmenu[2] , "Get pixel color as background");
        strcpy (intmenu[3] , "Copy Element's Colors");
        strcpy (intmenu[4] , "Horiz. Alignm.-middle of FIELD");
        strcpy (intmenu[5] , "Horiz. Alignm.-middle of Field's NAME");
        strcpy (intmenu[6] , "Copy Label's Colors");
        strcpy (intmenu[7] , "Copy Label's Dimensions");
        strcpy (intmenu[8] , "Horiz. Alignment to Label");
        strcpy (intmenu[9] , "Vertical Alignment to Label");
        strcpy (intmenu[10] , "Horiz. Alignment to the middle of Label");
        strcpy (intmenu[11] , "Vertical Alignment to the middle of Label");
        
        normtext_tomy("Text",keimeno);
        normtext_tomy("Input text",eis_keim);
        normtext_tomy("Image",photo);
        normtext_tomy("Text Color",xrkeimfose);
        normtext_tomy("Shape Filled",sximgem);
        normtext_tomy("Text Color & Shape Fill Color (text inside shape)",xrkeimgem);
        normtext_tomy("Outline Color in default Background",xrperfose);
        normtext_tomy("Outline Color in specific Background",xrperfo);
        normtext_tomy("Line Τhick. : 2",aplgr); normtext_tomy("Line Thick. : 3",diplgr);
        normtext_tomy("Coor. X : ",coor_t[0]); normtext_tomy("Coor. Υ : ",coor_t[1]);
        normtext_tomy("Wide : ",coor_t[2]); normtext_tomy("Height : ",coor_t[3]);
        normtext_tomy("Layer Front",lay_t[0]); normtext_tomy("Layer Back",lay_t[1]);
        normtext_tomy("Page : ",page_t); normtext_tomy("All Pages",pageoles);
        normtext_tomy("Drag & Drop Image file",dragphoto);
        normtext_tomy("Centered Horiz." , kentrx_t);
        normtext_tomy("Centered Vert." , kentry_t);
        normtext_tomy("Get Pict. Normal Dimensions" , nordim_t);
    }
    
    wtype_xt=xt+30; wtype_xb=xb-29; 
    wtype_yt=yt+46 ; wtype_yb=wtype_yt+80;
    inptext_xt=xt+10; inptext_yt=wtype_yb+4; 
    inptext_xb=xb-10; inptext_yb=inptext_yt+32;
    font_xt = xrkeimfose_xt =  xrkeimgem_xt = xrperfose_xt = xrperfo_xt = aplgr_xt = xt+10 ;
    font_xb = xrkeimgem_xb = xrperfose_xb = xrperfo_xb = sximgem_xb = xb-10 ;
    font_yt = inptext_yb+1 ;  font_yb = font_yt + 30 ;
    xrkeimfose_yt = sximgem_yt = font_yb+1 ; xrkeimfose_yb = sximgem_yb= xrkeimfose_yt+25;
    xrkeimfose_xb=xrkeimfose_xt+435 ; sximgem_xt=xrkeimfose_xb+1; 
    xrkeimgem_yt = xrkeimfose_yb + 1 ; xrkeimgem_yb = xrkeimgem_yt+25 ;
    xrperfose_yt = xrkeimgem_yb + 1 ; xrperfose_yb = xrperfose_yt+25 ;
    xrperfo_yt = xrperfose_yb + 1 ; xrperfo_yb = xrperfo_yt + 25 ;
    aplgr_yt = diplgr_yt = xrperfo_yb + 1; aplgr_xb = aplgr_xt + 200; aplgr_yb = aplgr_yt + 25 ;
    diplgr_xt = xb-210;   diplgr_xb = diplgr_xt + 200; diplgr_yb = diplgr_yt + 25 ;
    lay_xt[0] = xt+10; lay_yt[0] = diplgr_yb+1 ; lay_xb[0] = lay_xt[0]+200; lay_yb[0] = lay_yt[0] + 25; 
    lay_xt[1] = xb-210; lay_yt[1] = lay_yt[0] ; lay_xb[1] = lay_xt[1]+200; lay_yb[1] = lay_yt[1] + 25;
    coor_xt[0] =  coor_xt[2] = xt+10 ;  
    coor_xb[0] = coor_xb[2] = coor_xt[0]+200;
    coor_yt[0] = coor_yt[1] = lay_yb[1] + 1 ;
    coor_yb[0] = coor_yb[1] = coor_yt[0]+25;
    coor_xt[1] = coor_xt[3] = xb-210 ;
    coor_xb[1] = coor_xb[3] = coor_xt[1]+200;
    coor_yt[2] = coor_yt[3] = coor_yb[0] + 1;
    coor_yb[2] = coor_yb[3] = coor_yt[2] + 25 ;
    
    for (f=0 ; f<4 ; f++) {
        icoor_xt[f] = coor_xb[f]-70 ;
    }
    
    for (f=0 ; f<3 ; f++) {
        strcpy (secmenu[f] , intmenu[f]) ;
    }
    
    page_xt[0] = xt+10 ; page_xt[1] = xb-210 ;
    page_yt[0] = page_yt[1] = coor_yb[2] + 1 ;
    page_xb[0] = page_xt[0]+200 ; page_xb[1] = page_xt[1]+200;
    page_yb[0] = page_yb[1] = page_yt[0] + 25 ;   

    ipage_xt = page_xb[0]-70;
    
    aa_xt=xt+532; aa_yt=yt+14 ; aa_xb = aa_xt+42 ; aa_yb = aa_yt+22 ;
    keaaxt = aa_xt+17; keaayt=aa_yt+10;
    
    arrxt=xt+10 ; arryt=riyt=leyt=delyt=yt+10;
    rixt=xb-200 ; lext=xt+200; delxt=xb-40;
    xok=xb-60; ygo=yb-45; xgo=xt+15; yok=yb-45 ;
        
    g_xt=aplgr_xb + 2 ; g_yt = xrperfo_yb+2 ;
    g_xb = diplgr_xt-2 ; g_yb = yb-50;
    
    ph_xt=g_xt+120; ph_yt=g_yt+2;
    ph_xb=g_xb-120; ph_yb=yb-70;
    
    tet_xt = g_xt+170; tet_yt=g_yt+2;
    tet_xb = tet_xt+140; tet_yb=tet_yt+140;
    
    par_xt = g_xt + 20 ; par_yt = g_yt+2 ;
    par_xb = g_xb-20 ; par_yb = par_yt+140 ;
    
    kyk_xt=tet_xt+70; kyk_yt=tet_yt+70 ; kyk_r=69 ;
    
    ell_xt=kyk_xt; ell_yt=kyk_yt;
    ell_r1=180 ; ell_r2=69;
    
    kentrx_xt = xt+70 ;  kentrx_xb = kentrx_xt+200; 
    kentrx_yt = kentry_yt = nordim_yt = yb-40 ; kentrx_yb = kentry_yb = nordim_yb = kentrx_yt+29;
    kentry_xb = xb-70;
    kentry_xt = kentry_xb-200 ;
    
    nordim_xt = kentrx_xb+5;
    nordim_xb = nordim_xt+350;
    
    
    _bareacls(xt,yt,xb,yb,dbbkxr);
    setrgbcolor (dbred) ;
    rectangle (xt,yt,xb,yb);
    rectangle (xt+1,yt+1,xb-1,yb-1);
    setrgbcolor (dbaspro) ;
    rectangle (xt+2,yt+2,xb-2,yb-2);
    rectangle (xt+3,yt+3,xb-3,yb-3);
    setrgbcolor (dbblack) ;
    rectangle (xt+4,yt+4,xb-4,yb-4);
    rectangle (xt+5,yt+5,xb-5,yb-5);
    setrgbcolor (dbyel) ;
    rectangle (xt+6,yt+6,xb-6,yb-6);
    
    
        //EPIKEFALIDA
    
    if (keyb_gr) strcpy (str1024," Ετικέτα Νο : ");
    else strcpy (str1024," Label No : ");
    normtext_tomy (str1024,0);
    _outmystr_centund_col(1, str1024 , xt+30, yt+11, xb-30, yt+38, dbchxr , dbbkxr);
    refresh();
    
    // Σχεδίαση των τύπων ετικετών
    
    setcolor (3);
    rectangle (wtype_xt , wtype_yt , wtype_xb, wtype_yb);
    x1=wtype_xt; y1=wtype_yt;
    a=120; b=50; c=35 ;
    
    //text
    _outmystr_center_col(4, keimeno , x1 , y1 , x1+a-1, wtype_yb , dbchxr , dbbkxr);
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // text με υπογράμμιση
    _outmystr_centund_col(4, keimeno , x1 , y1 , x1+a-1, wtype_yb , dbchxr , dbbkxr);
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // Τετράγωνο
    setcolor (COLOR (dbchxr[0] , dbchxr[1], dbchxr[2]) );
    rectangle (x1+34,y1+14,x1+34+b,y1+14+b) ;
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // Παρμο
    setcolor (COLOR (dbchxr[0] , dbchxr[1], dbchxr[2]) );
    rectangle (x1+34,y1+24,x1+34+b,y1+24+c) ;
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // Κύκλος
    setcolor (COLOR (dbchxr[0] , dbchxr[1], dbchxr[2]) );
    circle (x1+59,y1+40,30);
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // Έλλειψη
    setcolor (COLOR (dbchxr[0] , dbchxr[1], dbchxr[2]) );
    ellipse (x1+59,y1+40,0,360,35,20);
    x1+=a;
    setcolor (3);
    line (x1,y1,x1,wtype_yb);
    
    // Photo
    
    _outmystr_center_col(4, photo , x1 , y1 , x1+a-1, wtype_yb , dbchxr , dbbkxr);
    
    setcolor (1);
    rectangle (inptext_xt , inptext_yt , inptext_xb , inptext_yb) ;
    rectangle (font_xt , font_yt, font_xb, font_yb);
    rectangle (xrkeimfose_xt, xrkeimfose_yt, xrkeimfose_xb, xrkeimfose_yb);
    rectangle (sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb) ;
    rectangle (xrkeimgem_xt, xrkeimgem_yt, xrkeimgem_xb, xrkeimgem_yb);
    rectangle (xrperfose_xt, xrperfose_yt, xrperfose_xb, xrperfose_yb);
    rectangle (xrperfo_xt, xrperfo_yt, xrperfo_xb, xrperfo_yb);
    rectangle (aplgr_xt, aplgr_yt, aplgr_xb, aplgr_yb);
    rectangle (diplgr_xt ,diplgr_yt ,diplgr_xb ,diplgr_yb );
    rectangle (lay_xt[0] , lay_yt[0] ,lay_xb[0] ,lay_yb[0]);
    rectangle (lay_xt[1] , lay_yt[1] ,lay_xb[1] ,lay_yb[1]);
    for (f=0; f<4 ; f++) {rectangle (coor_xt[f] , coor_yt[f] , coor_xb[f] , coor_yb[f]) ;}
    rectangle (page_xt[0] , page_yt[0] ,page_xb[0] ,page_yb[0] );
    rectangle (page_xt[1] , page_yt[1] ,page_xb[1] ,page_yb[1] );
    //setfillstyle(1,COLOR(kit[0], kit[1], kit[2]));
    _bareacls(aa_xt,aa_yt,aa_xb,aa_yb,dbbkxr);
    setcolor(2);
    ellipse (keaaxt,keaayt,0,360,26,16);
    _myfill_ellips(keaaxt,keaayt,kit);
    refresh();
    setcolor(4);
    rectangle ( kentrx_xt , kentrx_yt , kentrx_xb , kentrx_yb );
    rectangle ( kentrx_xt+1 , kentrx_yt+1 , kentrx_xb-1 , kentrx_yb-1 );
    rectangle ( kentry_xt , kentry_yt , kentry_xb , kentry_yb );
    rectangle ( kentry_xt+1 , kentry_yt+1 , kentry_xb-1 , kentry_yb-1 );
    rectangle ( nordim_xt , nordim_yt , nordim_xb , nordim_yb );
    rectangle ( nordim_xt+1 , nordim_yt+1 , nordim_xb-1 , nordim_yb-1 );
    _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
    _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,dbchxr , dbbkxr);
    _outmystr_center_col (4,nordim_t, nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2,dbchxr , dbbkxr);
    refresh() ;
    
    strcpy(file_1,path_name);
    strcat(file_1,"ICD/arrows_18.ico");
    mem_arrs=icontomem(file_1,255);
    if (mem_arrs==NULL) {information(2-keyb_gr,file_1,NULL);goto FYGE; } 
    
    strcpy (file_1,path_name);
    strcat (file_1,"ICD/Yel_ok_39.ico");
    mem_ok= icontomem (file_1,255);
    if (!mem_ok) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_right.ico");
    mem_ri = icontomem (file_1,255);
    if (!mem_ri) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_left.ico");
    mem_le = icontomem (file_1,255);
    if (!mem_le) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/go_36.ico");
    mem_go = icontomem (file_1,255);
    if (!mem_go) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }

    strcpy (file_1,path_name);
    strcat (file_1,"ICD/field_del.ico");
    mem_del = icontomem (file_1,255);
    if (!mem_del) {information(2-keyb_gr,file_1,NULL);goto FYGE ; }


_puticon(arrxt,arryt,mem_arrs,255);
_puticon(lext,leyt,mem_le,255);
_puticon(rixt,riyt,mem_ri,255);
_puticon(xok,yok,mem_ok,255);
_puticon(xgo,ygo,mem_go,255);
_puticon(delxt,delyt,mem_del,255);

refresh ();
// Προετοιμασία σε κάθε περίπτωση της επόμενης ετικέτας !
if (decor<149 && prin_dec!=decor) {
    
    f=decor;
    
    for (i=0 ; i<7 ; i++) ptr_dec[f].detype[i]=0 ;
    ptr_dec[f].dephoto[0]='\0';
    ptr_dec[f].detext[0]=255;    
    ptr_dec[f].dext=0;  
    ptr_dec[f].deyt=0;
    ptr_dec[f].dewid=0;
    ptr_dec[f].dehei=0; 
    ptr_dec[f].depg = dbcurpage; // Σελίδα στην οποία εμφανίζεται !
    ptr_dec[f].delayer=1;
    ptr_dec[f].defill=0;
    for (i=0 ; i<3 ; i++) {
        ptr_dec[f].delinexr[i]=dbchxr[i];
        ptr_dec[f].debkxr[i]=dbbkxr[i];
        ptr_dec[f].dechxr[i]=dbchxr[i];
    }

    ptr_dec[f].delinefat=1 ;
    ptr_dec[f].defont=4;
    ptr_dec[f].defohei = myfont_hei[4];
    ptr_dec[f].defowid = myfont_wid[4];
}

// Αντιγραφή νέας ή παλαιάς ετικέτας στη δομή cpy

    mem2 = (char *) &ptr_dec[new];
    mem3 = (char *) &cpy;
    for (f=0 ; f<decorsize; f++) {
        *mem3++ = *mem2++ ;
    }

    // Αυτά γράφονται μια για πάντα !!
    
        _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1, xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr , dbbkxr);
        
        _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1, xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr , dbbkxr);
        _outmystr_center_col (4,xrperfose,xrperfose_xt+1, xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr , dbbkxr);
        _outmystr_center_col (4,xrperfo,xrperfo_xt+1, xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr , dbbkxr);
        
        for (f=0; f<4 ; f++) {
            _outmystr_col (4, coor_t[f], coor_xt[f]+1 , coor_yt[f]+1 , coor_xb[f]-1 , dbchxr , dbbkxr) ;
        }
        
    // Όταν έρχεται υπάρχουσα (παλιά) ετικέτα (χρήσιμο για αριστερά - δεξιά) 
    
    if (new<decor || prin_dec==decor) { 
        
        for (f=0 ; f<7 ; f++) {
                x1= f*120+wtype_xt ;
                setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
            if (cpy.detype[f]) {
                setcolor (4);
                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
            }
        }
    
        sprintf (str1024 , "%03d", new+1);
        normtext_tomy(str1024,0);
        //setfillstyle(1,COLOR(kit[0], kit[1], kit[2]));
        //ellipse (keaaxt,keaayt,0,360,26,15);
        //floodfill(keaaxt,keaayt,1);
        _outmystr_col (4,str1024,aa_xt, aa_yt, aa_xb, bla , kit);
        normtext_tomy(myfont_name[cpy.defont],fonter);
        _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr , dbbkxr);
        
        if (cpy.detext[0]==255) {
        _outmystr_center_col (4,eis_keim,inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbchxr , dbbkxr ) ;
        }
        else  _outmystr_center_col (4,cpy.detext,inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbchxr , dbbkxr ) ;
        
        if (!cpy.defill) {
            // _barea...
            _outmystr_center_col (4,sximgem,sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,dbchxr , dbbkxr);}
        else {
            _bareacls (sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,energ);
            _outmystr_center_col (4,sximgem,sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,kok,energ);}
        
        if (cpy.delinefat==2) {
            _bareacls (aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,energ);
            _outmystr_center_col (4,aplgr,aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,kok , energ);}
        else {
            //_bareacls (
            _outmystr_center_col (4,aplgr,aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbchxr , dbbkxr);}
        
        if (cpy.delinefat==3) {
            _bareacls (diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,energ );
            _outmystr_center_col (4,diplgr,diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,kok, energ );}
        else {
            //barea..
            _outmystr_center_col (4,diplgr,diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,dbchxr , dbbkxr );}
        
        if (cpy.delayer==1) {
            _bareacls (lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,energ);
            _outmystr_center_col (4, lay_t[0], lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,kok , energ);}
        else {
            //bar..
            _outmystr_center_col (4, lay_t[0], lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,dbchxr , dbbkxr);}
        
        if (cpy.delayer==2) {
            _bareacls (lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,energ);
            _outmystr_center_col (4, lay_t[1], lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,kok , energ);}
        else {
            //bar..
            _outmystr_center_col (4, lay_t[1], lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,dbchxr , dbbkxr);}
        
        if (cpy.depg!=100) {
        _bareacls (page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 , page_yb[0]-1, energ);
        _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
        sprintf(str1024,"%03d" , cpy.depg);
        normtext_tomy (str1024,ipage);
        _outmystr_rcol (4,ipage,ipage_xt, page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
        _bareacls (page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,dbbkxr );
        _outmystr_center_col (4,pageoles, page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,dbchxr , dbbkxr );
        }
        else {
            ipage[0]=255;
            _bareacls (page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 , page_yb[0]-1, dbbkxr);
            _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 ,dbchxr , dbbkxr);
            _bareacls (page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,energ );
            _outmystr_center_col (4,pageoles, page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,kok , energ );
        }
        
        /*
        _bareacls (icoor_x , coor_yt[0]+1, coor_xb[0]-1 , coor_yb[0]-1, dbbkxr);
        _bareacls (icoor_y , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
        _bareacls (iwid , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
        _bareacls (ihei , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
        */
        
        if (cpy.dext) {sprintf(str1024,"%4d",cpy.dext); normtext_tomy(str1024,icoorx);
            _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
        else icoorx[0]=255;
            
        if (cpy.deyt) {sprintf(str1024,"%4d",cpy.deyt); normtext_tomy(str1024,icoory);
            _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
        else icoory[0]=255;
        
        if (cpy.dewid) {sprintf(str1024,"%4d",cpy.dewid); normtext_tomy(str1024,iwid);
            _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
        else iwid[0]=255;
        
        if (cpy.dehei) {sprintf(str1024,"%4d",cpy.dehei); normtext_tomy(str1024,ihei);
            _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
        else ihei[0]=255;
        
        refresh();
        
        anan=1; 
    } 
    else { // Νέα Ετικέτα (εντελώς)!!
        sprintf (str1024 , "%03d", new+1);
        normtext_tomy(str1024,0);
        _outmystr_col (4,str1024,aa_xt, aa_yt, aa_xb, bla , kit);
        
        normtext_tomy(myfont_name[4],fonter);
        cpy.detext[0]=255 ;
        _outmystr_center_col (4,eis_keim,inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbchxr , dbbkxr ) ;

        _outmystr_center_col (4,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr , dbbkxr);
        _outmystr_center_col (4,sximgem,sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,dbchxr , dbbkxr);
        
        _outmystr_center_col (4,aplgr,aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbchxr , dbbkxr);
        _outmystr_center_col (4,diplgr,diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,dbchxr , dbbkxr );
        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,energ);
        _outmystr_center_col (4, lay_t[0], lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,kok , energ);
        _outmystr_center_col (4, lay_t[1],lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,dbchxr , dbbkxr);
        
        _bareacls (page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 , page_yb[0]-1, energ);
        _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
        sprintf(str1024,"%03d" , cpy.depg);
        normtext_tomy (str1024,ipage);
         _outmystr_rcol (4,ipage,ipage_xt, page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
        _outmystr_center_col (4,pageoles, page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,dbchxr , dbbkxr );
        icoorx[0]=icoory[0]=iwid[0]=ihei[0] = 255;
        refresh();
    }

    SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
    

ektos=1; fyge=0 ;
go_ri = go_le = proenter = marrs= 0;
deldec = akyro =0 ; type=-1;

    do {
        if (!SDL_PollEvent(&sdlev)) continue;
        
        if (anan) {
            anan=0;
            _bareacls (g_xt,g_yt,g_xb,g_yb,dbbkxr);
            refresh();
                if (cpy.detype[6]) { 
                    if (cpy.dephoto[0]=='\0') {
                _outmystr_center_col (4,dragphoto,g_xt,g_yt,g_xb,g_yb,dbchxr, dbbkxr);
                refresh();
                goto OUTANAN;
                }
                fp_photo = fopen (cpy.dephoto , "rb");
                if (fp_photo==NULL) {
                _outmystr_center_col (4,dragphoto,g_xt,g_yt,g_xb,g_yb,dbchxr, dbbkxr);
                refresh();
                goto OUTANAN;
                }
                else {
                    fclose (fp_photo);
                    readimagefile (cpy.dephoto,ph_xt,ph_yt,ph_xb,ph_yb);
                    goto OUTANAN;
                }
            }
            
            if (cpy.detype[2]) {
                a=0;
                setcolor (COLOR(cpy.delinexr[0] ,cpy.delinexr[1] , cpy.delinexr[2] ));
                rectangle (tet_xt , tet_yt , tet_xb, tet_yb);
                if (cpy.delinefat>1) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
                if (cpy.delinefat>2) { a++; rectangle (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a); }
                a++;
                if (cpy.defill) _bareacls (tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a , cpy.debkxr);
                if (cpy.detext[0]!=255) {
                if (cpy.detype[0]) {_outmystr_center_col (cpy.defont,cpy.detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,cpy.dechxr, cpy.debkxr);}
                else if (cpy.detype[1]) {_outmystr_centund_col (cpy.defont,cpy.detext,tet_xt+a , tet_yt+a , tet_xb-a, tet_yb-a,cpy.dechxr, cpy.debkxr);}
                }
                refresh();
                goto OUTANAN;
            }
            
            
            if (cpy.detype[3]) {
                a=0;
                setcolor (COLOR(cpy.delinexr[0] ,cpy.delinexr[1] , cpy.delinexr[2] ));
                rectangle (par_xt , par_yt , par_xb, par_yb);
                if (cpy.delinefat>1) { a++; rectangle (par_xt+a , par_yt+a , par_xb-a, par_yb-a); }
                if (cpy.delinefat>2) { a++; rectangle (par_xt+a , par_yt+a , par_xb-a, par_yb-a); }
                a++;
                if (cpy.defill) _bareacls (par_xt+a , par_yt+a , par_xb-a, par_yb-a , cpy.debkxr);
                if (cpy.detext[0]!=255) {
                if (cpy.detype[0]) {_outmystr_center_col (cpy.defont,cpy.detext,par_xt+a , par_yt+a , par_xb-a, par_yb-a,cpy.dechxr, cpy.debkxr);}
                else if (cpy.detype[1]) {_outmystr_centund_col (cpy.defont,cpy.detext,par_xt+a , par_yt+a , par_xb-a, par_yb-a,cpy.dechxr, cpy.debkxr);}
                }
                refresh();
                goto OUTANAN;
            }
            
            if (cpy.detype[4]) {
                a=0;
                setcolor (COLOR(cpy.delinexr[0] ,cpy.delinexr[1] , cpy.delinexr[2] ));
                circle (kyk_xt , kyk_yt , kyk_r);
                if (cpy.delinefat>1) { a++; circle (kyk_xt , kyk_yt , kyk_r-a); }
                if (cpy.delinefat>2) { a++; circle (kyk_xt , kyk_yt , kyk_r-a); }
                a++;
                refresh();
                if (cpy.defill) {
                   _myfill_ellips (kyk_xt,kyk_yt,cpy.debkxr);
                }
                if (cpy.detext[0]!=255) {
                if (cpy.detype[0]) {_outmystr_center_col (cpy.defont,cpy.detext,kyk_xt-kyk_r+a , kyk_yt-cpy.defohei/2 , kyk_xt+kyk_r-a, kyk_yt+cpy.defohei/2,cpy.dechxr, cpy.debkxr);}
                else if (cpy.detype[1]) {_outmystr_centund_col (cpy.defont,cpy.detext,kyk_xt-kyk_r+a , kyk_yt-cpy.defohei/2 , kyk_xt+kyk_r-a, kyk_yt+cpy.defohei/2,cpy.dechxr, cpy.debkxr);}
                }
                refresh();
                goto OUTANAN;
            }
            
            
            if (cpy.detype[5]) {
                a=0;
                setcolor (COLOR(cpy.delinexr[0] ,cpy.delinexr[1] , cpy.delinexr[2] ));
                ellipse (ell_xt , ell_yt , 0, 360, ell_r1 , ell_r2);
                if (cpy.delinefat>1) { a++; ellipse (ell_xt , ell_yt , 0, 360, ell_r1-a , ell_r2-a); }
                if (cpy.delinefat>2) { a++;  ellipse (ell_xt , ell_yt , 0, 360, ell_r1-a , ell_r2-a); }
                a++;
                refresh();
                if (cpy.defill) {
                   _myfill_ellips (ell_xt,ell_yt,cpy.debkxr);
                }
                if (cpy.detext[0]!=255) {
                if (cpy.detype[0]) {_outmystr_center_col (cpy.defont,cpy.detext,ell_xt-ell_r1+a , ell_yt-cpy.defohei/2 , ell_xt+ell_r1-a, ell_yt+cpy.defohei/2,cpy.dechxr, cpy.debkxr);}
                else if (cpy.detype[1]) {_outmystr_centund_col (cpy.defont,cpy.detext,ell_xt-ell_r1+a , ell_yt-cpy.defohei/2 , ell_xt+ell_r1-a, ell_yt+cpy.defohei/2,cpy.dechxr, cpy.debkxr);}
                }
                refresh();
                goto OUTANAN;
            }
            
            if (cpy.detype[0]) {
                if (cpy.detext[0]!=255) {
                    _outmystr_center_col (cpy.defont,cpy.detext,g_xt,g_yt,g_xb,g_yb,cpy.dechxr, cpy.debkxr);
                    refresh();
                }
                goto OUTANAN;
            }
            
            if (cpy.detext[0]!=255) {
                _outmystr_centund_col (cpy.defont,cpy.detext,g_xt,g_yt,g_xb,g_yb,cpy.dechxr, cpy.debkxr);
                refresh();
                }
        }

OUTANAN:

            cross=0;

        switch (sdlev.type) {
    
            case SDL_MOUSEMOTION:
            while (SDL_PollEvent(&sdlev) && sdlev.type ==SDL_MOUSEMOTION) continue;
            mx=sdlev.motion.x ; my=sdlev.motion.y;
            if (mx<info.left || my<info.top || mx>info.right || my>info.bottom) continue ;
            setrgbcolor(dbtop); 
            for (i=0;i<40;i++) {for (f=1 ; f<19; f++) {_putpixel (Xt+i,f); _putpixel (Yt+i,f); _putpixel (Wt+i,f); _putpixel (Ht+i,f);}}
            sprintf(top_str,"%04d",mx); _outsouv_col(Xt,1,top_str,0,topchxr,topbkxr);
            sprintf (top_str,"%04d",my); _outsouv_col(Yt,1,top_str,0,topchxr,topbkxr);
            refresh();
            
            if (mx>=wtype_xt && mx<=wtype_xb && my>wtype_yt && my<wtype_yb) { // EPILOGH TYPOY
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }
                
                ektos=0;
                
                if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
                else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                else if (font_but) {
                    font_but=0; 
                    _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrkeimfose_but) {
                    xrkeimfose_but=0; 
                _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (xrkeimgem_but) {
                    xrkeimgem_but=0; 
                    _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrperfose_but) {
                    xrperfose_but=0; 
                _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                refresh();
                }
                else if (xrperfo_but) {
                    xrperfo_but=0; 
                _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                refresh();
                }
                else if (inptext_but) {
                    inptext_but=0;
                    _bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1 , dbbkxr);
                    if (cpy.detext[0]!=255) {
                    _outmystr_center_col (4,cpy.detext,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ;
                    }
                    else {
                    _outmystr_center_col (4,eis_keim,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ; 
                    }
                    refresh();
                }
                else if (aplgr_but) {
                    aplgr_but=0; 
                    if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (diplgr_but) {
                    diplgr_but=0; 
                    if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (lay1_but) {
                    lay1_but=0; 
                    if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (lay2_but) {
                    lay2_but=0; 
                    if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                    refresh();
                }
                else if (coorx_but) {
                    coorx_but=0; 
                    _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                    if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (coory_but) {
                    coory_but=0; 
                    _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                    if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (sximgem_but) {
                    sximgem_but=0; 
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (wid_but) {
                    wid_but=0; 
                    _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                    if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                    refresh();
                } 
                else if (hei_but) {
                    hei_but=0; 
                    _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                    if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (pgcur_but) {
                    pgcur_but=0; 
                    if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                    _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                    if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                    refresh();
                } 
                else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
                } 
                else if (kentrx_but) {
                    kentrx_but=0;
                    _bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , dbbkxr);
                    _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
                    refresh();
                }
                else if (kentry_but) {
                    kentry_but=0;
                    _bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , dbbkxr);
                    _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,dbchxr , dbbkxr);
                    refresh();
                }
                else if (nordim_but) {
                    nordim_but=0;
                    _bareacls (nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2 , dbbkxr);
                    _outmystr_center_col (4,nordim_t, nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2,dbchxr , dbbkxr);
                    refresh();
                }
                    
                
                // First Check
                dx=mx-wtype_xt;
                dx = dx/120;
                if (dx<0) dx=0;
                else if (dx>6) dx=6;
                
                if (dx==type) continue ;
                
                if (type==-1) {
                    type = dx;
                    x1= (dx*120) + wtype_xt ;
                    if (cpy.detype[type]) {
                        //setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                        setcolor(1);
                        rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                        rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                        rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                        rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                    else
                    {
                      setcolor (4);
                      rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                      rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2); 
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                }
                else {
                    x1= (type*120) + wtype_xt ;
                    if (cpy.detype[type]) {
                        setcolor (4);
                        rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                        rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                    else
                    {
                      setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                      rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                      rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);  
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                    
                    x1= (dx*120) + wtype_xt ;
                    type = dx;
                    if (cpy.detype[type]) {
                        //setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                        setcolor(1);
                        rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                        rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                    else
                    {
                      setcolor (4);
                      rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                      rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2); 
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                    }
                    
                }
                refresh();
                continue ;
            }
            
            if (type!=-1) {
                x1= (type*120) + wtype_xt ;
                if (cpy.detype[type]) {
                    setcolor (4);
                    rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                    rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                }
                else
                {
                    setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                    rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                    rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);  
                      rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                      rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                }
                refresh();
                type=-1;
                
            }
            
            
            if (cpy.detype[6] && cpy.dephoto[0]!=255) {
                if (mx>nordim_xt && mx<nordim_xb && my>nordim_yt && my<nordim_yb) { // Normal Dimensions for Images
                    
                    
                    if (ektos) {
                        cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }
                    
                    ektos=0;
                    
                    if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
                    else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                    else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                    else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                    else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                    else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                    else if (font_but) {
                        font_but=0; 
                        _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                        _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                        refresh();
                    }
                    else if (xrkeimfose_but) {
                        xrkeimfose_but=0; 
                    _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                    refresh();
                    } 
                    else if (xrkeimgem_but) {
                        xrkeimgem_but=0; 
                        _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                        _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                        refresh();
                    }
                    else if (xrperfose_but) {
                        xrperfose_but=0; 
                    _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                    refresh();
                    }
                    else if (xrperfo_but) {
                        xrperfo_but=0; 
                    _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                    refresh();
                    } 
                    else if (aplgr_but) {
                        aplgr_but=0; 
                        if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                        _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                        _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                        refresh();
                    }
                    else if (diplgr_but) {
                        diplgr_but=0; 
                        if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                        _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                        _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                        refresh();
                    }
                    else if (lay1_but) {
                        lay1_but=0; 
                        if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                        _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                        refresh();
                    } 
                    else if (lay2_but) {
                        lay2_but=0; 
                        if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                        _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                        refresh();
                    }
                    else if (coorx_but) {
                        coorx_but=0; 
                        _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                        if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                        refresh();
                    }
                    else if (coory_but) {
                        coory_but=0; 
                        _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                        if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                        refresh();
                    }
                    else if (sximgem_but) {
                        sximgem_but=0; 
                        if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                        _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                        _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                        refresh();
                    } 
                    else if (wid_but) {
                        wid_but=0; 
                        _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                        if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                        refresh();
                    } 
                    else if (hei_but) {
                        hei_but=0; 
                        _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                        if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                        refresh();
                    }
                    else if (pgcur_but) {
                        pgcur_but=0; 
                        if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                        _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                        _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                        if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                        refresh();
                    } 
                    else if (pgall_but) {
                    pgall_but=0; 
                    if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                    _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                    _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                    refresh();
                    } 
                    else if (kentrx_but) {
                        kentrx_but=0;
                        _bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , dbbkxr);
                        _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
                        refresh();
                    }
                    else if (kentry_but) {
                        kentry_but=0;
                        _bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , dbbkxr);
                        _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,dbchxr , dbbkxr);
                        refresh();
                    }
                
                    
                    if (nordim_but) continue ;
                    
                    nordim_but=1;
                    
                    _bareacls (nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2 , kit);
                    _outmystr_center_col (4,nordim_t, nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2,kok , kit);
                    refresh();
                    continue ;
                    
                } 
                
                if (nordim_but) {
                    nordim_but=0;
                    _bareacls (nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2 , dbbkxr);
                    _outmystr_center_col (4,nordim_t, nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2,dbchxr , dbbkxr);
                    refresh();
                }
            }
            
            
            if (mx>kentry_xt && mx<kentry_xb && my>kentry_yt && my<kentry_yb) { // Κεντράρισμα στον Y
                
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }
                
                ektos=0;
                
                if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
                else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                else if (font_but) {
                    font_but=0; 
                    _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrkeimfose_but) {
                    xrkeimfose_but=0; 
                _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (xrkeimgem_but) {
                    xrkeimgem_but=0; 
                    _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrperfose_but) {
                    xrperfose_but=0; 
                _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                refresh();
                }
                else if (xrperfo_but) {
                    xrperfo_but=0; 
                _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (aplgr_but) {
                    aplgr_but=0; 
                    if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (diplgr_but) {
                    diplgr_but=0; 
                    if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (lay1_but) {
                    lay1_but=0; 
                    if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (lay2_but) {
                    lay2_but=0; 
                    if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                    refresh();
                }
                else if (coorx_but) {
                    coorx_but=0; 
                    _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                    if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (coory_but) {
                    coory_but=0; 
                    _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                    if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (sximgem_but) {
                    sximgem_but=0; 
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (wid_but) {
                    wid_but=0; 
                    _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                    if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                    refresh();
                } 
                else if (hei_but) {
                    hei_but=0; 
                    _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                    if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (pgcur_but) {
                    pgcur_but=0; 
                    if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                    _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                    if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                    refresh();
                } 
                else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            else if (kentrx_but) {
                kentrx_but=0;
                _bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , dbbkxr);
                _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
                refresh();
            }
            
                
                if (kentry_but) continue ;
                
                kentry_but=1;
                
                _bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , kit);
                _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,kok , kit);
                refresh();
                continue ;
                
            } 
            
            if (kentry_but) {
                kentry_but=0;
                _bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , dbbkxr);
                _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,dbchxr , dbbkxr);
                refresh();
            }
            
            
            
            if (mx>kentrx_xt && mx<kentrx_xb && my>kentrx_yt && my<kentrx_yb) { // Κεντράρισμα στον Χ
                
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }
                
                ektos=0;
                
                if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
                else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                else if (font_but) {
                    font_but=0; 
                    _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrkeimfose_but) {
                    xrkeimfose_but=0; 
                _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (xrkeimgem_but) {
                    xrkeimgem_but=0; 
                    _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrperfose_but) {
                    xrperfose_but=0; 
                _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                refresh();
                }
                else if (xrperfo_but) {
                    xrperfo_but=0; 
                _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (aplgr_but) {
                    aplgr_but=0; 
                    if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (diplgr_but) {
                    diplgr_but=0; 
                    if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (lay1_but) {
                    lay1_but=0; 
                    if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (lay2_but) {
                    lay2_but=0; 
                    if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                    refresh();
                }
                else if (coorx_but) {
                    coorx_but=0; 
                    _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                    if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (coory_but) {
                    coory_but=0; 
                    _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                    if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (sximgem_but) {
                    sximgem_but=0; 
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (wid_but) {
                    wid_but=0; 
                    _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                    if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                    refresh();
                } 
                else if (hei_but) {
                    hei_but=0; 
                    _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                    if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (pgcur_but) {
                    pgcur_but=0; 
                    if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                    _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                    if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                    refresh();
                } 
                else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
                if (kentrx_but) continue ;
                
                kentrx_but=1;
                
                _bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , kit);
                _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,kok , kit);
                refresh();
                continue ;
                
            } 
            
            if (kentrx_but) {
                kentrx_but=0;
                _bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , dbbkxr);
                _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
                refresh();
            }
            
            if (mx>inptext_xt && mx<inptext_xb && my>inptext_yt && my<inptext_yb) { // Input Text
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
                }
                
                ektos=0;
                
                if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
                else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                else if (font_but) {
                    font_but=0; 
                    _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrkeimfose_but) {
                    xrkeimfose_but=0; 
                _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (xrkeimgem_but) {
                    xrkeimgem_but=0; 
                    _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                    refresh();
                }
                else if (xrperfose_but) {
                    xrperfose_but=0; 
                _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                refresh();
                }
                else if (xrperfo_but) {
                    xrperfo_but=0; 
                _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                refresh();
                } 
                else if (aplgr_but) {
                    aplgr_but=0; 
                    if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (diplgr_but) {
                    diplgr_but=0; 
                    if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                    refresh();
                }
                else if (lay1_but) {
                    lay1_but=0; 
                    if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (lay2_but) {
                    lay2_but=0; 
                    if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                    _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                    refresh();
                }
                else if (coorx_but) {
                    coorx_but=0; 
                    _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                    if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (coory_but) {
                    coory_but=0; 
                    _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                    if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (sximgem_but) {
                    sximgem_but=0; 
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                } 
                else if (wid_but) {
                    wid_but=0; 
                    _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                    if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                    refresh();
                } 
                else if (hei_but) {
                    hei_but=0; 
                    _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                    _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                    if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                    refresh();
                }
                else if (pgcur_but) {
                    pgcur_but=0; 
                    if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                    _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                    if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                    refresh();
                } 
                else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
                if (inptext_but) continue ;
                inptext_but=1;
                _bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1 , kit);
                if (cpy.detext[0]!=255) {
                    
                   _outmystr_center_col (4,cpy.detext,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,bla,kit ) ;

                }
                else {
                   _outmystr_center_col (4,eis_keim,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,bla,kit ) ; 
                }
                refresh();
                continue ;
            }
                        
            
            if (inptext_but) {
                inptext_but=0;
                _bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1 , dbbkxr);
                if (cpy.detext[0]!=255) {
                   _outmystr_center_col (4,cpy.detext,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ;
                }
                else {
                   _outmystr_center_col (4,eis_keim,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ; 
                }
                refresh();
            }
            
            
            if (mx>font_xt && mx<font_xb && my>font_yt && my<font_yb) {  //Font.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);} 
            else if (xrkeimfose_but) {
                xrkeimfose_but=0; 
            _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            else if (xrkeimgem_but) {
                xrkeimgem_but=0; 
            _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            else if (xrperfose_but) {
                xrperfose_but=0; 
            _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            else if (xrperfo_but) {
                xrperfo_but=0; 
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            else if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 ,dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (font_but) continue;
            font_but=1;
            _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , kit);
            _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,bla,kit);
            refresh ();
            continue;        
            }
            
            if (font_but) {
                font_but=0; 
                _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                refresh();
            }
            
            
            if (mx>xrkeimfose_xt && mx<xrkeimfose_xb && my>xrkeimfose_yt && my<xrkeimfose_yb) {  //xrkeimfose.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);} 
            else if (xrkeimgem_but) {
                xrkeimgem_but=0; 
            _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            else if (xrperfose_but) {
                xrperfose_but=0; 
            _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            else if (xrperfo_but) {
                xrperfo_but=0; 
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            else if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (xrkeimfose_but) continue;
            xrkeimfose_but=1;
            _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , kit);
            _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,bla,kit);
            refresh ();
            continue;        
            }
            
            if (xrkeimfose_but) {
                xrkeimfose_but=0; 
            _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            
            
            if (mx>xrkeimgem_xt && mx<xrkeimgem_xb && my>xrkeimgem_yt && my<xrkeimgem_yb) {  //xrkeimgem.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);} 
            else if (xrperfose_but) {
                xrperfose_but=0; 
            _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            else if (xrperfo_but) {
                xrperfo_but=0; 
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            else if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (xrkeimgem_but) continue;
            xrkeimgem_but=1;
            _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , kit);
            _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,bla,kit);
            refresh ();
            continue;        
            }
            
            if (xrkeimgem_but) {
                xrkeimgem_but=0; 
            _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            
            
            if (mx>xrperfose_xt && mx<xrperfose_xb && my>xrperfose_yt && my<xrperfose_yb) {  //xrperfose.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (xrperfo_but) {
                xrperfo_but=0; 
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            else if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1,dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 ,dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (xrperfose_but) continue;
            xrperfose_but=1;
            _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , kit);
            _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,bla,kit);
            refresh ();
            continue;        
            }
            
            if (xrperfose_but) {
                xrperfose_but=0; 
            _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
            refresh();
            }
            
            
            if (mx>xrperfo_xt && mx<xrperfo_xb && my>xrperfo_yt && my<xrperfo_yb) {  //xrperfo.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            }
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (xrperfo_but) continue;
            xrperfo_but=1;
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , kit);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,bla,kit);
            refresh ();
            continue;        
            }
            
            if (xrperfo_but) {
                xrperfo_but=0; 
            _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
            _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
            refresh();
            } 
            
            
            if (mx>aplgr_xt && mx<aplgr_xb && my>aplgr_yt && my<aplgr_yb) {  //aplgr.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (diplgr_but) {
                diplgr_but=0; 
                if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (aplgr_but) continue;
            aplgr_but=1;
            if (cpy.delinefat!=2) pioxr=bla ; else  pioxr=kok ;   
            _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , kit);
            _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (aplgr_but) {
                aplgr_but=0; 
                if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                refresh();
            } 
            
            
            if (mx>diplgr_xt && mx<diplgr_xb && my>diplgr_yt && my<diplgr_yb) {  //diplgr.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (diplgr_but) continue;
            diplgr_but=1;
            if (cpy.delinefat!=3) pioxr=bla ; else  pioxr=kok ;   
            _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , kit);
            _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (diplgr_but) {
                diplgr_but=0; 
            if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
            _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
            _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
            refresh();
            } 
            

            if (mx>lay_xt[0] && mx<lay_xb[0] && my>lay_yt[0] && my<lay_yb[0]) {  //layer 1.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            }
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (lay1_but) continue;
            lay1_but=1;
            if (cpy.delayer!=1) pioxr=bla ; else  pioxr=kok ;   
            _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , kit);
            _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (lay1_but) {
                lay1_but=0; 
                if (cpy.delayer!=1) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,pioxr, piobkxr);
                refresh();
            } 
            
            
            if (mx>lay_xt[1] && mx<lay_xb[1] && my>lay_yt[1] && my<lay_yb[1]) {  //layer 2.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (lay2_but) continue;
            lay2_but=1;
            if (cpy.delayer!=2) pioxr=bla ; else  pioxr=kok ;   
            _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , kit);
            _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (lay2_but) {
                lay2_but=0; 
                if (cpy.delayer!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , piobkxr);
                _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,pioxr, piobkxr);
                refresh();
            } 
            
            
            if (mx>coor_xt[0] && mx<coor_xb[0] && my>coor_yt[0] && my<coor_yb[0]) {  //coorxbut.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (coorx_but) continue;
            coorx_but=1;
            _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , kit);
            _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1,bla,kit);
            if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 ,bla,kit);}
            refresh ();
            continue;        
            }

            
            if (coorx_but) {
                coorx_but=0; 
                _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            
            
            if (mx>coor_xt[1] && mx<coor_xb[1] && my>coor_yt[1] && my<coor_yb[1]) {  //coorybut.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
                
            if (coory_but) continue;
            coory_but=1;
            _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , kit);
            _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1,bla,kit);
            if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , bla,kit);}
            refresh ();
            continue;        
            }
            
            if (coory_but) {
                coory_but=0; 
                _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            
            
            if (mx>sximgem_xt && mx<sximgem_xb && my>sximgem_yt && my<sximgem_yb) {  //sximgem.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            }
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            

            if (sximgem_but) continue;
            sximgem_but=1;
            if (!cpy.defill) pioxr=bla ; else  pioxr=kok ;   
            _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1, kit);
            _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (sximgem_but) {
                sximgem_but=0; 
                if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                refresh();
            } 
            
            
            if (mx>coor_xt[2] && mx<coor_xb[2] && my>coor_yt[2] && my<coor_yb[2]) {  //wid_but.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
                
            if (wid_but) continue;
            wid_but=1;
            _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , kit);
            _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1,bla,kit);
            if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , bla,kit);}
            refresh ();
            continue;        
            }
            
            if (wid_but) {
                wid_but=0; 
                _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            
            
            if (mx>coor_xt[3] && mx<coor_xb[3] && my>coor_yt[3] && my<coor_yb[3]) {  //hei_but.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , pioxr,piobkxr);}
                refresh();
            } 
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
                
            if (hei_but) continue;
            hei_but=1;
            _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , kit);
            _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1,bla,kit);
            if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , bla,kit);}
            refresh ();
            continue;        
            }
            
            if (hei_but) {
                hei_but=0; 
                _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                refresh();
            } 
            
            
            if (mx>page_xt[0] && mx<page_xb[0] && my>page_yt[0] && my<page_yb[0]) {  //pgcur_but.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
            else if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
                
            if (pgcur_but) continue;
            pgcur_but=1;
            if (cpy.depg==100) pioxr=bla ; else  pioxr=kok ;
            _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , kit);
            _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1,pioxr,kit);
            if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , kok,kit);}
            refresh ();
            continue;        
            }
            
            if (pgcur_but) {
                pgcur_but=0; 
                 if (cpy.depg==100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[0]+1 , page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1 , piobkxr);
                _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, pioxr,piobkxr);
                if (cpy.depg!=100) {_outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , kok,energ);}
                refresh();
            } 
            
            
            if (mx>page_xt[1] && mx<page_xb[1] && my>page_yt[1] && my<page_yb[1]) {  //pgall_but.. !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
            else if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);}
                
            if (pgall_but) continue;
            pgall_but=1;
            if (cpy.depg!=100) pioxr=bla ; else  pioxr=kok ;
            _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , kit);
            _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1,pioxr,kit);
            refresh ();
            continue;        
            }
            
            if (pgall_but) {
                pgall_but=0; 
                 if (cpy.depg!=100) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;}
                _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , piobkxr);
                _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, pioxr,piobkxr);
                refresh();
            } 
            
            
            if (mx>lext && mx<lext+25 && my>leyt && my<leyt+25) {  //Κίνηση στο Left !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
            else if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);}
                
            if (go_le) continue;
            putNOTicon (lext,leyt,mem_le);
            go_le=1;
            continue;        
            }
            
            if (go_le) {go_le=0; puticon(lext,leyt,mem_le,255);} 


            if (mx>rixt && mx<rixt+25 && my>riyt && my<riyt+25) {  //Κίνηση στο Right !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
            else if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}
                
            if (go_ri) continue;
            putNOTicon(rixt,riyt,mem_ri);
            go_ri=1;
            continue;        
            }
            
            if (go_ri) {go_ri=0; puticon(rixt,riyt,mem_ri,255);} 


            if (mx>arrxt && mx<arrxt+19 && my>arryt && my<arryt+19) {  //Κίνηση στο Marrs !!
            
            if (ektos) {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
            else if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}
                
            if (marrs) continue;
            putNOTicon(arrxt,arryt,mem_arrs);
            marrs=1;
            if (keyb_gr) show_help(" Μετακίνηση παραθύρου ", arrxt,arryt-18 , &hdhlpxt , &hdhlpyt) ;
            else show_help(" Move Window ", arrxt,arryt-18 , &hdhlpxt , &hdhlpyt) ;
            continue;        
            }
            
            if (marrs) {marrs=0; puticon(arrxt,arryt,mem_arrs,255);hide_help(hdhlpxt , hdhlpyt);}  

            

            if (mx>xok && mx<xok+54 && my>yok && my<yok+36) {  // Επιλογή στο Enter

            if (ektos) {
            cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
            SDL_SetCursor(cursor);
            }
            
            ektos=0;
            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}
            else if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}
                
            if (proenter) continue;
            proenter=1;
            putNOTicon(xok,yok,mem_ok);
            continue ;
            }
            
            if (proenter) {proenter=0 ; puticon(xok,yok,mem_ok,255);}

            

            if (mx>xgo && mx<xgo+30 && my>ygo && my<ygo+36) {  // Επιλογή στο GO !
            
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }
            
                ektos=0;
                
                if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}

                if (akyro) continue;
                putNOTicon(xgo,ygo,mem_go);
                akyro=1;
                continue;  
                
            }

            if (akyro) {akyro=0; puticon(xgo,ygo,mem_go,255);}

            if(mx>delxt && mx<delxt+30 && my>delyt && my<delyt+30) { // Delete Decor
                
                if (ektos) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
                    SDL_SetCursor(cursor);
                    }
            
                ektos=0;
                               
                if(deldec) continue;
                deldec=1;
                putNOTicon(delxt,delyt,mem_del);
                continue;
            }
            
            if (deldec) {deldec=0 ; puticon(delxt,delyt,mem_del,255);}

            
            if (mx>xb || mx<xt || my>yb || my<yt) {
                if (cross) continue;
                cross=1; ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
                SDL_SetCursor(cursor); 
            }
            else if (cross) {
                cross=0;ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor);
                continue;
            }
            
            if (!ektos) {
                ektos=1;
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                SDL_SetCursor(cursor); 
            }
            
            continue ;

            // ΤΕΛΟΣ ΤΟΥ case MOUSEMOTION
            
            case SDL_MOUSEBUTTONDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                mx1 = sdlev.button.x ; my1 = sdlev.button.y ;
                if (mx1<info.left || mx1>info.right || my1<info.top || my1>info.bottom) continue ;
                
            if(sdlev.button.button==SDL_BUTTON_RIGHT) {
                if (mx1>xt && mx1<xb && my1>yt && my1<yb) continue ;
                
                fo.co = getpixel(mx1,my1) ;
                
                    b=0;
                    for (f=0 ; f<dbar; f++) {
                        if (mx1>dbx1[f] && mx1<dbx2[f] && my1>dby1[f] && my1<dby2[f]) {b=1; break;}
                    }
                    if (b) { proel = f ; 
                        strcpy(secmenu[3], intmenu[3]);
                        if (db_elem[proel][1]) { strcpy(secmenu[4], intmenu[4]); strcpy(secmenu[5], "----------"); }
                        else { strcpy(secmenu[5], intmenu[5]); strcpy(secmenu[4], "----------"); }
                    } 
                    else {
                        proel=-1; 
                        strcpy(secmenu[3], "----------");
                        strcpy(secmenu[4], "----------");
                        strcpy(secmenu[5], "----------");
                    }
                    
                    b=0;
                    for (i=0 ; i<dcar; i++) {
                        if (mx1>dbdx1[i] && mx1<dbdx2[i] && my1>dbdy1[i] && my1<dbdy2[i]) {
                            b++ ;
                            if (b==1) {
                            dx=dbdx2[i]-dbdx1[i]+dbdy2[i]-dbdy1[i];
                            dy=mx1-dbdx1[i]+my1-dbdy1[i];
                            dz=i;
                            continue;
                            }
                            else {
                                dx1=dbdx2[i]-dbdx1[i]+dbdy2[i]-dbdy1[i];
                                dy1=mx-dbdx1[i]+my-dbdy1[i];
                                if (dx1<dx) { dx=dx1 ; dz=i; continue ; }
                                else if (dx1==dx) {
                                    if (dy1<dy) {dy=dy1; dz=i;}
                                }
                            }
                        }
                    }
                    if (b) { 
                        prodec = dz ; 
                        for (f=6; f<12; f++) {
                        strcpy(secmenu[f], intmenu[f]);
                        }
                        a=dd_elem[prodec];
                        dz = (ptr_dec[a].detype[6]) ? 1 : 0 ;
                        if (!dz) strcpy(secmenu[6], intmenu[6]);
                        else  strcpy(secmenu[6], "----------");
                    } 
                    else { 
                        prodec=-1;
                        for (f=6; f<12; f++) {
                        strcpy(secmenu[f], "----------");
                        }
                    }
                    
                    if (cpy.detype[6]) {
                        strcpy(secmenu[2], "----------");
                        strcpy(secmenu[3], "----------");
                        strcpy(secmenu[6], "----------");
                    }
                    
                    Stx = mx1-6; b=15 ;
                    if (Stx<info.left+1 || mx1+6>info.right-1) continue ;
                    if ( (my1+(12*20+38)>info.bottom-60)) {
                        if (my1+6>info.bottom-1) continue ;
                        while (my1+b>info.bottom-1  && (b>0) ) b-- ;
                        Sty=my1;
                        getimage (Stx,Sty,mx1+6,my1+b,mem_cross);
                        setcolor(5);
                        line (mx1,my1+b,mx1,my1);
                        line (mx1-1,my1+b,mx1-1,my1);
                        line (mx1+1,my1+b,mx1+1,my1);
                        _velos_up (mx1, mx1, my1) ; 
                    }
                    else {
                        while (my1-b<info.top+21   && (b>0) ) b-- ;
                        Sty = my1-b-6;
                        if (Sty<info.top) continue ;
                        getimage (Stx,Sty,mx1+6,my1,mem_cross);
                        setcolor(5);
                        line (mx1,Sty,mx1,my1);
                        line (mx1-1,Sty,mx1-1,my1);
                        line (mx1+1,Sty,mx1+1,my1);
                        _velos_down (mx1, mx1, my1) ; 
                    }

                        refresh();
                
                
                if (keyb_gr) sprintf (str1024 , "Επιλέξατε.."); 
                else sprintf (str1024 , "Choose..");
                normtext_tomy(str1024,0);
                dx = fastmenu_show(12, &secmenu[0][0], 80, str1024, (unsigned short) mx1, (unsigned short) my1 );
                putimage (Stx,Sty,mem_cross,0);refresh();
                while (!SDL_PollEvent(&sdlev)) continue ;
                mx = sdlev.button.x ; my = sdlev.button.y ;
                cross = (mx<xt || mx>xb || my<yt || my>yb) ? 1 : 0 ;

                if (!cross) {
                    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
                    SDL_SetCursor(cursor); 
                }
                else {
                cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_CROSSHAIR);
                SDL_SetCursor(cursor); 
                }

                if (dx<0) continue;
                if (!dx) {         // Λήψη Συντεταγμένων(Άνω & Αριστερά)
                    cpy.dext=(short int) mx1;
                    cpy.deyt=(short int) my1;
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                    _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                    _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);
                    if (cpy.dext+cpy.dewid>=info.right) { 
                        cpy.dewid=info.right-cpy.dext;
                        sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                        _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                        _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    }

                    if (cpy.deyt+cpy.dehei>=info.bottom) { 
                    cpy.dehei=info.bottom-cpy.deyt;
                    sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                    _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                    _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                    }
                    refresh();
                }
                else if (dx==1) {  // Υπολογισμός πλάτους-ύψους(Κάτω & Δεξιά)
                    if (mx1<=cpy.dext || my1<=cpy.deyt) continue;
                    cpy.dewid=(short int) mx1 - cpy.dext;
                    cpy.dehei=(short int) my1 - cpy.deyt;
                    sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                    _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                    _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                    _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                    _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);
                    refresh();
                }
                
                else if (dx==2 && (!cpy.detype[6]) ) {  // Χρώμα σημείου ως φόντο
                    if (!cpy.defill) {
                    cpy.defill=1;
                     pioxr=kok ; piobkxr=energ; 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                    }
                    cpy.debkxr[0] = fo.rgb[2];
                    cpy.debkxr[1] = fo.rgb[1];
                    cpy.debkxr[2] = fo.rgb[0];

                    anan=1;
                }
                
                else if (dx==3 && proel!=-1 && (!cpy.detype[6]) ) {   // Αντέγραψε χρώματα Στοιχείου
                    i = db_elem[proel][0];
                    if (!cpy.defill) {
                    cpy.defill=1;
                     pioxr=kok ; piobkxr=energ; 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                    }
                    cpy.debkxr[0] = ptr_pedio[i]->fibkxr[0];
                    cpy.debkxr[1] = ptr_pedio[i]->fibkxr[1];
                    cpy.debkxr[2] = ptr_pedio[i]->fibkxr[2];
                    cpy.dechxr[0] = ptr_pedio[i]->fichxr[0];
                    cpy.dechxr[1] = ptr_pedio[i]->fichxr[1];
                    cpy.dechxr[2] = ptr_pedio[i]->fichxr[2];
                    cpy.delinexr[0] = ptr_pedio[i]->fichxr[0];
                    cpy.delinexr[1] = ptr_pedio[i]->fichxr[1];
                    cpy.delinexr[2] = ptr_pedio[i]->fichxr[2];
                    anan=1;
                }
                
                else if (dx==4 && proel!=-1 && (db_elem[proel][1]) ) {  // Οριζ.στοίχιση στο μέσον του ΠΕΔΙΟΥ
                    i = db_elem[proel][0];
                    dy = ptr_pedio[i]->fixt + (ptr_pedio[i]->fiwid/2)  ;
                    cpy.dext = dy - (cpy.dewid/2) ;
                    if (cpy.dext<info.left+2) cpy.dext=0;
                    if (cpy.dext+cpy.dewid>=info.right) cpy.dext=0;
                    
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    refresh();
                }
                
                
                else if (dx==5 && proel!=-1 && (!db_elem[proel][1]) ) {  // Οριζ.στοίχιση στο μέσον του ONOMATOS
                    i = db_elem[proel][0];
                    dy = ptr_pedio[i]->filaxt + (ptr_pedio[i]->filawid/2)  ;
                    cpy.dext = dy - (cpy.dewid/2) ;
                    if (cpy.dext<info.left+2) cpy.dext=0;
                    if (cpy.dext+cpy.dewid>=info.right) cpy.dext=0;
                    
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    refresh();
                }
                
                               
                else if (dx==6 && prodec!=-1 && (!cpy.detype[6]) && (!dz) ) {  // Αντέγραψε χρώματα ετικέτας
                    i = dd_elem[prodec];
                    cpy.defill = ptr_dec[i].defill ;
                    cpy.delinexr[0] = ptr_dec[i].delinexr[0];
                    cpy.delinexr[1] = ptr_dec[i].delinexr[1];
                    cpy.delinexr[2] = ptr_dec[i].delinexr[2];
                    cpy.debkxr[0] = ptr_dec[i].debkxr[0];
                    cpy.debkxr[1] = ptr_dec[i].debkxr[1];
                    cpy.debkxr[2] = ptr_dec[i].debkxr[2];
                    cpy.dechxr[0] = ptr_dec[i].dechxr[0];
                    cpy.dechxr[1] = ptr_dec[i].dechxr[1];
                    cpy.dechxr[2] = ptr_dec[i].dechxr[2];
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                    anan=1;
                }
                
                else if (dx==7 && prodec!=-1) {  // Αντέγραψε διαστάσεις ετικέτας
                    i = dd_elem[prodec];
                    cpy.dewid = ptr_dec[i].dewid;
                    cpy.dehei = ptr_dec[i].dehei;
                    
                    if (cpy.dext+cpy.dewid>=info.right) { cpy.dewid=info.right-cpy.dext; }
                    sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                    _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                    _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    

                    if (cpy.deyt+cpy.dehei>=info.bottom) { cpy.dehei=info.bottom-cpy.deyt; }
                    sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                    _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                    _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                    
                    refresh();
                    
                }
                
                else if (dx==8 && prodec!=-1) {  // Στοίχιση Οριζόντια με ετικέτα
                    i = dd_elem[prodec];
                    cpy.dext = ptr_dec[i].dext;
                    
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    
                    if (cpy.dext+cpy.dewid>=info.right) { 
                        cpy.dewid=info.right-cpy.dext;
                        sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                        _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                        _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    }
                    refresh();
                    
                }
                
                else if (dx==9 && prodec!=-1) {    // Στοίχιση Κάθετα με ετικέτα
                    i = dd_elem[prodec];
                    cpy.deyt = ptr_dec[i].deyt;
                    
                    sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                    _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                    _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);
                    
                    if (cpy.deyt+cpy.dehei>=info.bottom) { 
                    cpy.dehei=info.bottom-cpy.deyt;
                    sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                    _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                    _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                    }
                    refresh();

                }
                
                else if (dx==10 && prodec!=-1) {  // Στοίχιση Οριζ. στο μέσον της ετικέτας
                    i = dd_elem[prodec];
                    dy = ptr_dec[i].dext + (ptr_dec[i].dewid/2)  ;
                    cpy.dext = dy - (cpy.dewid/2) ;
                    if (cpy.dext<info.left+2) cpy.dext=0;
                    if (cpy.dext+cpy.dewid>=info.right) cpy.dext=0;
                    
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    refresh();
                }
                
                
                else if (dx==11 && prodec!=-1) {   // Στοίχιση Κάθετα στο μέσον της ετικέτας
                    i = dd_elem[prodec];
                    dy = ptr_dec[i].deyt + (ptr_dec[i].dehei/2)  ;
                    cpy.deyt = dy - (cpy.dehei/2) ;
                    if (cpy.deyt<info.top+2) cpy.deyt=0;
                    if (cpy.deyt+cpy.dehei>=info.bottom) cpy.deyt=0;
                    
                    sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                    _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                    _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);
                    refresh();
                }
                
                continue ;
            }
            
            else if (sdlev.button.button==SDL_BUTTON_LEFT) {
                if (ektos) continue;
                dx=abs(mx1-mx); dy=abs(my1-my);
                if (dx>25 || dy>25) continue;
                
                if (type!=-1) {
                    
                    switch (type) {
                        case 0 :
                            if (cpy.detype[6]) continue ;
                            cpy.detype[0]=1-cpy.detype[0];
                            if (cpy.detype[0]) {
                                if (cpy.detype[1]) {
                                    cpy.detype[1]=0;
                                    x1= 120 + wtype_xt ;
                                    setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                    rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                    rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                    rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                    rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                                }
                                x1= wtype_xt ;
                                setcolor (4);
                                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                            }
                            else {
                                x1= wtype_xt ;
                                setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                            }
                            if (!cpy.detype[6]) anan=1 ;
                            break ;
                            
                        case 1:
                            if (cpy.detype[6]) continue ;
                            cpy.detype[1]=1-cpy.detype[1];
                            if (cpy.detype[1]) {
                                if (cpy.detype[0]) {
                                    cpy.detype[0]=0;
                                    x1= wtype_xt ;
                                    setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                    rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                    rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                    rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                    rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                                }
                                x1= 120+wtype_xt ;
                                setcolor (4);
                                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                            }
                            else {
                                x1= 120+wtype_xt ;
                                setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                            }
                            if (!cpy.detype[6]) anan=1 ;
                            break ;
                            
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            if (cpy.detype[6]) continue ;
                            cpy.detype[type] = 1 - cpy.detype[type] ;
                            if (cpy.detype[type]) {
                               x1= type*120+wtype_xt ;
                               setcolor (4);
                               rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                               rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                               rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                               rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                               
                               for (f=2 ; f<7 ; f++) {
                                   if (f==type) continue ;
                                   if (cpy.detype[f]) {
                                       cpy.detype[f]=0;
                                       x1= f*120+wtype_xt ;
                                       setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                       rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                       rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                       rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                       rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                                    }
                                }
                            }
                            anan=1;
                            break ;
                            
                        case 6:
                            cpy.detype[6] = 1 - cpy.detype[6] ;
                            if (cpy.detype[6]) {

                                if (cpy.defill) {
                                cpy.defill = 0 ;
                                pioxr=dbchxr ; piobkxr=dbbkxr;  
                                _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                                _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                                }

                                if (cpy.delinefat==3) {
                                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , dbbkxr);
                                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,dbchxr,dbbkxr);
                                }
                                else if (cpy.delinefat==2) {
                                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , dbbkxr);
                                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbchxr, dbbkxr);
                                }
                                cpy.delinefat=1;
                                
                               x1= 6*120+wtype_xt ;
                               setcolor (4);
                               rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                               rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                               rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                               rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                               
                               for (f=0 ; f<6 ; f++) {
                                   
                                   if (cpy.detype[f]) {
                                       cpy.detype[f]=0;
                                       x1= f*120+wtype_xt ;
                                       setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                                       rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                                       rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                                       rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                                       rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                                    }
                                }
                                anan=1;
                                
                            }
                            else anan=1;
                            break ;
                    }
                    refresh();
                    type=-1;
                    continue ;
                }
                
                
                    if (nordim_but) {
                        fp_photo = fopen (cpy.dephoto , "rb");
                        if (fp_photo==NULL) {goto ADYNBMP;}
                        else {
                            dx = fseek(fp_photo , 18, SEEK_SET);
                            if (dx) {fclose (fp_photo); goto ADYNBMP;}
                            fread (&norm_w , 4 , 1 , fp_photo);
                            fread (&norm_h , 4 , 1 , fp_photo);
                            if (ferror(fp_photo)) {clearerr(fp_photo); fclose (fp_photo); goto ADYNBMP;}
                            dx=info.right-info.left;
                            dy=info.bottom-info.top;
                            if (norm_w>dx || norm_h>dy) {fclose (fp_photo); goto ADYNBMP;}
                            fclose (fp_photo);
                            
                            if (!cpy.dext) cpy.dext=info.left+2;
                            if (!cpy.deyt) cpy.deyt=info.top+2;
                            b=cpy.dext; c=cpy.deyt;
                            
                            if (cpy.dext+norm_w > info.right-2) cpy.dext = info.right-2-norm_w;
                            while (cpy.dext<info.left+2) { norm_w--; cpy.dext = info.right-2-norm_w; }
                            if (cpy.deyt+norm_h > info.bottom-25) cpy.deyt = info.bottom-25-norm_h;
                            while (cpy.deyt<info.top+2) { norm_h--; cpy.deyt = info.bottom-25-norm_h; }
                            
                            cpy.dewid = (short int) norm_w;
                            cpy.dehei = (short int) norm_h;
                            
                            sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                            _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                            _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                            
                            sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                            _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                            _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                            
                            if (b!=cpy.dext) {
                            sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                            _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                            _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                            }
                            
                            if (c!=cpy.deyt) {
                                sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                                _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                                _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr); 
                            }
                            
                            refresh();
                        }
ADYNBMP:
                        do { 
                            SDL_PollEvent(&sdlev);
                            
                            } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
                            
                        bareacls (nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2 , dbbkxr);
                        _outmystr_center_col (4,nordim_t, nordim_xt+2 , nordim_yt+2 , nordim_xb-2 , nordim_yb-2,dbchxr , dbbkxr);
                        refresh();
                        continue ;
                    }
                    
                
                
                if (kentrx_but) {
                    bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , energ);
                    _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,kok , energ);
                    refresh();
                    
                    b=cpy.dewid; c=cpy.dehei ;
                    
                    if (!cpy.dewid) { cpy.dewid= (cpy.detype[6]) ? 200 : 31 ;}
                    else if (cpy.dewid<7) cpy.dewid=7;
                    
                    if (!cpy.dehei) cpy.dehei= (cpy.detype[6]) ? 200 : 31 ;
                    else if (cpy.dehei<7) cpy.dehei=7;
                    
                    dx = info.right - info.left + 1 - cpy.dewid ; dx=dx/2;
                    cpy.dext = info.left + dx  ;
                    sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                    _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                    
                    if (!cpy.deyt) {
                        cpy.deyt = info.top+2;
                        sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                        _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                        _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);
                    }
                    
                    if (b!=cpy.dewid) {
                        sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                        _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                        _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    }
                    
                    if (c!=cpy.dehei) {
                        sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                        _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                        _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                    }
                    
                    refresh();
                    
                    do { 
                        SDL_PollEvent(&sdlev);
                        
                        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
                    
                    
                    bareacls (kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2 , dbbkxr);
                    _outmystr_center_col (4,kentrx_t, kentrx_xt+2 , kentrx_yt+2 , kentrx_xb-2 , kentrx_yb-2,dbchxr , dbbkxr);
                    refresh();
                    continue ;
                }
                
                
                if (kentry_but) {
                    bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , energ);
                    _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,kok , energ);
                    refresh();
                    
                    b=cpy.dewid; c=cpy.dehei ;
                    
                    if (!cpy.dewid) { cpy.dewid= (cpy.detype[6]) ? 200 : 31 ;}
                    else if (cpy.dewid<7) cpy.dewid=7;
                    
                    if (!cpy.dehei) cpy.dehei= (cpy.detype[6]) ? 200 : 31 ;
                    else if (cpy.dehei<7) cpy.dehei=7;
                    
                        dx = info.bottom - info.top - cpy.dehei ; dx=dx/2;
                        cpy.deyt = info.top + dx  ;
                        sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                        _bareacls(icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                        _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);
                    
                        if (!cpy.dext) {
                            cpy.dext = info.left+2;
                            sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                            _bareacls (icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1,coor_yb[0]-1, dbbkxr);
                            _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);
                        }
                        
                    if (b!=cpy.dewid) {
                        sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                        _bareacls(icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                        _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);
                    }
                    
                    if (c!=cpy.dehei) {
                        sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                        _bareacls(icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                        _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 ,dbchxr,dbbkxr);
                    }
                    
                    refresh();
                    
                    do { 
                            SDL_PollEvent(&sdlev);
                            
                            } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 
                    
                    bareacls (kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2 , dbbkxr);
                    _outmystr_center_col (4,kentry_t, kentry_xt+2 , kentry_yt+2 , kentry_xb-2 , kentry_yb-2,dbchxr , dbbkxr);
                    refresh();
                    continue ;
                }
                
                if (pgall_but) {
                    if (cpy.depg==100) continue;
                    cpy.depg=100; ipage[0]=255;
                    _bareacls(page_xt[0]+1, page_yt[0]+1, page_xb[0]-1,page_yb[0]-1,dbbkxr);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, dbchxr,dbbkxr);
                    _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , energ);
                    _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, kok,energ);
                    refresh();
                    continue ;
                }
                
                if (pgcur_but) {
                    
                    _bareacls(page_xt[0]+1, page_yt[0]+1, page_xb[0]-1,page_yb[0]-1,kit);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, bla,kit);
                    if (cpy.depg==100) {
                        _bareacls (page_xt[1]+1 , page_yt[1]+1 , page_xb[1]-1 , page_yb[1]-1 , dbbkxr);
                        _outmystr_col (4,pageoles,page_xt[1]+1 , page_yt[1]+1, page_xb[1]-1, dbchxr,dbbkxr);
                        ipage[0]=255;cpy.depg=dbcurpage;
                    }
                    sprintf (str1024,"%d",cpy.depg); normtext_tomy (str1024,ipage);
                    for (i=0;i<3;i++) {chxr[i]=bla[i];bkxr[i]=kit[i]; slxr[i]=selkb[i];}
                    gouv=myfont[4];
                    num_input(ipage,ipage_xt, page_yt[0]+1 , page_xb[0]-1 , page_yb[0]-1, 3, 0);
                    _bareacls(page_xt[0]+1, page_yt[0]+1, page_xb[0]-1,page_yb[0]-1,energ);
                    if (ipage[0]==255) {
                        cpy.depg=dbcurpage;
                    }
                    else cpy.depg = (short int) convert_str(3 , ipage);
                    if (cpy.depg>dbpg+1) cpy.depg=dbpg+1;
                    if (cpy.depg>100) cpy.depg=100;
                    sprintf (str1024,"%03d",cpy.depg); normtext_tomy (str1024,ipage);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1, page_xb[0]-1, kok,energ);
                    _outmystr_rcol(4,ipage, ipage_xt, page_yt[0]+1, page_xb[0]-1 , kok,energ);
                    refresh();
                    continue;
                }
                              
                
                if (coorx_but) {
                    for (i=0;i<3;i++) {chxr[i]=bla[i];bkxr[i]=kit[i]; slxr[i]=selkb[i];}
                    gouv=myfont[4];
COORXTAB:            
                    if (cpy.dext) {sprintf(str1024,"%d",cpy.dext); normtext_tomy(str1024,icoorx);}
                    _bareacls (icoor_xt[0] , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , kit);
                    dx = num_input(icoorx, icoor_xt[0], coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1, 4, 0);
                    _bareacls (icoor_xt[0] , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , kit);
                    if (icoorx[0]==255) {
                        cpy.dext=0;
                    }
                    else {
                        cpy.dext= (short int) convert_str(4 , icoorx);
                        if (cpy.dext>=info.right) { 
                            cpy.dext=0;
                        }
                        else {
                            sprintf(str1024,"%04d",cpy.dext); normtext_tomy(str1024,icoorx);
                            _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , bla,kit);
                        }
                    }
                    refresh();
                    if (dx==-9) {
                        coorx_but=0; 
                        _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, dbchxr,dbbkxr);
                        if (cpy.dext) {_outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                        coory_but=1; 
                        _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , kit);
                        _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, bla,kit);
                        refresh();
                        goto COORYTAB ;
                    }
                    continue ;
                }
                
                
                if (coory_but) {
                    for (i=0;i<3;i++) {chxr[i]=bla[i];bkxr[i]=kit[i]; slxr[i]=selkb[i];}
                    gouv=myfont[4];
COORYTAB:
                    if (cpy.deyt) {sprintf(str1024,"%d",cpy.deyt); normtext_tomy(str1024,icoory);}
                    _bareacls (icoor_xt[1] , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , kit);
                    dx = num_input(icoory, icoor_xt[1], coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1, 4, 0);
                    _bareacls (icoor_xt[1] , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , kit);
                    if (icoory[0]==255) {
                        cpy.deyt=0;
                    }
                    else {
                        cpy.deyt= (short int) convert_str(4 , icoory);
                        if (cpy.deyt>=info.bottom) { 
                            cpy.deyt=0;
                        }
                        else {
                            sprintf(str1024,"%04d",cpy.deyt); normtext_tomy(str1024,icoory);
                            _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , bla,kit);
                        }
                    }
                    refresh();
                    if (dx==-9) {
                        coory_but=0; 
                        _bareacls (coor_xt[1]+1 , coor_yt[1]+1 , coor_xb[1]-1 , coor_yb[1]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[1],coor_xt[1]+1 , coor_yt[1]+1, coor_xb[1]-1, dbchxr,dbbkxr);
                        if (cpy.deyt) {_outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                        wid_but=1; 
                        _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , kit);
                        _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, bla,kit);
                        refresh();
                        goto WIDTAB ;
                    }
                    continue ;
                }
                
                
                if (wid_but) {
                    for (i=0;i<3;i++) {chxr[i]=bla[i];bkxr[i]=kit[i]; slxr[i]=selkb[i];}
                    gouv=myfont[4];
WIDTAB:
                    if (cpy.dewid) {sprintf(str1024,"%d",cpy.dewid); normtext_tomy(str1024,iwid);}
                    _bareacls (icoor_xt[2] , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , kit);
                    dx = num_input(iwid, icoor_xt[2], coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1, 4, 0);
                    _bareacls (icoor_xt[2] , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , kit);
                    if (iwid[0]==255) {
                        cpy.dewid=0;
                    }
                    else {
                        cpy.dewid= (short int) convert_str(4 , iwid);
                        if (cpy.dext+cpy.dewid>=info.right) { 
                            cpy.dewid=info.right-cpy.dext;
                        }
                            sprintf(str1024,"%04d",cpy.dewid); normtext_tomy(str1024,iwid);
                            _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , bla,kit);
                    }
                    refresh();
                    if (dx==-9) {
                        wid_but=0; 
                        _bareacls (coor_xt[2]+1 , coor_yt[2]+1 , coor_xb[2]-1 , coor_yb[2]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[2],coor_xt[2]+1 , coor_yt[2]+1, coor_xb[2]-1, dbchxr,dbbkxr);
                        if (cpy.dewid) {_outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                        hei_but=1; 
                        _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , kit);
                        _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, bla,kit);
                        refresh();
                        goto HEITAB ;
                    }
                    continue ;
                }
                
                
                if (hei_but) {
                    for (i=0;i<3;i++) {chxr[i]=bla[i];bkxr[i]=kit[i]; slxr[i]=selkb[i];}
                    gouv=myfont[4];
HEITAB:
                    if (cpy.dehei) {sprintf(str1024,"%d",cpy.dehei); normtext_tomy(str1024,ihei);}
                    _bareacls (icoor_xt[3] , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , kit);
                    dx = num_input(ihei, icoor_xt[3], coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1, 4, 0);
                    _bareacls (icoor_xt[3] , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , kit);
                    if (ihei[0]==255) {
                        cpy.dehei=0;
                    }
                    else {
                        cpy.dehei= (short int) convert_str(4 , ihei);
                        if (cpy.deyt+cpy.dehei>=info.bottom) { 
                            cpy.dehei=info.bottom-cpy.deyt;
                        }
                        sprintf(str1024,"%04d",cpy.dehei); normtext_tomy(str1024,ihei);
                        _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , bla,kit);
                    }
                    refresh();
                    if (dx==-9) {
                        hei_but=0; 
                        _bareacls (coor_xt[3]+1 , coor_yt[3]+1 , coor_xb[3]-1 , coor_yb[3]-1 , dbbkxr);
                        _outmystr_col (4,coor_t[3],coor_xt[3]+1 , coor_yt[3]+1, coor_xb[3]-1, dbchxr,dbbkxr);
                        if (cpy.dehei) {_outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                        coorx_but=1; 
                        _bareacls (coor_xt[0]+1 , coor_yt[0]+1 , coor_xb[0]-1 , coor_yb[0]-1 , kit);
                        _outmystr_col (4,coor_t[0],coor_xt[0]+1 , coor_yt[0]+1, coor_xb[0]-1, bla,kit);
                        refresh();
                        goto COORXTAB ;
                    }
                    continue ;
                }
                
                
                if(sximgem_but) {
                    if (!cpy.defill) {
                        if (cpy.detype[6]) continue ;
                        a=0;
                        for (f=2 ; f<6 ; f++) { if (cpy.detype[f]) {a=1; break ;} }
                        if (!a) continue ;
                    }
                    cpy.defill = 1 - cpy.defill ;
                    if (!cpy.defill) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1 , piobkxr);
                    _outmystr_center_col (4,sximgem,sximgem_xt+1 , sximgem_yt+1 , sximgem_xb-1, sximgem_yb-1,pioxr, piobkxr);
                    refresh();
                    anan=1 ;
                    continue ;
                }
                
                if (xrkeimfose_but) {  // Χρώμα για κείμενο εκτός σχήματος
                    if (!cpy.detype[0] && !cpy.detype[1]) continue ;
                    inkualizer_spec (cpy.defont,cpy.dechxr , dbbkxr , 0 , 0 ,dbbkxr);
                    xrkeimfose_but=0; 
                    _bareacls (xrkeimfose_xt+1 , xrkeimfose_yt+1 , xrkeimfose_xb-1 , xrkeimfose_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimfose,xrkeimfose_xt+1 , xrkeimfose_yt+1, xrkeimfose_xb-1, xrkeimfose_yb-1,dbchxr, dbbkxr);
                    refresh();
                    if (!cpy.detype[6]) anan=1 ;
                    continue ;
                }
                
                if (xrkeimgem_but) {  // Χρώμα για κείμενο εντός σχήματος και χρώμα γεμίσματος σχήματος
                    if (cpy.detype[6]) continue ;
                    if (!cpy.defill) continue ;
                    a=0;
                    for (f=2 ; f<6 ; f++) {if (cpy.detype[f]) {a=1; break ;} }
                    if (!a) continue ;
                    inkualizer_spec (cpy.defont, cpy.dechxr , cpy.debkxr , 0 , 2 ,dbbkxr);
                    xrkeimgem_but=0; 
                    _bareacls (xrkeimgem_xt+1 , xrkeimgem_yt+1 , xrkeimgem_xb-1 , xrkeimgem_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrkeimgem,xrkeimgem_xt+1 , xrkeimgem_yt+1, xrkeimgem_xb-1, xrkeimgem_yb-1,dbchxr, dbbkxr);
                    refresh();
                    anan=1 ;
                    continue ;
                }
                
                if (xrperfose_but) {  // Χρώμα περιγράμματος στο τρέχων φόντο
                    if (cpy.detype[6]) continue ;
                    a=0;
                    for (f=2 ; f<6 ; f++) { if (cpy.detype[f]) {a=1; break ;} }
                    if (!a) continue ;
                    if (cpy.defill) piobkxr=cpy.debkxr ; else piobkxr=dbbkxr;
                    inkualizer_spec (cpy.defont,cpy.delinexr , dbbkxr , 1 , 0 , piobkxr);
                    xrperfose_but=0; 
                    _bareacls (xrperfose_xt+1 , xrperfose_yt+1 , xrperfose_xb-1 , xrperfose_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrperfose,xrperfose_xt+1 , xrperfose_yt+1, xrperfose_xb-1, xrperfose_yb-1,dbchxr, dbbkxr);
                    anan=1;
                    refresh();
                    continue ;
                }
                
                if (xrperfo_but) {  // Χρώμα περιγράμματος σε άλλο φόντο από το τρέχων φόντο
                    if (cpy.detype[6]) continue ;
                    a=0;
                    for (f=2 ; f<6 ; f++) {if (cpy.detype[f]) {a=1; break ;} }
                    if (!a) continue ;
                    
                    for (f=0 ; f<3 ; f++) enbkxr[f] = dbbkxr[f];
                    
                    if (cpy.defill) piobkxr = cpy.debkxr;
                    else piobkxr = dbbkxr ;
                    
                          
                    inkualizer_spec (cpy.defont,cpy.delinexr , enbkxr , 1 , 2 , piobkxr);
                    xrperfo_but=0; 
                    _bareacls (xrperfo_xt+1 , xrperfo_yt+1 , xrperfo_xb-1 , xrperfo_yb-1 , dbbkxr);
                    _outmystr_center_col (4,xrperfo,xrperfo_xt+1 , xrperfo_yt+1, xrperfo_xb-1, xrperfo_yb-1,dbchxr, dbbkxr);
                    refresh();
                    anan=1;
                    continue ;
                }
                
                if (aplgr_but) {
                    if (cpy.detype[6]) continue ;
                    a=0;
                    for (f=2 ; f<6 ; f++) {if (cpy.detype[f]) {a=1; break ;} }
                    if (!a) continue ;
                    if (cpy.delinefat==3) {
                        _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , dbbkxr);
                        _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,dbchxr,dbbkxr);
                    }
                    if (cpy.delinefat==2) cpy.delinefat=1; else cpy.delinefat=2 ;
                    
                    if (cpy.delinefat!=2) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,pioxr, piobkxr);
                    refresh();
                    anan=1;
                    continue ;
                }
                
                if (diplgr_but) {
                    if (cpy.detype[6]) continue ;
                    a=0;
                    for (f=2 ; f<6 ; f++) {if (cpy.detype[f]) {a=1; break ;} }
                    if (!a) continue ;
                    if (cpy.delinefat==2) {
                        _bareacls (aplgr_xt+1 , aplgr_yt+1 , aplgr_xb-1 , aplgr_yb-1 , dbbkxr);
                        _outmystr_center_col (4,aplgr,aplgr_xt+1 , aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbchxr, dbbkxr);
                    }
                    if (cpy.delinefat==3) cpy.delinefat=1; else cpy.delinefat=3 ;
                    
                    if (cpy.delinefat!=3) { pioxr=dbchxr ; piobkxr=dbbkxr; } else { pioxr=kok ; piobkxr=energ;} 
                    _bareacls (diplgr_xt+1 , diplgr_yt+1 , diplgr_xb-1 , diplgr_yb-1 , piobkxr);
                    _outmystr_center_col (4,diplgr,diplgr_xt+1 , diplgr_yt+1, diplgr_xb-1, diplgr_yb-1,pioxr, piobkxr);
                    refresh();
                    anan=1;
                    continue ;
                }
                
                if (lay1_but) {
                    
                    if (cpy.delayer==1) {
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , dbbkxr);
                        _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,dbchxr, dbbkxr);
                        cpy.delayer=2;
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , energ);
                        _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,kok,energ);
                    }
                    else {
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , dbbkxr);
                        _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,dbchxr,dbbkxr);
                        cpy.delayer=1;
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , energ);
                        _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,kok,energ);
                    }
                    
                    refresh();
                    continue ;
                }
                
                
                if (lay2_but) {
                    
                    if (cpy.delayer==1) {
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , dbbkxr);
                        _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,dbchxr, dbbkxr);
                        cpy.delayer=2;
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , energ);
                        _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,kok,energ);
                    }
                    else {
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 , lay_xb[1]-1 , lay_yb[1]-1 , dbbkxr);
                        _outmystr_center_col (4,lay_t[1],lay_xt[1]+1 , lay_yt[1]+1, lay_xb[1]-1, lay_yb[1]-1,dbchxr,dbbkxr);
                        cpy.delayer=1;
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 , lay_xb[0]-1 , lay_yb[0]-1 , energ);
                        _outmystr_center_col (4,lay_t[0],lay_xt[0]+1 , lay_yt[0]+1, lay_xb[0]-1, lay_yb[0]-1,kok,energ);
                    }
                    
                    refresh();
                    continue ;
                }
                
                
                if (font_but) {
                    dx=fonts_show(dbfnt.mem_fn, dbfnt.fn_data, dbfnt.fn_ar, dbfnt.fn_orio, dbfnt.fn_name, &dbfnt.fn_sorton,0, dbchxr,dbbkxr,dbslxr );    
                    if (dx>=0) {
                        cpy.defont=(short int) dx;
                        cpy.defowid = myfont_wid[cpy.defont];
                        cpy.defohei = myfont_hei[cpy.defont];
                        normtext_tomy(myfont_name[cpy.defont],fonter);
                    }
                    
                    _bareacls (font_xt+1 , font_yt+1 , font_xb-1 , font_yb-1 , dbbkxr);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr, dbbkxr);
                    refresh();
                    font_but=0;
                    if (!cpy.detype[6]) anan=1;
                    continue ;
                }
                
                if (inptext_but) {
                    inptext_but=0;
                    if ( (!cpy.detype[0]) && (!cpy.detype[1]) ) continue ;
                    bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1 , dbbkxr);
                    for (f=0;f<3;f++) {chxr[f]=dbchxr[f]; bkxr[f]=dbbkxr[f]; slxr[f]=dbslxr[f];}
                    gouv=myfont[4];
                    text_input(cpy.detext, inptext_xt+1 , inptext_yt+3 , inptext_xb-1 , inptext_yb-1 , 70);

                    _bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1 , dbbkxr);
                    
                    if (cpy.detext[0]!=255) {
                        
                    _outmystr_center_col (4,cpy.detext,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ;
                    }
                    else {
                    _outmystr_center_col (4,eis_keim,inptext_xt+1,inptext_yt+1,inptext_xb-1,inptext_yb-1,dbchxr,dbbkxr ) ; 
                    }
                    refresh();
                    anan=1;
                    continue ;
                }
                
                if (marrs) {
                    
                    mem_form=malloc(imagesize(xt,yt,xb,yb));
                    if (!mem_form) {information(2-keyb_gr,0,0); continue;}
                    getimage(xt,yt,xb,yb,mem_form);
                    xt1=xt ; yt1=yt ; xb1=xb; yb1=yb;
                    dx=change_pos (&xt1, &yt1, &xb1, &yb1);
                    if (dx<0) {information(2-keyb_gr,0,0); free (mem_form); mem_form=0;continue;}
                    putimage (xt,yt,mem0,0);
                    getimage (xt1,yt1,xb1,yb1,mem0);
                    
                    xt=xt1; yt=yt1; xb=xb1; yb=yb1;

                    putimage (xt,yt,mem_form,0);
                    free(mem_form) ; mem_form=0;
                    
                    wtype_xt=xt+30; wtype_xb=xb-29; 
                    wtype_yt=yt+46 ; wtype_yb=wtype_yt+80;
                    inptext_xt=xt+10; inptext_yt=wtype_yb+4; 
                    inptext_xb=xb-10; inptext_yb=inptext_yt+32;
                    font_xt = xrkeimfose_xt =  xrkeimgem_xt = xrperfose_xt = xrperfo_xt = aplgr_xt = xt+10 ;
                    font_xb = xrkeimgem_xb = xrperfose_xb = xrperfo_xb = sximgem_xb = xb-10 ;
                    font_yt = inptext_yb+1 ;  font_yb = font_yt + 30 ;
                    xrkeimfose_yt = sximgem_yt = font_yb+1 ; xrkeimfose_yb = sximgem_yb= xrkeimfose_yt+25;
                    xrkeimfose_xb=xrkeimfose_xt+435 ; sximgem_xt=xrkeimfose_xb+1; 
                    xrkeimgem_yt = xrkeimfose_yb + 1 ; xrkeimgem_yb = xrkeimgem_yt+25 ;
                    xrperfose_yt = xrkeimgem_yb + 1 ; xrperfose_yb = xrperfose_yt+25 ;
                    xrperfo_yt = xrperfose_yb + 1 ; xrperfo_yb = xrperfo_yt + 25 ;
                    aplgr_yt = diplgr_yt = xrperfo_yb + 1; aplgr_xb = aplgr_xt + 200; aplgr_yb = aplgr_yt + 25 ;
                    diplgr_xt = xb-210;   diplgr_xb = diplgr_xt + 200; diplgr_yb = diplgr_yt + 25 ;
                    lay_xt[0] = xt+10; lay_yt[0] = diplgr_yb+1 ; lay_xb[0] = lay_xt[0]+200; lay_yb[0] = lay_yt[0] + 25; 
                    lay_xt[1] = xb-210; lay_yt[1] = lay_yt[0] ; lay_xb[1] = lay_xt[1]+200; lay_yb[1] = lay_yt[1] + 25;
                    coor_xt[0] =  coor_xt[2] = xt+10 ;  
                    coor_xb[0] = coor_xb[2] = coor_xt[0]+200;
                    coor_yt[0] = coor_yt[1] = lay_yb[1] + 1 ;
                    coor_yb[0] = coor_yb[1] = coor_yt[0]+25;
                    coor_xt[1] = coor_xt[3] = xb-210 ;
                    coor_xb[1] = coor_xb[3] = coor_xt[1]+200;
                    coor_yt[2] = coor_yt[3] = coor_yb[0] + 1;
                    coor_yb[2] = coor_yb[3] = coor_yt[2] + 25 ;

                    for (f=0 ; f<4 ; f++) {
                        icoor_xt[f] = coor_xb[f]-70 ;
                    }

                    page_xt[0] = xt+10 ; page_xt[1] = xb-210 ;
                    page_yt[0] = page_yt[1] = coor_yb[2] + 1 ;
                    page_xb[0] = page_xt[0]+200 ; page_xb[1] = page_xt[1]+200;
                    page_yb[0] = page_yb[1] = page_yt[0] + 25 ;   

                    ipage_xt = page_xb[0]-70;

                    aa_xt=xt+532; aa_yt=yt+14 ; aa_xb = aa_xt+42 ; aa_yb = aa_yt+22 ;
                    keaaxt = aa_xt+17; keaayt=aa_yt+10;

                    arrxt=xt+10 ; arryt=riyt=leyt=delyt=yt+10;
                    rixt=xb-200 ; lext=xt+200; delxt=xb-40;
                    xok=xb-60; ygo=yb-45; xgo=xt+15; yok=yb-45 ;
                        
                    g_xt=aplgr_xb + 2 ; g_yt = xrperfo_yb+2 ;
                    g_xb = diplgr_xt-2 ; g_yb = yb-50;

                    ph_xt=g_xt+120; ph_yt=g_yt+2;
                    ph_xb=g_xb-120; ph_yb=yb-70;

                    tet_xt = g_xt+170; tet_yt=g_yt+2;
                    tet_xb = tet_xt+140; tet_yb=tet_yt+140;

                    par_xt = g_xt + 20 ; par_yt = g_yt+2 ;
                    par_xb = g_xb-20 ; par_yb = par_yt+140 ;

                    kyk_xt=tet_xt+70; kyk_yt=tet_yt+70 ; kyk_r=69 ;

                    ell_xt=kyk_xt; ell_yt=kyk_yt;
                    ell_r1=180 ; ell_r2=69;           
                    
                    kentrx_xt = xt+70 ;  kentrx_xb = kentrx_xt+200; 
                    kentrx_yt = kentry_yt = nordim_yt = yb-40 ; kentrx_yb = kentry_yb = nordim_yb = kentrx_yt+29;
                    kentry_xb = xb-70;
                    kentry_xt = kentry_xb-200 ;
                    
                    nordim_xt = kentrx_xb+5;
                    nordim_xb = nordim_xt+350;
                    
                    refresh();
                    
                    continue ;
                }
                
                else if (proenter) {
                    if (new==decor) {
                        mem2 = (char *) &ptr_dec[new];
                        mem3 = (char *) &cpy;
                        for (f=0 ; f<decorsize; f++) {
                            *mem2++ = *mem3++ ;
                        }
                        prin_dec=decor;
                    }
                    a=0;
                    for (f=0; f<7 ; f++) {
                        if (cpy.detype[f]) { a=1; break; }
                    }
                    if (!a) { fyge=2; continue ;}
                    
                    sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                    fpdec=fopen(str1024,"r+b");
                    if (fpdec==NULL) {
                        decor=0;
                        fpdec=fopen(str1024,"wb");
                        
                        if (fpdec==NULL) {
                            fseek(fpdb, dec_lab_db , 0);
                            fwrite (&decor,4,1,fpdb);
                            fdatasync (fide_fpdb);
                            information(6-keyb_gr,str1024,0); 
                            fyge=2 ; 
                            continue ;}
                            
                        new=0;
                    }
                    
                    fide_fpdec = fileno (fpdec) ;
                    
                // Αντιγραφή της δομής cpy στη δομή ετικέτας
                    a=0;
                    if (!cpy.dext && !cpy.deyt) a=1;
                    if (!a) {
                        if (cpy.dext<info.left+3) cpy.dext=info.left+3 ;
                        if (cpy.deyt<info.top+3) cpy.deyt=info.top+3 ;
                    }
                    if (!cpy.dewid) { cpy.dewid= (cpy.detype[6]) ? 200 : 31 ;}
                    else if (cpy.dewid<7) cpy.dewid=7;
                    while (cpy.dext+cpy.dewid>info.right-3 && cpy.dext>info.left+2) cpy.dext--;
                    while (cpy.dext+cpy.dewid>info.right-3) cpy.dewid--;
                    if (!cpy.dehei) cpy.dehei= (cpy.detype[6]) ? 200 : 31 ;
                    else if (cpy.dehei<7) cpy.dehei=7;
                    while (cpy.deyt+cpy.dehei>info.bottom-3  && cpy.deyt>info.top+2) cpy.deyt--;
                    while (cpy.deyt+cpy.dehei>info.bottom-3) cpy.dehei--;
                    
                                        
                    mem2 = (char *) &ptr_dec[new];
                    mem3 = (char *) &cpy;
                    for (f=0 ; f<decorsize; f++) {
                        *mem2++ = *mem3++ ;
                    } 
                    
                    if (cpy.depg!=100) decor_coord ((int) new , (int) cpy.depg);
                    else decor_coord ((int) new , (int) dbcurpage);
                    
                    fseek(fpdec , (new*decorsize) ,0);
                    fwrite (&ptr_dec[new] , decorsize, 1, fpdec);
                    fdatasync(fide_fpdec);
                    fsync(fide_fpdec);
                    fclose(fpdec);
                    if (new==decor) {
                        decor++;
                        fseek(fpdb, dec_lab_db , 0);
                        fwrite (&decor,4,1,fpdb);
                        fdatasync (fide_fpdb);
                    }
                    fyge=1; *new1=new;
                    continue ;
                }
                
                else if (go_ri || go_le) {
                    
                    if (go_ri) {
                        if (new==decor) continue;
                        if (new==149) continue;
                        new++;
                    }
                    else if (go_le) {
                        if (!new) continue ;
                        if (new==decor) {
                            mem2 = (char *) &ptr_dec[new];
                            mem3 = (char *) &cpy;
                            for (f=0 ; f<decorsize; f++) {
                                *mem2++ = *mem3++ ;
                            }
                            prin_dec=decor;
                        }
                        new--;
                    }
                    
                    

                // Αντιγραφή νέας ετικέτας στη δομή cpy

                    mem2 = (char *) &ptr_dec[new];
                    mem3 = (char *) &cpy;
                    for (f=0 ; f<decorsize; f++) {
                        *mem3++ = *mem2++ ;
                    }
                    
                    
                    if (prorec) {  // Κρύβει το παράθυρο - Αποκαθιστά τέως επιλεγμένη ετικέτα 
                        mem_form=malloc(imagesize(xt,yt,xb,yb)); 
                        if (!mem_form) {information(2-keyb_gr,0,0); prorec=0; goto SYNEX_RILAB;}
                        getimage(xt,yt,xb,yb,mem_form);
                        putimage (xt,yt,mem0,0);
                        refresh();
                        putimage (trecx,trecy,mem_ouon,0);refresh();
                    }
                    
                    if (new==decor) {
                        if (prorec) {
                            prorec=0;
                            getimage(xt,yt,xb,yb,mem0);
                            putimage (xt,yt,mem_form,0);
                            refresh();
                            free(mem_form); mem_form=0;
                        }
                    }
                    else {
                        dy=0;
                        for (f=0; f<dcar; f++) {
                            if (new==dd_elem[f]) {dy=1;break;}
                        }
                        if (dy) {
                            if (!prorec) {
                                mem_form=malloc(imagesize(xt,yt,xb,yb)); 
                                if (!mem_form) {information(2-keyb_gr,0,0); goto SYNEX_RILAB;}
                                getimage(xt,yt,xb,yb,mem_form);
                                putimage (xt,yt,mem0,0);
                                refresh();
                                prorec=1;
                            }
                            
                            trecx=dbdx1[f]; trecy=dbdy1[f];
                            getimage(trecx,trecy,dbdx2[f],dbdy2[f],mem_ouon);
                            setrgbcolor(dbmag);
                            rectangle (dbdx1[f],dbdy1[f],dbdx2[f],dbdy2[f]);
                            rectangle (dbdx1[f]+1,dbdy1[f]+1,dbdx2[f]-1,dbdy2[f]-1);
                            refresh();
                            
                            getimage(xt,yt,xb,yb,mem0);
                            putimage (xt,yt,mem_form,0);
                            refresh();
                            free(mem_form); mem_form=0;
                            
                        }
                        else { 
                            if (prorec) {
                                prorec=0;
                                getimage(xt,yt,xb,yb,mem0);
                                putimage (xt,yt,mem_form,0);
                                refresh();
                                free(mem_form); mem_form=0;
                            }
                        }
                    }

SYNEX_RILAB :
                    for (f=0 ; f<7 ; f++) {
                            x1= f*120+wtype_xt ;
                            setcolor (COLOR(dbbkxr[0], dbbkxr[1], dbbkxr[2]));
                            rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                            rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                            rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                            rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                        if (cpy.detype[f]) {
                            setcolor (4);
                            rectangle (x1+1 , wtype_yt+1 , x1+119, wtype_yb-1);
                            rectangle (x1+2 , wtype_yt+2 , x1+118, wtype_yb-2);
                            rectangle (x1+3 , wtype_yt+3 , x1+117, wtype_yb-3);
                            rectangle (x1+4 , wtype_yt+4 , x1+116, wtype_yb-4);
                        }
                    }
                    
                    
                    sprintf (str1024 , "%03d", new+1);
                    normtext_tomy(str1024,0);
                    //setfillstyle(1,COLOR(kit[0], kit[1], kit[2]));
                    
                    _bareacls(aa_xt,aa_yt,aa_xb,aa_yb,dbbkxr);
                    setcolor(2);
                    ellipse (keaaxt,keaayt,0,360,26,16);
                    _myfill_ellips(keaaxt,keaayt,kit);
                    //floodfill(keaaxt,keaayt,2);
                    _outmystr_col (4,str1024,aa_xt, aa_yt, aa_xb, bla , kit);
                    
                    _bareacls (font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbbkxr);
                    normtext_tomy(myfont_name[cpy.defont],fonter);
                    _outmystr_center_col (cpy.defont,fonter,font_xt+1 , font_yt+1, font_xb-1, font_yb-1,dbchxr , dbbkxr);
                    
                    _bareacls (inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbbkxr);
                    if (cpy.detext[0]==255) {
                    _outmystr_center_col (4,eis_keim,inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbchxr , dbbkxr ) ;
                    }
                    else  _outmystr_center_col (4,cpy.detext,inptext_xt+1 , inptext_yt+1 , inptext_xb-1 , inptext_yb-1,dbchxr , dbbkxr ) ;
                    
                    if (!cpy.defill) {
                        _bareacls (sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,dbbkxr);
                        _outmystr_center_col (4,sximgem,sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,dbchxr , dbbkxr);}
                    else {
                        _bareacls (sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,energ);
                        _outmystr_center_col (4,sximgem,sximgem_xt , sximgem_yt , sximgem_xb, sximgem_yb,kok,energ);}
                    
                    if (cpy.delinefat==2) {
                        _bareacls (aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,energ);
                        _outmystr_center_col (4,aplgr,aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,kok , energ);}
                    else {
                        _bareacls (aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbbkxr);
                        _outmystr_center_col (4,aplgr,aplgr_xt+1, aplgr_yt+1, aplgr_xb-1, aplgr_yb-1,dbchxr , dbbkxr);}
                    
                    if (cpy.delinefat==3) {
                        _bareacls (diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,energ );
                        _outmystr_center_col (4,diplgr,diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,kok, energ );}
                    else {
                        _bareacls (diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,dbbkxr );
                        _outmystr_center_col (4,diplgr,diplgr_xt+1 ,diplgr_yt+1 ,diplgr_xb-1 ,diplgr_yb-1,dbchxr , dbbkxr );}
                    
                    if (cpy.delayer==1) {
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,energ);
                        _outmystr_center_col (4, lay_t[0], lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,kok , energ);}
                    else {
                        _bareacls (lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,dbbkxr);
                        _outmystr_center_col (4, lay_t[0], lay_xt[0]+1 , lay_yt[0]+1 ,lay_xb[0]-1 ,lay_yb[0]-1,dbchxr , dbbkxr);}
                    
                    if (cpy.delayer==2) {
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,energ);
                        _outmystr_center_col (4, lay_t[1], lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,kok , energ);}
                    else {
                        _bareacls (lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,dbbkxr);
                        _outmystr_center_col (4, lay_t[1], lay_xt[1]+1 , lay_yt[1]+1 ,lay_xb[1]-1 ,lay_yb[1]-1,dbchxr , dbbkxr);}
                    
                    if (cpy.depg!=100) {
                    _bareacls (page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 , page_yb[0]-1, energ);
                    _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
                    sprintf(str1024,"%03d" , cpy.depg);
                    normtext_tomy (str1024,ipage);
                    _outmystr_rcol (4,ipage,ipage_xt, page_yt[0]+1 ,page_xb[0]-1 ,kok , energ);
                    _bareacls (page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,dbbkxr );
                    _outmystr_center_col (4,pageoles, page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,dbchxr , dbbkxr );
                    }
                    else {
                        ipage[0]=255;
                        _bareacls (page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 , page_yb[0]-1, dbbkxr);
                        _outmystr_col (4,page_t,page_xt[0]+1 , page_yt[0]+1 ,page_xb[0]-1 ,dbchxr , dbbkxr);
                        _bareacls (page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,energ );
                        _outmystr_center_col (4,pageoles, page_xt[1]+1 , page_yt[1]+1 ,page_xb[1]-1 ,page_yb[1]-1,kok , energ );
                    }
                    
                    
                    _bareacls (icoor_xt[0]+1, coor_yt[0]+1, coor_xb[0]-1 , coor_yb[0]-1, dbbkxr);
                    _bareacls (icoor_xt[1]+1, coor_yt[1]+1, coor_xb[1]-1 , coor_yb[1]-1, dbbkxr);
                    _bareacls (icoor_xt[2]+1, coor_yt[2]+1, coor_xb[2]-1 , coor_yb[2]-1, dbbkxr);
                    _bareacls (icoor_xt[3]+1, coor_yt[3]+1, coor_xb[3]-1 , coor_yb[3]-1, dbbkxr);
                    
                    
                    if (cpy.dext) {sprintf(str1024,"%4d",cpy.dext); normtext_tomy(str1024,icoorx);
                        _outmystr_rcol(4,icoorx, icoor_xt[0] , coor_yt[0]+1, coor_xb[0]-1 , dbchxr,dbbkxr);}
                    else icoorx[0]=255;
                        
                    if (cpy.deyt) {sprintf(str1024,"%4d",cpy.deyt); normtext_tomy(str1024,icoory);
                        _outmystr_rcol(4,icoory, icoor_xt[1] , coor_yt[1]+1, coor_xb[1]-1 , dbchxr,dbbkxr);}
                    else icoory[0]=255;
                    
                    if (cpy.dewid) {sprintf(str1024,"%4d",cpy.dewid); normtext_tomy(str1024,iwid);
                        _outmystr_rcol(4,iwid, icoor_xt[2] , coor_yt[2]+1, coor_xb[2]-1 , dbchxr,dbbkxr);}
                    else iwid[0]=255;
                    
                    if (cpy.dehei) {sprintf(str1024,"%4d",cpy.dehei); normtext_tomy(str1024,ihei);
                        _outmystr_rcol(4,ihei, icoor_xt[3] , coor_yt[3]+1, coor_xb[3]-1 , dbchxr,dbbkxr);}
                    else ihei[0]=255;
                    
                    refresh();
                    
                    anan=1; 
                    
                    continue ;
                    
                }
                
                else if (deldec) {

                    if (new==decor) continue ;
                    if (keyb_gr) strcpy (str1kb,"Η Ετικέτα θα διαγραφεί μόνιμα!\nΘέλετε σίγουρα να διαγραφεί ;");
                    else strcpy (str1kb,"The Label will be permanently erased!\nAre you sure that you want this ?");
                    dx=alert(0,str1kb,0);
                    if (dx!=1) continue;
                    
                    
                    sprintf(str1024,"%s%s",savedbpath,"decor1.aba"); // Αρχείο Διακοσμ. ετικετών
                    fpdec=fopen(str1024,"r+b");
                    if (fpdec==NULL) {
                        information(6-keyb_gr,str1024,0);
                        continue ;
                    }
                    
                    if (new<149){
                        for (f=new+1 ; f<=decor ; f++) {
                            mem2 = (char *) &ptr_dec[f-1];
                            mem3 = (char *) &ptr_dec[f];
                            for (i=0 ; i<decorsize; i++) {
                                *mem2++ = *mem3++ ;
                            }
                        }
                    }
                    else {
                        for (f=new+1 ; f<decor ; f++) {
                            mem2 = (char *) &ptr_dec[f-1];
                            mem3 = (char *) &ptr_dec[f];
                            for (i=0 ; i<decorsize; i++) {
                                *mem2++ = *mem3++ ;
                            }
                        }
                    }
                    decor--;
                    if (decor) {
                        fide_fpdec = fileno (fpdec) ;
                        fwrite (ptr_dec,decorsize,decor,fpdec);
                        fdatasync(fide_fpdec);
                        fsync(fide_fpdec);
                        fclose(fpdec); fpdec=NULL;
                    }
                    else {fclose(fpdec); fpdec=NULL;}
                    fseek(fpdb, dec_lab_db , 0);
                    fwrite (&decor,4,1,fpdb);
                    fdatasync (fide_fpdb);
                    if (prin_dec!=-1) prin_dec--;
                    fyge=3;
                    continue;
            }
            
            else if (akyro) {
            if (new==decor) {
                mem2 = (char *) &ptr_dec[new];
                mem3 = (char *) &cpy;
                for (f=0 ; f<decorsize; f++) {
                    *mem2++ = *mem3++ ;
                }
                prin_dec=decor;
            }
                fyge=2;
                continue ;
            }
        }
            
            break ;
            
            case SDL_DROPFILE :
                dropfile=sdlev.drop.file;
                if (!dropfile) break;
                c=strlen (dropfile);
                if ( c < 1024 ) strcpy (str1024,dropfile);
                else { SDL_free(dropfile); break; }
                SDL_free(dropfile);
                setcurrentwindow(win_id);refresh();
                if (!cpy.detype[6]) break ; 
                ptr_char=strstr(str1024,".bmp");
                if (!ptr_char) {
                    if (keyb_gr) information (0,"Πρέπει να είναι εικόνα τύπου .bmp","Προσπαθήστε πάλι..");
                    else information (0,"It must be a .bmp icon file!","Try again..");
                    break;}
                a=0;
                do {
                    if ( ! SDL_PollEvent(&sdlev)  ) continue ;
                    if  (sdlev.type != SDL_MOUSEMOTION) continue ; 
                    mx = sdlev.motion.x ; my = sdlev.motion.y ;
                    if (my<info.top || my>info.bottom || mx<info.left || mx>info.right) a=0 ;
                    else a=1;
                }
                while (!a);
                //printf ("%s\n",str1024);
                    
                if (mx>xt && mx<xb && my>yt && my<yb) {
                    strcpy (cpy.dephoto , str1024) ;
                    bareacls (g_xt,g_yt,g_xb,g_yb,dbbkxr);
                    readimagefile (cpy.dephoto,ph_xt,ph_yt,ph_xb,ph_yb);
                }

                break;
                
            case SDL_KEYDOWN:
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                ch_scan=sdlev.key.keysym.scancode;
                do { SDL_PollEvent(&sdlev) ; } while ( (SDL_PollEvent(&sdlev)) && (sdlev.type == SDL_KEYDOWN) ) ;
                if (ch_scan==SDL_SCANCODE_ESCAPE) {
                    if (new==decor) {
                        mem2 = (char *) &ptr_dec[new];
                        mem3 = (char *) &cpy;
                        for (f=0 ; f<decorsize; f++) {
                            *mem2++ = *mem3++ ;
                        }
                        prin_dec=decor;
                    }
                    fyge=2; continue ;
                }
                break ;
            
            case SDL_WINDOWEVENT :
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                refresh(); 
                continue; 
                
            case SDL_QUIT :
                if (mem_small) hide_help(hdhlpxt , hdhlpyt);
                fyge=2;
                continue;
        }
    } while (!fyge);
    
    
FYGE :
        do { 
           SDL_PollEvent(&sdlev);
           
        } while ( sdlev.type==SDL_MOUSEBUTTONDOWN  &&  SDL_PollEvent(&sdlev) ); 

    if (mem_ok) free (mem_ok);
    if (mem_ri) free(mem_ri);
    if (mem_le) free(mem_le);
    if (mem_yel) free (mem_yel);
    if (mem_arrs) free(mem_arrs);
    if(mem_del) free(mem_del);
    if (mem_go) free (mem_go);
    cursor=SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_SetCursor(cursor); 
    if (fyge!=1) fidicls(xt,yt,xb,yb,0,0,0);
    if (mem0) { putimage(xt,yt,mem0,0); free(mem0);}//EPANAFORA ΜΕΡΟΥΣ ΟΘΟΝΗΣ
    for (f=0;f<3;f++) {
        bkxr[f]=bkxr1[f] ; chxr[f]=chxr1[f] ; slxr[f]=slxr1[f];
    }
    gouv=trampa;
    refresh();

    return fyge ;
}
    


